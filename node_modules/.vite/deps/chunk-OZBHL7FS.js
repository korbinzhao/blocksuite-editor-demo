import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-AX6B7HUW.js";

// node_modules/merge/lib/src/index.js
var require_src = __commonJS({
  "node_modules/merge/lib/src/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPlainObject = exports2.clone = exports2.recursive = exports2.merge = exports2.main = void 0;
    module2.exports = exports2 = main;
    exports2.default = main;
    function main() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return merge3.apply(void 0, items);
    }
    exports2.main = main;
    main.clone = clone;
    main.isPlainObject = isPlainObject;
    main.recursive = recursive;
    function merge3() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return _merge(items[0] === true, false, items);
    }
    exports2.merge = merge3;
    function recursive() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return _merge(items[0] === true, true, items);
    }
    exports2.recursive = recursive;
    function clone(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var index = 0; index < input.length; ++index)
          output.push(clone(input[index]));
        return output;
      } else if (isPlainObject(input)) {
        var output = {};
        for (var index in input)
          output[index] = clone(input[index]);
        return output;
      } else {
        return input;
      }
    }
    exports2.clone = clone;
    function isPlainObject(input) {
      return input && typeof input === "object" && !Array.isArray(input);
    }
    exports2.isPlainObject = isPlainObject;
    function _recursiveMerge(base, extend) {
      if (!isPlainObject(base))
        return extend;
      for (var key in extend) {
        if (key === "__proto__" || key === "constructor" || key === "prototype")
          continue;
        base[key] = isPlainObject(base[key]) && isPlainObject(extend[key]) ? _recursiveMerge(base[key], extend[key]) : extend[key];
      }
      return base;
    }
    function _merge(isClone, isRecursive, items) {
      var result;
      if (isClone || !isPlainObject(result = items.shift()))
        result = {};
      for (var index = 0; index < items.length; ++index) {
        var item = items[index];
        if (!isPlainObject(item))
          continue;
        for (var key in item) {
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            continue;
          var value = isClone ? clone(item[key]) : item[key];
          result[key] = isRecursive ? _recursiveMerge(result[key], value) : value;
        }
      }
      return result;
    }
  }
});

// node_modules/simple-peer/simplepeer.min.js
var require_simplepeer_min = __commonJS({
  "node_modules/simple-peer/simplepeer.min.js"(exports2, module2) {
    (function(e) {
      if ("object" == typeof exports2 && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var t2;
        t2 = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t2.SimplePeer = e();
      }
    })(function() {
      var t2 = Math.floor, n = Math.abs, r = Math.pow;
      return function() {
        function d3(s, e, n2) {
          function t3(o, i) {
            if (!e[o]) {
              if (!s[o]) {
                var l = "function" == typeof __require && __require;
                if (!i && l)
                  return l(o, true);
                if (r2)
                  return r2(o, true);
                var c2 = new Error("Cannot find module '" + o + "'");
                throw c2.code = "MODULE_NOT_FOUND", c2;
              }
              var a3 = e[o] = { exports: {} };
              s[o][0].call(a3.exports, function(e2) {
                var r3 = s[o][1][e2];
                return t3(r3 || e2);
              }, a3, a3.exports, d3, s, e, n2);
            }
            return e[o].exports;
          }
          for (var r2 = "function" == typeof __require && __require, a2 = 0; a2 < n2.length; a2++)
            t3(n2[a2]);
          return t3;
        }
        return d3;
      }()({ 1: [function(e, t3, n2) {
        "use strict";
        function r2(e2) {
          var t4 = e2.length;
          if (0 < t4 % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var n3 = e2.indexOf("=");
          -1 === n3 && (n3 = t4);
          var r3 = n3 === t4 ? 0 : 4 - n3 % 4;
          return [n3, r3];
        }
        function a2(e2, t4, n3) {
          return 3 * (t4 + n3) / 4 - n3;
        }
        function o(e2) {
          var t4, n3, o2 = r2(e2), d4 = o2[0], s2 = o2[1], l2 = new p(a2(e2, d4, s2)), c3 = 0, f2 = 0 < s2 ? d4 - 4 : d4;
          for (n3 = 0; n3 < f2; n3 += 4)
            t4 = u2[e2.charCodeAt(n3)] << 18 | u2[e2.charCodeAt(n3 + 1)] << 12 | u2[e2.charCodeAt(n3 + 2)] << 6 | u2[e2.charCodeAt(n3 + 3)], l2[c3++] = 255 & t4 >> 16, l2[c3++] = 255 & t4 >> 8, l2[c3++] = 255 & t4;
          return 2 === s2 && (t4 = u2[e2.charCodeAt(n3)] << 2 | u2[e2.charCodeAt(n3 + 1)] >> 4, l2[c3++] = 255 & t4), 1 === s2 && (t4 = u2[e2.charCodeAt(n3)] << 10 | u2[e2.charCodeAt(n3 + 1)] << 4 | u2[e2.charCodeAt(n3 + 2)] >> 2, l2[c3++] = 255 & t4 >> 8, l2[c3++] = 255 & t4), l2;
        }
        function d3(e2) {
          return c2[63 & e2 >> 18] + c2[63 & e2 >> 12] + c2[63 & e2 >> 6] + c2[63 & e2];
        }
        function s(e2, t4, n3) {
          for (var r3, a3 = [], o2 = t4; o2 < n3; o2 += 3)
            r3 = (16711680 & e2[o2] << 16) + (65280 & e2[o2 + 1] << 8) + (255 & e2[o2 + 2]), a3.push(d3(r3));
          return a3.join("");
        }
        function l(e2) {
          for (var t4, n3 = e2.length, r3 = n3 % 3, a3 = [], o2 = 16383, d4 = 0, l2 = n3 - r3; d4 < l2; d4 += o2)
            a3.push(s(e2, d4, d4 + o2 > l2 ? l2 : d4 + o2));
          return 1 === r3 ? (t4 = e2[n3 - 1], a3.push(c2[t4 >> 2] + c2[63 & t4 << 4] + "==")) : 2 === r3 && (t4 = (e2[n3 - 2] << 8) + e2[n3 - 1], a3.push(c2[t4 >> 10] + c2[63 & t4 >> 4] + c2[63 & t4 << 2] + "=")), a3.join("");
        }
        n2.byteLength = function(e2) {
          var t4 = r2(e2), n3 = t4[0], a3 = t4[1];
          return 3 * (n3 + a3) / 4 - a3;
        }, n2.toByteArray = o, n2.fromByteArray = l;
        for (var c2 = [], u2 = [], p = "undefined" == typeof Uint8Array ? Array : Uint8Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, _ = f.length; g < _; ++g)
          c2[g] = f[g], u2[f.charCodeAt(g)] = g;
        u2[45] = 62, u2[95] = 63;
      }, {}], 2: [function() {
      }, {}], 3: [function(e, t3, n2) {
        (function() {
          (function() {
            "use strict";
            var t4 = String.fromCharCode, o = Math.min;
            function d3(e2) {
              if (2147483647 < e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t5 = new Uint8Array(e2);
              return t5.__proto__ = s.prototype, t5;
            }
            function s(e2, t5, n3) {
              if ("number" == typeof e2) {
                if ("string" == typeof t5)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return p(e2);
              }
              return l(e2, t5, n3);
            }
            function l(e2, t5, n3) {
              if ("string" == typeof e2)
                return f(e2, t5);
              if (ArrayBuffer.isView(e2))
                return g(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (K2(e2, ArrayBuffer) || e2 && K2(e2.buffer, ArrayBuffer))
                return _(e2, t5, n3);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var r2 = e2.valueOf && e2.valueOf();
              if (null != r2 && r2 !== e2)
                return s.from(r2, t5, n3);
              var a2 = h(e2);
              if (a2)
                return a2;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return s.from(e2[Symbol.toPrimitive]("string"), t5, n3);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function c2(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              else if (0 > e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u2(e2, t5, n3) {
              return c2(e2), 0 >= e2 ? d3(e2) : void 0 === t5 ? d3(e2) : "string" == typeof n3 ? d3(e2).fill(t5, n3) : d3(e2).fill(t5);
            }
            function p(e2) {
              return c2(e2), d3(0 > e2 ? 0 : 0 | m(e2));
            }
            function f(e2, t5) {
              if (("string" != typeof t5 || "" === t5) && (t5 = "utf8"), !s.isEncoding(t5))
                throw new TypeError("Unknown encoding: " + t5);
              var n3 = 0 | b2(e2, t5), r2 = d3(n3), a2 = r2.write(e2, t5);
              return a2 !== n3 && (r2 = r2.slice(0, a2)), r2;
            }
            function g(e2) {
              for (var t5 = 0 > e2.length ? 0 : 0 | m(e2.length), n3 = d3(t5), r2 = 0; r2 < t5; r2 += 1)
                n3[r2] = 255 & e2[r2];
              return n3;
            }
            function _(e2, t5, n3) {
              if (0 > t5 || e2.byteLength < t5)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (e2.byteLength < t5 + (n3 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var r2;
              return r2 = void 0 === t5 && void 0 === n3 ? new Uint8Array(e2) : void 0 === n3 ? new Uint8Array(e2, t5) : new Uint8Array(e2, t5, n3), r2.__proto__ = s.prototype, r2;
            }
            function h(e2) {
              if (s.isBuffer(e2)) {
                var t5 = 0 | m(e2.length), n3 = d3(t5);
                return 0 === n3.length ? n3 : (e2.copy(n3, 0, 0, t5), n3);
              }
              return void 0 === e2.length ? "Buffer" === e2.type && Array.isArray(e2.data) ? g(e2.data) : void 0 : "number" != typeof e2.length || X(e2.length) ? d3(0) : g(e2);
            }
            function m(e2) {
              if (e2 >= 2147483647)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
              return 0 | e2;
            }
            function b2(e2, t5) {
              if (s.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || K2(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var n3 = e2.length, r2 = 2 < arguments.length && true === arguments[2];
              if (!r2 && 0 === n3)
                return 0;
              for (var a2 = false; ; )
                switch (t5) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n3;
                  case "utf8":
                  case "utf-8":
                    return H(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n3;
                  case "hex":
                    return n3 >>> 1;
                  case "base64":
                    return z2(e2).length;
                  default:
                    if (a2)
                      return r2 ? -1 : H(e2).length;
                    t5 = ("" + t5).toLowerCase(), a2 = true;
                }
            }
            function y(e2, t5, n3) {
              var r2 = false;
              if ((void 0 === t5 || 0 > t5) && (t5 = 0), t5 > this.length)
                return "";
              if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), 0 >= n3)
                return "";
              if (n3 >>>= 0, t5 >>>= 0, n3 <= t5)
                return "";
              for (e2 || (e2 = "utf8"); ; )
                switch (e2) {
                  case "hex":
                    return P2(this, t5, n3);
                  case "utf8":
                  case "utf-8":
                    return x2(this, t5, n3);
                  case "ascii":
                    return D2(this, t5, n3);
                  case "latin1":
                  case "binary":
                    return I2(this, t5, n3);
                  case "base64":
                    return A(this, t5, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M2(this, t5, n3);
                  default:
                    if (r2)
                      throw new TypeError("Unknown encoding: " + e2);
                    e2 = (e2 + "").toLowerCase(), r2 = true;
                }
            }
            function C2(e2, t5, n3) {
              var r2 = e2[t5];
              e2[t5] = e2[n3], e2[n3] = r2;
            }
            function R(e2, t5, n3, r2, a2) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof n3 ? (r2 = n3, n3 = 0) : 2147483647 < n3 ? n3 = 2147483647 : -2147483648 > n3 && (n3 = -2147483648), n3 = +n3, X(n3) && (n3 = a2 ? 0 : e2.length - 1), 0 > n3 && (n3 = e2.length + n3), n3 >= e2.length) {
                if (a2)
                  return -1;
                n3 = e2.length - 1;
              } else if (0 > n3)
                if (a2)
                  n3 = 0;
                else
                  return -1;
              if ("string" == typeof t5 && (t5 = s.from(t5, r2)), s.isBuffer(t5))
                return 0 === t5.length ? -1 : E2(e2, t5, n3, r2, a2);
              if ("number" == typeof t5)
                return t5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a2 ? Uint8Array.prototype.indexOf.call(e2, t5, n3) : Uint8Array.prototype.lastIndexOf.call(e2, t5, n3) : E2(e2, [t5], n3, r2, a2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function E2(e2, t5, n3, r2, a2) {
              function o2(e3, t6) {
                return 1 === d4 ? e3[t6] : e3.readUInt16BE(t6 * d4);
              }
              var d4 = 1, s2 = e2.length, l2 = t5.length;
              if (void 0 !== r2 && (r2 = (r2 + "").toLowerCase(), "ucs2" === r2 || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
                if (2 > e2.length || 2 > t5.length)
                  return -1;
                d4 = 2, s2 /= 2, l2 /= 2, n3 /= 2;
              }
              var c3;
              if (a2) {
                var u3 = -1;
                for (c3 = n3; c3 < s2; c3++)
                  if (o2(e2, c3) !== o2(t5, -1 === u3 ? 0 : c3 - u3))
                    -1 !== u3 && (c3 -= c3 - u3), u3 = -1;
                  else if (-1 === u3 && (u3 = c3), c3 - u3 + 1 === l2)
                    return u3 * d4;
              } else
                for (n3 + l2 > s2 && (n3 = s2 - l2), c3 = n3; 0 <= c3; c3--) {
                  for (var p2 = true, f2 = 0; f2 < l2; f2++)
                    if (o2(e2, c3 + f2) !== o2(t5, f2)) {
                      p2 = false;
                      break;
                    }
                  if (p2)
                    return c3;
                }
              return -1;
            }
            function w(e2, t5, n3, r2) {
              n3 = +n3 || 0;
              var a2 = e2.length - n3;
              r2 ? (r2 = +r2, r2 > a2 && (r2 = a2)) : r2 = a2;
              var o2 = t5.length;
              r2 > o2 / 2 && (r2 = o2 / 2);
              for (var d4, s2 = 0; s2 < r2; ++s2) {
                if (d4 = parseInt(t5.substr(2 * s2, 2), 16), X(d4))
                  return s2;
                e2[n3 + s2] = d4;
              }
              return s2;
            }
            function S2(e2, t5, n3, r2) {
              return G2(H(t5, e2.length - n3), e2, n3, r2);
            }
            function T2(e2, t5, n3, r2) {
              return G2(Y2(t5), e2, n3, r2);
            }
            function v2(e2, t5, n3, r2) {
              return T2(e2, t5, n3, r2);
            }
            function k(e2, t5, n3, r2) {
              return G2(z2(t5), e2, n3, r2);
            }
            function L2(e2, t5, n3, r2) {
              return G2(V2(t5, e2.length - n3), e2, n3, r2);
            }
            function A(e2, t5, n3) {
              return 0 === t5 && n3 === e2.length ? $.fromByteArray(e2) : $.fromByteArray(e2.slice(t5, n3));
            }
            function x2(e2, t5, n3) {
              n3 = o(e2.length, n3);
              for (var r2 = [], a2 = t5; a2 < n3; ) {
                var d4 = e2[a2], s2 = null, l2 = 239 < d4 ? 4 : 223 < d4 ? 3 : 191 < d4 ? 2 : 1;
                if (a2 + l2 <= n3) {
                  var c3, u3, p2, f2;
                  1 === l2 ? 128 > d4 && (s2 = d4) : 2 === l2 ? (c3 = e2[a2 + 1], 128 == (192 & c3) && (f2 = (31 & d4) << 6 | 63 & c3, 127 < f2 && (s2 = f2))) : 3 === l2 ? (c3 = e2[a2 + 1], u3 = e2[a2 + 2], 128 == (192 & c3) && 128 == (192 & u3) && (f2 = (15 & d4) << 12 | (63 & c3) << 6 | 63 & u3, 2047 < f2 && (55296 > f2 || 57343 < f2) && (s2 = f2))) : 4 === l2 ? (c3 = e2[a2 + 1], u3 = e2[a2 + 2], p2 = e2[a2 + 3], 128 == (192 & c3) && 128 == (192 & u3) && 128 == (192 & p2) && (f2 = (15 & d4) << 18 | (63 & c3) << 12 | (63 & u3) << 6 | 63 & p2, 65535 < f2 && 1114112 > f2 && (s2 = f2))) : void 0;
                }
                null === s2 ? (s2 = 65533, l2 = 1) : 65535 < s2 && (s2 -= 65536, r2.push(55296 | 1023 & s2 >>> 10), s2 = 56320 | 1023 & s2), r2.push(s2), a2 += l2;
              }
              return N2(r2);
            }
            function N2(e2) {
              var n3 = e2.length;
              if (n3 <= 4096)
                return t4.apply(String, e2);
              for (var r2 = "", a2 = 0; a2 < n3; )
                r2 += t4.apply(String, e2.slice(a2, a2 += 4096));
              return r2;
            }
            function D2(e2, n3, r2) {
              var a2 = "";
              r2 = o(e2.length, r2);
              for (var d4 = n3; d4 < r2; ++d4)
                a2 += t4(127 & e2[d4]);
              return a2;
            }
            function I2(e2, n3, r2) {
              var a2 = "";
              r2 = o(e2.length, r2);
              for (var d4 = n3; d4 < r2; ++d4)
                a2 += t4(e2[d4]);
              return a2;
            }
            function P2(e2, t5, n3) {
              var r2 = e2.length;
              (!t5 || 0 > t5) && (t5 = 0), (!n3 || 0 > n3 || n3 > r2) && (n3 = r2);
              for (var a2 = "", o2 = t5; o2 < n3; ++o2)
                a2 += W2(e2[o2]);
              return a2;
            }
            function M2(e2, n3, r2) {
              for (var a2 = e2.slice(n3, r2), o2 = "", d4 = 0; d4 < a2.length; d4 += 2)
                o2 += t4(a2[d4] + 256 * a2[d4 + 1]);
              return o2;
            }
            function O2(e2, t5, n3) {
              if (0 != e2 % 1 || 0 > e2)
                throw new RangeError("offset is not uint");
              if (e2 + t5 > n3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function F2(e2, t5, n3, r2, a2, o2) {
              if (!s.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t5 > a2 || t5 < o2)
                throw new RangeError('"value" argument is out of bounds');
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function B(e2, t5, n3, r2) {
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
              if (0 > n3)
                throw new RangeError("Index out of range");
            }
            function U2(e2, t5, n3, r2, a2) {
              return t5 = +t5, n3 >>>= 0, a2 || B(e2, t5, n3, 4, 34028234663852886e22, -34028234663852886e22), J2.write(e2, t5, n3, r2, 23, 4), n3 + 4;
            }
            function j(e2, t5, n3, r2, a2) {
              return t5 = +t5, n3 >>>= 0, a2 || B(e2, t5, n3, 8, 17976931348623157e292, -17976931348623157e292), J2.write(e2, t5, n3, r2, 52, 8), n3 + 8;
            }
            function q(e2) {
              if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Q2, ""), 2 > e2.length)
                return "";
              for (; 0 != e2.length % 4; )
                e2 += "=";
              return e2;
            }
            function W2(e2) {
              return 16 > e2 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function H(e2, t5) {
              t5 = t5 || 1 / 0;
              for (var n3, r2 = e2.length, a2 = null, o2 = [], d4 = 0; d4 < r2; ++d4) {
                if (n3 = e2.charCodeAt(d4), 55295 < n3 && 57344 > n3) {
                  if (!a2) {
                    if (56319 < n3) {
                      -1 < (t5 -= 3) && o2.push(239, 191, 189);
                      continue;
                    } else if (d4 + 1 === r2) {
                      -1 < (t5 -= 3) && o2.push(239, 191, 189);
                      continue;
                    }
                    a2 = n3;
                    continue;
                  }
                  if (56320 > n3) {
                    -1 < (t5 -= 3) && o2.push(239, 191, 189), a2 = n3;
                    continue;
                  }
                  n3 = (a2 - 55296 << 10 | n3 - 56320) + 65536;
                } else
                  a2 && -1 < (t5 -= 3) && o2.push(239, 191, 189);
                if (a2 = null, 128 > n3) {
                  if (0 > (t5 -= 1))
                    break;
                  o2.push(n3);
                } else if (2048 > n3) {
                  if (0 > (t5 -= 2))
                    break;
                  o2.push(192 | n3 >> 6, 128 | 63 & n3);
                } else if (65536 > n3) {
                  if (0 > (t5 -= 3))
                    break;
                  o2.push(224 | n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else if (1114112 > n3) {
                  if (0 > (t5 -= 4))
                    break;
                  o2.push(240 | n3 >> 18, 128 | 63 & n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else
                  throw new Error("Invalid code point");
              }
              return o2;
            }
            function Y2(e2) {
              for (var t5 = [], n3 = 0; n3 < e2.length; ++n3)
                t5.push(255 & e2.charCodeAt(n3));
              return t5;
            }
            function V2(e2, t5) {
              for (var n3, r2, a2, o2 = [], d4 = 0; d4 < e2.length && !(0 > (t5 -= 2)); ++d4)
                n3 = e2.charCodeAt(d4), r2 = n3 >> 8, a2 = n3 % 256, o2.push(a2), o2.push(r2);
              return o2;
            }
            function z2(e2) {
              return $.toByteArray(q(e2));
            }
            function G2(e2, t5, n3, r2) {
              for (var a2 = 0; a2 < r2 && !(a2 + n3 >= t5.length || a2 >= e2.length); ++a2)
                t5[a2 + n3] = e2[a2];
              return a2;
            }
            function K2(e2, t5) {
              return e2 instanceof t5 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t5.name;
            }
            function X(e2) {
              return e2 !== e2;
            }
            var $ = e("base64-js"), J2 = e("ieee754");
            n2.Buffer = s, n2.SlowBuffer = function(e2) {
              return +e2 != e2 && (e2 = 0), s.alloc(+e2);
            }, n2.INSPECT_MAX_BYTES = 50;
            n2.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (t5) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.buffer : void 0;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.byteOffset : void 0;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t5, n3) {
              return l(e2, t5, n3);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t5, n3) {
              return u2(e2, t5, n3);
            }, s.allocUnsafe = function(e2) {
              return p(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return p(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t5) {
              if (K2(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), K2(t5, Uint8Array) && (t5 = s.from(t5, t5.offset, t5.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t5))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t5)
                return 0;
              for (var n3 = e2.length, r2 = t5.length, d4 = 0, l2 = o(n3, r2); d4 < l2; ++d4)
                if (e2[d4] !== t5[d4]) {
                  n3 = e2[d4], r2 = t5[d4];
                  break;
                }
              return n3 < r2 ? -1 : r2 < n3 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch ((e2 + "").toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t5) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return s.alloc(0);
              var n3;
              if (t5 === void 0)
                for (t5 = 0, n3 = 0; n3 < e2.length; ++n3)
                  t5 += e2[n3].length;
              var r2 = s.allocUnsafe(t5), a2 = 0;
              for (n3 = 0; n3 < e2.length; ++n3) {
                var o2 = e2[n3];
                if (K2(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(r2, a2), a2 += o2.length;
              }
              return r2;
            }, s.byteLength = b2, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (0 != e2 % 2)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t5 = 0; t5 < e2; t5 += 2)
                C2(this, t5, t5 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (0 != e2 % 4)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t5 = 0; t5 < e2; t5 += 4)
                C2(this, t5, t5 + 3), C2(this, t5 + 1, t5 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (0 != e2 % 8)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t5 = 0; t5 < e2; t5 += 8)
                C2(this, t5, t5 + 7), C2(this, t5 + 1, t5 + 6), C2(this, t5 + 2, t5 + 5), C2(this, t5 + 3, t5 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? x2(this, 0, e2) : y.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t5 = n2.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t5).replace(/(.{2})/g, "$1 ").trim(), this.length > t5 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t5, n3, r2, a2) {
              if (K2(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t5 && (t5 = 0), void 0 === n3 && (n3 = e2 ? e2.length : 0), void 0 === r2 && (r2 = 0), void 0 === a2 && (a2 = this.length), 0 > t5 || n3 > e2.length || 0 > r2 || a2 > this.length)
                throw new RangeError("out of range index");
              if (r2 >= a2 && t5 >= n3)
                return 0;
              if (r2 >= a2)
                return -1;
              if (t5 >= n3)
                return 1;
              if (t5 >>>= 0, n3 >>>= 0, r2 >>>= 0, a2 >>>= 0, this === e2)
                return 0;
              for (var d4 = a2 - r2, l2 = n3 - t5, c3 = o(d4, l2), u3 = this.slice(r2, a2), p2 = e2.slice(t5, n3), f2 = 0; f2 < c3; ++f2)
                if (u3[f2] !== p2[f2]) {
                  d4 = u3[f2], l2 = p2[f2];
                  break;
                }
              return d4 < l2 ? -1 : l2 < d4 ? 1 : 0;
            }, s.prototype.includes = function(e2, t5, n3) {
              return -1 !== this.indexOf(e2, t5, n3);
            }, s.prototype.indexOf = function(e2, t5, n3) {
              return R(this, e2, t5, n3, true);
            }, s.prototype.lastIndexOf = function(e2, t5, n3) {
              return R(this, e2, t5, n3, false);
            }, s.prototype.write = function(e2, t5, n3, r2) {
              if (void 0 === t5)
                r2 = "utf8", n3 = this.length, t5 = 0;
              else if (void 0 === n3 && "string" == typeof t5)
                r2 = t5, n3 = this.length, t5 = 0;
              else if (isFinite(t5))
                t5 >>>= 0, isFinite(n3) ? (n3 >>>= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n3, n3 = void 0);
              else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              var a2 = this.length - t5;
              if ((void 0 === n3 || n3 > a2) && (n3 = a2), 0 < e2.length && (0 > n3 || 0 > t5) || t5 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              r2 || (r2 = "utf8");
              for (var o2 = false; ; )
                switch (r2) {
                  case "hex":
                    return w(this, e2, t5, n3);
                  case "utf8":
                  case "utf-8":
                    return S2(this, e2, t5, n3);
                  case "ascii":
                    return T2(this, e2, t5, n3);
                  case "latin1":
                  case "binary":
                    return v2(this, e2, t5, n3);
                  case "base64":
                    return k(this, e2, t5, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return L2(this, e2, t5, n3);
                  default:
                    if (o2)
                      throw new TypeError("Unknown encoding: " + r2);
                    r2 = ("" + r2).toLowerCase(), o2 = true;
                }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            s.prototype.slice = function(e2, t5) {
              var n3 = this.length;
              e2 = ~~e2, t5 = t5 === void 0 ? n3 : ~~t5, 0 > e2 ? (e2 += n3, 0 > e2 && (e2 = 0)) : e2 > n3 && (e2 = n3), 0 > t5 ? (t5 += n3, 0 > t5 && (t5 = 0)) : t5 > n3 && (t5 = n3), t5 < e2 && (t5 = e2);
              var r2 = this.subarray(e2, t5);
              return r2.__proto__ = s.prototype, r2;
            }, s.prototype.readUIntLE = function(e2, t5, n3) {
              e2 >>>= 0, t5 >>>= 0, n3 || O2(e2, t5, this.length);
              for (var r2 = this[e2], a2 = 1, o2 = 0; ++o2 < t5 && (a2 *= 256); )
                r2 += this[e2 + o2] * a2;
              return r2;
            }, s.prototype.readUIntBE = function(e2, t5, n3) {
              e2 >>>= 0, t5 >>>= 0, n3 || O2(e2, t5, this.length);
              for (var r2 = this[e2 + --t5], a2 = 1; 0 < t5 && (a2 *= 256); )
                r2 += this[e2 + --t5] * a2;
              return r2;
            }, s.prototype.readUInt8 = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t5, n3) {
              e2 >>>= 0, t5 >>>= 0, n3 || O2(e2, t5, this.length);
              for (var a2 = this[e2], o2 = 1, d4 = 0; ++d4 < t5 && (o2 *= 256); )
                a2 += this[e2 + d4] * o2;
              return o2 *= 128, a2 >= o2 && (a2 -= r(2, 8 * t5)), a2;
            }, s.prototype.readIntBE = function(e2, t5, n3) {
              e2 >>>= 0, t5 >>>= 0, n3 || O2(e2, t5, this.length);
              for (var a2 = t5, o2 = 1, d4 = this[e2 + --a2]; 0 < a2 && (o2 *= 256); )
                d4 += this[e2 + --a2] * o2;
              return o2 *= 128, d4 >= o2 && (d4 -= r(2, 8 * t5)), d4;
            }, s.prototype.readInt8 = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t5) {
              e2 >>>= 0, t5 || O2(e2, 2, this.length);
              var n3 = this[e2] | this[e2 + 1] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt16BE = function(e2, t5) {
              e2 >>>= 0, t5 || O2(e2, 2, this.length);
              var n3 = this[e2 + 1] | this[e2] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt32LE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), J2.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 4, this.length), J2.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 8, this.length), J2.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t5) {
              return e2 >>>= 0, t5 || O2(e2, 8, this.length), J2.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t5, n3, a2) {
              if (e2 = +e2, t5 >>>= 0, n3 >>>= 0, !a2) {
                var o2 = r(2, 8 * n3) - 1;
                F2(this, e2, t5, n3, o2, 0);
              }
              var d4 = 1, s2 = 0;
              for (this[t5] = 255 & e2; ++s2 < n3 && (d4 *= 256); )
                this[t5 + s2] = 255 & e2 / d4;
              return t5 + n3;
            }, s.prototype.writeUIntBE = function(e2, t5, n3, a2) {
              if (e2 = +e2, t5 >>>= 0, n3 >>>= 0, !a2) {
                var o2 = r(2, 8 * n3) - 1;
                F2(this, e2, t5, n3, o2, 0);
              }
              var d4 = n3 - 1, s2 = 1;
              for (this[t5 + d4] = 255 & e2; 0 <= --d4 && (s2 *= 256); )
                this[t5 + d4] = 255 & e2 / s2;
              return t5 + n3;
            }, s.prototype.writeUInt8 = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 1, 255, 0), this[t5] = 255 & e2, t5 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 2, 65535, 0), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 2, 65535, 0), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 4, 4294967295, 0), this[t5 + 3] = e2 >>> 24, this[t5 + 2] = e2 >>> 16, this[t5 + 1] = e2 >>> 8, this[t5] = 255 & e2, t5 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 4, 4294967295, 0), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
            }, s.prototype.writeIntLE = function(e2, t5, n3, a2) {
              if (e2 = +e2, t5 >>>= 0, !a2) {
                var o2 = r(2, 8 * n3 - 1);
                F2(this, e2, t5, n3, o2 - 1, -o2);
              }
              var d4 = 0, s2 = 1, l2 = 0;
              for (this[t5] = 255 & e2; ++d4 < n3 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t5 + d4 - 1] && (l2 = 1), this[t5 + d4] = 255 & (e2 / s2 >> 0) - l2;
              return t5 + n3;
            }, s.prototype.writeIntBE = function(e2, t5, n3, a2) {
              if (e2 = +e2, t5 >>>= 0, !a2) {
                var o2 = r(2, 8 * n3 - 1);
                F2(this, e2, t5, n3, o2 - 1, -o2);
              }
              var d4 = n3 - 1, s2 = 1, l2 = 0;
              for (this[t5 + d4] = 255 & e2; 0 <= --d4 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t5 + d4 + 1] && (l2 = 1), this[t5 + d4] = 255 & (e2 / s2 >> 0) - l2;
              return t5 + n3;
            }, s.prototype.writeInt8 = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 1, 127, -128), 0 > e2 && (e2 = 255 + e2 + 1), this[t5] = 255 & e2, t5 + 1;
            }, s.prototype.writeInt16LE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 2, 32767, -32768), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
            }, s.prototype.writeInt16BE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 2, 32767, -32768), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
            }, s.prototype.writeInt32LE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 4, 2147483647, -2147483648), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, this[t5 + 2] = e2 >>> 16, this[t5 + 3] = e2 >>> 24, t5 + 4;
            }, s.prototype.writeInt32BE = function(e2, t5, n3) {
              return e2 = +e2, t5 >>>= 0, n3 || F2(this, e2, t5, 4, 2147483647, -2147483648), 0 > e2 && (e2 = 4294967295 + e2 + 1), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
            }, s.prototype.writeFloatLE = function(e2, t5, n3) {
              return U2(this, e2, t5, true, n3);
            }, s.prototype.writeFloatBE = function(e2, t5, n3) {
              return U2(this, e2, t5, false, n3);
            }, s.prototype.writeDoubleLE = function(e2, t5, n3) {
              return j(this, e2, t5, true, n3);
            }, s.prototype.writeDoubleBE = function(e2, t5, n3) {
              return j(this, e2, t5, false, n3);
            }, s.prototype.copy = function(e2, t5, n3, r2) {
              if (!s.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (n3 || (n3 = 0), r2 || 0 === r2 || (r2 = this.length), t5 >= e2.length && (t5 = e2.length), t5 || (t5 = 0), 0 < r2 && r2 < n3 && (r2 = n3), r2 === n3)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (0 > t5)
                throw new RangeError("targetStart out of bounds");
              if (0 > n3 || n3 >= this.length)
                throw new RangeError("Index out of range");
              if (0 > r2)
                throw new RangeError("sourceEnd out of bounds");
              r2 > this.length && (r2 = this.length), e2.length - t5 < r2 - n3 && (r2 = e2.length - t5 + n3);
              var a2 = r2 - n3;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t5, n3, r2);
              else if (this === e2 && n3 < t5 && t5 < r2)
                for (var o2 = a2 - 1; 0 <= o2; --o2)
                  e2[o2 + t5] = this[o2 + n3];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(n3, r2), t5);
              return a2;
            }, s.prototype.fill = function(e2, t5, n3, r2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t5 ? (r2 = t5, t5 = 0, n3 = this.length) : "string" == typeof n3 && (r2 = n3, n3 = this.length), void 0 !== r2 && "string" != typeof r2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof r2 && !s.isEncoding(r2))
                  throw new TypeError("Unknown encoding: " + r2);
                if (1 === e2.length) {
                  var a2 = e2.charCodeAt(0);
                  ("utf8" === r2 && 128 > a2 || "latin1" === r2) && (e2 = a2);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (0 > t5 || this.length < t5 || this.length < n3)
                throw new RangeError("Out of range index");
              if (n3 <= t5)
                return this;
              t5 >>>= 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e2 || (e2 = 0);
              var o2;
              if ("number" == typeof e2)
                for (o2 = t5; o2 < n3; ++o2)
                  this[o2] = e2;
              else {
                var d4 = s.isBuffer(e2) ? e2 : s.from(e2, r2), l2 = d4.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < n3 - t5; ++o2)
                  this[o2 + t5] = d4[o2 % l2];
              }
              return this;
            };
            var Q2 = /[^+/0-9A-Za-z-_]/g;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 1, buffer: 3, ieee754: 9 }], 4: [function(e, t3, n2) {
        (function(a2) {
          (function() {
            function r2() {
              let e2;
              try {
                e2 = n2.storage.getItem("debug");
              } catch (e3) {
              }
              return !e2 && "undefined" != typeof a2 && "env" in a2 && (e2 = a2.env.DEBUG), e2;
            }
            n2.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t3.exports.humanize(this.diff), !this.useColors)
                return;
              const n3 = "color: " + this.color;
              e2.splice(1, 0, n3, "color: inherit");
              let r3 = 0, a3 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" === e3 || (r3++, "%c" === e3 && (a3 = r3));
              }), e2.splice(a3, 0, n3);
            }, n2.save = function(e2) {
              try {
                e2 ? n2.storage.setItem("debug", e2) : n2.storage.removeItem("debug");
              } catch (e3) {
              }
            }, n2.load = r2, n2.useColors = function() {
              return !!("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }, n2.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), n2.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), n2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n2.log = console.debug || console.log || (() => {
            }), t3.exports = e("./common")(n2);
            const { formatters: o } = t3.exports;
            o.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 5, _process: 12 }], 5: [function(e, t3) {
        t3.exports = function(t4) {
          function r2(e2) {
            function t5(...e3) {
              if (!t5.enabled)
                return;
              const a3 = t5, o3 = +/* @__PURE__ */ new Date(), i = o3 - (n2 || o3);
              a3.diff = i, a3.prev = n2, a3.curr = o3, n2 = o3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let d3 = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t6, n3) => {
                if ("%%" === t6)
                  return "%";
                d3++;
                const o4 = r2.formatters[n3];
                if ("function" == typeof o4) {
                  const n4 = e3[d3];
                  t6 = o4.call(a3, n4), e3.splice(d3, 1), d3--;
                }
                return t6;
              }), r2.formatArgs.call(a3, e3);
              const s = a3.log || r2.log;
              s.apply(a3, e3);
            }
            let n2, o2 = null;
            return t5.namespace = e2, t5.useColors = r2.useColors(), t5.color = r2.selectColor(e2), t5.extend = a2, t5.destroy = r2.destroy, Object.defineProperty(t5, "enabled", { enumerable: true, configurable: false, get: () => null === o2 ? r2.enabled(e2) : o2, set: (e3) => {
              o2 = e3;
            } }), "function" == typeof r2.init && r2.init(t5), t5;
          }
          function a2(e2, t5) {
            const n2 = r2(this.namespace + ("undefined" == typeof t5 ? ":" : t5) + e2);
            return n2.log = this.log, n2;
          }
          function o(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            return e2 instanceof Error ? e2.stack || e2.message : e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(o), ...r2.skips.map(o).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            r2.save(e2), r2.names = [], r2.skips = [];
            let t5;
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), a3 = n2.length;
            for (t5 = 0; t5 < a3; t5++)
              n2[t5] && (e2 = n2[t5].replace(/\*/g, ".*?"), "-" === e2[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t5, n2;
            for (t5 = 0, n2 = r2.skips.length; t5 < n2; t5++)
              if (r2.skips[t5].test(e2))
                return false;
            for (t5 = 0, n2 = r2.names.length; t5 < n2; t5++)
              if (r2.names[t5].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t4).forEach((e2) => {
            r2[e2] = t4[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t5 = 0;
            for (let n2 = 0; n2 < e2.length; n2++)
              t5 = (t5 << 5) - t5 + e2.charCodeAt(n2), t5 |= 0;
            return r2.colors[n(t5) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 11 }], 6: [function(e, t3) {
        "use strict";
        function n2(e2, t4) {
          for (const n3 in t4)
            Object.defineProperty(e2, n3, { value: t4[n3], enumerable: true, configurable: true });
          return e2;
        }
        t3.exports = function(e2, t4, r2) {
          if (!e2 || "string" == typeof e2)
            throw new TypeError("Please pass an Error to err-code");
          r2 || (r2 = {}), "object" == typeof t4 && (r2 = t4, t4 = ""), t4 && (r2.code = t4);
          try {
            return n2(e2, r2);
          } catch (t5) {
            r2.message = e2.message, r2.stack = e2.stack;
            const a2 = function() {
            };
            a2.prototype = Object.create(Object.getPrototypeOf(e2));
            const o = n2(new a2(), r2);
            return o;
          }
        };
      }, {}], 7: [function(e, t3) {
        "use strict";
        function n2(e2) {
          console && console.warn && console.warn(e2);
        }
        function r2() {
          r2.init.call(this);
        }
        function a2(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function o(e2) {
          return void 0 === e2._maxListeners ? r2.defaultMaxListeners : e2._maxListeners;
        }
        function i(e2, t4, r3, i2) {
          var d4, s2, l2;
          if (a2(r3), s2 = e2._events, void 0 === s2 ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t4, r3.listener ? r3.listener : r3), s2 = e2._events), l2 = s2[t4]), void 0 === l2)
            l2 = s2[t4] = r3, ++e2._eventsCount;
          else if ("function" == typeof l2 ? l2 = s2[t4] = i2 ? [r3, l2] : [l2, r3] : i2 ? l2.unshift(r3) : l2.push(r3), d4 = o(e2), 0 < d4 && l2.length > d4 && !l2.warned) {
            l2.warned = true;
            var c3 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + (t4 + " listeners added. Use emitter.setMaxListeners() to increase limit"));
            c3.name = "MaxListenersExceededWarning", c3.emitter = e2, c3.type = t4, c3.count = l2.length, n2(c3);
          }
          return e2;
        }
        function d3() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function s(e2, t4, n3) {
          var r3 = { fired: false, wrapFn: void 0, target: e2, type: t4, listener: n3 }, a3 = d3.bind(r3);
          return a3.listener = n3, r3.wrapFn = a3, a3;
        }
        function l(e2, t4, n3) {
          var r3 = e2._events;
          if (r3 === void 0)
            return [];
          var a3 = r3[t4];
          return void 0 === a3 ? [] : "function" == typeof a3 ? n3 ? [a3.listener || a3] : [a3] : n3 ? f(a3) : u2(a3, a3.length);
        }
        function c2(e2) {
          var t4 = this._events;
          if (t4 !== void 0) {
            var n3 = t4[e2];
            if ("function" == typeof n3)
              return 1;
            if (void 0 !== n3)
              return n3.length;
          }
          return 0;
        }
        function u2(e2, t4) {
          for (var n3 = Array(t4), r3 = 0; r3 < t4; ++r3)
            n3[r3] = e2[r3];
          return n3;
        }
        function p(e2, t4) {
          for (; t4 + 1 < e2.length; t4++)
            e2[t4] = e2[t4 + 1];
          e2.pop();
        }
        function f(e2) {
          for (var t4 = Array(e2.length), n3 = 0; n3 < t4.length; ++n3)
            t4[n3] = e2[n3].listener || e2[n3];
          return t4;
        }
        function g(e2, t4, n3) {
          "function" == typeof e2.on && _(e2, "error", t4, n3);
        }
        function _(e2, t4, n3, r3) {
          if ("function" == typeof e2.on)
            r3.once ? e2.once(t4, n3) : e2.on(t4, n3);
          else if ("function" == typeof e2.addEventListener)
            e2.addEventListener(t4, function a3(o2) {
              r3.once && e2.removeEventListener(t4, a3), n3(o2);
            });
          else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
        }
        var h, m = "object" == typeof Reflect ? Reflect : null, b2 = m && "function" == typeof m.apply ? m.apply : function(e2, t4, n3) {
          return Function.prototype.apply.call(e2, t4, n3);
        };
        h = m && "function" == typeof m.ownKeys ? m.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var y = Number.isNaN || function(e2) {
          return e2 !== e2;
        };
        t3.exports = r2, t3.exports.once = function(e2, t4) {
          return new Promise(function(n3, r3) {
            function a3(n4) {
              e2.removeListener(t4, o2), r3(n4);
            }
            function o2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", a3), n3([].slice.call(arguments));
            }
            _(e2, t4, o2, { once: true }), "error" !== t4 && g(e2, a3, { once: true });
          });
        }, r2.EventEmitter = r2, r2.prototype._events = void 0, r2.prototype._eventsCount = 0, r2.prototype._maxListeners = void 0;
        var C2 = 10;
        Object.defineProperty(r2, "defaultMaxListeners", { enumerable: true, get: function() {
          return C2;
        }, set: function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          C2 = e2;
        } }), r2.init = function() {
          (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, r2.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, r2.prototype.getMaxListeners = function() {
          return o(this);
        }, r2.prototype.emit = function(e2) {
          for (var t4 = [], n3 = 1; n3 < arguments.length; n3++)
            t4.push(arguments[n3]);
          var r3 = "error" === e2, a3 = this._events;
          if (a3 !== void 0)
            r3 = r3 && a3.error === void 0;
          else if (!r3)
            return false;
          if (r3) {
            var o2;
            if (0 < t4.length && (o2 = t4[0]), o2 instanceof Error)
              throw o2;
            var d4 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw d4.context = o2, d4;
          }
          var s2 = a3[e2];
          if (s2 === void 0)
            return false;
          if ("function" == typeof s2)
            b2(s2, this, t4);
          else
            for (var l2 = s2.length, c3 = u2(s2, l2), n3 = 0; n3 < l2; ++n3)
              b2(c3[n3], this, t4);
          return true;
        }, r2.prototype.addListener = function(e2, t4) {
          return i(this, e2, t4, false);
        }, r2.prototype.on = r2.prototype.addListener, r2.prototype.prependListener = function(e2, t4) {
          return i(this, e2, t4, true);
        }, r2.prototype.once = function(e2, t4) {
          return a2(t4), this.on(e2, s(this, e2, t4)), this;
        }, r2.prototype.prependOnceListener = function(e2, t4) {
          return a2(t4), this.prependListener(e2, s(this, e2, t4)), this;
        }, r2.prototype.removeListener = function(e2, t4) {
          var n3, r3, o2, d4, s2;
          if (a2(t4), r3 = this._events, void 0 === r3)
            return this;
          if (n3 = r3[e2], void 0 === n3)
            return this;
          if (n3 === t4 || n3.listener === t4)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e2], r3.removeListener && this.emit("removeListener", e2, n3.listener || t4));
          else if ("function" != typeof n3) {
            for (o2 = -1, d4 = n3.length - 1; 0 <= d4; d4--)
              if (n3[d4] === t4 || n3[d4].listener === t4) {
                s2 = n3[d4].listener, o2 = d4;
                break;
              }
            if (0 > o2)
              return this;
            0 === o2 ? n3.shift() : p(n3, o2), 1 === n3.length && (r3[e2] = n3[0]), void 0 !== r3.removeListener && this.emit("removeListener", e2, s2 || t4);
          }
          return this;
        }, r2.prototype.off = r2.prototype.removeListener, r2.prototype.removeAllListeners = function(e2) {
          var t4, n3, r3;
          if (n3 = this._events, void 0 === n3)
            return this;
          if (void 0 === n3.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e2]), this;
          if (0 === arguments.length) {
            var a3, o2 = Object.keys(n3);
            for (r3 = 0; r3 < o2.length; ++r3)
              a3 = o2[r3], "removeListener" !== a3 && this.removeAllListeners(a3);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (t4 = n3[e2], "function" == typeof t4)
            this.removeListener(e2, t4);
          else if (void 0 !== t4)
            for (r3 = t4.length - 1; 0 <= r3; r3--)
              this.removeListener(e2, t4[r3]);
          return this;
        }, r2.prototype.listeners = function(e2) {
          return l(this, e2, true);
        }, r2.prototype.rawListeners = function(e2) {
          return l(this, e2, false);
        }, r2.listenerCount = function(e2, t4) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t4) : c2.call(e2, t4);
        }, r2.prototype.listenerCount = c2, r2.prototype.eventNames = function() {
          return 0 < this._eventsCount ? h(this._events) : [];
        };
      }, {}], 8: [function(e, t3) {
        t3.exports = function() {
          if ("undefined" == typeof globalThis)
            return null;
          var e2 = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate };
          return e2.RTCPeerConnection ? e2 : null;
        };
      }, {}], 9: [function(e, a2, o) {
        o.read = function(t3, n2, a3, o2, l) {
          var c2, u2, p = 8 * l - o2 - 1, f = (1 << p) - 1, g = f >> 1, _ = -7, h = a3 ? l - 1 : 0, b2 = a3 ? -1 : 1, d3 = t3[n2 + h];
          for (h += b2, c2 = d3 & (1 << -_) - 1, d3 >>= -_, _ += p; 0 < _; c2 = 256 * c2 + t3[n2 + h], h += b2, _ -= 8)
            ;
          for (u2 = c2 & (1 << -_) - 1, c2 >>= -_, _ += o2; 0 < _; u2 = 256 * u2 + t3[n2 + h], h += b2, _ -= 8)
            ;
          if (0 === c2)
            c2 = 1 - g;
          else {
            if (c2 === f)
              return u2 ? NaN : (d3 ? -1 : 1) * (1 / 0);
            u2 += r(2, o2), c2 -= g;
          }
          return (d3 ? -1 : 1) * u2 * r(2, c2 - o2);
        }, o.write = function(a3, o2, l, u2, p, f) {
          var h, b2, y, g = Math.LN2, _ = Math.log, C2 = 8 * f - p - 1, R = (1 << C2) - 1, E2 = R >> 1, w = 23 === p ? r(2, -24) - r(2, -77) : 0, S2 = u2 ? 0 : f - 1, T2 = u2 ? 1 : -1, d3 = 0 > o2 || 0 === o2 && 0 > 1 / o2 ? 1 : 0;
          for (o2 = n(o2), isNaN(o2) || o2 === 1 / 0 ? (b2 = isNaN(o2) ? 1 : 0, h = R) : (h = t2(_(o2) / g), 1 > o2 * (y = r(2, -h)) && (h--, y *= 2), o2 += 1 <= h + E2 ? w / y : w * r(2, 1 - E2), 2 <= o2 * y && (h++, y /= 2), h + E2 >= R ? (b2 = 0, h = R) : 1 <= h + E2 ? (b2 = (o2 * y - 1) * r(2, p), h += E2) : (b2 = o2 * r(2, E2 - 1) * r(2, p), h = 0)); 8 <= p; a3[l + S2] = 255 & b2, S2 += T2, b2 /= 256, p -= 8)
            ;
          for (h = h << p | b2, C2 += p; 0 < C2; a3[l + S2] = 255 & h, S2 += T2, h /= 256, C2 -= 8)
            ;
          a3[l + S2 - T2] |= 128 * d3;
        };
      }, {}], 10: [function(e, t3) {
        t3.exports = "function" == typeof Object.create ? function(e2, t4) {
          t4 && (e2.super_ = t4, e2.prototype = Object.create(t4.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : function(e2, t4) {
          if (t4) {
            e2.super_ = t4;
            var n2 = function() {
            };
            n2.prototype = t4.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 11: [function(e, t3) {
        var r2 = Math.round;
        function a2(e2) {
          if (e2 += "", !(100 < e2.length)) {
            var t4 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
            if (t4) {
              var r3 = parseFloat(t4[1]), n2 = (t4[2] || "ms").toLowerCase();
              return "years" === n2 || "year" === n2 || "yrs" === n2 || "yr" === n2 || "y" === n2 ? 315576e5 * r3 : "weeks" === n2 || "week" === n2 || "w" === n2 ? 6048e5 * r3 : "days" === n2 || "day" === n2 || "d" === n2 ? 864e5 * r3 : "hours" === n2 || "hour" === n2 || "hrs" === n2 || "hr" === n2 || "h" === n2 ? 36e5 * r3 : "minutes" === n2 || "minute" === n2 || "mins" === n2 || "min" === n2 || "m" === n2 ? 6e4 * r3 : "seconds" === n2 || "second" === n2 || "secs" === n2 || "sec" === n2 || "s" === n2 ? 1e3 * r3 : "milliseconds" === n2 || "millisecond" === n2 || "msecs" === n2 || "msec" === n2 || "ms" === n2 ? r3 : void 0;
            }
          }
        }
        function o(e2) {
          var t4 = n(e2);
          return 864e5 <= t4 ? r2(e2 / 864e5) + "d" : 36e5 <= t4 ? r2(e2 / 36e5) + "h" : 6e4 <= t4 ? r2(e2 / 6e4) + "m" : 1e3 <= t4 ? r2(e2 / 1e3) + "s" : e2 + "ms";
        }
        function i(e2) {
          var t4 = n(e2);
          return 864e5 <= t4 ? s(e2, t4, 864e5, "day") : 36e5 <= t4 ? s(e2, t4, 36e5, "hour") : 6e4 <= t4 ? s(e2, t4, 6e4, "minute") : 1e3 <= t4 ? s(e2, t4, 1e3, "second") : e2 + " ms";
        }
        function s(e2, t4, a3, n2) {
          return r2(e2 / a3) + " " + n2 + (t4 >= 1.5 * a3 ? "s" : "");
        }
        var l = 24 * (60 * 6e4);
        t3.exports = function(e2, t4) {
          t4 = t4 || {};
          var n2 = typeof e2;
          if ("string" == n2 && 0 < e2.length)
            return a2(e2);
          if ("number" === n2 && isFinite(e2))
            return t4.long ? i(e2) : o(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 12: [function(e, t3) {
        function n2() {
          throw new Error("setTimeout has not been defined");
        }
        function r2() {
          throw new Error("clearTimeout has not been defined");
        }
        function a2(t4) {
          if (c2 === setTimeout)
            return setTimeout(t4, 0);
          if ((c2 === n2 || !c2) && setTimeout)
            return c2 = setTimeout, setTimeout(t4, 0);
          try {
            return c2(t4, 0);
          } catch (n3) {
            try {
              return c2.call(null, t4, 0);
            } catch (n4) {
              return c2.call(this, t4, 0);
            }
          }
        }
        function o(t4) {
          if (u2 === clearTimeout)
            return clearTimeout(t4);
          if ((u2 === r2 || !u2) && clearTimeout)
            return u2 = clearTimeout, clearTimeout(t4);
          try {
            return u2(t4);
          } catch (n3) {
            try {
              return u2.call(null, t4);
            } catch (n4) {
              return u2.call(this, t4);
            }
          }
        }
        function i() {
          _ && f && (_ = false, f.length ? g = f.concat(g) : h = -1, g.length && d3());
        }
        function d3() {
          if (!_) {
            var e2 = a2(i);
            _ = true;
            for (var t4 = g.length; t4; ) {
              for (f = g, g = []; ++h < t4; )
                f && f[h].run();
              h = -1, t4 = g.length;
            }
            f = null, _ = false, o(e2);
          }
        }
        function s(e2, t4) {
          this.fun = e2, this.array = t4;
        }
        function l() {
        }
        var c2, u2, p = t3.exports = {};
        (function() {
          try {
            c2 = "function" == typeof setTimeout ? setTimeout : n2;
          } catch (t4) {
            c2 = n2;
          }
          try {
            u2 = "function" == typeof clearTimeout ? clearTimeout : r2;
          } catch (t4) {
            u2 = r2;
          }
        })();
        var f, g = [], _ = false, h = -1;
        p.nextTick = function(e2) {
          var t4 = Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var n3 = 1; n3 < arguments.length; n3++)
              t4[n3 - 1] = arguments[n3];
          g.push(new s(e2, t4)), 1 !== g.length || _ || a2(d3);
        }, s.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function() {
          return [];
        }, p.binding = function() {
          throw new Error("process.binding is not supported");
        }, p.cwd = function() {
          return "/";
        }, p.chdir = function() {
          throw new Error("process.chdir is not supported");
        }, p.umask = function() {
          return 0;
        };
      }, {}], 13: [function(e, t3) {
        (function(e2) {
          (function() {
            let n2;
            t3.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" == typeof window ? e2 : window) : (e3) => (n2 || (n2 = Promise.resolve())).then(e3).catch((e4) => setTimeout(() => {
              throw e4;
            }, 0));
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], 14: [function(e, t3) {
        (function(n2, r2) {
          (function() {
            "use strict";
            var a2 = e("safe-buffer").Buffer, o = r2.crypto || r2.msCrypto;
            t3.exports = o && o.getRandomValues ? function(e2, t4) {
              if (e2 > 4294967295)
                throw new RangeError("requested too many random bytes");
              var r3 = a2.allocUnsafe(e2);
              if (0 < e2)
                if (65536 < e2)
                  for (var i = 0; i < e2; i += 65536)
                    o.getRandomValues(r3.slice(i, i + 65536));
                else
                  o.getRandomValues(r3);
              return "function" == typeof t4 ? n2.nextTick(function() {
                t4(null, r3);
              }) : r3;
            } : function() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { _process: 12, "safe-buffer": 30 }], 15: [function(e, t3) {
        "use strict";
        function n2(e2, t4) {
          e2.prototype = Object.create(t4.prototype), e2.prototype.constructor = e2, e2.__proto__ = t4;
        }
        function r2(e2, t4, r3) {
          function a3(e3, n3, r4) {
            return "string" == typeof t4 ? t4 : t4(e3, n3, r4);
          }
          r3 || (r3 = Error);
          var o2 = function(e3) {
            function t5(t6, n3, r4) {
              return e3.call(this, a3(t6, n3, r4)) || this;
            }
            return n2(t5, e3), t5;
          }(r3);
          o2.prototype.name = r3.name, o2.prototype.code = e2, s[e2] = o2;
        }
        function a2(e2, t4) {
          if (Array.isArray(e2)) {
            var n3 = e2.length;
            return e2 = e2.map(function(e3) {
              return e3 + "";
            }), 2 < n3 ? "one of ".concat(t4, " ").concat(e2.slice(0, n3 - 1).join(", "), ", or ") + e2[n3 - 1] : 2 === n3 ? "one of ".concat(t4, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t4, " ").concat(e2[0]);
          }
          return "of ".concat(t4, " ").concat(e2 + "");
        }
        function o(e2, t4, n3) {
          return e2.substr(!n3 || 0 > n3 ? 0 : +n3, t4.length) === t4;
        }
        function i(e2, t4, n3) {
          return (void 0 === n3 || n3 > e2.length) && (n3 = e2.length), e2.substring(n3 - t4.length, n3) === t4;
        }
        function d3(e2, t4, n3) {
          return "number" != typeof n3 && (n3 = 0), !(n3 + t4.length > e2.length) && -1 !== e2.indexOf(t4, n3);
        }
        var s = {};
        r2("ERR_INVALID_OPT_VALUE", function(e2, t4) {
          return 'The value "' + t4 + '" is invalid for option "' + e2 + '"';
        }, TypeError), r2("ERR_INVALID_ARG_TYPE", function(e2, t4, n3) {
          var r3;
          "string" == typeof t4 && o(t4, "not ") ? (r3 = "must not be", t4 = t4.replace(/^not /, "")) : r3 = "must be";
          var s2;
          if (i(e2, " argument"))
            s2 = "The ".concat(e2, " ").concat(r3, " ").concat(a2(t4, "type"));
          else {
            var l = d3(e2, ".") ? "property" : "argument";
            s2 = 'The "'.concat(e2, '" ').concat(l, " ").concat(r3, " ").concat(a2(t4, "type"));
          }
          return s2 += ". Received type ".concat(typeof n3), s2;
        }, TypeError), r2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r2("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), r2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r2("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), r2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r2("ERR_STREAM_WRITE_AFTER_END", "write after end"), r2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r2("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), r2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t3.exports.codes = s;
      }, {}], 16: [function(e, t3) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2) {
              return this instanceof r2 ? void (d3.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a2)))) : new r2(e2);
            }
            function a2() {
              this._writableState.ended || n2.nextTick(o, this);
            }
            function o(e2) {
              e2.end();
            }
            var i = Object.keys || function(e2) {
              var t4 = [];
              for (var n3 in e2)
                t4.push(n3);
              return t4;
            };
            t3.exports = r2;
            var d3 = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(r2, d3);
            for (var l, c2 = i(s.prototype), u2 = 0; u2 < c2.length; u2++)
              l = c2[u2], r2.prototype[l] || (r2.prototype[l] = s.prototype[l]);
            Object.defineProperty(r2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(r2.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(r2.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(r2.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            }, set: function(e2) {
              void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 18, "./_stream_writable": 20, _process: 12, inherits: 10 }], 17: [function(e, t3) {
        "use strict";
        function n2(e2) {
          return this instanceof n2 ? void r2.call(this, e2) : new n2(e2);
        }
        t3.exports = n2;
        var r2 = e("./_stream_transform");
        e("inherits")(n2, r2), n2.prototype._transform = function(e2, t4, n3) {
          n3(null, e2);
        };
      }, { "./_stream_transform": 19, inherits: 10 }], 18: [function(e, t3) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a2(e2) {
              return P2.from(e2);
            }
            function o(e2) {
              return P2.isBuffer(e2) || e2 instanceof M2;
            }
            function i(e2, t4, n3) {
              return "function" == typeof e2.prependListener ? e2.prependListener(t4, n3) : void (e2._events && e2._events[t4] ? Array.isArray(e2._events[t4]) ? e2._events[t4].unshift(n3) : e2._events[t4] = [n3, e2._events[t4]] : e2.on(t4, n3));
            }
            function d3(t4, n3, r3) {
              A = A || e("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof A), this.objectMode = !!t4.objectMode, r3 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = H(this, t4, "readableHighWaterMark", r3), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (!F2 && (F2 = e("string_decoder/").StringDecoder), this.decoder = new F2(t4.encoding), this.encoding = t4.encoding);
            }
            function s(t4) {
              if (A = A || e("./_stream_duplex"), !(this instanceof s))
                return new s(t4);
              var n3 = this instanceof A;
              this._readableState = new d3(t4, this, n3), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), I2.call(this);
            }
            function l(e2, t4, n3, r3, o2) {
              x2("readableAddChunk", t4);
              var i2 = e2._readableState;
              if (null === t4)
                i2.reading = false, g(e2, i2);
              else {
                var d4;
                if (o2 || (d4 = u2(i2, t4)), d4)
                  X(e2, d4);
                else if (!(i2.objectMode || t4 && 0 < t4.length))
                  r3 || (i2.reading = false, m(e2, i2));
                else if ("string" == typeof t4 || i2.objectMode || Object.getPrototypeOf(t4) === P2.prototype || (t4 = a2(t4)), r3)
                  i2.endEmitted ? X(e2, new K2()) : c2(e2, i2, t4, true);
                else if (i2.ended)
                  X(e2, new z2());
                else {
                  if (i2.destroyed)
                    return false;
                  i2.reading = false, i2.decoder && !n3 ? (t4 = i2.decoder.write(t4), i2.objectMode || 0 !== t4.length ? c2(e2, i2, t4, false) : m(e2, i2)) : c2(e2, i2, t4, false);
                }
              }
              return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
            }
            function c2(e2, t4, n3, r3) {
              t4.flowing && 0 === t4.length && !t4.sync ? (t4.awaitDrain = 0, e2.emit("data", n3)) : (t4.length += t4.objectMode ? 1 : n3.length, r3 ? t4.buffer.unshift(n3) : t4.buffer.push(n3), t4.needReadable && _(e2)), m(e2, t4);
            }
            function u2(e2, t4) {
              var n3;
              return o(t4) || "string" == typeof t4 || void 0 === t4 || e2.objectMode || (n3 = new V2("chunk", ["string", "Buffer", "Uint8Array"], t4)), n3;
            }
            function p(e2) {
              return 1073741824 <= e2 ? e2 = 1073741824 : (e2--, e2 |= e2 >>> 1, e2 |= e2 >>> 2, e2 |= e2 >>> 4, e2 |= e2 >>> 8, e2 |= e2 >>> 16, e2++), e2;
            }
            function f(e2, t4) {
              return 0 >= e2 || 0 === t4.length && t4.ended ? 0 : t4.objectMode ? 1 : e2 === e2 ? (e2 > t4.highWaterMark && (t4.highWaterMark = p(e2)), e2 <= t4.length ? e2 : t4.ended ? t4.length : (t4.needReadable = true, 0)) : t4.flowing && t4.length ? t4.buffer.head.data.length : t4.length;
            }
            function g(e2, t4) {
              if (x2("onEofChunk"), !t4.ended) {
                if (t4.decoder) {
                  var n3 = t4.decoder.end();
                  n3 && n3.length && (t4.buffer.push(n3), t4.length += t4.objectMode ? 1 : n3.length);
                }
                t4.ended = true, t4.sync ? _(e2) : (t4.needReadable = false, !t4.emittedReadable && (t4.emittedReadable = true, h(e2)));
              }
            }
            function _(e2) {
              var t4 = e2._readableState;
              x2("emitReadable", t4.needReadable, t4.emittedReadable), t4.needReadable = false, t4.emittedReadable || (x2("emitReadable", t4.flowing), t4.emittedReadable = true, n2.nextTick(h, e2));
            }
            function h(e2) {
              var t4 = e2._readableState;
              x2("emitReadable_", t4.destroyed, t4.length, t4.ended), !t4.destroyed && (t4.length || t4.ended) && (e2.emit("readable"), t4.emittedReadable = false), t4.needReadable = !t4.flowing && !t4.ended && t4.length <= t4.highWaterMark, S2(e2);
            }
            function m(e2, t4) {
              t4.readingMore || (t4.readingMore = true, n2.nextTick(b2, e2, t4));
            }
            function b2(e2, t4) {
              for (; !t4.reading && !t4.ended && (t4.length < t4.highWaterMark || t4.flowing && 0 === t4.length); ) {
                var n3 = t4.length;
                if (x2("maybeReadMore read 0"), e2.read(0), n3 === t4.length)
                  break;
              }
              t4.readingMore = false;
            }
            function y(e2) {
              return function() {
                var t4 = e2._readableState;
                x2("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && D2(e2, "data") && (t4.flowing = true, S2(e2));
              };
            }
            function C2(e2) {
              var t4 = e2._readableState;
              t4.readableListening = 0 < e2.listenerCount("readable"), t4.resumeScheduled && !t4.paused ? t4.flowing = true : 0 < e2.listenerCount("data") && e2.resume();
            }
            function R(e2) {
              x2("readable nexttick read 0"), e2.read(0);
            }
            function E2(e2, t4) {
              t4.resumeScheduled || (t4.resumeScheduled = true, n2.nextTick(w, e2, t4));
            }
            function w(e2, t4) {
              x2("resume", t4.reading), t4.reading || e2.read(0), t4.resumeScheduled = false, e2.emit("resume"), S2(e2), t4.flowing && !t4.reading && e2.read(0);
            }
            function S2(e2) {
              var t4 = e2._readableState;
              for (x2("flow", t4.flowing); t4.flowing && null !== e2.read(); )
                ;
            }
            function T2(e2, t4) {
              if (0 === t4.length)
                return null;
              var n3;
              return t4.objectMode ? n3 = t4.buffer.shift() : !e2 || e2 >= t4.length ? (n3 = t4.decoder ? t4.buffer.join("") : 1 === t4.buffer.length ? t4.buffer.first() : t4.buffer.concat(t4.length), t4.buffer.clear()) : n3 = t4.buffer.consume(e2, t4.decoder), n3;
            }
            function v2(e2) {
              var t4 = e2._readableState;
              x2("endReadable", t4.endEmitted), t4.endEmitted || (t4.ended = true, n2.nextTick(k, t4, e2));
            }
            function k(e2, t4) {
              if (x2("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t4.readable = false, t4.emit("end"), e2.autoDestroy)) {
                var n3 = t4._writableState;
                (!n3 || n3.autoDestroy && n3.finished) && t4.destroy();
              }
            }
            function L2(e2, t4) {
              for (var n3 = 0, r3 = e2.length; n3 < r3; n3++)
                if (e2[n3] === t4)
                  return n3;
              return -1;
            }
            t3.exports = s;
            var A;
            s.ReadableState = d3;
            var x2, N2 = e("events").EventEmitter, D2 = function(e2, t4) {
              return e2.listeners(t4).length;
            }, I2 = e("./internal/streams/stream"), P2 = e("buffer").Buffer, M2 = r2.Uint8Array || function() {
            }, O2 = e("util");
            x2 = O2 && O2.debuglog ? O2.debuglog("stream") : function() {
            };
            var F2, B, U2, j = e("./internal/streams/buffer_list"), q = e("./internal/streams/destroy"), W2 = e("./internal/streams/state"), H = W2.getHighWaterMark, Y2 = e("../errors").codes, V2 = Y2.ERR_INVALID_ARG_TYPE, z2 = Y2.ERR_STREAM_PUSH_AFTER_EOF, G2 = Y2.ERR_METHOD_NOT_IMPLEMENTED, K2 = Y2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(s, I2);
            var X = q.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
            Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function(e2, t4) {
              t4(e2);
            }, s.prototype.push = function(e2, t4) {
              var n3, r3 = this._readableState;
              return r3.objectMode ? n3 = true : "string" == typeof e2 && (t4 = t4 || r3.defaultEncoding, t4 !== r3.encoding && (e2 = P2.from(e2, t4), t4 = ""), n3 = true), l(this, e2, t4, false, n3);
            }, s.prototype.unshift = function(e2) {
              return l(this, e2, null, true, false);
            }, s.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, s.prototype.setEncoding = function(t4) {
              F2 || (F2 = e("string_decoder/").StringDecoder);
              var n3 = new F2(t4);
              this._readableState.decoder = n3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var r3 = this._readableState.buffer.head, a3 = ""; null !== r3; )
                a3 += n3.write(r3.data), r3 = r3.next;
              return this._readableState.buffer.clear(), "" !== a3 && this._readableState.buffer.push(a3), this._readableState.length = a3.length, this;
            };
            s.prototype.read = function(e2) {
              x2("read", e2), e2 = parseInt(e2, 10);
              var t4 = this._readableState, r3 = e2;
              if (0 !== e2 && (t4.emittedReadable = false), 0 === e2 && t4.needReadable && ((0 === t4.highWaterMark ? 0 < t4.length : t4.length >= t4.highWaterMark) || t4.ended))
                return x2("read: emitReadable", t4.length, t4.ended), 0 === t4.length && t4.ended ? v2(this) : _(this), null;
              if (e2 = f(e2, t4), 0 === e2 && t4.ended)
                return 0 === t4.length && v2(this), null;
              var a3 = t4.needReadable;
              x2("need readable", a3), (0 === t4.length || t4.length - e2 < t4.highWaterMark) && (a3 = true, x2("length less than watermark", a3)), t4.ended || t4.reading ? (a3 = false, x2("reading or ended", a3)) : a3 && (x2("do read"), t4.reading = true, t4.sync = true, 0 === t4.length && (t4.needReadable = true), this._read(t4.highWaterMark), t4.sync = false, !t4.reading && (e2 = f(r3, t4)));
              var o2;
              return o2 = 0 < e2 ? T2(e2, t4) : null, null === o2 ? (t4.needReadable = t4.length <= t4.highWaterMark, e2 = 0) : (t4.length -= e2, t4.awaitDrain = 0), 0 === t4.length && (!t4.ended && (t4.needReadable = true), r3 !== e2 && t4.ended && v2(this)), null !== o2 && this.emit("data", o2), o2;
            }, s.prototype._read = function() {
              X(this, new G2("_read()"));
            }, s.prototype.pipe = function(e2, t4) {
              function r3(e3, t5) {
                x2("onunpipe"), e3 === p2 && t5 && false === t5.hasUnpiped && (t5.hasUnpiped = true, o2());
              }
              function a3() {
                x2("onend"), e2.end();
              }
              function o2() {
                x2("cleanup"), e2.removeListener("close", l2), e2.removeListener("finish", c3), e2.removeListener("drain", h2), e2.removeListener("error", s2), e2.removeListener("unpipe", r3), p2.removeListener("end", a3), p2.removeListener("end", u3), p2.removeListener("data", d4), m2 = true, f2.awaitDrain && (!e2._writableState || e2._writableState.needDrain) && h2();
              }
              function d4(t5) {
                x2("ondata");
                var n3 = e2.write(t5);
                x2("dest.write", n3), false === n3 && ((1 === f2.pipesCount && f2.pipes === e2 || 1 < f2.pipesCount && -1 !== L2(f2.pipes, e2)) && !m2 && (x2("false write response, pause", f2.awaitDrain), f2.awaitDrain++), p2.pause());
              }
              function s2(t5) {
                x2("onerror", t5), u3(), e2.removeListener("error", s2), 0 === D2(e2, "error") && X(e2, t5);
              }
              function l2() {
                e2.removeListener("finish", c3), u3();
              }
              function c3() {
                x2("onfinish"), e2.removeListener("close", l2), u3();
              }
              function u3() {
                x2("unpipe"), p2.unpipe(e2);
              }
              var p2 = this, f2 = this._readableState;
              switch (f2.pipesCount) {
                case 0:
                  f2.pipes = e2;
                  break;
                case 1:
                  f2.pipes = [f2.pipes, e2];
                  break;
                default:
                  f2.pipes.push(e2);
              }
              f2.pipesCount += 1, x2("pipe count=%d opts=%j", f2.pipesCount, t4);
              var g2 = (!t4 || false !== t4.end) && e2 !== n2.stdout && e2 !== n2.stderr, _2 = g2 ? a3 : u3;
              f2.endEmitted ? n2.nextTick(_2) : p2.once("end", _2), e2.on("unpipe", r3);
              var h2 = y(p2);
              e2.on("drain", h2);
              var m2 = false;
              return p2.on("data", d4), i(e2, "error", s2), e2.once("close", l2), e2.once("finish", c3), e2.emit("pipe", p2), f2.flowing || (x2("pipe resume"), p2.resume()), e2;
            }, s.prototype.unpipe = function(e2) {
              var t4 = this._readableState, n3 = { hasUnpiped: false };
              if (0 === t4.pipesCount)
                return this;
              if (1 === t4.pipesCount)
                return e2 && e2 !== t4.pipes ? this : (e2 || (e2 = t4.pipes), t4.pipes = null, t4.pipesCount = 0, t4.flowing = false, e2 && e2.emit("unpipe", this, n3), this);
              if (!e2) {
                var r3 = t4.pipes, a3 = t4.pipesCount;
                t4.pipes = null, t4.pipesCount = 0, t4.flowing = false;
                for (var o2 = 0; o2 < a3; o2++)
                  r3[o2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var d4 = L2(t4.pipes, e2);
              return -1 === d4 ? this : (t4.pipes.splice(d4, 1), t4.pipesCount -= 1, 1 === t4.pipesCount && (t4.pipes = t4.pipes[0]), e2.emit("unpipe", this, n3), this);
            }, s.prototype.on = function(e2, t4) {
              var r3 = I2.prototype.on.call(this, e2, t4), a3 = this._readableState;
              return "data" === e2 ? (a3.readableListening = 0 < this.listenerCount("readable"), false !== a3.flowing && this.resume()) : "readable" == e2 && !a3.endEmitted && !a3.readableListening && (a3.readableListening = a3.needReadable = true, a3.flowing = false, a3.emittedReadable = false, x2("on readable", a3.length, a3.reading), a3.length ? _(this) : !a3.reading && n2.nextTick(R, this)), r3;
            }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function(e2, t4) {
              var r3 = I2.prototype.removeListener.call(this, e2, t4);
              return "readable" === e2 && n2.nextTick(C2, this), r3;
            }, s.prototype.removeAllListeners = function(e2) {
              var t4 = I2.prototype.removeAllListeners.apply(this, arguments);
              return ("readable" === e2 || void 0 === e2) && n2.nextTick(C2, this), t4;
            }, s.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (x2("resume"), e2.flowing = !e2.readableListening, E2(this, e2)), e2.paused = false, this;
            }, s.prototype.pause = function() {
              return x2("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (x2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, s.prototype.wrap = function(e2) {
              var t4 = this, r3 = this._readableState, a3 = false;
              for (var o2 in e2.on("end", function() {
                if (x2("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t4.push(e3);
                }
                t4.push(null);
              }), e2.on("data", function(n3) {
                if ((x2("wrapped data"), r3.decoder && (n3 = r3.decoder.write(n3)), !(r3.objectMode && (null === n3 || void 0 === n3))) && (r3.objectMode || n3 && n3.length)) {
                  var o3 = t4.push(n3);
                  o3 || (a3 = true, e2.pause());
                }
              }), e2)
                void 0 === this[o2] && "function" == typeof e2[o2] && (this[o2] = function(t5) {
                  return function() {
                    return e2[t5].apply(e2, arguments);
                  };
                }(o2));
              for (var i2 = 0; i2 < $.length; i2++)
                e2.on($[i2], this.emit.bind(this, $[i2]));
              return this._read = function(t5) {
                x2("wrapped _read", t5), a3 && (a3 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function() {
              return void 0 === B && (B = e("./internal/streams/async_iterator")), B(this);
            }), Object.defineProperty(s.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(s.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(s.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), s._fromList = T2, Object.defineProperty(s.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (s.from = function(t4, n3) {
              return void 0 === U2 && (U2 = e("./internal/streams/from")), U2(s, t4, n3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/async_iterator": 21, "./internal/streams/buffer_list": 22, "./internal/streams/destroy": 23, "./internal/streams/from": 25, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, events: 7, inherits: 10, "string_decoder/": 31, util: 2 }], 19: [function(e, t3) {
        "use strict";
        function n2(e2, t4) {
          var n3 = this._transformState;
          n3.transforming = false;
          var r3 = n3.writecb;
          if (null === r3)
            return this.emit("error", new s());
          n3.writechunk = null, n3.writecb = null, null != t4 && this.push(t4), r3(e2);
          var a3 = this._readableState;
          a3.reading = false, (a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
        }
        function r2(e2) {
          return this instanceof r2 ? void (u2.call(this, e2), this._transformState = { afterTransform: n2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a2)) : new r2(e2);
        }
        function a2() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function(t4, n3) {
            o(e2, t4, n3);
          });
        }
        function o(e2, t4, n3) {
          if (t4)
            return e2.emit("error", t4);
          if (null != n3 && e2.push(n3), e2._writableState.length)
            throw new c2();
          if (e2._transformState.transforming)
            throw new l();
          return e2.push(null);
        }
        t3.exports = r2;
        var i = e("../errors").codes, d3 = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, c2 = i.ERR_TRANSFORM_WITH_LENGTH_0, u2 = e("./_stream_duplex");
        e("inherits")(r2, u2), r2.prototype.push = function(e2, t4) {
          return this._transformState.needTransform = false, u2.prototype.push.call(this, e2, t4);
        }, r2.prototype._transform = function(e2, t4, n3) {
          n3(new d3("_transform()"));
        }, r2.prototype._write = function(e2, t4, n3) {
          var r3 = this._transformState;
          if (r3.writecb = n3, r3.writechunk = e2, r3.writeencoding = t4, !r3.transforming) {
            var a3 = this._readableState;
            (r3.needTransform || a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
          }
        }, r2.prototype._read = function() {
          var e2 = this._transformState;
          null === e2.writechunk || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
        }, r2.prototype._destroy = function(e2, t4) {
          u2.prototype._destroy.call(this, e2, function(e3) {
            t4(e3);
          });
        };
      }, { "../errors": 15, "./_stream_duplex": 16, inherits: 10 }], 20: [function(e, t3) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a2(e2) {
              var t4 = this;
              this.next = null, this.entry = null, this.finish = function() {
                v2(t4, e2);
              };
            }
            function o(e2) {
              return x2.from(e2);
            }
            function i(e2) {
              return x2.isBuffer(e2) || e2 instanceof N2;
            }
            function d3() {
            }
            function s(t4, n3, r3) {
              k = k || e("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof k), this.objectMode = !!t4.objectMode, r3 && (this.objectMode = this.objectMode || !!t4.writableObjectMode), this.highWaterMark = P2(this, t4, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var o2 = false === t4.decodeStrings;
              this.decodeStrings = !o2, this.defaultEncoding = t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                m(n3, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a2(this);
            }
            function l(t4) {
              k = k || e("./_stream_duplex");
              var n3 = this instanceof k;
              return n3 || V2.call(l, this) ? void (this._writableState = new s(t4, this, n3), this.writable = true, t4 && ("function" == typeof t4.write && (this._write = t4.write), "function" == typeof t4.writev && (this._writev = t4.writev), "function" == typeof t4.destroy && (this._destroy = t4.destroy), "function" == typeof t4.final && (this._final = t4.final)), A.call(this)) : new l(t4);
            }
            function c2(e2, t4) {
              var r3 = new W2();
              Y2(e2, r3), n2.nextTick(t4, r3);
            }
            function u2(e2, t4, r3, a3) {
              var o2;
              return null === r3 ? o2 = new q() : "string" != typeof r3 && !t4.objectMode && (o2 = new O2("chunk", ["string", "Buffer"], r3)), !o2 || (Y2(e2, o2), n2.nextTick(a3, o2), false);
            }
            function p(e2, t4, n3) {
              return e2.objectMode || false === e2.decodeStrings || "string" != typeof t4 || (t4 = x2.from(t4, n3)), t4;
            }
            function f(e2, t4, n3, r3, a3, o2) {
              if (!n3) {
                var i2 = p(t4, r3, a3);
                r3 !== i2 && (n3 = true, a3 = "buffer", r3 = i2);
              }
              var d4 = t4.objectMode ? 1 : r3.length;
              t4.length += d4;
              var s2 = t4.length < t4.highWaterMark;
              if (s2 || (t4.needDrain = true), t4.writing || t4.corked) {
                var l2 = t4.lastBufferedRequest;
                t4.lastBufferedRequest = { chunk: r3, encoding: a3, isBuf: n3, callback: o2, next: null }, l2 ? l2.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
              } else
                g(e2, t4, false, d4, r3, a3, o2);
              return s2;
            }
            function g(e2, t4, n3, r3, a3, o2, i2) {
              t4.writelen = r3, t4.writecb = i2, t4.writing = true, t4.sync = true, t4.destroyed ? t4.onwrite(new j("write")) : n3 ? e2._writev(a3, t4.onwrite) : e2._write(a3, o2, t4.onwrite), t4.sync = false;
            }
            function _(e2, t4, r3, a3, o2) {
              --t4.pendingcb, r3 ? (n2.nextTick(o2, a3), n2.nextTick(S2, e2, t4), e2._writableState.errorEmitted = true, Y2(e2, a3)) : (o2(a3), e2._writableState.errorEmitted = true, Y2(e2, a3), S2(e2, t4));
            }
            function h(e2) {
              e2.writing = false, e2.writecb = null, e2.length -= e2.writelen, e2.writelen = 0;
            }
            function m(e2, t4) {
              var r3 = e2._writableState, a3 = r3.sync, o2 = r3.writecb;
              if ("function" != typeof o2)
                throw new B();
              if (h(r3), t4)
                _(e2, r3, a3, t4, o2);
              else {
                var i2 = R(r3) || e2.destroyed;
                i2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || C2(e2, r3), a3 ? n2.nextTick(b2, e2, r3, i2, o2) : b2(e2, r3, i2, o2);
              }
            }
            function b2(e2, t4, n3, r3) {
              n3 || y(e2, t4), t4.pendingcb--, r3(), S2(e2, t4);
            }
            function y(e2, t4) {
              0 === t4.length && t4.needDrain && (t4.needDrain = false, e2.emit("drain"));
            }
            function C2(e2, t4) {
              t4.bufferProcessing = true;
              var n3 = t4.bufferedRequest;
              if (e2._writev && n3 && n3.next) {
                var r3 = t4.bufferedRequestCount, o2 = Array(r3), i2 = t4.corkedRequestsFree;
                i2.entry = n3;
                for (var d4 = 0, s2 = true; n3; )
                  o2[d4] = n3, n3.isBuf || (s2 = false), n3 = n3.next, d4 += 1;
                o2.allBuffers = s2, g(e2, t4, true, t4.length, o2, "", i2.finish), t4.pendingcb++, t4.lastBufferedRequest = null, i2.next ? (t4.corkedRequestsFree = i2.next, i2.next = null) : t4.corkedRequestsFree = new a2(t4), t4.bufferedRequestCount = 0;
              } else {
                for (; n3; ) {
                  var l2 = n3.chunk, c3 = n3.encoding, u3 = n3.callback, p2 = t4.objectMode ? 1 : l2.length;
                  if (g(e2, t4, false, p2, l2, c3, u3), n3 = n3.next, t4.bufferedRequestCount--, t4.writing)
                    break;
                }
                null === n3 && (t4.lastBufferedRequest = null);
              }
              t4.bufferedRequest = n3, t4.bufferProcessing = false;
            }
            function R(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function E2(e2, t4) {
              e2._final(function(n3) {
                t4.pendingcb--, n3 && Y2(e2, n3), t4.prefinished = true, e2.emit("prefinish"), S2(e2, t4);
              });
            }
            function w(e2, t4) {
              t4.prefinished || t4.finalCalled || ("function" != typeof e2._final || t4.destroyed ? (t4.prefinished = true, e2.emit("prefinish")) : (t4.pendingcb++, t4.finalCalled = true, n2.nextTick(E2, e2, t4)));
            }
            function S2(e2, t4) {
              var n3 = R(t4);
              if (n3 && (w(e2, t4), 0 === t4.pendingcb && (t4.finished = true, e2.emit("finish"), t4.autoDestroy))) {
                var r3 = e2._readableState;
                (!r3 || r3.autoDestroy && r3.endEmitted) && e2.destroy();
              }
              return n3;
            }
            function T2(e2, t4, r3) {
              t4.ending = true, S2(e2, t4), r3 && (t4.finished ? n2.nextTick(r3) : e2.once("finish", r3)), t4.ended = true, e2.writable = false;
            }
            function v2(e2, t4, n3) {
              var r3 = e2.entry;
              for (e2.entry = null; r3; ) {
                var a3 = r3.callback;
                t4.pendingcb--, a3(n3), r3 = r3.next;
              }
              t4.corkedRequestsFree.next = e2;
            }
            t3.exports = l;
            var k;
            l.WritableState = s;
            var L2 = { deprecate: e("util-deprecate") }, A = e("./internal/streams/stream"), x2 = e("buffer").Buffer, N2 = r2.Uint8Array || function() {
            }, D2 = e("./internal/streams/destroy"), I2 = e("./internal/streams/state"), P2 = I2.getHighWaterMark, M2 = e("../errors").codes, O2 = M2.ERR_INVALID_ARG_TYPE, F2 = M2.ERR_METHOD_NOT_IMPLEMENTED, B = M2.ERR_MULTIPLE_CALLBACK, U2 = M2.ERR_STREAM_CANNOT_PIPE, j = M2.ERR_STREAM_DESTROYED, q = M2.ERR_STREAM_NULL_VALUES, W2 = M2.ERR_STREAM_WRITE_AFTER_END, H = M2.ERR_UNKNOWN_ENCODING, Y2 = D2.errorOrDestroy;
            e("inherits")(l, A), s.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t4 = []; e2; )
                t4.push(e2), e2 = e2.next;
              return t4;
            }, function() {
              try {
                Object.defineProperty(s.prototype, "buffer", { get: L2.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }();
            var V2;
            "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (V2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, { value: function(e2) {
              return !!V2.call(this, e2) || !(this !== l) && e2 && e2._writableState instanceof s;
            } })) : V2 = function(e2) {
              return e2 instanceof this;
            }, l.prototype.pipe = function() {
              Y2(this, new U2());
            }, l.prototype.write = function(e2, t4, n3) {
              var r3 = this._writableState, a3 = false, s2 = !r3.objectMode && i(e2);
              return s2 && !x2.isBuffer(e2) && (e2 = o(e2)), "function" == typeof t4 && (n3 = t4, t4 = null), s2 ? t4 = "buffer" : !t4 && (t4 = r3.defaultEncoding), "function" != typeof n3 && (n3 = d3), r3.ending ? c2(this, n3) : (s2 || u2(this, r3, e2, n3)) && (r3.pendingcb++, a3 = f(this, r3, s2, e2, t4, n3)), a3;
            }, l.prototype.cork = function() {
              this._writableState.corked++;
            }, l.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, !e2.writing && !e2.corked && !e2.bufferProcessing && e2.bufferedRequest && C2(this, e2));
            }, l.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase())))
                throw new H(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(l.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), l.prototype._write = function(e2, t4, n3) {
              n3(new F2("_write()"));
            }, l.prototype._writev = null, l.prototype.end = function(e2, t4, n3) {
              var r3 = this._writableState;
              return "function" == typeof e2 ? (n3 = e2, e2 = null, t4 = null) : "function" == typeof t4 && (n3 = t4, t4 = null), null !== e2 && void 0 !== e2 && this.write(e2, t4), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || T2(this, r3, n3), this;
            }, Object.defineProperty(l.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(l.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), l.prototype.destroy = D2.destroy, l.prototype._undestroy = D2.undestroy, l.prototype._destroy = function(e2, t4) {
              t4(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/destroy": 23, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, inherits: 10, "util-deprecate": 32 }], 21: [function(e, t3) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2, t4, n3) {
              return t4 in e2 ? Object.defineProperty(e2, t4, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t4] = n3, e2;
            }
            function a2(e2, t4) {
              return { value: e2, done: t4 };
            }
            function o(e2) {
              var t4 = e2[c2];
              if (null !== t4) {
                var n3 = e2[h].read();
                null !== n3 && (e2[g] = null, e2[c2] = null, e2[u2] = null, t4(a2(n3, false)));
              }
            }
            function i(e2) {
              n2.nextTick(o, e2);
            }
            function d3(e2, t4) {
              return function(n3, r3) {
                e2.then(function() {
                  return t4[f] ? void n3(a2(void 0, true)) : void t4[_](n3, r3);
                }, r3);
              };
            }
            var s, l = e("./end-of-stream"), c2 = Symbol("lastResolve"), u2 = Symbol("lastReject"), p = Symbol("error"), f = Symbol("ended"), g = Symbol("lastPromise"), _ = Symbol("handlePromise"), h = Symbol("stream"), m = Object.getPrototypeOf(function() {
            }), b2 = Object.setPrototypeOf((s = { get stream() {
              return this[h];
            }, next: function() {
              var e2 = this, t4 = this[p];
              if (null !== t4)
                return Promise.reject(t4);
              if (this[f])
                return Promise.resolve(a2(void 0, true));
              if (this[h].destroyed)
                return new Promise(function(t5, r4) {
                  n2.nextTick(function() {
                    e2[p] ? r4(e2[p]) : t5(a2(void 0, true));
                  });
                });
              var r3, o2 = this[g];
              if (o2)
                r3 = new Promise(d3(o2, this));
              else {
                var i2 = this[h].read();
                if (null !== i2)
                  return Promise.resolve(a2(i2, false));
                r3 = new Promise(this[_]);
              }
              return this[g] = r3, r3;
            } }, r2(s, Symbol.asyncIterator, function() {
              return this;
            }), r2(s, "return", function() {
              var e2 = this;
              return new Promise(function(t4, n3) {
                e2[h].destroy(null, function(e3) {
                  return e3 ? void n3(e3) : void t4(a2(void 0, true));
                });
              });
            }), s), m);
            t3.exports = function(e2) {
              var t4, n3 = Object.create(b2, (t4 = {}, r2(t4, h, { value: e2, writable: true }), r2(t4, c2, { value: null, writable: true }), r2(t4, u2, { value: null, writable: true }), r2(t4, p, { value: null, writable: true }), r2(t4, f, { value: e2._readableState.endEmitted, writable: true }), r2(t4, _, { value: function(e3, t5) {
                var r3 = n3[h].read();
                r3 ? (n3[g] = null, n3[c2] = null, n3[u2] = null, e3(a2(r3, false))) : (n3[c2] = e3, n3[u2] = t5);
              }, writable: true }), t4));
              return n3[g] = null, l(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t5 = n3[u2];
                  return null !== t5 && (n3[g] = null, n3[c2] = null, n3[u2] = null, t5(e3)), void (n3[p] = e3);
                }
                var r3 = n3[c2];
                null !== r3 && (n3[g] = null, n3[c2] = null, n3[u2] = null, r3(a2(void 0, true))), n3[f] = true;
              }), e2.on("readable", i.bind(null, n3)), n3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 24, _process: 12 }], 22: [function(e, t3) {
        "use strict";
        function n2(e2, t4) {
          var n3 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e2);
            t4 && (r3 = r3.filter(function(t5) {
              return Object.getOwnPropertyDescriptor(e2, t5).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function r2(e2) {
          for (var t4, r3 = 1; r3 < arguments.length; r3++)
            t4 = null == arguments[r3] ? {} : arguments[r3], r3 % 2 ? n2(Object(t4), true).forEach(function(n3) {
              a2(e2, n3, t4[n3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t4)) : n2(Object(t4)).forEach(function(n3) {
              Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t4, n3));
            });
          return e2;
        }
        function a2(e2, t4, n3) {
          return t4 in e2 ? Object.defineProperty(e2, t4, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t4] = n3, e2;
        }
        function o(e2, t4) {
          if (!(e2 instanceof t4))
            throw new TypeError("Cannot call a class as a function");
        }
        function i(e2, t4) {
          for (var n3, r3 = 0; r3 < t4.length; r3++)
            n3 = t4[r3], n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
        }
        function d3(e2, t4, n3) {
          return t4 && i(e2.prototype, t4), n3 && i(e2, n3), e2;
        }
        function s(e2, t4, n3) {
          u2.prototype.copy.call(e2, t4, n3);
        }
        var l = e("buffer"), u2 = l.Buffer, p = e("util"), f = p.inspect, g = f && f.custom || "inspect";
        t3.exports = function() {
          function e2() {
            o(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          return d3(e2, [{ key: "push", value: function(e3) {
            var t4 = { data: e3, next: null };
            0 < this.length ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t4 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t4 = this.head, n3 = "" + t4.data; t4 = t4.next; )
              n3 += e3 + t4.data;
            return n3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return u2.alloc(0);
            for (var t4 = u2.allocUnsafe(e3 >>> 0), n3 = this.head, r3 = 0; n3; )
              s(n3.data, t4, r3), r3 += n3.data.length, n3 = n3.next;
            return t4;
          } }, { key: "consume", value: function(e3, t4) {
            var n3;
            return e3 < this.head.data.length ? (n3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : e3 === this.head.data.length ? n3 = this.shift() : n3 = t4 ? this._getString(e3) : this._getBuffer(e3), n3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t4 = this.head, r3 = 1, a3 = t4.data;
            for (e3 -= a3.length; t4 = t4.next; ) {
              var o2 = t4.data, i2 = e3 > o2.length ? o2.length : e3;
              if (a3 += i2 === o2.length ? o2 : o2.slice(0, e3), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++r3, this.head = t4.next ? t4.next : this.tail = null) : (this.head = t4, t4.data = o2.slice(i2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, a3;
          } }, { key: "_getBuffer", value: function(e3) {
            var t4 = u2.allocUnsafe(e3), r3 = this.head, a3 = 1;
            for (r3.data.copy(t4), e3 -= r3.data.length; r3 = r3.next; ) {
              var o2 = r3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (o2.copy(t4, t4.length - e3, 0, i2), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++a3, this.head = r3.next ? r3.next : this.tail = null) : (this.head = r3, r3.data = o2.slice(i2));
                break;
              }
              ++a3;
            }
            return this.length -= a3, t4;
          } }, { key: g, value: function(e3, t4) {
            return f(this, r2({}, t4, { depth: 0, customInspect: false }));
          } }]), e2;
        }();
      }, { buffer: 3, util: 2 }], 23: [function(e, t3) {
        (function(e2) {
          (function() {
            "use strict";
            function n2(e3, t4) {
              a2(e3, t4), r2(e3);
            }
            function r2(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function a2(e3, t4) {
              e3.emit("error", t4);
            }
            t3.exports = { destroy: function(t4, o) {
              var i = this, d3 = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
              return d3 || s ? (o ? o(t4) : t4 && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = true, e2.nextTick(a2, this, t4)) : e2.nextTick(a2, this, t4)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t4 || null, function(t5) {
                !o && t5 ? i._writableState ? i._writableState.errorEmitted ? e2.nextTick(r2, i) : (i._writableState.errorEmitted = true, e2.nextTick(n2, i, t5)) : e2.nextTick(n2, i, t5) : o ? (e2.nextTick(r2, i), o(t5)) : e2.nextTick(r2, i);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t4) {
              var n3 = e3._readableState, r3 = e3._writableState;
              n3 && n3.autoDestroy || r3 && r3.autoDestroy ? e3.destroy(t4) : e3.emit("error", t4);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 12 }], 24: [function(e, t3) {
        "use strict";
        function n2(e2) {
          var t4 = false;
          return function() {
            if (!t4) {
              t4 = true;
              for (var n3 = arguments.length, r3 = Array(n3), a3 = 0; a3 < n3; a3++)
                r3[a3] = arguments[a3];
              e2.apply(this, r3);
            }
          };
        }
        function r2() {
        }
        function a2(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(e2, t4, d3) {
          if ("function" == typeof t4)
            return o(e2, null, t4);
          t4 || (t4 = {}), d3 = n2(d3 || r2);
          var s = t4.readable || false !== t4.readable && e2.readable, l = t4.writable || false !== t4.writable && e2.writable, c2 = function() {
            e2.writable || p();
          }, u2 = e2._writableState && e2._writableState.finished, p = function() {
            l = false, u2 = true, s || d3.call(e2);
          }, f = e2._readableState && e2._readableState.endEmitted, g = function() {
            s = false, f = true, l || d3.call(e2);
          }, _ = function(t5) {
            d3.call(e2, t5);
          }, h = function() {
            var t5;
            return s && !f ? (e2._readableState && e2._readableState.ended || (t5 = new i()), d3.call(e2, t5)) : l && !u2 ? (e2._writableState && e2._writableState.ended || (t5 = new i()), d3.call(e2, t5)) : void 0;
          }, m = function() {
            e2.req.on("finish", p);
          };
          return a2(e2) ? (e2.on("complete", p), e2.on("abort", h), e2.req ? m() : e2.on("request", m)) : l && !e2._writableState && (e2.on("end", c2), e2.on("close", c2)), e2.on("end", g), e2.on("finish", p), false !== t4.error && e2.on("error", _), e2.on("close", h), function() {
            e2.removeListener("complete", p), e2.removeListener("abort", h), e2.removeListener("request", m), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", c2), e2.removeListener("close", c2), e2.removeListener("finish", p), e2.removeListener("end", g), e2.removeListener("error", _), e2.removeListener("close", h);
          };
        }
        var i = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        t3.exports = o;
      }, { "../../../errors": 15 }], 25: [function(e, t3) {
        t3.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 26: [function(e, t3) {
        "use strict";
        function n2(e2) {
          var t4 = false;
          return function() {
            t4 || (t4 = true, e2.apply(void 0, arguments));
          };
        }
        function r2(e2) {
          if (e2)
            throw e2;
        }
        function a2(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(t4, r3, o2, i2) {
          i2 = n2(i2);
          var d4 = false;
          t4.on("close", function() {
            d4 = true;
          }), l === void 0 && (l = e("./end-of-stream")), l(t4, { readable: r3, writable: o2 }, function(e2) {
            return e2 ? i2(e2) : void (d4 = true, i2());
          });
          var s2 = false;
          return function(e2) {
            if (!d4)
              return s2 ? void 0 : (s2 = true, a2(t4) ? t4.abort() : "function" == typeof t4.destroy ? t4.destroy() : void i2(e2 || new p("pipe")));
          };
        }
        function i(e2) {
          e2();
        }
        function d3(e2, t4) {
          return e2.pipe(t4);
        }
        function s(e2) {
          return e2.length ? "function" == typeof e2[e2.length - 1] ? e2.pop() : r2 : r2;
        }
        var l, c2 = e("../../../errors").codes, u2 = c2.ERR_MISSING_ARGS, p = c2.ERR_STREAM_DESTROYED;
        t3.exports = function() {
          for (var e2 = arguments.length, t4 = Array(e2), n3 = 0; n3 < e2; n3++)
            t4[n3] = arguments[n3];
          var r3 = s(t4);
          if (Array.isArray(t4[0]) && (t4 = t4[0]), 2 > t4.length)
            throw new u2("streams");
          var a3, l2 = t4.map(function(e3, n4) {
            var d4 = n4 < t4.length - 1;
            return o(e3, d4, 0 < n4, function(e4) {
              a3 || (a3 = e4), e4 && l2.forEach(i), d4 || (l2.forEach(i), r3(a3));
            });
          });
          return t4.reduce(d3);
        };
      }, { "../../../errors": 15, "./end-of-stream": 24 }], 27: [function(e, n2) {
        "use strict";
        function r2(e2, t3, n3) {
          return null == e2.highWaterMark ? t3 ? e2[n3] : null : e2.highWaterMark;
        }
        var a2 = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        n2.exports = { getHighWaterMark: function(e2, n3, o, i) {
          var d3 = r2(n3, i, o);
          if (null != d3) {
            if (!(isFinite(d3) && t2(d3) === d3) || 0 > d3) {
              var s = i ? o : "highWaterMark";
              throw new a2(s, d3);
            }
            return t2(d3);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 15 }], 28: [function(e, t3) {
        t3.exports = e("events").EventEmitter;
      }, { events: 7 }], 29: [function(e, t3, n2) {
        n2 = t3.exports = e("./lib/_stream_readable.js"), n2.Stream = n2, n2.Readable = n2, n2.Writable = e("./lib/_stream_writable.js"), n2.Duplex = e("./lib/_stream_duplex.js"), n2.Transform = e("./lib/_stream_transform.js"), n2.PassThrough = e("./lib/_stream_passthrough.js"), n2.finished = e("./lib/internal/streams/end-of-stream.js"), n2.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20, "./lib/internal/streams/end-of-stream.js": 24, "./lib/internal/streams/pipeline.js": 26 }], 30: [function(e, t3, n2) {
        function r2(e2, t4) {
          for (var n3 in e2)
            t4[n3] = e2[n3];
        }
        function a2(e2, t4, n3) {
          return i(e2, t4, n3);
        }
        var o = e("buffer"), i = o.Buffer;
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t3.exports = o : (r2(o, n2), n2.Buffer = a2), a2.prototype = Object.create(i.prototype), r2(i, a2), a2.from = function(e2, t4, n3) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t4, n3);
        }, a2.alloc = function(e2, t4, n3) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var r3 = i(e2);
          return void 0 === t4 ? r3.fill(0) : "string" == typeof n3 ? r3.fill(t4, n3) : r3.fill(t4), r3;
        }, a2.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, a2.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return o.SlowBuffer(e2);
        };
      }, { buffer: 3 }], 31: [function(e, t3, n2) {
        "use strict";
        function r2(e2) {
          if (!e2)
            return "utf8";
          for (var t4; ; )
            switch (e2) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return e2;
              default:
                if (t4)
                  return;
                e2 = ("" + e2).toLowerCase(), t4 = true;
            }
        }
        function a2(e2) {
          var t4 = r2(e2);
          if ("string" != typeof t4 && (m.isEncoding === b2 || !b2(e2)))
            throw new Error("Unknown encoding: " + e2);
          return t4 || e2;
        }
        function o(e2) {
          this.encoding = a2(e2);
          var t4;
          switch (this.encoding) {
            case "utf16le":
              this.text = u2, this.end = p, t4 = 4;
              break;
            case "utf8":
              this.fillLast = c2, t4 = 4;
              break;
            case "base64":
              this.text = f, this.end = g, t4 = 3;
              break;
            default:
              return this.write = _, void (this.end = h);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m.allocUnsafe(t4);
        }
        function d3(e2) {
          if (127 >= e2)
            return 0;
          return 6 == e2 >> 5 ? 2 : 14 == e2 >> 4 ? 3 : 30 == e2 >> 3 ? 4 : 2 == e2 >> 6 ? -1 : -2;
        }
        function s(e2, t4, n3) {
          var r3 = t4.length - 1;
          if (r3 < n3)
            return 0;
          var a3 = d3(t4[r3]);
          return 0 <= a3 ? (0 < a3 && (e2.lastNeed = a3 - 1), a3) : --r3 < n3 || -2 === a3 ? 0 : (a3 = d3(t4[r3]), 0 <= a3) ? (0 < a3 && (e2.lastNeed = a3 - 2), a3) : --r3 < n3 || -2 === a3 ? 0 : (a3 = d3(t4[r3]), 0 <= a3 ? (0 < a3 && (2 === a3 ? a3 = 0 : e2.lastNeed = a3 - 3), a3) : 0);
        }
        function l(e2, t4) {
          if (128 != (192 & t4[0]))
            return e2.lastNeed = 0, "�";
          if (1 < e2.lastNeed && 1 < t4.length) {
            if (128 != (192 & t4[1]))
              return e2.lastNeed = 1, "�";
            if (2 < e2.lastNeed && 2 < t4.length && 128 != (192 & t4[2]))
              return e2.lastNeed = 2, "�";
          }
        }
        function c2(e2) {
          var t4 = this.lastTotal - this.lastNeed, n3 = l(this, e2, t4);
          return void 0 === n3 ? this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t4, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, t4, 0, e2.length), this.lastNeed -= e2.length) : n3;
        }
        function u2(e2, t4) {
          if (0 == (e2.length - t4) % 2) {
            var n3 = e2.toString("utf16le", t4);
            if (n3) {
              var r3 = n3.charCodeAt(n3.length - 1);
              if (55296 <= r3 && 56319 >= r3)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], n3.slice(0, -1);
            }
            return n3;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t4, e2.length - 1);
        }
        function p(e2) {
          var t4 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var n3 = this.lastTotal - this.lastNeed;
            return t4 + this.lastChar.toString("utf16le", 0, n3);
          }
          return t4;
        }
        function f(e2, t4) {
          var r3 = (e2.length - t4) % 3;
          return 0 == r3 ? e2.toString("base64", t4) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 == r3 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t4, e2.length - r3));
        }
        function g(e2) {
          var t4 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t4 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t4;
        }
        function _(e2) {
          return e2.toString(this.encoding);
        }
        function h(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        var m = e("safe-buffer").Buffer, b2 = m.isEncoding || function(e2) {
          switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        n2.StringDecoder = o, o.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t4, n3;
          if (this.lastNeed) {
            if (t4 = this.fillLast(e2), void 0 === t4)
              return "";
            n3 = this.lastNeed, this.lastNeed = 0;
          } else
            n3 = 0;
          return n3 < e2.length ? t4 ? t4 + this.text(e2, n3) : this.text(e2, n3) : t4 || "";
        }, o.prototype.end = function(e2) {
          var t4 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t4 + "�" : t4;
        }, o.prototype.text = function(e2, t4) {
          var n3 = s(this, e2, t4);
          if (!this.lastNeed)
            return e2.toString("utf8", t4);
          this.lastTotal = n3;
          var r3 = e2.length - (n3 - this.lastNeed);
          return e2.copy(this.lastChar, 0, r3), e2.toString("utf8", t4, r3);
        }, o.prototype.fillLast = function(e2) {
          return this.lastNeed <= e2.length ? (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length);
        };
      }, { "safe-buffer": 30 }], 32: [function(e, t3) {
        (function(e2) {
          (function() {
            function n2(t4) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var n3 = e2.localStorage[t4];
              return null != n3 && "true" === (n3 + "").toLowerCase();
            }
            t3.exports = function(e3, t4) {
              function r2() {
                if (!a2) {
                  if (n2("throwDeprecation"))
                    throw new Error(t4);
                  else
                    n2("traceDeprecation") ? console.trace(t4) : console.warn(t4);
                  a2 = true;
                }
                return e3.apply(this, arguments);
              }
              if (n2("noDeprecation"))
                return e3;
              var a2 = false;
              return r2;
            };
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], "/": [function(e, t3) {
        function n2(e2) {
          return e2.replace(/a=ice-options:trickle\s\n/g, "");
        }
        function r2(e2) {
          console.warn(e2);
        }
        const a2 = e("debug")("simple-peer"), o = e("get-browser-rtc"), i = e("randombytes"), d3 = e("readable-stream"), s = e("queue-microtask"), l = e("err-code"), { Buffer: c2 } = e("buffer"), u2 = 65536;
        class p extends d3.Duplex {
          constructor(e2) {
            if (e2 = Object.assign({ allowHalfOpen: false }, e2), super(e2), this._id = i(4).toString("hex").slice(0, 7), this._debug("new peer %o", e2), this.channelName = e2.initiator ? e2.channelName || i(20).toString("hex") : null, this.initiator = e2.initiator || false, this.channelConfig = e2.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e2.config), this.offerOptions = e2.offerOptions || {}, this.answerOptions = e2.answerOptions || {}, this.sdpTransform = e2.sdpTransform || ((e3) => e3), this.streams = e2.streams || (e2.stream ? [e2.stream] : []), this.trickle = void 0 === e2.trickle || e2.trickle, this.allowHalfTrickle = void 0 !== e2.allowHalfTrickle && e2.allowHalfTrickle, this.iceCompleteTimeout = e2.iceCompleteTimeout || 5e3, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e2.wrtc && "object" == typeof e2.wrtc ? e2.wrtc : o(), !this._wrtc)
              if ("undefined" == typeof window)
                throw l(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
              else
                throw l(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
            try {
              this._pc = new this._wrtc.RTCPeerConnection(this.config);
            } catch (e3) {
              return void this.destroy(l(e3, "ERR_PC_CONSTRUCTOR"));
            }
            this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onicegatheringstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onconnectionstatechange = () => {
              this._onConnectionStateChange();
            }, this._pc.onsignalingstatechange = () => {
              this._onSignalingStateChange();
            }, this._pc.onicecandidate = (e3) => {
              this._onIceCandidate(e3);
            }, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e3) => {
              this.destroy(l(e3, "ERR_PC_PEER_IDENTITY"));
            }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e3) => {
              this._setupData(e3);
            }, this.streams && this.streams.forEach((e3) => {
              this.addStream(e3);
            }), this._pc.ontrack = (e3) => {
              this._onTrack(e3);
            }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
              this._onFinish();
            }, this.once("finish", this._onFinishBound);
          }
          get bufferSize() {
            return this._channel && this._channel.bufferedAmount || 0;
          }
          get connected() {
            return this._connected && "open" === this._channel.readyState;
          }
          address() {
            return { port: this.localPort, family: this.localFamily, address: this.localAddress };
          }
          signal(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
              if ("string" == typeof e2)
                try {
                  e2 = JSON.parse(e2);
                } catch (t4) {
                  e2 = {};
                }
              this._debug("signal()"), e2.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e2.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e2.transceiverRequest.kind, e2.transceiverRequest.init)), e2.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e2.candidate) : this._pendingCandidates.push(e2.candidate)), e2.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e2)).then(() => {
                this.destroyed || (this._pendingCandidates.forEach((e3) => {
                  this._addIceCandidate(e3);
                }), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer());
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_REMOTE_DESCRIPTION"));
              }), e2.sdp || e2.candidate || e2.renegotiate || e2.transceiverRequest || this.destroy(l(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
            }
          }
          _addIceCandidate(e2) {
            const t4 = new this._wrtc.RTCIceCandidate(e2);
            this._pc.addIceCandidate(t4).catch((e3) => {
              !t4.address || t4.address.endsWith(".local") ? r2("Ignoring unsupported ICE candidate.") : this.destroy(l(e3, "ERR_ADD_ICE_CANDIDATE"));
            });
          }
          send(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
              this._channel.send(e2);
            }
          }
          addTransceiver(e2, t4) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
              if (this._debug("addTransceiver()"), this.initiator)
                try {
                  this._pc.addTransceiver(e2, t4), this._needsNegotiation();
                } catch (e3) {
                  this.destroy(l(e3, "ERR_ADD_TRANSCEIVER"));
                }
              else
                this.emit("signal", { type: "transceiverRequest", transceiverRequest: { kind: e2, init: t4 } });
            }
          }
          addStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addStream()"), e2.getTracks().forEach((t4) => {
                this.addTrack(t4, e2);
              });
            }
          }
          addTrack(e2, t4) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("addTrack()");
            const n3 = this._senderMap.get(e2) || /* @__PURE__ */ new Map();
            let r3 = n3.get(t4);
            if (!r3)
              r3 = this._pc.addTrack(e2, t4), n3.set(t4, r3), this._senderMap.set(e2, n3), this._needsNegotiation();
            else if (r3.removed)
              throw l(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
            else
              throw l(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
          replaceTrack(e2, t4, n3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("replaceTrack()");
            const r3 = this._senderMap.get(e2), a3 = r3 ? r3.get(n3) : null;
            if (!a3)
              throw l(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
            t4 && this._senderMap.set(t4, r3), null == a3.replaceTrack ? this.destroy(l(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")) : a3.replaceTrack(t4);
          }
          removeTrack(e2, t4) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("removeSender()");
            const n3 = this._senderMap.get(e2), r3 = n3 ? n3.get(t4) : null;
            if (!r3)
              throw l(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
            try {
              r3.removed = true, this._pc.removeTrack(r3);
            } catch (e3) {
              "NS_ERROR_UNEXPECTED" === e3.name ? this._sendersAwaitingStable.push(r3) : this.destroy(l(e3, "ERR_REMOVE_TRACK"));
            }
            this._needsNegotiation();
          }
          removeStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSenders()"), e2.getTracks().forEach((t4) => {
                this.removeTrack(t4, e2);
              });
            }
          }
          _needsNegotiation() {
            this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = true, s(() => {
              this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
            }));
          }
          negotiate() {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
              this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
                this._createOffer();
              }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: true })), this._isNegotiating = true;
            }
          }
          destroy(e2) {
            this._destroy(e2, () => {
            });
          }
          _destroy(e2, t4) {
            this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e2 && (e2.message || e2)), s(() => {
              if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e2 && (e2.message || e2)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                try {
                  this._channel.close();
                } catch (e3) {
                }
                this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
              }
              if (this._pc) {
                try {
                  this._pc.close();
                } catch (e3) {
                }
                this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
              }
              this._pc = null, this._channel = null, e2 && this.emit("error", e2), this.emit("close"), t4();
            }));
          }
          _setupData(e2) {
            if (!e2.channel)
              return this.destroy(l(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
            this._channel = e2.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u2), this.channelName = this._channel.label, this._channel.onmessage = (e3) => {
              this._onChannelMessage(e3);
            }, this._channel.onbufferedamountlow = () => {
              this._onChannelBufferedAmountLow();
            }, this._channel.onopen = () => {
              this._onChannelOpen();
            }, this._channel.onclose = () => {
              this._onChannelClose();
            }, this._channel.onerror = (e3) => {
              const t5 = e3.error instanceof Error ? e3.error : new Error(`Datachannel error: ${e3.message} ${e3.filename}:${e3.lineno}:${e3.colno}`);
              this.destroy(l(t5, "ERR_DATA_CHANNEL"));
            };
            let t4 = false;
            this._closingInterval = setInterval(() => {
              this._channel && "closing" === this._channel.readyState ? (t4 && this._onChannelClose(), t4 = true) : t4 = false;
            }, 5e3);
          }
          _read() {
          }
          _write(e2, t4, n3) {
            if (this.destroyed)
              return n3(l(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
            if (this._connected) {
              try {
                this.send(e2);
              } catch (e3) {
                return this.destroy(l(e3, "ERR_DATA_CHANNEL"));
              }
              this._channel.bufferedAmount > u2 ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n3) : n3(null);
            } else
              this._debug("write before connect"), this._chunk = e2, this._cb = n3;
          }
          _onFinish() {
            if (!this.destroyed) {
              const e2 = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              this._connected ? e2() : this.once("connect", e2);
            }
          }
          _startIceCompleteTimeout() {
            this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
              this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
            }, this.iceCompleteTimeout));
          }
          _createOffer() {
            this.destroyed || this._pc.createOffer(this.offerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t4 = () => {
                if (!this.destroyed) {
                  const t5 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t5.type, sdp: t5.sdp });
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t4() : this.once("_iceComplete", t4));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_OFFER"));
            });
          }
          _requestMissingTransceivers() {
            this._pc.getTransceivers && this._pc.getTransceivers().forEach((e2) => {
              e2.mid || !e2.sender.track || e2.requested || (e2.requested = true, this.addTransceiver(e2.sender.track.kind));
            });
          }
          _createAnswer() {
            this.destroyed || this._pc.createAnswer(this.answerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t4 = () => {
                if (!this.destroyed) {
                  const t5 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t5.type, sdp: t5.sdp }), this.initiator || this._requestMissingTransceivers();
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this.destroyed || (this.trickle || this._iceComplete ? t4() : this.once("_iceComplete", t4));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_ANSWER"));
            });
          }
          _onConnectionStateChange() {
            this.destroyed || "failed" === this._pc.connectionState && this.destroy(l(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
          _onIceStateChange() {
            if (this.destroyed)
              return;
            const e2 = this._pc.iceConnectionState, t4 = this._pc.iceGatheringState;
            this._debug("iceStateChange (connection: %s) (gathering: %s)", e2, t4), this.emit("iceStateChange", e2, t4), ("connected" === e2 || "completed" === e2) && (this._pcReady = true, this._maybeReady()), "failed" === e2 && this.destroy(l(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e2 && this.destroy(l(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
          getStats(e2) {
            const t4 = (e3) => ("[object Array]" === Object.prototype.toString.call(e3.values) && e3.values.forEach((t5) => {
              Object.assign(e3, t5);
            }), e3);
            0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n3) => {
              const r3 = [];
              n3.forEach((e3) => {
                r3.push(t4(e3));
              }), e2(null, r3);
            }, (t5) => e2(t5)) : 0 < this._pc.getStats.length ? this._pc.getStats((n3) => {
              if (this.destroyed)
                return;
              const r3 = [];
              n3.result().forEach((e3) => {
                const n4 = {};
                e3.names().forEach((t5) => {
                  n4[t5] = e3.stat(t5);
                }), n4.id = e3.id, n4.type = e3.type, n4.timestamp = e3.timestamp, r3.push(t4(n4));
              }), e2(null, r3);
            }, (t5) => e2(t5)) : e2(null, []);
          }
          _maybeReady() {
            if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
              return;
            this._connecting = true;
            const e2 = () => {
              this.destroyed || this.getStats((t4, n3) => {
                if (this.destroyed)
                  return;
                t4 && (n3 = []);
                const r3 = {}, a3 = {}, o2 = {};
                let i2 = false;
                n3.forEach((e3) => {
                  ("remotecandidate" === e3.type || "remote-candidate" === e3.type) && (r3[e3.id] = e3), ("localcandidate" === e3.type || "local-candidate" === e3.type) && (a3[e3.id] = e3), ("candidatepair" === e3.type || "candidate-pair" === e3.type) && (o2[e3.id] = e3);
                });
                const d4 = (e3) => {
                  i2 = true;
                  let t5 = a3[e3.localCandidateId];
                  t5 && (t5.ip || t5.address) ? (this.localAddress = t5.ip || t5.address, this.localPort = +t5.port) : t5 && t5.ipAddress ? (this.localAddress = t5.ipAddress, this.localPort = +t5.portNumber) : "string" == typeof e3.googLocalAddress && (t5 = e3.googLocalAddress.split(":"), this.localAddress = t5[0], this.localPort = +t5[1]), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                  let n4 = r3[e3.remoteCandidateId];
                  n4 && (n4.ip || n4.address) ? (this.remoteAddress = n4.ip || n4.address, this.remotePort = +n4.port) : n4 && n4.ipAddress ? (this.remoteAddress = n4.ipAddress, this.remotePort = +n4.portNumber) : "string" == typeof e3.googRemoteAddress && (n4 = e3.googRemoteAddress.split(":"), this.remoteAddress = n4[0], this.remotePort = +n4[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                };
                if (n3.forEach((e3) => {
                  "transport" === e3.type && e3.selectedCandidatePairId && d4(o2[e3.selectedCandidatePairId]), ("googCandidatePair" === e3.type && "true" === e3.googActiveConnection || ("candidatepair" === e3.type || "candidate-pair" === e3.type) && e3.selected) && d4(e3);
                }), !i2 && (!Object.keys(o2).length || Object.keys(a3).length))
                  return void setTimeout(e2, 100);
                if (this._connecting = false, this._connected = true, this._chunk) {
                  try {
                    this.send(this._chunk);
                  } catch (e4) {
                    return this.destroy(l(e4, "ERR_DATA_CHANNEL"));
                  }
                  this._chunk = null, this._debug('sent chunk from "write before connect"');
                  const e3 = this._cb;
                  this._cb = null, e3(null);
                }
                "number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
              });
            };
            e2();
          }
          _onInterval() {
            this._cb && this._channel && !(this._channel.bufferedAmount > u2) && this._onChannelBufferedAmountLow();
          }
          _onSignalingStateChange() {
            this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e2) => {
              this._pc.removeTrack(e2), this._queuedNegotiation = true;
            }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
          }
          _onIceCandidate(e2) {
            this.destroyed || (e2.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e2.candidate.candidate, sdpMLineIndex: e2.candidate.sdpMLineIndex, sdpMid: e2.candidate.sdpMid } }) : !e2.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e2.candidate && this._startIceCompleteTimeout());
          }
          _onChannelMessage(e2) {
            if (this.destroyed)
              return;
            let t4 = e2.data;
            t4 instanceof ArrayBuffer && (t4 = c2.from(t4)), this.push(t4);
          }
          _onChannelBufferedAmountLow() {
            if (!this.destroyed && this._cb) {
              this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              const e2 = this._cb;
              this._cb = null, e2(null);
            }
          }
          _onChannelOpen() {
            this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
          }
          _onChannelClose() {
            this.destroyed || (this._debug("on channel close"), this.destroy());
          }
          _onTrack(e2) {
            this.destroyed || e2.streams.forEach((t4) => {
              this._debug("on track"), this.emit("track", e2.track, t4), this._remoteTracks.push({ track: e2.track, stream: t4 }), this._remoteStreams.some((e3) => e3.id === t4.id) || (this._remoteStreams.push(t4), s(() => {
                this._debug("on stream"), this.emit("stream", t4);
              }));
            });
          }
          _debug() {
            const e2 = [].slice.call(arguments);
            e2[0] = "[" + this._id + "] " + e2[0], a2.apply(null, e2);
          }
        }
        p.WEBRTC_SUPPORT = !!o(), p.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, p.channelConfig = {}, t3.exports = p;
      }, { buffer: 3, debug: 4, "err-code": 6, "get-browser-rtc": 8, "queue-microtask": 13, randombytes: 14, "readable-stream": 29 }] }, {}, [])("/");
    });
  }
});

// node_modules/ansi-colors/symbols.js
var require_symbols = __commonJS({
  "node_modules/ansi-colors/symbols.js"(exports2, module2) {
    "use strict";
    var isHyper = typeof process !== "undefined" && process.env.TERM_PROGRAM === "Hyper";
    var isWindows = typeof process !== "undefined" && process.platform === "win32";
    var isLinux = typeof process !== "undefined" && process.platform === "linux";
    var common = {
      ballotDisabled: "☒",
      ballotOff: "☐",
      ballotOn: "☑",
      bullet: "•",
      bulletWhite: "◦",
      fullBlock: "█",
      heart: "❤",
      identicalTo: "≡",
      line: "─",
      mark: "※",
      middot: "·",
      minus: "－",
      multiplication: "×",
      obelus: "÷",
      pencilDownRight: "✎",
      pencilRight: "✏",
      pencilUpRight: "✐",
      percent: "%",
      pilcrow2: "❡",
      pilcrow: "¶",
      plusMinus: "±",
      question: "?",
      section: "§",
      starsOff: "☆",
      starsOn: "★",
      upDownArrow: "↕"
    };
    var windows = Object.assign({}, common, {
      check: "√",
      cross: "×",
      ellipsisLarge: "...",
      ellipsis: "...",
      info: "i",
      questionSmall: "?",
      pointer: ">",
      pointerSmall: "»",
      radioOff: "( )",
      radioOn: "(*)",
      warning: "‼"
    });
    var other = Object.assign({}, common, {
      ballotCross: "✘",
      check: "✔",
      cross: "✖",
      ellipsisLarge: "⋯",
      ellipsis: "…",
      info: "ℹ",
      questionFull: "？",
      questionSmall: "﹖",
      pointer: isLinux ? "▸" : "❯",
      pointerSmall: isLinux ? "‣" : "›",
      radioOff: "◯",
      radioOn: "◉",
      warning: "⚠"
    });
    module2.exports = isWindows && !isHyper ? windows : other;
    Reflect.defineProperty(module2.exports, "common", { enumerable: false, value: common });
    Reflect.defineProperty(module2.exports, "windows", { enumerable: false, value: windows });
    Reflect.defineProperty(module2.exports, "other", { enumerable: false, value: other });
  }
});

// node_modules/ansi-colors/index.js
var require_ansi_colors = __commonJS({
  "node_modules/ansi-colors/index.js"(exports2, module2) {
    "use strict";
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
    var hasColor = () => {
      if (typeof process !== "undefined") {
        return process.env.FORCE_COLOR !== "0";
      }
      return false;
    };
    var create7 = () => {
      const colors = {
        enabled: hasColor(),
        visible: true,
        styles: {},
        keys: {}
      };
      const ansi = (style2) => {
        let open = style2.open = `\x1B[${style2.codes[0]}m`;
        let close = style2.close = `\x1B[${style2.codes[1]}m`;
        let regex = style2.regex = new RegExp(`\\u001b\\[${style2.codes[1]}m`, "g");
        style2.wrap = (input, newline) => {
          if (input.includes(close))
            input = input.replace(regex, close + open);
          let output = open + input + close;
          return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
        };
        return style2;
      };
      const wrap3 = (style2, input, newline) => {
        return typeof style2 === "function" ? style2(input) : style2.wrap(input, newline);
      };
      const style = (input, stack) => {
        if (input === "" || input == null)
          return "";
        if (colors.enabled === false)
          return input;
        if (colors.visible === false)
          return "";
        let str = "" + input;
        let nl = str.includes("\n");
        let n = stack.length;
        if (n > 0 && stack.includes("unstyle")) {
          stack = [.../* @__PURE__ */ new Set(["unstyle", ...stack])].reverse();
        }
        while (n-- > 0)
          str = wrap3(colors.styles[stack[n]], str, nl);
        return str;
      };
      const define2 = (name, codes, type) => {
        colors.styles[name] = ansi({ name, codes });
        let keys2 = colors.keys[type] || (colors.keys[type] = []);
        keys2.push(name);
        Reflect.defineProperty(colors, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors.alias(name, value);
          },
          get() {
            let color2 = (input) => style(input, color2.stack);
            Reflect.setPrototypeOf(color2, colors);
            color2.stack = this.stack ? this.stack.concat(name) : [name];
            return color2;
          }
        });
      };
      define2("reset", [0, 0], "modifier");
      define2("bold", [1, 22], "modifier");
      define2("dim", [2, 22], "modifier");
      define2("italic", [3, 23], "modifier");
      define2("underline", [4, 24], "modifier");
      define2("inverse", [7, 27], "modifier");
      define2("hidden", [8, 28], "modifier");
      define2("strikethrough", [9, 29], "modifier");
      define2("black", [30, 39], "color");
      define2("red", [31, 39], "color");
      define2("green", [32, 39], "color");
      define2("yellow", [33, 39], "color");
      define2("blue", [34, 39], "color");
      define2("magenta", [35, 39], "color");
      define2("cyan", [36, 39], "color");
      define2("white", [37, 39], "color");
      define2("gray", [90, 39], "color");
      define2("grey", [90, 39], "color");
      define2("bgBlack", [40, 49], "bg");
      define2("bgRed", [41, 49], "bg");
      define2("bgGreen", [42, 49], "bg");
      define2("bgYellow", [43, 49], "bg");
      define2("bgBlue", [44, 49], "bg");
      define2("bgMagenta", [45, 49], "bg");
      define2("bgCyan", [46, 49], "bg");
      define2("bgWhite", [47, 49], "bg");
      define2("blackBright", [90, 39], "bright");
      define2("redBright", [91, 39], "bright");
      define2("greenBright", [92, 39], "bright");
      define2("yellowBright", [93, 39], "bright");
      define2("blueBright", [94, 39], "bright");
      define2("magentaBright", [95, 39], "bright");
      define2("cyanBright", [96, 39], "bright");
      define2("whiteBright", [97, 39], "bright");
      define2("bgBlackBright", [100, 49], "bgBright");
      define2("bgRedBright", [101, 49], "bgBright");
      define2("bgGreenBright", [102, 49], "bgBright");
      define2("bgYellowBright", [103, 49], "bgBright");
      define2("bgBlueBright", [104, 49], "bgBright");
      define2("bgMagentaBright", [105, 49], "bgBright");
      define2("bgCyanBright", [106, 49], "bgBright");
      define2("bgWhiteBright", [107, 49], "bgBright");
      colors.ansiRegex = ANSI_REGEX;
      colors.hasColor = colors.hasAnsi = (str) => {
        colors.ansiRegex.lastIndex = 0;
        return typeof str === "string" && str !== "" && colors.ansiRegex.test(str);
      };
      colors.alias = (name, color2) => {
        let fn = typeof color2 === "string" ? colors[color2] : color2;
        if (typeof fn !== "function") {
          throw new TypeError("Expected alias to be the name of an existing color (string) or a function");
        }
        if (!fn.stack) {
          Reflect.defineProperty(fn, "name", { value: name });
          colors.styles[name] = fn;
          fn.stack = [name];
        }
        Reflect.defineProperty(colors, name, {
          configurable: true,
          enumerable: true,
          set(value) {
            colors.alias(name, value);
          },
          get() {
            let color3 = (input) => style(input, color3.stack);
            Reflect.setPrototypeOf(color3, colors);
            color3.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
            return color3;
          }
        });
      };
      colors.theme = (custom2) => {
        if (!isObject(custom2))
          throw new TypeError("Expected theme to be an object");
        for (let name of Object.keys(custom2)) {
          colors.alias(name, custom2[name]);
        }
        return colors;
      };
      colors.alias("unstyle", (str) => {
        if (typeof str === "string" && str !== "") {
          colors.ansiRegex.lastIndex = 0;
          return str.replace(colors.ansiRegex, "");
        }
        return "";
      });
      colors.alias("noop", (str) => str);
      colors.none = colors.clear = colors.noop;
      colors.stripColor = colors.unstyle;
      colors.symbols = require_symbols();
      colors.define = define2;
      return colors;
    };
    module2.exports = create7();
    module2.exports.create = create7;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d3;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d3, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d3, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e)) < 1) {
          e--;
          c2 *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e++;
          c2 /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d3, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d3, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d3] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length4) {
      if (length4 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length4);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length4) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from3(arg, encodingOrOffset, length4);
    }
    Buffer3.poolSize = 8192;
    function from3(value, encodingOrOffset, length4) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length4);
      }
      const b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length4) {
      return from3(value, encodingOrOffset, length4);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length4 = byteLength(string, encoding) | 0;
      let buf = createBuffer(length4);
      const actual = buf.write(string, encoding);
      if (actual !== length4) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length4 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length4);
      for (let i = 0; i < length4; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length4) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length4 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length4 === void 0) {
        buf = new Uint8Array(array);
      } else if (length4 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length4);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length4) {
      if (length4 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length4 | 0;
    }
    function SlowBuffer(length4) {
      if (+length4 != length4) {
        length4 = 0;
      }
      return Buffer3.alloc(+length4);
    }
    Buffer3.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array))
        a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
      if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2)
        return 0;
      let x2 = a2.length;
      let y = b2.length;
      for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
        if (a2[i] !== b2[i]) {
          x2 = a2[i];
          y = b2[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length4) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length4 === void 0) {
        length4 = 0;
        for (i = 0; i < list.length; ++i) {
          length4 += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length4);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b2, n, m) {
      const i = b2[n];
      b2[n] = b2[m];
      b2[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length4 = this.length;
      if (length4 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length4);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b2) {
      if (!Buffer3.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer3.compare(this, b2) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x2 = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x2, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length4) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length4) {
        length4 = remaining;
      } else {
        length4 = Number(length4);
        if (length4 > remaining) {
          length4 = remaining;
        }
      }
      const strLen = string.length;
      if (length4 > strLen / 2) {
        length4 = strLen / 2;
      }
      let i;
      for (i = 0; i < length4; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length4) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length4);
    }
    function asciiWrite(buf, string, offset, length4) {
      return blitBuffer(asciiToBytes(string), buf, offset, length4);
    }
    function base64Write(buf, string, offset, length4) {
      return blitBuffer(base64ToBytes(string), buf, offset, length4);
    }
    function ucs2Write(buf, string, offset, length4) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length4);
    }
    Buffer3.prototype.write = function write2(string, offset, length4, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length4 = this.length;
        offset = 0;
      } else if (length4 === void 0 && typeof offset === "string") {
        encoding = offset;
        length4 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length4)) {
          length4 = length4 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length4;
          length4 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length4 === void 0 || length4 > remaining)
        length4 = remaining;
      if (string.length > 0 && (length4 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length4);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length4);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length4);
          case "base64":
            return base64Write(this, string, offset, length4);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length4);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext2, length4) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext2 > length4)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext2, max2, min2) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext2 > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext2, max2, min2) {
      if (offset + ext2 > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset, byteLength2) {
      if (value > max2 || value < min2) {
        const n = typeof min2 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min2}${n} and <= ${max2}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length4, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length4 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length4}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length4 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length4; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length4) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length4) {
      let i;
      for (i = 0; i < length4; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/flexsearch/dist/flexsearch.bundle.js
var require_flexsearch_bundle = __commonJS({
  "node_modules/flexsearch/dist/flexsearch.bundle.js"(exports, module) {
    (function _f(self) {
      "use strict";
      try {
        if (module)
          self = module;
      } catch (e) {
      }
      self._factory = _f;
      var t;
      function u(a2) {
        return "undefined" !== typeof a2 ? a2 : true;
      }
      function aa(a2) {
        const b2 = Array(a2);
        for (let c2 = 0; c2 < a2; c2++)
          b2[c2] = v();
        return b2;
      }
      function v() {
        return /* @__PURE__ */ Object.create(null);
      }
      function ba(a2, b2) {
        return b2.length - a2.length;
      }
      function x(a2) {
        return "string" === typeof a2;
      }
      function C(a2) {
        return "object" === typeof a2;
      }
      function D(a2) {
        return "function" === typeof a2;
      }
      ;
      function ca(a2, b2) {
        var c2 = da;
        if (a2 && (b2 && (a2 = E(a2, b2)), this.H && (a2 = E(a2, this.H)), this.J && 1 < a2.length && (a2 = E(a2, this.J)), c2 || "" === c2)) {
          a2 = a2.split(c2);
          if (this.filter) {
            b2 = this.filter;
            c2 = a2.length;
            const d3 = [];
            for (let e = 0, f = 0; e < c2; e++) {
              const g = a2[e];
              g && !b2[g] && (d3[f++] = g);
            }
            a2 = d3;
          }
          return a2;
        }
        return a2;
      }
      const da = /[\p{Z}\p{S}\p{P}\p{C}]+/u, ea = /[\u0300-\u036f]/g;
      function fa(a2, b2) {
        const c2 = Object.keys(a2), d3 = c2.length, e = [];
        let f = "", g = 0;
        for (let h = 0, k, m; h < d3; h++)
          k = c2[h], (m = a2[k]) ? (e[g++] = F(b2 ? "(?!\\b)" + k + "(\\b|_)" : k), e[g++] = m) : f += (f ? "|" : "") + k;
        f && (e[g++] = F(b2 ? "(?!\\b)(" + f + ")(\\b|_)" : "(" + f + ")"), e[g] = "");
        return e;
      }
      function E(a2, b2) {
        for (let c2 = 0, d3 = b2.length; c2 < d3 && (a2 = a2.replace(b2[c2], b2[c2 + 1]), a2); c2 += 2)
          ;
        return a2;
      }
      function F(a2) {
        return new RegExp(a2, "g");
      }
      function ha(a2) {
        let b2 = "", c2 = "";
        for (let d3 = 0, e = a2.length, f; d3 < e; d3++)
          (f = a2[d3]) !== c2 && (b2 += c2 = f);
        return b2;
      }
      ;
      var ja = { encode: ia, F: false, G: "" };
      function ia(a2) {
        return ca.call(this, ("" + a2).toLowerCase(), false);
      }
      ;
      const ka = {}, G = {};
      function la(a2) {
        I(a2, "add");
        I(a2, "append");
        I(a2, "search");
        I(a2, "update");
        I(a2, "remove");
      }
      function I(a2, b2) {
        a2[b2 + "Async"] = function() {
          const c2 = this, d3 = arguments;
          var e = d3[d3.length - 1];
          let f;
          D(e) && (f = e, delete d3[d3.length - 1]);
          e = new Promise(function(g) {
            setTimeout(function() {
              c2.async = true;
              const h = c2[b2].apply(c2, d3);
              c2.async = false;
              g(h);
            });
          });
          return f ? (e.then(f), this) : e;
        };
      }
      ;
      function ma(a2, b2, c2, d3) {
        const e = a2.length;
        let f = [], g, h, k = 0;
        d3 && (d3 = []);
        for (let m = e - 1; 0 <= m; m--) {
          const n = a2[m], w = n.length, q = v();
          let r = !g;
          for (let l = 0; l < w; l++) {
            const p = n[l], z2 = p.length;
            if (z2)
              for (let B = 0, A, y; B < z2; B++)
                if (y = p[B], g) {
                  if (g[y]) {
                    if (!m) {
                      if (c2)
                        c2--;
                      else if (f[k++] = y, k === b2)
                        return f;
                    }
                    if (m || d3)
                      q[y] = 1;
                    r = true;
                  }
                  if (d3 && (h[y] = (A = h[y]) ? ++A : A = 1, A < e)) {
                    const H = d3[A - 2] || (d3[A - 2] = []);
                    H[H.length] = y;
                  }
                } else
                  q[y] = 1;
          }
          if (d3)
            g || (h = q);
          else if (!r)
            return [];
          g = q;
        }
        if (d3)
          for (let m = d3.length - 1, n, w; 0 <= m; m--) {
            n = d3[m];
            w = n.length;
            for (let q = 0, r; q < w; q++)
              if (r = n[q], !g[r]) {
                if (c2)
                  c2--;
                else if (f[k++] = r, k === b2)
                  return f;
                g[r] = 1;
              }
          }
        return f;
      }
      function na(a2, b2) {
        const c2 = v(), d3 = v(), e = [];
        for (let f = 0; f < a2.length; f++)
          c2[a2[f]] = 1;
        for (let f = 0, g; f < b2.length; f++) {
          g = b2[f];
          for (let h = 0, k; h < g.length; h++)
            k = g[h], c2[k] && !d3[k] && (d3[k] = 1, e[e.length] = k);
        }
        return e;
      }
      ;
      function J(a2) {
        this.l = true !== a2 && a2;
        this.cache = v();
        this.h = [];
      }
      function oa(a2, b2, c2) {
        C(a2) && (a2 = a2.query);
        let d3 = this.cache.get(a2);
        d3 || (d3 = this.search(a2, b2, c2), this.cache.set(a2, d3));
        return d3;
      }
      J.prototype.set = function(a2, b2) {
        if (!this.cache[a2]) {
          var c2 = this.h.length;
          c2 === this.l ? delete this.cache[this.h[c2 - 1]] : c2++;
          for (--c2; 0 < c2; c2--)
            this.h[c2] = this.h[c2 - 1];
          this.h[0] = a2;
        }
        this.cache[a2] = b2;
      };
      J.prototype.get = function(a2) {
        const b2 = this.cache[a2];
        if (this.l && b2 && (a2 = this.h.indexOf(a2))) {
          const c2 = this.h[a2 - 1];
          this.h[a2 - 1] = this.h[a2];
          this.h[a2] = c2;
        }
        return b2;
      };
      const qa = { memory: { charset: "latin:extra", D: 3, B: 4, m: false }, performance: { D: 3, B: 3, s: false, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, "default": {} };
      function ra(a2, b2, c2, d3, e, f) {
        setTimeout(function() {
          const g = a2(c2, JSON.stringify(f));
          g && g.then ? g.then(function() {
            b2.export(a2, b2, c2, d3, e + 1);
          }) : b2.export(a2, b2, c2, d3, e + 1);
        });
      }
      ;
      function K(a2, b2) {
        if (!(this instanceof K))
          return new K(a2);
        var c2;
        if (a2) {
          x(a2) ? a2 = qa[a2] : (c2 = a2.preset) && (a2 = Object.assign({}, c2[c2], a2));
          c2 = a2.charset;
          var d3 = a2.lang;
          x(c2) && (-1 === c2.indexOf(":") && (c2 += ":default"), c2 = G[c2]);
          x(d3) && (d3 = ka[d3]);
        } else
          a2 = {};
        let e, f, g = a2.context || {};
        this.encode = a2.encode || c2 && c2.encode || ia;
        this.register = b2 || v();
        this.D = e = a2.resolution || 9;
        this.G = b2 = c2 && c2.G || a2.tokenize || "strict";
        this.depth = "strict" === b2 && g.depth;
        this.l = u(g.bidirectional);
        this.s = f = u(a2.optimize);
        this.m = u(a2.fastupdate);
        this.B = a2.minlength || 1;
        this.C = a2.boost;
        this.map = f ? aa(e) : v();
        this.A = e = g.resolution || 1;
        this.h = f ? aa(e) : v();
        this.F = c2 && c2.F || a2.rtl;
        this.H = (b2 = a2.matcher || d3 && d3.H) && fa(b2, false);
        this.J = (b2 = a2.stemmer || d3 && d3.J) && fa(b2, true);
        if (c2 = b2 = a2.filter || d3 && d3.filter) {
          c2 = b2;
          d3 = v();
          for (let h = 0, k = c2.length; h < k; h++)
            d3[c2[h]] = 1;
          c2 = d3;
        }
        this.filter = c2;
        this.cache = (b2 = a2.cache) && new J(b2);
      }
      t = K.prototype;
      t.append = function(a2, b2) {
        return this.add(a2, b2, true);
      };
      t.add = function(a2, b2, c2, d3) {
        if (b2 && (a2 || 0 === a2)) {
          if (!d3 && !c2 && this.register[a2])
            return this.update(a2, b2);
          b2 = this.encode(b2);
          if (d3 = b2.length) {
            const m = v(), n = v(), w = this.depth, q = this.D;
            for (let r = 0; r < d3; r++) {
              let l = b2[this.F ? d3 - 1 - r : r];
              var e = l.length;
              if (l && e >= this.B && (w || !n[l])) {
                var f = L(q, d3, r), g = "";
                switch (this.G) {
                  case "full":
                    if (3 < e) {
                      for (f = 0; f < e; f++)
                        for (var h = e; h > f; h--)
                          if (h - f >= this.B) {
                            var k = L(q, d3, r, e, f);
                            g = l.substring(f, h);
                            M(this, n, g, k, a2, c2);
                          }
                      break;
                    }
                  case "reverse":
                    if (2 < e) {
                      for (h = e - 1; 0 < h; h--)
                        g = l[h] + g, g.length >= this.B && M(
                          this,
                          n,
                          g,
                          L(q, d3, r, e, h),
                          a2,
                          c2
                        );
                      g = "";
                    }
                  case "forward":
                    if (1 < e) {
                      for (h = 0; h < e; h++)
                        g += l[h], g.length >= this.B && M(this, n, g, f, a2, c2);
                      break;
                    }
                  default:
                    if (this.C && (f = Math.min(f / this.C(b2, l, r) | 0, q - 1)), M(this, n, l, f, a2, c2), w && 1 < d3 && r < d3 - 1) {
                      for (e = v(), g = this.A, f = l, h = Math.min(w + 1, d3 - r), e[f] = 1, k = 1; k < h; k++)
                        if ((l = b2[this.F ? d3 - 1 - r - k : r + k]) && l.length >= this.B && !e[l]) {
                          e[l] = 1;
                          const p = this.l && l > f;
                          M(this, m, p ? f : l, L(g + (d3 / 2 > g ? 0 : 1), d3, r, h - 1, k - 1), a2, c2, p ? l : f);
                        }
                    }
                }
              }
            }
            this.m || (this.register[a2] = 1);
          }
        }
        return this;
      };
      function L(a2, b2, c2, d3, e) {
        return c2 && 1 < a2 ? b2 + (d3 || 0) <= a2 ? c2 + (e || 0) : (a2 - 1) / (b2 + (d3 || 0)) * (c2 + (e || 0)) + 1 | 0 : 0;
      }
      function M(a2, b2, c2, d3, e, f, g) {
        let h = g ? a2.h : a2.map;
        if (!b2[c2] || g && !b2[c2][g])
          a2.s && (h = h[d3]), g ? (b2 = b2[c2] || (b2[c2] = v()), b2[g] = 1, h = h[g] || (h[g] = v())) : b2[c2] = 1, h = h[c2] || (h[c2] = []), a2.s || (h = h[d3] || (h[d3] = [])), f && -1 !== h.indexOf(e) || (h[h.length] = e, a2.m && (a2 = a2.register[e] || (a2.register[e] = []), a2[a2.length] = h));
      }
      t.search = function(a2, b2, c2) {
        c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2));
        let d3 = [], e;
        let f, g = 0;
        if (c2) {
          b2 = c2.limit;
          g = c2.offset || 0;
          var h = c2.context;
          f = c2.suggest;
        }
        if (a2 && (a2 = this.encode(a2), e = a2.length, 1 < e)) {
          c2 = v();
          var k = [];
          for (let n = 0, w = 0, q; n < e; n++)
            if ((q = a2[n]) && q.length >= this.B && !c2[q])
              if (this.s || f || this.map[q])
                k[w++] = q, c2[q] = 1;
              else
                return d3;
          a2 = k;
          e = a2.length;
        }
        if (!e)
          return d3;
        b2 || (b2 = 100);
        h = this.depth && 1 < e && false !== h;
        c2 = 0;
        let m;
        h ? (m = a2[0], c2 = 1) : 1 < e && a2.sort(ba);
        for (let n, w; c2 < e; c2++) {
          w = a2[c2];
          h ? (n = sa(this, d3, f, b2, g, 2 === e, w, m), f && false === n && d3.length || (m = w)) : n = sa(this, d3, f, b2, g, 1 === e, w);
          if (n)
            return n;
          if (f && c2 === e - 1) {
            k = d3.length;
            if (!k) {
              if (h) {
                h = 0;
                c2 = -1;
                continue;
              }
              return d3;
            }
            if (1 === k)
              return ta(d3[0], b2, g);
          }
        }
        return ma(d3, b2, g, f);
      };
      function sa(a2, b2, c2, d3, e, f, g, h) {
        let k = [], m = h ? a2.h : a2.map;
        a2.s || (m = ua(m, g, h, a2.l));
        if (m) {
          let n = 0;
          const w = Math.min(m.length, h ? a2.A : a2.D);
          for (let q = 0, r = 0, l, p; q < w; q++)
            if (l = m[q]) {
              if (a2.s && (l = ua(l, g, h, a2.l)), e && l && f && (p = l.length, p <= e ? (e -= p, l = null) : (l = l.slice(e), e = 0)), l && (k[n++] = l, f && (r += l.length, r >= d3)))
                break;
            }
          if (n) {
            if (f)
              return ta(k, d3, 0);
            b2[b2.length] = k;
            return;
          }
        }
        return !c2 && k;
      }
      function ta(a2, b2, c2) {
        a2 = 1 === a2.length ? a2[0] : [].concat.apply([], a2);
        return c2 || a2.length > b2 ? a2.slice(c2, c2 + b2) : a2;
      }
      function ua(a2, b2, c2, d3) {
        c2 ? (d3 = d3 && b2 > c2, a2 = (a2 = a2[d3 ? b2 : c2]) && a2[d3 ? c2 : b2]) : a2 = a2[b2];
        return a2;
      }
      t.contain = function(a2) {
        return !!this.register[a2];
      };
      t.update = function(a2, b2) {
        return this.remove(a2).add(a2, b2);
      };
      t.remove = function(a2, b2) {
        const c2 = this.register[a2];
        if (c2) {
          if (this.m)
            for (let d3 = 0, e; d3 < c2.length; d3++)
              e = c2[d3], e.splice(e.indexOf(a2), 1);
          else
            N(this.map, a2, this.D, this.s), this.depth && N(this.h, a2, this.A, this.s);
          b2 || delete this.register[a2];
          if (this.cache) {
            b2 = this.cache;
            for (let d3 = 0, e, f; d3 < b2.h.length; d3++)
              f = b2.h[d3], e = b2.cache[f], -1 !== e.indexOf(a2) && (b2.h.splice(d3--, 1), delete b2.cache[f]);
          }
        }
        return this;
      };
      function N(a2, b2, c2, d3, e) {
        let f = 0;
        if (a2.constructor === Array)
          if (e)
            b2 = a2.indexOf(b2), -1 !== b2 ? 1 < a2.length && (a2.splice(b2, 1), f++) : f++;
          else {
            e = Math.min(a2.length, c2);
            for (let g = 0, h; g < e; g++)
              if (h = a2[g])
                f = N(h, b2, c2, d3, e), d3 || f || delete a2[g];
          }
        else
          for (let g in a2)
            (f = N(a2[g], b2, c2, d3, e)) || delete a2[g];
        return f;
      }
      t.searchCache = oa;
      t.export = function(a2, b2, c2, d3, e) {
        let f, g;
        switch (e || (e = 0)) {
          case 0:
            f = "reg";
            if (this.m) {
              g = v();
              for (let h in this.register)
                g[h] = 1;
            } else
              g = this.register;
            break;
          case 1:
            f = "cfg";
            g = { doc: 0, opt: this.s ? 1 : 0 };
            break;
          case 2:
            f = "map";
            g = this.map;
            break;
          case 3:
            f = "ctx";
            g = this.h;
            break;
          default:
            return;
        }
        ra(a2, b2 || this, c2 ? c2 + "." + f : f, d3, e, g);
        return true;
      };
      t.import = function(a2, b2) {
        if (b2)
          switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
            case "cfg":
              this.s = !!b2.opt;
              break;
            case "reg":
              this.m = false;
              this.register = b2;
              break;
            case "map":
              this.map = b2;
              break;
            case "ctx":
              this.h = b2;
          }
      };
      la(K.prototype);
      function va(a2) {
        a2 = a2.data;
        var b2 = self._index;
        const c2 = a2.args;
        var d3 = a2.task;
        switch (d3) {
          case "init":
            d3 = a2.options || {};
            a2 = a2.factory;
            b2 = d3.encode;
            d3.cache = false;
            b2 && 0 === b2.indexOf("function") && (d3.encode = Function("return " + b2)());
            a2 ? (Function("return " + a2)()(self), self._index = new self.FlexSearch.Index(d3), delete self.FlexSearch) : self._index = new K(d3);
            break;
          default:
            a2 = a2.id, b2 = b2[d3].apply(b2, c2), postMessage("search" === d3 ? { id: a2, msg: b2 } : { id: a2 });
        }
      }
      ;
      let wa = 0;
      function O(a2) {
        if (!(this instanceof O))
          return new O(a2);
        var b2;
        a2 ? D(b2 = a2.encode) && (a2.encode = b2.toString()) : a2 = {};
        (b2 = (self || window)._factory) && (b2 = b2.toString());
        const c2 = self.exports, d3 = this;
        this.o = xa(b2, c2, a2.worker);
        this.h = v();
        if (this.o) {
          if (c2)
            this.o.on("message", function(e) {
              d3.h[e.id](e.msg);
              delete d3.h[e.id];
            });
          else
            this.o.onmessage = function(e) {
              e = e.data;
              d3.h[e.id](e.msg);
              delete d3.h[e.id];
            };
          this.o.postMessage({ task: "init", factory: b2, options: a2 });
        }
      }
      P("add");
      P("append");
      P("search");
      P("update");
      P("remove");
      function P(a2) {
        O.prototype[a2] = O.prototype[a2 + "Async"] = function() {
          const b2 = this, c2 = [].slice.call(arguments);
          var d3 = c2[c2.length - 1];
          let e;
          D(d3) && (e = d3, c2.splice(c2.length - 1, 1));
          d3 = new Promise(function(f) {
            setTimeout(function() {
              b2.h[++wa] = f;
              b2.o.postMessage({ task: a2, id: wa, args: c2 });
            });
          });
          return e ? (d3.then(e), this) : d3;
        };
      }
      function xa(a, b, c) {
        let d;
        try {
          d = b ? eval('new (require("worker_threads")["Worker"])("../dist/node/node.js")') : a ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + va.toString()], { type: "text/javascript" }))) : new Worker(x(c) ? c : "worker/worker.js", { type: "module" });
        } catch (e) {
        }
        return d;
      }
      ;
      function Q(a2) {
        if (!(this instanceof Q))
          return new Q(a2);
        var b2 = a2.document || a2.doc || a2, c2;
        this.K = [];
        this.h = [];
        this.A = [];
        this.register = v();
        this.key = (c2 = b2.key || b2.id) && S(c2, this.A) || "id";
        this.m = u(a2.fastupdate);
        this.C = (c2 = b2.store) && true !== c2 && [];
        this.store = c2 && v();
        this.I = (c2 = b2.tag) && S(c2, this.A);
        this.l = c2 && v();
        this.cache = (c2 = a2.cache) && new J(c2);
        a2.cache = false;
        this.o = a2.worker;
        this.async = false;
        c2 = v();
        let d3 = b2.index || b2.field || b2;
        x(d3) && (d3 = [d3]);
        for (let e = 0, f, g; e < d3.length; e++)
          f = d3[e], x(f) || (g = f, f = f.field), g = C(g) ? Object.assign({}, a2, g) : a2, this.o && (c2[f] = new O(g), c2[f].o || (this.o = false)), this.o || (c2[f] = new K(g, this.register)), this.K[e] = S(f, this.A), this.h[e] = f;
        if (this.C)
          for (a2 = b2.store, x(a2) && (a2 = [a2]), b2 = 0; b2 < a2.length; b2++)
            this.C[b2] = S(a2[b2], this.A);
        this.index = c2;
      }
      function S(a2, b2) {
        const c2 = a2.split(":");
        let d3 = 0;
        for (let e = 0; e < c2.length; e++)
          a2 = c2[e], 0 <= a2.indexOf("[]") && (a2 = a2.substring(0, a2.length - 2)) && (b2[d3] = true), a2 && (c2[d3++] = a2);
        d3 < c2.length && (c2.length = d3);
        return 1 < d3 ? c2 : c2[0];
      }
      function T(a2, b2) {
        if (x(b2))
          a2 = a2[b2];
        else
          for (let c2 = 0; a2 && c2 < b2.length; c2++)
            a2 = a2[b2[c2]];
        return a2;
      }
      function U(a2, b2, c2, d3, e) {
        a2 = a2[e];
        if (d3 === c2.length - 1)
          b2[e] = a2;
        else if (a2)
          if (a2.constructor === Array)
            for (b2 = b2[e] = Array(a2.length), e = 0; e < a2.length; e++)
              U(a2, b2, c2, d3, e);
          else
            b2 = b2[e] || (b2[e] = v()), e = c2[++d3], U(a2, b2, c2, d3, e);
      }
      function V(a2, b2, c2, d3, e, f, g, h) {
        if (a2 = a2[g])
          if (d3 === b2.length - 1) {
            if (a2.constructor === Array) {
              if (c2[d3]) {
                for (b2 = 0; b2 < a2.length; b2++)
                  e.add(f, a2[b2], true, true);
                return;
              }
              a2 = a2.join(" ");
            }
            e.add(f, a2, h, true);
          } else if (a2.constructor === Array)
            for (g = 0; g < a2.length; g++)
              V(a2, b2, c2, d3, e, f, g, h);
          else
            g = b2[++d3], V(a2, b2, c2, d3, e, f, g, h);
      }
      t = Q.prototype;
      t.add = function(a2, b2, c2) {
        C(a2) && (b2 = a2, a2 = T(b2, this.key));
        if (b2 && (a2 || 0 === a2)) {
          if (!c2 && this.register[a2])
            return this.update(a2, b2);
          for (let d3 = 0, e, f; d3 < this.h.length; d3++)
            f = this.h[d3], e = this.K[d3], x(e) && (e = [e]), V(b2, e, this.A, 0, this.index[f], a2, e[0], c2);
          if (this.I) {
            let d3 = T(b2, this.I), e = v();
            x(d3) && (d3 = [d3]);
            for (let f = 0, g, h; f < d3.length; f++)
              if (g = d3[f], !e[g] && (e[g] = 1, h = this.l[g] || (this.l[g] = []), !c2 || -1 === h.indexOf(a2))) {
                if (h[h.length] = a2, this.m) {
                  const k = this.register[a2] || (this.register[a2] = []);
                  k[k.length] = h;
                }
              }
          }
          if (this.store && (!c2 || !this.store[a2])) {
            let d3;
            if (this.C) {
              d3 = v();
              for (let e = 0, f; e < this.C.length; e++)
                f = this.C[e], x(f) ? d3[f] = b2[f] : U(b2, d3, f, 0, f[0]);
            }
            this.store[a2] = d3 || b2;
          }
        }
        return this;
      };
      t.append = function(a2, b2) {
        return this.add(a2, b2, true);
      };
      t.update = function(a2, b2) {
        return this.remove(a2).add(a2, b2);
      };
      t.remove = function(a2) {
        C(a2) && (a2 = T(a2, this.key));
        if (this.register[a2]) {
          for (var b2 = 0; b2 < this.h.length && (this.index[this.h[b2]].remove(a2, !this.o), !this.m); b2++)
            ;
          if (this.I && !this.m)
            for (let c2 in this.l) {
              b2 = this.l[c2];
              const d3 = b2.indexOf(a2);
              -1 !== d3 && (1 < b2.length ? b2.splice(d3, 1) : delete this.l[c2]);
            }
          this.store && delete this.store[a2];
          delete this.register[a2];
        }
        return this;
      };
      t.search = function(a2, b2, c2, d3) {
        c2 || (!b2 && C(a2) ? (c2 = a2, a2 = c2.query) : C(b2) && (c2 = b2, b2 = 0));
        let e = [], f = [], g, h, k, m, n, w, q = 0;
        if (c2)
          if (c2.constructor === Array)
            k = c2, c2 = null;
          else {
            k = (g = c2.pluck) || c2.index || c2.field;
            m = c2.tag;
            h = this.store && c2.enrich;
            n = "and" === c2.bool;
            b2 = c2.limit || 100;
            w = c2.offset || 0;
            if (m && (x(m) && (m = [m]), !a2)) {
              for (let l = 0, p; l < m.length; l++)
                if (p = ya.call(this, m[l], b2, w, h))
                  e[e.length] = p, q++;
              return q ? e : [];
            }
            x(k) && (k = [k]);
          }
        k || (k = this.h);
        n = n && (1 < k.length || m && 1 < m.length);
        const r = !d3 && (this.o || this.async) && [];
        for (let l = 0, p, z2, B; l < k.length; l++) {
          let A;
          z2 = k[l];
          x(z2) || (A = z2, z2 = z2.field);
          if (r)
            r[l] = this.index[z2].searchAsync(a2, b2, A || c2);
          else {
            d3 ? p = d3[l] : p = this.index[z2].search(a2, b2, A || c2);
            B = p && p.length;
            if (m && B) {
              const y = [];
              let H = 0;
              n && (y[0] = [p]);
              for (let X = 0, pa, R; X < m.length; X++)
                if (pa = m[X], B = (R = this.l[pa]) && R.length)
                  H++, y[y.length] = n ? [R] : R;
              H && (p = n ? ma(y, b2 || 100, w || 0) : na(p, y), B = p.length);
            }
            if (B)
              f[q] = z2, e[q++] = p;
            else if (n)
              return [];
          }
        }
        if (r) {
          const l = this;
          return new Promise(function(p) {
            Promise.all(r).then(function(z2) {
              p(l.search(a2, b2, c2, z2));
            });
          });
        }
        if (!q)
          return [];
        if (g && (!h || !this.store))
          return e[0];
        for (let l = 0, p; l < f.length; l++) {
          p = e[l];
          p.length && h && (p = za.call(this, p));
          if (g)
            return p;
          e[l] = { field: f[l], result: p };
        }
        return e;
      };
      function ya(a2, b2, c2, d3) {
        let e = this.l[a2], f = e && e.length - c2;
        if (f && 0 < f) {
          if (f > b2 || c2)
            e = e.slice(c2, c2 + b2);
          d3 && (e = za.call(this, e));
          return { tag: a2, result: e };
        }
      }
      function za(a2) {
        const b2 = Array(a2.length);
        for (let c2 = 0, d3; c2 < a2.length; c2++)
          d3 = a2[c2], b2[c2] = { id: d3, doc: this.store[d3] };
        return b2;
      }
      t.contain = function(a2) {
        return !!this.register[a2];
      };
      t.get = function(a2) {
        return this.store[a2];
      };
      t.set = function(a2, b2) {
        this.store[a2] = b2;
        return this;
      };
      t.searchCache = oa;
      t.export = function(a2, b2, c2, d3, e) {
        e || (e = 0);
        d3 || (d3 = 0);
        if (d3 < this.h.length) {
          const f = this.h[d3], g = this.index[f];
          b2 = this;
          setTimeout(function() {
            g.export(a2, b2, e ? f.replace(":", "-") : "", d3, e++) || (d3++, e = 1, b2.export(a2, b2, f, d3, e));
          });
        } else {
          let f;
          switch (e) {
            case 1:
              c2 = "tag";
              f = this.l;
              break;
            case 2:
              c2 = "store";
              f = this.store;
              break;
            default:
              return;
          }
          ra(a2, this, c2, d3, e, f);
        }
      };
      t.import = function(a2, b2) {
        if (b2)
          switch (x(b2) && (b2 = JSON.parse(b2)), a2) {
            case "tag":
              this.l = b2;
              break;
            case "reg":
              this.m = false;
              this.register = b2;
              for (let d3 = 0, e; d3 < this.h.length; d3++)
                e = this.index[this.h[d3]], e.register = b2, e.m = false;
              break;
            case "store":
              this.store = b2;
              break;
            default:
              a2 = a2.split(".");
              const c2 = a2[0];
              a2 = a2[1];
              c2 && a2 && this.index[c2].import(a2, b2);
          }
      };
      la(Q.prototype);
      var Ba = { encode: Aa, F: false, G: "" };
      const Ca = [F("[àáâãäå]"), "a", F("[èéêë]"), "e", F("[ìíîï]"), "i", F("[òóôõöő]"), "o", F("[ùúûüű]"), "u", F("[ýŷÿ]"), "y", F("ñ"), "n", F("[çc]"), "k", F("ß"), "s", F(" & "), " and "];
      function Aa(a2) {
        var b2 = a2;
        b2.normalize && (b2 = b2.normalize("NFD").replace(ea, ""));
        return ca.call(this, b2.toLowerCase(), !a2.normalize && Ca);
      }
      ;
      var Ea = { encode: Da, F: false, G: "strict" };
      const Fa = /[^a-z0-9]+/, Ga = { b: "p", v: "f", w: "f", z: "s", x: "s", "ß": "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
      function Da(a2) {
        a2 = Aa.call(this, a2).join(" ");
        const b2 = [];
        if (a2) {
          const c2 = a2.split(Fa), d3 = c2.length;
          for (let e = 0, f, g = 0; e < d3; e++)
            if ((a2 = c2[e]) && (!this.filter || !this.filter[a2])) {
              f = a2[0];
              let h = Ga[f] || f, k = h;
              for (let m = 1; m < a2.length; m++) {
                f = a2[m];
                const n = Ga[f] || f;
                n && n !== k && (h += n, k = n);
              }
              b2[g++] = h;
            }
        }
        return b2;
      }
      ;
      var Ia = { encode: Ha, F: false, G: "" };
      const Ja = [F("ae"), "a", F("oe"), "o", F("sh"), "s", F("th"), "t", F("ph"), "f", F("pf"), "f", F("(?![aeo])h(?![aeo])"), "", F("(?!^[aeo])h(?!^[aeo])"), ""];
      function Ha(a2, b2) {
        a2 && (a2 = Da.call(this, a2).join(" "), 2 < a2.length && (a2 = E(a2, Ja)), b2 || (1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" "))));
        return a2;
      }
      ;
      var La = { encode: Ka, F: false, G: "" };
      const Ma = F("(?!\\b)[aeo]");
      function Ka(a2) {
        a2 && (a2 = Ha.call(this, a2, true), 1 < a2.length && (a2 = a2.replace(Ma, "")), 1 < a2.length && (a2 = ha(a2)), a2 && (a2 = a2.split(" ")));
        return a2;
      }
      ;
      G["latin:default"] = ja;
      G["latin:simple"] = Ba;
      G["latin:balance"] = Ea;
      G["latin:advanced"] = Ia;
      G["latin:extra"] = La;
      const W = self;
      let Y;
      const Z = { Index: K, Document: Q, Worker: O, registerCharset: function(a2, b2) {
        G[a2] = b2;
      }, registerLanguage: function(a2, b2) {
        ka[a2] = b2;
      } };
      (Y = W.define) && Y.amd ? Y([], function() {
        return Z;
      }) : W.exports ? W.exports = Z : W.FlexSearch = Z;
    })(exports);
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a2, b2, str) {
      if (a2 instanceof RegExp)
        a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r = range(a2, b2, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a2.length, r[1]),
        post: str.slice(r[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b2, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a2, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x2 = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x2;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N2 = [];
          for (var i = x2; test(i, y); i += incr) {
            var c2;
            if (isAlphaSequence) {
              c2 = String.fromCharCode(i);
              if (c2 === "\\")
                c2 = "";
            } else {
              c2 = String(i);
              if (pad) {
                var need = width - c2.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i < 0)
                    c2 = "-" + z2 + c2.slice(1);
                  else
                    c2 = z2 + c2;
                }
              }
            }
            N2.push(c2);
          }
        } else {
          N2 = [];
          for (var j = 0; j < n.length; j++) {
            N2.push.apply(N2, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N2.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N2[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/@blocksuite/global/dist/config/consts/platform.js
var _a;
var IS_SAFARI = /Apple Computer/.test((_a = globalThis.navigator) == null ? void 0 : _a.vendor);
var _a2, _b;
var IS_IOS = IS_SAFARI && (/Mobile\/\w+/.test((_a2 = globalThis.navigator) == null ? void 0 : _a2.userAgent) || ((_b = globalThis.navigator) == null ? void 0 : _b.maxTouchPoints) > 2);
var _a3;
var IS_MAC = /Mac/i.test((_a3 = globalThis.navigator) == null ? void 0 : _a3.platform);
var SHORT_KEY = IS_MAC ? "command" : "ctrl";

// node_modules/@lit/reactive-element/development/css-tag.js
var NODE_MODE = false;
var global2 = NODE_MODE ? globalThis : window;
var supportsAdoptingStyleSheets = global2.ShadowRoot && (global2.ShadyCSS === void 0 || global2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var cssTagCache = /* @__PURE__ */ new WeakMap();
var CSSResult = class {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  // This is a getter so that it's lazy. In practice, this means stylesheets
  // are not created until the first element instance is made.
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
var unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
var css = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
var adoptStyles = (renderRoot, styles) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
  } else {
    styles.forEach((s) => {
      const style = document.createElement("style");
      const nonce = global2["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s.cssText;
      renderRoot.appendChild(style);
    });
  }
};
var cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
var getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE && global2.CSSStyleSheet === void 0 ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;

// node_modules/@lit/reactive-element/development/reactive-element.js
var _a4;
var _b2;
var _c;
var _d;
var _e;
var NODE_MODE2 = false;
var global3 = NODE_MODE2 ? globalThis : window;
if (NODE_MODE2) {
  (_a4 = global3.customElements) !== null && _a4 !== void 0 ? _a4 : global3.customElements = customElements;
}
var DEV_MODE = true;
var requestUpdateThenable;
var issueWarning;
var trustedTypes = global3.trustedTypes;
var emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : "";
var polyfillSupport = DEV_MODE ? global3.reactiveElementPolyfillSupportDevMode : global3.reactiveElementPolyfillSupport;
if (DEV_MODE) {
  const issuedWarnings = (_b2 = global3.litIssuedWarnings) !== null && _b2 !== void 0 ? _b2 : global3.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
  issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  if (((_c = global3.ShadyDOM) === null || _c === void 0 ? void 0 : _c.inUse) && polyfillSupport === void 0) {
    issueWarning("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
  }
  requestUpdateThenable = (name) => ({
    then: (onfulfilled, _onrejected) => {
      issueWarning("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name}\`. Use \`updateComplete\` instead.`);
      if (onfulfilled !== void 0) {
        onfulfilled(false);
      }
    }
  });
}
var debugLogEvent = DEV_MODE ? (event) => {
  const shouldEmit = global3.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global3.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var finalized = "finalized";
var ReactiveElement = class extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  /**
   * Adds an initializer function to the class that is called during instance
   * construction.
   *
   * This is useful for code that runs against a `ReactiveElement`
   * subclass, such as a decorator, that needs to do work for each
   * instance, such as setting up a `ReactiveController`.
   *
   * ```ts
   * const myDecorator = (target: typeof ReactiveElement, key: string) => {
   *   target.addInitializer((instance: ReactiveElement) => {
   *     // This is run during construction of the element
   *     new MyController(instance);
   *   });
   * }
   * ```
   *
   * Decorating a field will then cause each instance to run an initializer
   * that adds a controller:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   @myDecorator foo;
   * }
   * ```
   *
   * Initializers are stored per-constructor. Adding an initializer to a
   * subclass does not add it to a superclass. Since initializers are run in
   * constructors, initializers will run in order of the class hierarchy,
   * starting with superclasses and progressing to the instance's class.
   *
   * @nocollapse
   */
  static addInitializer(initializer) {
    var _a10;
    this.finalize();
    ((_a10 = this._initializers) !== null && _a10 !== void 0 ? _a10 : this._initializers = []).push(initializer);
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   * @category attributes
   */
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v2, p) => {
      const attr = this.__attributeNameForProperty(p, v2);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a {@linkcode PropertyDeclaration} for the property with the
   * given options. The property setter calls the property's `hasChanged`
   * property option or uses a strict identity check to determine whether or not
   * to request an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * ```ts
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    var _a10;
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
      const key = typeof name === "symbol" ? Symbol() : `__${name}`;
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== void 0) {
        Object.defineProperty(this.prototype, name, descriptor);
        if (DEV_MODE) {
          if (!this.hasOwnProperty("__reactivePropertyKeys")) {
            this.__reactivePropertyKeys = new Set((_a10 = this.__reactivePropertyKeys) !== null && _a10 !== void 0 ? _a10 : []);
          }
          this.__reactivePropertyKeys.add(name);
        }
      }
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   * ```ts
   * class MyElement extends LitElement {
   *   static getPropertyDescriptor(name, key, options) {
   *     const defaultDescriptor =
   *         super.getPropertyDescriptor(name, key, options);
   *     const setter = defaultDescriptor.set;
   *     return {
   *       get: defaultDescriptor.get,
   *       set(value) {
   *         setter.call(this, value);
   *         // custom action.
   *       },
   *       configurable: true,
   *       enumerable: true
   *     }
   *   }
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static getPropertyDescriptor(name, key, options) {
    return {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a `PropertyDeclaration` via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override
   * {@linkcode createProperty}.
   *
   * @nocollapse
   * @final
   * @category properties
   */
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties, sets up element
   * styling, and ensures any superclasses are also finalized. Returns true if
   * the element was finalized.
   * @nocollapse
   */
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== void 0) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    if (DEV_MODE) {
      const warnRemovedOrRenamed = (name, renamed = false) => {
        if (this.prototype.hasOwnProperty(name)) {
          issueWarning(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
        }
      };
      warnRemovedOrRenamed("initialize");
      warnRemovedOrRenamed("requestUpdateInternal");
      warnRemovedOrRenamed("_getUpdateComplete", true);
    }
    return true;
  }
  /**
   * Takes the styles the user supplied via the `static styles` property and
   * returns the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * Styles are deduplicated preserving the _last_ instance in the list. This
   * is a performance optimization to avoid duplicated styles that can occur
   * especially when composing via subclassing. The last item is kept to try
   * to preserve the cascade order with the assumption that it's most important
   * that last added styles override previous styles.
   *
   * @nocollapse
   * @category styles
   */
  static finalizeStyles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
      const set = new Set(styles.flat(Infinity).reverse());
      for (const s of set) {
        elementStyles.unshift(getCompatibleStyle(s));
      }
    } else if (styles !== void 0) {
      elementStyles.push(getCompatibleStyle(styles));
    }
    return elementStyles;
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  /**
   * Internal only override point for customizing work done when elements
   * are constructed.
   *
   * @internal
   */
  _initialize() {
    var _a10;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a10 = this.constructor._initializers) === null || _a10 === void 0 ? void 0 : _a10.forEach((i) => i(this));
  }
  /**
   * Registers a `ReactiveController` to participate in the element's reactive
   * update cycle. The element automatically calls into any registered
   * controllers during its lifecycle callbacks.
   *
   * If the element is connected when `addController()` is called, the
   * controller's `hostConnected()` callback will be immediately called.
   * @category controllers
   */
  addController(controller) {
    var _a10, _b6;
    ((_a10 = this.__controllers) !== null && _a10 !== void 0 ? _a10 : this.__controllers = []).push(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_b6 = controller.hostConnected) === null || _b6 === void 0 ? void 0 : _b6.call(controller);
    }
  }
  /**
   * Removes a `ReactiveController` from the element.
   * @category controllers
   */
  removeController(controller) {
    var _a10;
    (_a10 = this.__controllers) === null || _a10 === void 0 ? void 0 : _a10.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        this.__instanceProperties.set(p, this[p]);
        delete this[p];
      }
    });
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   *
   * @return Returns a node into which to render.
   * @category rendering
   */
  createRenderRoot() {
    var _a10;
    const renderRoot = (_a10 = this.shadowRoot) !== null && _a10 !== void 0 ? _a10 : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  /**
   * On first connection, creates the element's renderRoot, sets up
   * element styling, and enables updating.
   * @category lifecycle
   */
  connectedCallback() {
    var _a10;
    if (this.renderRoot === void 0) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a10 = this.__controllers) === null || _a10 === void 0 ? void 0 : _a10.forEach((c2) => {
      var _a11;
      return (_a11 = c2.hostConnected) === null || _a11 === void 0 ? void 0 : _a11.call(c2);
    });
  }
  /**
   * Note, this method should be considered final and not overridden. It is
   * overridden on the element instance with a function that triggers the first
   * update.
   * @category updates
   */
  enableUpdating(_requestedUpdate) {
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a10;
    (_a10 = this.__controllers) === null || _a10 === void 0 ? void 0 : _a10.forEach((c2) => {
      var _a11;
      return (_a11 = c2.hostDisconnected) === null || _a11 === void 0 ? void 0 : _a11.call(c2);
    });
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * Specifically, when an attribute is set, the corresponding property is set.
   * You should rarely need to implement this callback. If this method is
   * overridden, `super.attributeChangedCallback(name, _old, value)` must be
   * called.
   *
   * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
   * on MDN for more information about the `attributeChangedCallback`.
   * @category attributes
   */
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    var _a10;
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== void 0 && options.reflect === true) {
      const converter = ((_a10 = options.converter) === null || _a10 === void 0 ? void 0 : _a10.toAttribute) !== void 0 ? options.converter : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      if (DEV_MODE && this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
        issueWarning("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  /** @internal */
  _$attributeToProperty(name, value) {
    var _a10;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : ((_a10 = options.converter) === null || _a10 === void 0 ? void 0 : _a10.fromAttribute) !== void 0 ? options.converter : defaultConverter;
      this.__reflectingProperty = propName;
      this[propName] = converter.fromAttribute(
        value,
        options.type
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      );
      this.__reflectingProperty = null;
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should be called
   * when an element should update based on some state not triggered by setting
   * a reactive property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored.
   *
   * @param name name of requesting property
   * @param oldValue old value of requesting property
   * @param options property options to use instead of the previously
   *     configured options
   * @category updates
   */
  requestUpdate(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      options = options || this.constructor.getPropertyOptions(name);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name], oldValue)) {
        if (!this._$changedProperties.has(name)) {
          this._$changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name) {
          if (this.__reflectingProperties === void 0) {
            this.__reflectingProperties = /* @__PURE__ */ new Map();
          }
          this.__reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return DEV_MODE ? requestUpdateThenable(this.localName) : void 0;
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  /**
   * Schedules an element update. You can override this method to change the
   * timing of updates by returning a Promise. The update will await the
   * returned Promise, and you should resolve the Promise to allow the update
   * to proceed. If this method is overridden, `super.scheduleUpdate()`
   * must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```ts
   * override protected async scheduleUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.scheduleUpdate();
   * }
   * ```
   * @category updates
   */
  scheduleUpdate() {
    return this.performUpdate();
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * Call `performUpdate()` to immediately process a pending update. This should
   * generally not be needed, but it can be done in rare cases when you need to
   * update synchronously.
   *
   * Note: To ensure `performUpdate()` synchronously completes a pending update,
   * it should not be overridden. In LitElement 2.x it was suggested to override
   * `performUpdate()` to also customizing update scheduling. Instead, you should now
   * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,
   * scheduling updates via `performUpdate()` continues to work, but will make
   * also calling `performUpdate()` to synchronously process updates difficult.
   *
   * @category updates
   */
  performUpdate() {
    var _a10, _b6;
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({ kind: "update" });
    if (!this.hasUpdated) {
      if (DEV_MODE) {
        const shadowedProperties = [];
        (_a10 = this.constructor.__reactivePropertyKeys) === null || _a10 === void 0 ? void 0 : _a10.forEach((p) => {
          var _a11;
          if (this.hasOwnProperty(p) && !((_a11 = this.__instanceProperties) === null || _a11 === void 0 ? void 0 : _a11.has(p))) {
            shadowedProperties.push(p);
          }
        });
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
    }
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v2, p) => this[p] = v2);
      this.__instanceProperties = void 0;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_b6 = this.__controllers) === null || _b6 === void 0 ? void 0 : _b6.forEach((c2) => {
          var _a11;
          return (_a11 = c2.hostUpdate) === null || _a11 === void 0 ? void 0 : _a11.call(c2);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  /**
   * Invoked before `update()` to compute values needed during the update.
   *
   * Implement `willUpdate` to compute property values that depend on other
   * properties and are used in the rest of the update process.
   *
   * ```ts
   * willUpdate(changedProperties) {
   *   // only need to check changed properties for an expensive computation.
   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
   *   }
   * }
   *
   * render() {
   *   return html`SHA: ${this.sha}`;
   * }
   * ```
   *
   * @category updates
   */
  willUpdate(_changedProperties) {
  }
  // Note, this is an override point for polyfill-support.
  // @internal
  _$didUpdate(changedProperties) {
    var _a10;
    (_a10 = this.__controllers) === null || _a10 === void 0 ? void 0 : _a10.forEach((c2) => {
      var _a11;
      return (_a11 = c2.hostUpdated) === null || _a11 === void 0 ? void 0 : _a11.call(c2);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (DEV_MODE && this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
      issueWarning("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super.getUpdateComplete()`, then any subsequent state.
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  get updateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   override async getUpdateComplete() {
   *     const result = await super.getUpdateComplete();
   *     await this._myChild.updateComplete;
   *     return result;
   *   }
   * }
   * ```
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  getUpdateComplete() {
    return this.__updatePromise;
  }
  /**
   * Controls whether or not `update()` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  update(_changedProperties) {
    if (this.__reflectingProperties !== void 0) {
      this.__reflectingProperties.forEach((v2, k) => this.__propertyToAttribute(k, this[k], v2));
      this.__reflectingProperties = void 0;
    }
    this.__markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * ```ts
   * firstUpdated() {
   *   this.renderRoot.getElementById('my-text-area').focus();
   * }
   * ```
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  firstUpdated(_changedProperties) {
  }
};
_e = finalized;
ReactiveElement[_e] = true;
ReactiveElement.elementProperties = /* @__PURE__ */ new Map();
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ ReactiveElement });
if (DEV_MODE) {
  ReactiveElement.enabledWarnings = ["change-in-update"];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (this.enabledWarnings.indexOf(warning) < 0) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i = this.enabledWarnings.indexOf(warning);
    if (i >= 0) {
      this.enabledWarnings.splice(i, 1);
    }
  };
}
((_d = global3.reactiveElementVersions) !== null && _d !== void 0 ? _d : global3.reactiveElementVersions = []).push("1.6.2");
if (DEV_MODE && global3.reactiveElementVersions.length > 1) {
  issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}

// node_modules/lit-html/development/lit-html.js
var _a5;
var _b3;
var _c2;
var _d2;
var DEV_MODE2 = true;
var ENABLE_EXTRA_SECURITY_HOOKS = true;
var ENABLE_SHADYDOM_NOPATCH = true;
var NODE_MODE3 = false;
var global4 = NODE_MODE3 ? globalThis : window;
var debugLogEvent2 = DEV_MODE2 ? (event) => {
  const shouldEmit = global4.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global4.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var debugLogRenderId = 0;
var issueWarning2;
if (DEV_MODE2) {
  (_a5 = global4.litIssuedWarnings) !== null && _a5 !== void 0 ? _a5 : global4.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning2 = (code, warning) => {
    warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
    if (!global4.litIssuedWarnings.has(warning)) {
      console.warn(warning);
      global4.litIssuedWarnings.add(warning);
    }
  };
  issueWarning2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
}
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_b3 = global4.ShadyDOM) === null || _b3 === void 0 ? void 0 : _b3.inUse) && ((_c2 = global4.ShadyDOM) === null || _c2 === void 0 ? void 0 : _c2.noPatch) === true ? global4.ShadyDOM.wrap : (node) => node;
var trustedTypes2 = global4.trustedTypes;
var policy = trustedTypes2 ? trustedTypes2.createPolicy("lit-html", {
  createHTML: (s) => s
}) : void 0;
var identityFunction = (value) => value;
var noopSanitizer = (_node, _name, _type) => identityFunction;
var setSanitizer = (newSanitizer) => {
  if (!ENABLE_EXTRA_SECURITY_HOOKS) {
    return;
  }
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
var _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
var createSanitizer = (node, name, type) => {
  return sanitizerFactoryInternal(node, name, type);
};
var boundAttributeSuffix = "$lit$";
var marker = `lit$${String(Math.random()).slice(9)}$`;
var markerMatch = "?" + marker;
var nodeMarker = `<${markerMatch}>`;
var d2 = NODE_MODE3 && global4.document === void 0 ? {
  createTreeWalker() {
    return {};
  }
} : document;
var createMarker = () => d2.createComment("");
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isArray = Array.isArray;
var isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === "function";
var SPACE_CHAR = `[ 	
\f\r]`;
var ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
var NAME_CHAR = `[^\\s"'>=/]`;
var textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var COMMENT_START = 1;
var TAG_NAME = 2;
var DYNAMIC_TAG_NAME = 3;
var commentEndRegex = /-->/g;
var comment2EndRegex = />/g;
var tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
var ENTIRE_MATCH = 0;
var ATTRIBUTE_NAME = 1;
var SPACES_AND_EQUALS = 2;
var QUOTE_CHAR = 3;
var singleQuoteAttrEndRegex = /'/g;
var doubleQuoteAttrEndRegex = /"/g;
var rawTextElement = /^(?:script|style|textarea|title)$/i;
var HTML_RESULT = 1;
var SVG_RESULT = 2;
var ATTRIBUTE_PART = 1;
var CHILD_PART = 2;
var PROPERTY_PART = 3;
var BOOLEAN_ATTRIBUTE_PART = 4;
var EVENT_PART = 5;
var ELEMENT_PART = 6;
var COMMENT_PART = 7;
var tag = (type) => (strings, ...values) => {
  if (DEV_MODE2 && strings.some((s) => s === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  return {
    // This property needs to remain unminified.
    ["_$litType$"]: type,
    strings,
    values
  };
};
var html = tag(HTML_RESULT);
var svg = tag(SVG_RESULT);
var noChange = Symbol.for("lit-noChange");
var nothing = Symbol.for("lit-nothing");
var templateCache = /* @__PURE__ */ new WeakMap();
var walker = d2.createTreeWalker(d2, 129, null, false);
var sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
  if (!Array.isArray(tsa) || !tsa.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    if (DEV_MODE2) {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return policy !== void 0 ? policy.createHTML(stringFromTSA) : stringFromTSA;
}
var getTemplateHtml = (strings, type) => {
  const l = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i = 0; i < l; i++) {
    const s = strings[i];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match2;
    while (lastIndex < s.length) {
      regex.lastIndex = lastIndex;
      match2 = regex.exec(s);
      if (match2 === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match2[COMMENT_START] === "!--") {
          regex = commentEndRegex;
        } else if (match2[COMMENT_START] !== void 0) {
          regex = comment2EndRegex;
        } else if (match2[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match2[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match2[TAG_NAME]}`, "g");
          }
          regex = tagEndRegex;
        } else if (match2[DYNAMIC_TAG_NAME] !== void 0) {
          if (DEV_MODE2) {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
          regex = tagEndRegex;
        }
      } else if (regex === tagEndRegex) {
        if (match2[ENTIRE_MATCH] === ">") {
          regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
          attrNameEndIndex = -1;
        } else if (match2[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match2[SPACES_AND_EQUALS].length;
          attrName = match2[ATTRIBUTE_NAME];
          regex = match2[QUOTE_CHAR] === void 0 ? tagEndRegex : match2[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    if (DEV_MODE2) {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex === tagEndRegex && strings[i + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex ? s + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix + s.slice(attrNameEndIndex)) + marker + end : s + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
  }
  const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
  return [trustFromTemplateString(strings, htmlResult), attrNames];
};
var Template = class _Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = _Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (DEV_MODE2) {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m);
            } else
              issueWarning2("", m);
          }
        }
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name of node.getAttributeNames()) {
            if (name.endsWith(boundAttributeSuffix) || name.startsWith(marker)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                const statics = value.split(marker);
                const m = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART,
                  index: nodeIndex,
                  name: m[2],
                  strings: statics,
                  ctor: m[1] === "." ? PropertyPart : m[1] === "?" ? BooleanAttributePart : m[1] === "@" ? EventPart : AttributePart
                });
              } else {
                parts.push({
                  type: ELEMENT_PART,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name of attrsToRemove) {
            node.removeAttribute(name);
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes2 ? trustedTypes2.emptyScript : "";
            for (let i = 0; i < lastIndex; i++) {
              node.append(strings2[i], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @nocollapse */
  static createElement(html2, _options2) {
    const el = d2.createElement("template");
    el.innerHTML = html2;
    return el;
  }
};
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a10, _b6, _c4;
  var _d3;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a10 = parent.__directives) === null || _a10 === void 0 ? void 0 : _a10[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b6 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b6 === void 0 ? void 0 : _b6.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c4 = (_d3 = parent).__directives) !== null && _c4 !== void 0 ? _c4 : _d3.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
var TemplateInstance = class {
  constructor(template, parent) {
    this._$parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template;
    this._$parent = parent;
  }
  // Called by ChildPart parentNode getter
  get parentNode() {
    return this._$parent.parentNode;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  // This method is separate from the constructor because we need to return a
  // DocumentFragment and we don't want to hold onto it with an instance field.
  _clone(options) {
    var _a10;
    const { el: { content }, parts } = this._$template;
    const fragment = ((_a10 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a10 !== void 0 ? _a10 : d2).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d2;
    return fragment;
  }
  _update(values) {
    let i = 0;
    for (const part of this._$parts) {
      if (part !== void 0) {
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "set part",
          part,
          value: values[i],
          valueIndex: i,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i);
          i += part.strings.length - 2;
        } else {
          part._$setValue(values[i]);
        }
      }
      i++;
    }
  }
};
var ChildPart = class _ChildPart {
  constructor(startNode, endNode, parent, options) {
    var _a10;
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (_a10 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a10 !== void 0 ? _a10 : true;
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._textSanitizer = void 0;
    }
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    var _a10, _b6;
    return (_b6 = (_a10 = this._$parent) === null || _a10 === void 0 ? void 0 : _a10._$isConnected) !== null && _b6 !== void 0 ? _b6 : this.__isConnected;
  }
  /**
   * The parent node into which the part renders its content.
   *
   * A ChildPart's content consists of a range of adjacent child nodes of
   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
   * `.endNode`).
   *
   * - If both `.startNode` and `.endNode` are non-null, then the part's content
   * consists of all siblings between `.startNode` and `.endNode`, exclusively.
   *
   * - If `.startNode` is non-null but `.endNode` is null, then the part's
   * content consists of all siblings following `.startNode`, up to and
   * including the last child of `.parentNode`. If `.endNode` is non-null, then
   * `.startNode` will always be non-null.
   *
   * - If both `.endNode` and `.startNode` are null, then the part's content
   * consists of all child nodes of `.parentNode`.
   */
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && (parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  /**
   * The part's leading marker node, if any. See `.parentNode` for more
   * information.
   */
  get startNode() {
    return this._$startNode;
  }
  /**
   * The part's trailing marker node, if any. See `.parentNode` for more
   * information.
   */
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    var _a10;
    if (DEV_MODE2 && this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      if (DEV_MODE2 && ((_a10 = this.options) === null || _a10 === void 0 ? void 0 : _a10.host) === value) {
        this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
        console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
        return;
      }
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
  }
  _commitNode(value) {
    var _a10;
    if (this._$committedValue !== value) {
      this._$clear();
      if (ENABLE_EXTRA_SECURITY_HOOKS && sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a10 = this._$startNode.parentNode) === null || _a10 === void 0 ? void 0 : _a10.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          if (DEV_MODE2) {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        const textNode = d2.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      } else {
        this._commitNode(d2.createTextNode(value));
        debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
          kind: "commit text",
          node: wrap(this._$startNode).nextSibling,
          value,
          options: this.options
        });
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a10;
    const { values, ["_$litType$"]: type } = result;
    const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);
    if (((_a10 = this._$committedValue) === null || _a10 === void 0 ? void 0 : _a10._$template) === template) {
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "template updating",
        template,
        instance: this._$committedValue,
        parts: this._$committedValue._$parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template, this);
      const fragment = instance._clone(this.options);
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "template instantiated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "template instantiated and updated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @internal */
  _$getTemplate(result) {
    let template = templateCache.get(result.strings);
    if (template === void 0) {
      templateCache.set(result.strings, template = new Template(result));
    }
    return template;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new _ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  /**
   * Removes the nodes contained within this Part from the DOM.
   *
   * @param start Start node to clear from, for clearing a subset of the part's
   *     DOM (used when truncating iterables)
   * @param from  When `start` is specified, the index within the iterable from
   *     which ChildParts are being removed, used for disconnecting directives in
   *     those Parts.
   *
   * @internal
   */
  _$clear(start = wrap(this._$startNode).nextSibling, from3) {
    var _a10;
    (_a10 = this._$notifyConnectionChanged) === null || _a10 === void 0 ? void 0 : _a10.call(this, false, true, from3);
    while (start && start !== this._$endNode) {
      const n = wrap(start).nextSibling;
      wrap(start).remove();
      start = n;
    }
  }
  /**
   * Implementation of RootPart's `isConnected`. Note that this metod
   * should only be called on `RootPart`s (the `ChildPart` returned from a
   * top-level `render()` call). It has no effect on non-root ChildParts.
   * @param isConnected Whether to set
   * @internal
   */
  setConnected(isConnected) {
    var _a10;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a10 = this._$notifyConnectionChanged) === null || _a10 === void 0 ? void 0 : _a10.call(this, isConnected);
    } else if (DEV_MODE2) {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
};
var AttributePart = class {
  constructor(element2, name, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element2;
    this.name = name;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /**
   * Sets the value of this part by resolving the value from possibly multiple
   * values and static strings and committing it to the DOM.
   * If this part is single-valued, `this._strings` will be undefined, and the
   * method will be called with a single value argument. If this part is
   * multi-value, `this._strings` will be defined, and the method is called
   * with the value array of the part's owning TemplateInstance, and an offset
   * into the value array from which the values should be read.
   * This method is overloaded this way to eliminate short-lived array slices
   * of the template instance values, and allow a fast-path for single-valued
   * parts.
   *
   * @param value The part value, or an array of values for multi-valued parts
   * @param valueIndex the index to start reading values from. `undefined` for
   *   single-valued parts
   * @param noCommit causes the part to not commit its value to the DOM. Used
   *   in hydration to prime attribute parts with their first-rendered value,
   *   but not set the attribute, and in SSR to no-op the DOM operation and
   *   capture the value for serialization.
   *
   * @internal
   */
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i, v2;
      for (i = 0; i < strings.length - 1; i++) {
        v2 = resolveDirective(this, values[valueIndex + i], directiveParent, i);
        if (v2 === noChange) {
          v2 = this._$committedValue[i];
        }
        change || (change = !isPrimitive(v2) || v2 !== this._$committedValue[i]);
        if (v2 === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i + 1];
        }
        this._$committedValue[i] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  /** @internal */
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
};
var PropertyPart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  /** @internal */
  _commitValue(value) {
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
};
var emptyStringForBooleanAttribute2 = trustedTypes2 ? trustedTypes2.emptyScript : "";
var BooleanAttributePart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  /** @internal */
  _commitValue(value) {
    debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    if (value && value !== nothing) {
      wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute2);
    } else {
      wrap(this.element).removeAttribute(this.name);
    }
  }
};
var EventPart = class extends AttributePart {
  constructor(element2, name, strings, parent, options) {
    super(element2, name, strings, parent, options);
    this.type = EVENT_PART;
    if (DEV_MODE2 && this.strings !== void 0) {
      throw new Error(`A \`<${element2.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  // EventPart does not use the base _$setValue/_resolveValue implementation
  // since the dirty checking is more complex
  /** @internal */
  _$setValue(newListener, directiveParent = this) {
    var _a10;
    newListener = (_a10 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a10 !== void 0 ? _a10 : nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a10, _b6;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b6 = (_a10 = this.options) === null || _a10 === void 0 ? void 0 : _a10.host) !== null && _b6 !== void 0 ? _b6 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
};
var ElementPart = class {
  constructor(element2, parent, options) {
    this.element = element2;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
};
var _$LH = {
  // Used in lit-ssr
  _boundAttributeSuffix: boundAttributeSuffix,
  _marker: marker,
  _markerMatch: markerMatch,
  _HTML_RESULT: HTML_RESULT,
  _getTemplateHtml: getTemplateHtml,
  // Used in tests and private-ssr-support
  _TemplateInstance: TemplateInstance,
  _isIterable: isIterable,
  _resolveDirective: resolveDirective,
  _ChildPart: ChildPart,
  _AttributePart: AttributePart,
  _BooleanAttributePart: BooleanAttributePart,
  _EventPart: EventPart,
  _PropertyPart: PropertyPart,
  _ElementPart: ElementPart
};
var polyfillSupport2 = DEV_MODE2 ? global4.litHtmlPolyfillSupportDevMode : global4.litHtmlPolyfillSupport;
polyfillSupport2 === null || polyfillSupport2 === void 0 ? void 0 : polyfillSupport2(Template, ChildPart);
((_d2 = global4.litHtmlVersions) !== null && _d2 !== void 0 ? _d2 : global4.litHtmlVersions = []).push("2.7.5");
if (DEV_MODE2 && global4.litHtmlVersions.length > 1) {
  issueWarning2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
var render = (value, container, options) => {
  var _a10, _b6;
  if (DEV_MODE2 && container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = DEV_MODE2 ? debugLogRenderId++ : 0;
  const partOwnerNode = (_a10 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a10 !== void 0 ? _a10 : container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = (_b6 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b6 !== void 0 ? _b6 : null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
  }
  part._$setValue(value);
  debugLogEvent2 === null || debugLogEvent2 === void 0 ? void 0 : debugLogEvent2({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
if (ENABLE_EXTRA_SECURITY_HOOKS) {
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  if (DEV_MODE2) {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}

// node_modules/lit-element/development/lit-element.js
var _a6;
var _b4;
var _c3;
var DEV_MODE3 = true;
var issueWarning3;
if (DEV_MODE3) {
  const issuedWarnings = (_a6 = globalThis.litIssuedWarnings) !== null && _a6 !== void 0 ? _a6 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning3 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
}
var LitElement = class extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  /**
   * @category rendering
   */
  createRenderRoot() {
    var _a10;
    var _b6;
    const renderRoot = super.createRenderRoot();
    (_a10 = (_b6 = this.renderOptions).renderBefore) !== null && _a10 !== void 0 ? _a10 : _b6.renderBefore = renderRoot.firstChild;
    return renderRoot;
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param changedProperties Map of changed properties with old values
   * @category updates
   */
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  /**
   * Invoked when the component is added to the document's DOM.
   *
   * In `connectedCallback()` you should setup tasks that should only occur when
   * the element is connected to the document. The most common of these is
   * adding event listeners to nodes external to the element, like a keydown
   * event handler added to the window.
   *
   * ```ts
   * connectedCallback() {
   *   super.connectedCallback();
   *   addEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * Typically, anything done in `connectedCallback()` should be undone when the
   * element is disconnected, in `disconnectedCallback()`.
   *
   * @category lifecycle
   */
  connectedCallback() {
    var _a10;
    super.connectedCallback();
    (_a10 = this.__childPart) === null || _a10 === void 0 ? void 0 : _a10.setConnected(true);
  }
  /**
   * Invoked when the component is removed from the document's DOM.
   *
   * This callback is the main signal to the element that it may no longer be
   * used. `disconnectedCallback()` should ensure that nothing is holding a
   * reference to the element (such as event listeners added to nodes external
   * to the element), so that it is free to be garbage collected.
   *
   * ```ts
   * disconnectedCallback() {
   *   super.disconnectedCallback();
   *   window.removeEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * An element may be re-connected after being disconnected.
   *
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a10;
    super.disconnectedCallback();
    (_a10 = this.__childPart) === null || _a10 === void 0 ? void 0 : _a10.setConnected(false);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `ChildPart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   * @category rendering
   */
  render() {
    return noChange;
  }
};
LitElement["finalized"] = true;
LitElement["_$litElement$"] = true;
(_b4 = globalThis.litElementHydrateSupport) === null || _b4 === void 0 ? void 0 : _b4.call(globalThis, { LitElement });
var polyfillSupport3 = DEV_MODE3 ? globalThis.litElementPolyfillSupportDevMode : globalThis.litElementPolyfillSupport;
polyfillSupport3 === null || polyfillSupport3 === void 0 ? void 0 : polyfillSupport3({ LitElement });
if (DEV_MODE3) {
  LitElement["finalize"] = function() {
    const finalized2 = ReactiveElement.finalize.call(this);
    if (!finalized2) {
      return false;
    }
    const warnRemovedOrRenamed = (obj, name, renamed = false) => {
      if (obj.hasOwnProperty(name)) {
        const ctorName = (typeof obj === "function" ? obj : obj.constructor).name;
        issueWarning3(renamed ? "renamed-api" : "removed-api", `\`${name}\` is implemented on class ${ctorName}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
      }
    };
    warnRemovedOrRenamed(this, "render");
    warnRemovedOrRenamed(this, "getStyles", true);
    warnRemovedOrRenamed(this.prototype, "adoptStyles");
    return true;
  };
}
((_c3 = globalThis.litElementVersions) !== null && _c3 !== void 0 ? _c3 : globalThis.litElementVersions = []).push("3.3.2");
if (DEV_MODE3 && globalThis.litElementVersions.length > 1) {
  issueWarning3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}

// node_modules/@blocksuite/global/dist/config/icons/database.js
var DatabaseSearchIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11 3.75C6.99594 3.75 3.75 6.99594 3.75 11C3.75 15.0041 6.99594 18.25 11 18.25C13.0026 18.25 14.8156 17.4381 16.1276 16.1254L16.1287 16.1243C17.4393 14.8125 18.25 13.0008 18.25 11C18.25 6.99594 15.0041 3.75 11 3.75ZM17.6965 16.6324C18.9779 15.1104 19.75 13.1453 19.75 11C19.75 6.16751 15.8325 2.25 11 2.25C6.16751 2.25 2.25 6.16751 2.25 11C2.25 15.8325 6.16751 19.75 11 19.75C13.1471 19.75 15.1136 18.9767 16.6361 17.6933L20.4694 21.5301C20.7622 21.8231 21.2371 21.8233 21.5301 21.5306C21.8231 21.2378 21.8233 20.7629 21.5306 20.4699L17.6965 16.6324Z"
  />
</svg>`;
var DatabasePen = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M14 6.20314L5.5 15L4 20L9 18.5L17.7969 10M14 6.20314L15.3595 4.79619C16.4211 3.73461 18.1422 3.7346 19.2038 4.79619C20.2654 5.85777 20.2654 7.57894 19.2038 8.64052L17.7969 10M14 6.20314L17.7969 10"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</svg>`;
var DatabaseDelete = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M4 6H20M16 6L15.7294 5.18807C15.4671 4.40125 15.3359 4.00784 15.0927 3.71698C14.8779 3.46013 14.6021 3.26132 14.2905 3.13878C13.9376 3 13.523 3 12.6936 3H11.3064C10.477 3 10.0624 3 9.70951 3.13878C9.39792 3.26132 9.12208 3.46013 8.90729 3.71698C8.66405 4.00784 8.53292 4.40125 8.27064 5.18807L8 6M18 6V16.2C18 17.8802 18 18.7202 17.673 19.362C17.3854 19.9265 16.9265 20.3854 16.362 20.673C15.7202 21 14.8802 21 13.2 21H10.8C9.11984 21 8.27976 21 7.63803 20.673C7.07354 20.3854 6.6146 19.9265 6.32698 19.362C6 18.7202 6 17.8802 6 16.2V6M14 10V17M10 10V17"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</svg>`;
var DatabaseDuplicate = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M11.25 9C11.25 9.41421 11.5858 9.75 12 9.75H13.1893L7.46967 15.4697C7.17678 15.7626 7.17678 16.2374 7.46967 16.5303C7.76256 16.8232 8.23744 16.8232 8.53033 16.5303L14.25 10.8107V12C14.25 12.4142 14.5858 12.75 15 12.75C15.4142 12.75 15.75 12.4142 15.75 12V9.1C15.75 9.08264 15.7495 9.0654 15.7485 9.04829C15.7618 8.84059 15.6891 8.62841 15.5303 8.46967C15.3716 8.31093 15.1594 8.23823 14.9517 8.25155C14.9346 8.25052 14.9174 8.25 14.9 8.25H12C11.5858 8.25 11.25 8.58579 11.25 9Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.8304 3.25H11.1696C10.6354 3.24999 10.1896 3.24998 9.82533 3.27974C9.44545 3.31078 9.08879 3.37789 8.75153 3.54973C8.23408 3.81338 7.81339 4.23408 7.54973 4.75153C7.37789 5.08879 7.31078 5.44545 7.27974 5.82533C7.24998 6.18956 7.24999 6.63541 7.25 7.16956L7.25 7.25L7.16957 7.25C6.63542 7.24999 6.18956 7.24998 5.82533 7.27974C5.44545 7.31078 5.08879 7.37789 4.75153 7.54973C4.23408 7.81339 3.81338 8.23408 3.54973 8.75153C3.37789 9.08879 3.31078 9.44545 3.27974 9.82533C3.24998 10.1896 3.24999 10.6354 3.25 11.1696V16.8304C3.24999 17.3646 3.24998 17.8104 3.27974 18.1747C3.31078 18.5546 3.37789 18.9112 3.54973 19.2485C3.81338 19.7659 4.23408 20.1866 4.75153 20.4503C5.08879 20.6221 5.44545 20.6892 5.82533 20.7203C6.18956 20.75 6.6354 20.75 7.16955 20.75H12.8305C13.3646 20.75 13.8104 20.75 14.1747 20.7203C14.5546 20.6892 14.9112 20.6221 15.2485 20.4503C15.7659 20.1866 16.1866 19.7659 16.4503 19.2485C16.6221 18.9112 16.6892 18.5546 16.7203 18.1747C16.75 17.8105 16.75 17.3646 16.75 16.8305V16.75H16.8305C17.3646 16.75 17.8105 16.75 18.1747 16.7203C18.5546 16.6892 18.9112 16.6221 19.2485 16.4503C19.7659 16.1866 20.1866 15.7659 20.4503 15.2485C20.6221 14.9112 20.6892 14.5546 20.7203 14.1747C20.75 13.8104 20.75 13.3646 20.75 12.8305V7.16955C20.75 6.6354 20.75 6.18956 20.7203 5.82533C20.6892 5.44545 20.6221 5.08879 20.4503 4.75153C20.1866 4.23408 19.7659 3.81338 19.2485 3.54973C18.9112 3.37789 18.5546 3.31078 18.1747 3.27974C17.8104 3.24998 17.3646 3.24999 16.8304 3.25ZM7.25 11V8.75H7.2C6.62757 8.75 6.24336 8.75058 5.94748 8.77476C5.66036 8.79822 5.52307 8.8401 5.43251 8.88624C5.19731 9.00608 5.00608 9.19731 4.88624 9.43251C4.8401 9.52307 4.79822 9.66036 4.77476 9.94748C4.75058 10.2434 4.75 10.6276 4.75 11.2V16.8C4.75 17.3724 4.75058 17.7566 4.77476 18.0525C4.79822 18.3396 4.8401 18.4769 4.88624 18.5675C5.00608 18.8027 5.19731 18.9939 5.43251 19.1138C5.52307 19.1599 5.66036 19.2018 5.94748 19.2252C6.24336 19.2494 6.62757 19.25 7.2 19.25H12.8C13.3724 19.25 13.7566 19.2494 14.0525 19.2252C14.3396 19.2018 14.4769 19.1599 14.5675 19.1138C14.8027 18.9939 14.9939 18.8027 15.1138 18.5675C15.1599 18.4769 15.2018 18.3396 15.2252 18.0525C15.2494 17.7566 15.25 17.3724 15.25 16.8V16.75H13C12.5858 16.75 12.25 16.4142 12.25 16C12.25 15.5858 12.5858 15.25 13 15.25H16.8C17.3724 15.25 17.7566 15.2494 18.0525 15.2252C18.3396 15.2018 18.4769 15.1599 18.5675 15.1138C18.8027 14.9939 18.9939 14.8027 19.1138 14.5675C19.1599 14.4769 19.2018 14.3396 19.2252 14.0525C19.2494 13.7566 19.25 13.3724 19.25 12.8V7.2C19.25 6.62757 19.2494 6.24336 19.2252 5.94748C19.2018 5.66036 19.1599 5.52307 19.1138 5.43251C18.9939 5.19731 18.8027 5.00608 18.5675 4.88624C18.4769 4.8401 18.3396 4.79822 18.0525 4.77476C17.7566 4.75058 17.3724 4.75 16.8 4.75H11.2C10.6276 4.75 10.2434 4.75058 9.94748 4.77476C9.66036 4.79822 9.52307 4.8401 9.43251 4.88624C9.19731 5.00608 9.00608 5.19731 8.88624 5.43251C8.8401 5.52307 8.79822 5.66036 8.77476 5.94748C8.75058 6.24336 8.75 6.62757 8.75 7.2V11C8.75 11.4142 8.41422 11.75 8 11.75C7.58579 11.75 7.25 11.4142 7.25 11Z"
  />
</svg>`;
var DatabaseInsertLeft = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12.25 6C12.25 4.48122 13.4812 3.25 15 3.25H18C19.5188 3.25 20.75 4.48122 20.75 6V18C20.75 19.5188 19.5188 20.75 18 20.75H15C13.4812 20.75 12.25 19.5188 12.25 18V6ZM15 4.75C14.3096 4.75 13.75 5.30964 13.75 6V18C13.75 18.6904 14.3096 19.25 15 19.25H18C18.6904 19.25 19.25 18.6904 19.25 18V6C19.25 5.30964 18.6904 4.75 18 4.75H15Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 12C3.25 11.5858 3.58579 11.25 4 11.25L10 11.25C10.4142 11.25 10.75 11.5858 10.75 12C10.75 12.4142 10.4142 12.75 10 12.75L4 12.75C3.58579 12.75 3.25 12.4142 3.25 12Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7 15.75C6.58579 15.75 6.25 15.4142 6.25 15L6.25 9C6.25 8.58579 6.58579 8.25 7 8.25C7.41421 8.25 7.75 8.58579 7.75 9L7.75 15C7.75 15.4142 7.41421 15.75 7 15.75Z"
  />
</svg>`;
var DatabaseInsertRight = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11.75 6C11.75 4.48122 10.5188 3.25 9 3.25H6C4.48122 3.25 3.25 4.48122 3.25 6V18C3.25 19.5188 4.48122 20.75 6 20.75H9C10.5188 20.75 11.75 19.5188 11.75 18V6ZM9 4.75C9.69036 4.75 10.25 5.30964 10.25 6V18C10.25 18.6904 9.69036 19.25 9 19.25H6C5.30964 19.25 4.75 18.6904 4.75 18V6C4.75 5.30964 5.30964 4.75 6 4.75H9Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.75 12C20.75 11.5858 20.4142 11.25 20 11.25L14 11.25C13.5858 11.25 13.25 11.5858 13.25 12C13.25 12.4142 13.5858 12.75 14 12.75L20 12.75C20.4142 12.75 20.75 12.4142 20.75 12Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M17 15.75C17.4142 15.75 17.75 15.4142 17.75 15V9C17.75 8.58579 17.4142 8.25 17 8.25C16.5858 8.25 16.25 8.58579 16.25 9V15C16.25 15.4142 16.5858 15.75 17 15.75Z"
  />
</svg>`;
var DatabaseMoveLeft = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M4 4V20M8 12H20M8 12L12 8M8 12L12 16"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</svg>`;
var DatabaseMoveRight = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M20 4V20M4 12H16M16 12L12 8M16 12L12 16"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</svg>`;
var DatabaseMultiSelect = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M4 5L6.42929 7.42929C6.46834 7.46834 6.53166 7.46834 6.57071 7.42929L9 5"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M4 11L6.42929 13.4293C6.46834 13.4683 6.53166 13.4683 6.57071 13.4293L9 11"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M4 17L6.42929 19.4293C6.46834 19.4683 6.53166 19.4683 6.57071 19.4293L9 17"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M12 6L20 6"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M12 12L20 12"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M12 18L20 18"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
</svg>`;
var DatabaseNumber = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M18.5 4L12.5 20"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M12 4L6 20"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M20 8.5H5.5"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
  <path
    d="M19 15L4 15"
    stroke="currentColor"
    stroke-width="1.5"
    stroke-linecap="round"
  />
</svg>`;
var DatabaseSelect = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 3.75C7.44365 3.75 3.75 7.44365 3.75 12C3.75 16.5563 7.44365 20.25 12 20.25C16.5563 20.25 20.25 16.5563 20.25 12C20.25 7.44365 16.5563 3.75 12 3.75ZM2.25 12C2.25 6.61522 6.61522 2.25 12 2.25C17.3848 2.25 21.75 6.61522 21.75 12C21.75 17.3848 17.3848 21.75 12 21.75C6.61522 21.75 2.25 17.3848 2.25 12Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.46967 10.4697C7.76256 10.1768 8.23744 10.1768 8.53033 10.4697L12 13.9393L15.4697 10.4697C15.7626 10.1768 16.2374 10.1768 16.5303 10.4697C16.8232 10.7626 16.8232 11.2374 16.5303 11.5303L12.601 15.4596C12.2691 15.7916 11.7309 15.7916 11.399 15.4596L7.46967 11.5303C7.17678 11.2374 7.17678 10.7626 7.46967 10.4697Z"
  />
</svg>`;
var DatabaseProgress = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M15 4.25C15.4142 4.25 15.75 4.58579 15.75 5V6.25H18C20.0711 6.25 21.75 7.92893 21.75 10V14C21.75 16.0711 20.0711 17.75 18 17.75H15.75V19C15.75 19.4142 15.4142 19.75 15 19.75C14.5858 19.75 14.25 19.4142 14.25 19V17.75H6C3.92893 17.75 2.25 16.0711 2.25 14V10C2.25 7.92893 3.92893 6.25 6 6.25H14.25V5C14.25 4.58579 14.5858 4.25 15 4.25ZM14.25 7.75H6C4.75736 7.75 3.75 8.75736 3.75 10V14C3.75 15.2426 4.75736 16.25 6 16.25H14.25V7.75ZM15.75 16.25H18C19.2426 16.25 20.25 15.2426 20.25 14V10C20.25 8.75736 19.2426 7.75 18 7.75H15.75V16.25ZM6 9.25C6.41421 9.25 6.75 9.58579 6.75 10V14C6.75 14.4142 6.41421 14.75 6 14.75C5.58579 14.75 5.25 14.4142 5.25 14L5.25 10C5.25 9.58579 5.58579 9.25 6 9.25ZM9 9.25C9.41421 9.25 9.75 9.58579 9.75 10L9.75 14C9.75 14.4142 9.41421 14.75 9 14.75C8.58579 14.75 8.25 14.4142 8.25 14L8.25 10C8.25 9.58579 8.58579 9.25 9 9.25ZM12 9.25C12.4142 9.25 12.75 9.58579 12.75 10V14C12.75 14.4142 12.4142 14.75 12 14.75C11.5858 14.75 11.25 14.4142 11.25 14V10C11.25 9.58579 11.5858 9.25 12 9.25Z"
  />
</svg>`;
var DatabaseSearchClose = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  xmlns="http://www.w3.org/2000/svg"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.22872 4.22878C4.42398 4.03352 4.74057 4.03352 4.93583 4.22878L7.99996 7.29291L11.0641 4.22878C11.2593 4.03352 11.5759 4.03352 11.7712 4.22878C11.9665 4.42405 11.9665 4.74063 11.7712 4.93589L8.70707 8.00002L11.7712 11.0641C11.9665 11.2594 11.9665 11.576 11.7712 11.7713C11.5759 11.9665 11.2593 11.9665 11.0641 11.7713L7.99996 8.70713L4.93583 11.7713C4.74057 11.9665 4.42398 11.9665 4.22872 11.7713C4.03346 11.576 4.03346 11.2594 4.22872 11.0641L7.29285 8.00002L4.22872 4.93589C4.03346 4.74063 4.03346 4.42405 4.22872 4.22878Z"
  />
</svg>`;
var DatabaseDone = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.5322 5.97152C20.824 6.26543 20.8224 6.7403 20.5285 7.03217L9.45156 18.0322C9.15909 18.3226 8.68706 18.3226 8.3946 18.0322L3.47152 13.1433C3.17761 12.8514 3.17595 12.3765 3.46783 12.0826C3.7597 11.7887 4.23457 11.7871 4.52848 12.0789L8.92308 16.443L19.4715 5.96783C19.7654 5.67595 20.2403 5.67761 20.5322 5.97152Z"
  />
</svg>`;
var addColumnStyle = `
  width: 12px;
  height: 12px;
  fill: var(--affine-text-primary-color);
`;
var DatabaseAddColumn = html`<svg
  viewBox="0 0 16 16"
  style=${addColumnStyle}
>
  <path
    d="M7.977 14.963c.407 0 .747-.324.747-.723V8.72h5.362c.399 0 .74-.34.74-.747a.746.746 0 00-.74-.738H8.724V1.706c0-.398-.34-.722-.747-.722a.732.732 0 00-.739.722v5.529h-5.37a.746.746 0 00-.74.738c0 .407.341.747.74.747h5.37v5.52c0 .399.332.723.739.723z"
  ></path>
</svg>`;
var DatabaseDragIcon = html`<svg
  width="10"
  height="14"
  viewBox="0 0 10 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <rect width="10" height="14" rx="2" />
  <rect width="10" height="14" rx="2" fill-opacity="0.08" />
  <g clip-path="url(#clip0_179_9218)">
    <circle cx="3" cy="3" r="1" fill="var(--affine-icon-color)" />
    <circle cx="3" cy="6.79163" r="1" fill="var(--affine-icon-color)" />
    <circle cx="3" cy="10.5833" r="1" fill="var(--affine-icon-color)" />
    <circle cx="7" cy="3" r="1" fill="var(--affine-icon-color)" />
    <circle cx="7" cy="6.79163" r="1" fill="var(--affine-icon-color)" />
    <circle cx="7" cy="10.5833" r="1" fill="var(--affine-icon-color)" />
  </g>
  <defs>
    <clipPath id="clip0_179_9218">
      <rect width="6" height="10" transform="translate(2 2)" />
    </clipPath>
  </defs>
</svg>`;

// node_modules/@blocksuite/global/dist/config/icons/edgeless.js
var SelectIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M10.3383 3.88231L18.071 8.69778C19.0571 9.31182 19.8404 9.79964 20.4017 10.2216C20.9493 10.6333 21.4318 11.0842 21.62 11.6695C21.8868 12.4988 21.7381 13.4034 21.2188 14.1027C20.852 14.5967 20.2493 14.8668 19.599 15.0782C18.9323 15.2949 18.0344 15.5017 16.9044 15.7619L14.4307 16.3314C14.0188 16.4263 13.91 16.4546 13.8157 16.4966C13.7187 16.5398 13.6281 16.5952 13.546 16.6612C13.4669 16.7248 13.3935 16.807 13.1235 17.1285L11.9305 18.5487C11.162 19.4637 10.552 20.1898 10.0419 20.6983C9.54488 21.1937 9.0177 21.6165 8.39807 21.7155C7.52714 21.8546 6.63964 21.5686 6.0146 20.9464C5.56965 20.5035 5.39026 19.852 5.27806 19.16C5.1629 18.4498 5.09457 17.5048 5.00849 16.3143L4.36527 7.41939C4.2957 6.4575 4.23967 5.68281 4.25165 5.08075C4.26359 4.48099 4.34126 3.90703 4.65756 3.44031C5.11363 2.76734 5.84836 2.33594 6.65832 2.25865C7.21739 2.2053 7.76104 2.406 8.30191 2.67862C8.84485 2.95229 9.51023 3.36666 10.3383 3.88231ZM7.62675 4.01809C7.14246 3.77397 6.9194 3.74055 6.80081 3.75187C6.43097 3.78716 6.10155 3.98334 5.89928 4.28182C5.83742 4.37309 5.762 4.57571 5.75136 5.11059C5.74092 5.635 5.79114 6.34017 5.8642 7.35039L6.50172 16.1665C6.59131 17.4054 6.65553 18.2835 6.75873 18.92C6.86617 19.5826 6.99326 19.8041 7.07279 19.8833C7.35743 20.1666 7.76348 20.2978 8.16142 20.2342C8.27334 20.2164 8.507 20.1103 8.98299 19.6359C9.44028 19.1801 10.0077 18.5057 10.8074 17.5536L11.975 16.1637C11.9876 16.1487 12 16.1338 12.0123 16.1192C12.2275 15.8628 12.3982 15.6594 12.606 15.4923C12.7891 15.345 12.9907 15.222 13.2055 15.1264C13.4489 15.018 13.7084 14.9583 14.0374 14.8828C14.0561 14.8785 14.075 14.8741 14.0941 14.8697L16.5295 14.3089C17.7063 14.038 18.5392 13.8455 19.1353 13.6517C19.7553 13.4501 19.9497 13.2958 20.0146 13.2084C20.2446 12.8987 20.3109 12.4982 20.1921 12.1288C20.1582 12.0234 20.0225 11.8131 19.5003 11.4206C18.9982 11.0431 18.2715 10.5897 17.2448 9.95034L9.57801 5.17595C8.70973 4.63525 8.10185 4.25756 7.62675 4.01809Z"
  />
</svg>`;
var ShapeIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 3.25C12.2691 3.25 12.5177 3.39421 12.6512 3.6279L16.2067 9.85012C16.3394 10.0822 16.3384 10.3674 16.2042 10.5987C16.07 10.8299 15.8229 10.9722 15.5556 10.9722H8.44444C8.17709 10.9722 7.92995 10.8299 7.79576 10.5987C7.66157 10.3674 7.66062 10.0822 7.79326 9.85012L11.3488 3.6279C11.4823 3.39421 11.7309 3.25 12 3.25ZM9.73683 9.47222H14.2632L12 5.51167L9.73683 9.47222ZM7.11111 14.5278C5.80711 14.5278 4.75 15.5849 4.75 16.8889C4.75 18.1929 5.80711 19.25 7.11111 19.25C8.41512 19.25 9.47222 18.1929 9.47222 16.8889C9.47222 15.5849 8.41512 14.5278 7.11111 14.5278ZM3.25 16.8889C3.25 14.7565 4.97868 13.0278 7.11111 13.0278C9.24354 13.0278 10.9722 14.7565 10.9722 16.8889C10.9722 19.0213 9.24354 20.75 7.11111 20.75C4.97868 20.75 3.25 19.0213 3.25 16.8889ZM13.0278 13.7778C13.0278 13.3636 13.3636 13.0278 13.7778 13.0278H20C20.4142 13.0278 20.75 13.3636 20.75 13.7778V20C20.75 20.4142 20.4142 20.75 20 20.75H13.7778C13.3636 20.75 13.0278 20.4142 13.0278 20V13.7778ZM14.5278 14.5278V19.25H19.25V14.5278H14.5278Z"
  />
</svg>`;
var ImageSVG = svg`<path
fill-rule="evenodd"
clip-rule="evenodd"
d="M15 6.25C13.4812 6.25 12.25 7.48122 12.25 9C12.25 10.5188 13.4812 11.75 15 11.75C16.5188 11.75 17.75 10.5188 17.75 9C17.75 7.48122 16.5188 6.25 15 6.25ZM13.75 9C13.75 8.30964 14.3096 7.75 15 7.75C15.6904 7.75 16.25 8.30964 16.25 9C16.25 9.69036 15.6904 10.25 15 10.25C14.3096 10.25 13.75 9.69036 13.75 9Z"
/>
<path
fill-rule="evenodd"
clip-rule="evenodd"
d="M5 4.25C3.48122 4.25 2.25 5.48122 2.25 7V17C2.25 18.5188 3.48122 19.75 5 19.75H16.9863C16.9956 19.7502 17.0049 19.7502 17.0142 19.75H19C20.5188 19.75 21.75 18.5188 21.75 17V7C21.75 5.48122 20.5188 4.25 19 4.25H5ZM17.3356 18.25H19C19.4585 18.25 19.8593 18.0031 20.0769 17.6351L18.6231 16.1718C18.2208 15.7541 17.9502 15.4738 17.7245 15.275C17.5054 15.0819 17.3784 15.0117 17.2815 14.9786C17.0293 14.8926 16.7562 14.8895 16.5021 14.9697C16.4045 15.0005 16.276 15.0678 16.0524 15.2558C15.8542 15.4224 15.6213 15.6486 15.2976 15.9689L17.3356 18.25ZM20.25 15.681V7C20.25 6.30964 19.6904 5.75 19 5.75H5C4.30964 5.75 3.75 6.30964 3.75 7V17C3.75 17.1543 3.77795 17.302 3.82907 17.4385L7.50733 13.8054L7.52247 13.7897C7.89807 13.4008 8.21139 13.0763 8.48886 12.8325C8.7781 12.5783 9.07737 12.3666 9.43913 12.2436C9.99371 12.0551 10.594 12.0486 11.1525 12.2251C11.5168 12.3402 11.8206 12.5454 12.1153 12.7932C12.398 13.031 12.7182 13.3486 13.1022 13.7293L14.2639 14.8814C14.5765 14.5722 14.8455 14.3108 15.087 14.1077C15.382 13.8597 15.6861 13.6542 16.0508 13.5392C16.6099 13.3628 17.2107 13.3697 17.7656 13.5589C18.1276 13.6823 18.4269 13.8947 18.7161 14.1495C18.9936 14.3939 19.3068 14.7192 19.6824 15.1091L19.6996 15.127L20.25 15.681ZM5.142 18.25H15.3241L13.7197 16.4542L12.0677 14.816C11.6564 14.4081 11.3797 14.1346 11.1498 13.9412C10.9266 13.7535 10.7982 13.6862 10.7006 13.6554C10.4468 13.5752 10.1739 13.5781 9.92184 13.6638C9.825 13.6967 9.6981 13.7667 9.47895 13.9593C9.25327 14.1576 8.98257 14.4371 8.58019 14.8537L8.56773 14.8663L5.142 18.25Z"
/>`;
var ImageIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  ${ImageSVG}
</svg>`;
var ImageIcon20 = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  ${ImageSVG}
</svg>`;
var EmbedIcon = html`
  <svg
    width="20"
    height="20"
    viewBox="0 0 20 20"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3334_82005)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M5.144 3.54166H14.856C15.3035 3.54166 15.6722 3.54165 15.9726 3.56312C16.2832 3.58533 16.5712 3.63292 16.8445 3.75478C17.2675 3.94339 17.6272 4.25139 17.8584 4.64842C18.0131 4.91401 18.0726 5.19494 18.0996 5.48406C18.125 5.75652 18.125 6.08757 18.125 6.47237V13.5276C18.125 13.9124 18.125 14.2435 18.0996 14.5159C18.0726 14.8051 18.0131 15.086 17.8584 15.3516C17.6272 15.7486 17.2675 16.0566 16.8445 16.2452C16.5712 16.3671 16.2832 16.4147 15.9726 16.4369C15.6722 16.4583 15.3034 16.4583 14.856 16.4583H5.144C4.69656 16.4583 4.32777 16.4583 4.02744 16.4369C3.71685 16.4147 3.42883 16.3671 3.15552 16.2452C2.73246 16.0566 2.37275 15.7486 2.14156 15.3516C1.9869 15.086 1.92741 14.8051 1.90042 14.5159C1.87497 14.2435 1.87499 13.9124 1.875 13.5276V6.4724C1.87499 6.08759 1.87497 5.75652 1.90042 5.48406C1.92741 5.19494 1.9869 4.91401 2.14156 4.64842C2.37275 4.25139 2.73247 3.94339 3.15552 3.75478C3.42883 3.63292 3.71685 3.58533 4.02744 3.56312C4.32777 3.54165 4.69655 3.54166 5.144 3.54166ZM3.125 8.4375V13.5C3.125 13.9201 3.12563 14.1923 3.145 14.3997C3.16342 14.597 3.19476 14.6762 3.22176 14.7226C3.31014 14.8743 3.46036 15.0125 3.66452 15.1035C3.74772 15.1406 3.87132 15.1725 4.11657 15.1901C4.36702 15.208 4.69092 15.2083 5.16667 15.2083H14.8333C15.3091 15.2083 15.633 15.208 15.8834 15.1901C16.1287 15.1725 16.2523 15.1406 16.3355 15.1035C16.5396 15.0125 16.6899 14.8743 16.7782 14.7226C16.8052 14.6762 16.8366 14.597 16.855 14.3997C16.8744 14.1923 16.875 13.9201 16.875 13.5V8.4375H3.125ZM16.875 7.1875H3.125V6.5C3.125 6.07986 3.12563 5.80768 3.145 5.60027C3.16342 5.40303 3.19476 5.3238 3.22176 5.27744C3.31014 5.12566 3.46036 4.98747 3.66452 4.89645C3.74772 4.85935 3.87132 4.82748 4.11657 4.80994C4.36702 4.79204 4.69092 4.79166 5.16667 4.79166H14.8333C15.3091 4.79166 15.633 4.79204 15.8834 4.80994C16.1287 4.82748 16.2523 4.85935 16.3355 4.89645C16.5396 4.98747 16.6899 5.12566 16.7782 5.27744C16.8052 5.3238 16.8366 5.40303 16.855 5.60027C16.8744 5.80768 16.875 6.07986 16.875 6.5V7.1875Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M8.86926 9.56896C9.10731 9.81892 9.09766 10.2145 8.8477 10.4526L7.57292 11.6667L8.8477 12.8807C9.09766 13.1188 9.10731 13.5144 8.86926 13.7644C8.6312 14.0143 8.23559 14.024 7.98563 13.7859L6.23563 12.1193C6.11177 12.0013 6.04167 11.8377 6.04167 11.6667C6.04167 11.4956 6.11177 11.332 6.23563 11.2141L7.98563 9.54741C8.23559 9.30936 8.6312 9.31901 8.86926 9.56896ZM11.1307 9.56896C11.3688 9.31901 11.7644 9.30936 12.0144 9.54741L13.7644 11.2141C13.8882 11.332 13.9583 11.4956 13.9583 11.6667C13.9583 11.8377 13.8882 12.0013 13.7644 12.1193L12.0144 13.7859C11.7644 14.024 11.3688 14.0143 11.1307 13.7644C10.8927 13.5144 10.9023 13.1188 11.1523 12.8807L12.4271 11.6667L11.1523 10.4526C10.9023 10.2145 10.8927 9.81892 11.1307 9.56896Z"
        fill="currentColor"
      />
      <path
        d="M5.08333 6.04166C5.08333 6.38684 4.80351 6.66666 4.45833 6.66666C4.11316 6.66666 3.83333 6.38684 3.83333 6.04166C3.83333 5.69649 4.11316 5.41666 4.45833 5.41666C4.80351 5.41666 5.08333 5.69649 5.08333 6.04166Z"
        fill="currentColor"
      />
      <path
        d="M6.75008 6.04166C6.75008 6.38684 6.47026 6.66666 6.12508 6.66666C5.77991 6.66666 5.50008 6.38684 5.50008 6.04166C5.50008 5.69649 5.77991 5.41666 6.12508 5.41666C6.47026 5.41666 6.75008 5.69649 6.75008 6.04166Z"
        fill="currentColor"
      />
      <path
        d="M8.41675 6.04166C8.41675 6.38684 8.13693 6.66666 7.79175 6.66666C7.44657 6.66666 7.16675 6.38684 7.16675 6.04166C7.16675 5.69649 7.44657 5.41666 7.79175 5.41666C8.13693 5.41666 8.41675 5.69649 8.41675 6.04166Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3334_82005">
        <rect width="20" height="20" fill="white" />
      </clipPath>
    </defs>
  </svg>
`;
var BookmarkIcon = html`
  <svg
    width="20"
    height="20"
    viewBox="0 0 20 20"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3433_78963)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        fill="currentColor"
        d="M4.16667 4.79167C3.59137 4.79167 3.125 5.25804 3.125 5.83334V14.1667C3.125 14.742 3.59137 15.2083 4.16667 15.2083H15.8333C16.4086 15.2083 16.875 14.742 16.875 14.1667V10C16.875 9.65483 17.1548 9.375 17.5 9.375C17.8452 9.375 18.125 9.65483 18.125 10V14.1667C18.125 15.4323 17.099 16.4583 15.8333 16.4583H4.16667C2.90101 16.4583 1.875 15.4323 1.875 14.1667V5.83334C1.875 4.56768 2.90101 3.54167 4.16667 3.54167H10C10.3452 3.54167 10.625 3.82149 10.625 4.16667C10.625 4.51185 10.3452 4.79167 10 4.79167H4.16667Z"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        fill="currentColor"
        d="M13.6063 3.48363C14.64 2.44991 16.316 2.44991 17.3497 3.48363C18.3834 4.51735 18.3834 6.19334 17.3497 7.22706L16.2774 8.29939C16.0333 8.54347 15.6376 8.54347 15.3935 8.29939C15.3371 8.24297 15.2937 8.17845 15.2634 8.10958C15.2915 8.82166 15.0338 9.54296 14.4902 10.0866L13.0604 11.5164C12.0267 12.5501 10.3507 12.5501 9.31696 11.5164C8.28324 10.4827 8.28324 8.80667 9.31696 7.77295L10.3893 6.70062C10.6334 6.45654 11.0291 6.45654 11.2732 6.70062C11.3296 6.75703 11.373 6.82155 11.4033 6.89043C11.3751 6.17834 11.6329 5.45705 12.1765 4.9134L13.6063 3.48363ZM11.4445 7.26331C11.4215 7.38099 11.3643 7.49333 11.2732 7.5845L10.2008 8.65683C9.65528 9.2024 9.65528 10.0869 10.2008 10.6325C10.7464 11.1781 11.6309 11.1781 12.1765 10.6325L13.6063 9.20272C14.1518 8.65716 14.1518 7.77262 13.6063 7.22706C13.5203 7.1411 13.4267 7.06921 13.3279 7.01087C13.0307 6.83533 12.932 6.45209 13.1076 6.15488C13.2831 5.85767 13.6664 5.75903 13.9636 5.93457C14.1521 6.04591 14.3293 6.18228 14.4902 6.34317C14.8849 6.73788 15.1289 7.22622 15.2221 7.7367C15.2452 7.61901 15.3023 7.50668 15.3935 7.4155L16.4658 6.34317C17.0114 5.79761 17.0114 4.91307 16.4658 4.36751C15.9203 3.82194 15.0357 3.82194 14.4902 4.36751L13.0604 5.79728C12.5148 6.34285 12.5148 7.22738 13.0604 7.77295C13.1463 7.8589 13.24 7.9308 13.3388 7.98914C13.636 8.16467 13.7346 8.54791 13.5591 8.84512C13.3835 9.14234 13.0003 9.24097 12.7031 9.06544C12.5146 8.9541 12.3374 8.81773 12.1765 8.65683C11.7818 8.26213 11.5378 7.77378 11.4445 7.26331Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_3433_78963">
        <rect width="20" height="20" fill="white" />
      </clipPath>
    </defs>
  </svg>
`;
var ConnectorIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M17.5 4.75C16.5335 4.75 15.75 5.5335 15.75 6.5C15.75 7.4665 16.5335 8.25 17.5 8.25C18.4665 8.25 19.25 7.4665 19.25 6.5C19.25 5.5335 18.4665 4.75 17.5 4.75ZM14.25 6.5C14.25 4.70507 15.7051 3.25 17.5 3.25C19.2949 3.25 20.75 4.70507 20.75 6.5C20.75 8.29493 19.2949 9.75 17.5 9.75C16.8901 9.75 16.3194 9.58197 15.8317 9.28968L9.28968 15.8317C9.58197 16.3194 9.75 16.8901 9.75 17.5C9.75 19.2949 8.29493 20.75 6.5 20.75C4.70507 20.75 3.25 19.2949 3.25 17.5C3.25 15.7051 4.70507 14.25 6.5 14.25C7.1415 14.25 7.73958 14.4359 8.24335 14.7567L14.7567 8.24335C14.4359 7.73958 14.25 7.1415 14.25 6.5ZM6.5 15.75C5.5335 15.75 4.75 16.5335 4.75 17.5C4.75 18.4665 5.5335 19.25 6.5 19.25C7.4665 19.25 8.25 18.4665 8.25 17.5C8.25 16.5335 7.4665 15.75 6.5 15.75Z"
  />
</svg>`;
var PenIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M15.894 5.32233L15.0516 6.19412L17.8059 8.94836L18.6776 8.106C19.4422 7.33698 19.4408 6.09381 18.6735 5.32652C17.9062 4.55923 16.663 4.55783 15.894 5.32233ZM16.727 9.99082L14.0092 7.27298L6.16599 15.3901L5.11859 18.8814L8.60991 17.834L16.727 9.99082ZM14.8291 4.26586C16.1836 2.91138 18.3797 2.91138 19.7341 4.26586C21.0886 5.62033 21.0886 7.81637 19.7341 9.17085L19.725 9.17995L9.52114 19.0394C9.43501 19.1226 9.33021 19.184 9.2155 19.2184L4.2155 20.7184C3.95122 20.7977 3.66476 20.7254 3.46966 20.5303C3.27456 20.3352 3.20234 20.0488 3.28162 19.7845L4.78162 14.7845C4.81603 14.6698 4.87742 14.565 4.96064 14.4788L14.8291 4.26586Z"
  />
</svg>`;
var HandIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M14.8114 20.999C13.2447 20.9679 11.7002 20.6209 10.2699 19.9787L4.67482 17.3458C4.12742 17.0853 3.70531 16.6178 3.501 16.0458C3.29668 15.4737 3.32684 14.8437 3.58486 14.2938C3.84271 13.7454 4.30714 13.3222 4.87604 13.1172C5.44494 12.9122 6.07173 12.9422 6.61858 13.2006L7.66312 13.6926C7.17264 12.0254 6.19168 9.26496 4.72024 7.65243L3.81194 6.9145C3.37099 6.55513 3.08591 6.03846 3.01648 5.47286C2.94705 4.90727 3.09867 4.33669 3.43953 3.88077C3.78344 3.42341 4.29072 3.11757 4.85476 3.02753C5.4188 2.93748 5.99569 3.07025 6.46417 3.39792C7.56208 4.18419 8.52532 5.14417 9.31623 6.24033C9.58326 5.83988 9.97184 5.53639 10.4244 5.37486C10.7041 5.27066 11.002 5.22422 11.3001 5.23831C11.5982 5.2524 11.8904 5.32672 12.1592 5.45685C12.4015 5.57016 12.6227 5.72422 12.8132 5.91236C13.058 5.63326 13.371 5.42289 13.7215 5.30197C13.9828 5.20656 14.2604 5.16466 14.5381 5.17874C14.8158 5.19282 15.0879 5.2626 15.3383 5.38396C15.6253 5.51414 15.8775 5.71086 16.074 5.95792C16.1756 5.89185 16.2856 5.83976 16.401 5.80304C16.7997 5.65961 17.2388 5.68073 17.622 5.86179C18.0052 6.04285 18.301 6.36905 18.4446 6.76873L20.6155 12.818C21.1282 14.2647 21.1282 15.8444 20.6155 17.2911C20.3444 18.0579 19.9061 18.7544 19.3326 19.3296C18.759 19.9049 18.0647 20.3445 17.3002 20.6164C16.4979 20.8833 15.6566 21.0127 14.8114 20.999ZM5.75747 14.4032C5.62583 14.3751 5.4278 14.3671 5.32879 14.4032C5.21385 14.4428 5.108 14.5051 5.01751 14.5865C4.92702 14.6678 4.85373 14.7666 4.80198 14.8769C4.74874 14.9866 4.71803 15.106 4.71166 15.2278C4.7053 15.3497 4.72341 15.4716 4.76492 15.5863C4.80643 15.7011 4.8705 15.8062 4.95332 15.8957C5.03614 15.9851 5.13602 16.0569 5.24704 16.1068L10.8058 18.7943C10.8058 18.7943 14.0939 20.3249 16.8006 19.3501C17.3787 19.1551 17.9049 18.8307 18.3392 18.4013C18.7736 17.9719 19.1048 17.449 19.3075 16.8721C19.7157 15.7262 19.7157 14.474 19.3075 13.3282L17.1276 7.27891C17.1185 7.2489 17.1033 7.22112 17.083 7.19728C17.0626 7.17344 17.0376 7.15407 17.0095 7.14038C16.9813 7.1267 16.9507 7.119 16.9194 7.11775C16.8882 7.11651 16.857 7.12174 16.8279 7.13314C16.7706 7.1556 16.7243 7.19958 16.6989 7.25572C16.6734 7.31186 16.6708 7.37574 16.6916 7.43378L17.0004 8.34481C17.0366 8.43122 17.0546 8.52416 17.0534 8.61785C17.0522 8.71153 17.0318 8.80397 16.9934 8.88941C16.9551 8.97485 16.8997 9.05147 16.8305 9.11451C16.7614 9.17755 16.6801 9.22565 16.5917 9.25584C16.5056 9.29207 16.4129 9.31014 16.3195 9.30893C16.2261 9.30772 16.1339 9.28726 16.0487 9.24881C15.9636 9.21036 15.8872 9.15474 15.8243 9.08543C15.7615 9.01611 15.7135 8.93458 15.6834 8.84588L15.0839 7.16959C15.0101 6.98388 14.8712 6.8316 14.6934 6.7414C14.6028 6.70307 14.5055 6.68331 14.4072 6.68331C14.309 6.68331 14.2117 6.70307 14.1211 6.7414C13.9396 6.80212 13.7882 6.93063 13.6986 7.10026C13.609 7.2699 13.5879 7.46763 13.6397 7.65243L13.8941 8.60902C13.9389 8.7793 13.9156 8.96042 13.829 9.11365C13.7424 9.26688 13.5995 9.38005 13.4308 9.42894C13.2645 9.4814 13.0845 9.46702 12.9285 9.38884C12.7726 9.31065 12.6531 9.17476 12.5952 9.00986L11.9957 7.35179C11.9119 7.12856 11.7441 6.94721 11.5284 6.84671C11.3127 6.7462 11.0663 6.73457 10.8422 6.81429C10.6196 6.89838 10.4388 7.06666 10.3386 7.283C10.2384 7.49933 10.2268 7.74646 10.3063 7.97129L10.7423 9.19208C10.7784 9.27848 10.7964 9.37141 10.7952 9.4651C10.794 9.55878 10.7736 9.65122 10.7352 9.73666C10.6969 9.8221 10.6415 9.89872 10.5724 9.96176C10.5033 10.0248 10.422 10.0729 10.3335 10.1031C10.2474 10.1393 10.1547 10.1574 10.0613 10.1562C9.96791 10.155 9.87575 10.1345 9.79056 10.0961C9.70538 10.0576 9.62899 10.002 9.56614 9.93269C9.50329 9.86338 9.45533 9.78183 9.42523 9.69313C8.68278 7.68202 7.3454 5.94647 5.5922 4.71891C5.41716 4.59322 5.19975 4.54185 4.98718 4.57597C4.7746 4.61008 4.58403 4.72692 4.45683 4.90112C4.32552 5.07405 4.33703 5.23645 4.36245 5.45231C4.38787 5.66818 4.49591 5.8657 4.66377 6.00319L5.57207 6.76845L5.63565 6.83222C8.11531 9.50154 9.26884 14.7126 9.31426 14.9313C9.34154 15.0568 9.33301 15.1875 9.28963 15.3083C9.24625 15.4292 9.1698 15.5353 9.06902 15.6146C8.96956 15.6916 8.85101 15.74 8.72616 15.7544C8.60131 15.7689 8.47489 15.7489 8.36055 15.6966L6.77594 14.8769C6.38102 14.6614 6.29788 14.5865 5.75747 14.4032Z"
  />
</svg>`;
var SquareIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <rect x="4" y="4" width="16" height="16" stroke-width="1.5" />
</svg>`;
var EllipseIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <circle cx="12" cy="12" r="9" stroke-width="1.5" />
</svg>`;
var DiamondIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path d="M3 12L12 3L21 12L12 21L3 12Z" stroke-width="1.5" />
</svg>`;
var TriangleIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path d="M12 4L20.6603 19H3.33975L12 4Z" stroke-width="1.5" />
</svg>`;
var RoundedRectangleIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <rect x="3" y="5" width="18" height="14" rx="2" stroke-width="1.5" />
</svg>`;
var CollapseDownIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 3.25C12.4142 3.25 12.75 3.58579 12.75 4V14.1893L15.4697 11.4697C15.7626 11.1768 16.2374 11.1768 16.5303 11.4697C16.8232 11.7626 16.8232 12.2374 16.5303 12.5303L12.5303 16.5303C12.2374 16.8232 11.7626 16.8232 11.4697 16.5303L7.46967 12.5303C7.17678 12.2374 7.17678 11.7626 7.46967 11.4697C7.76256 11.1768 8.23744 11.1768 8.53033 11.4697L11.25 14.1893V4C11.25 3.58579 11.5858 3.25 12 3.25ZM3.25 20C3.25 19.5858 3.58579 19.25 4 19.25H20C20.4142 19.25 20.75 19.5858 20.75 20C20.75 20.4142 20.4142 20.75 20 20.75H4C3.58579 20.75 3.25 20.4142 3.25 20Z"
  />
</svg>`;
var MinusIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.25 12C5.25 11.5858 5.58579 11.25 6 11.25H18C18.4142 11.25 18.75 11.5858 18.75 12C18.75 12.4142 18.4142 12.75 18 12.75H6C5.58579 12.75 5.25 12.4142 5.25 12Z"
  />
</svg>`;
var PlusIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 5.25C12.4142 5.25 12.75 5.58579 12.75 6V11.25H18C18.4142 11.25 18.75 11.5858 18.75 12C18.75 12.4142 18.4142 12.75 18 12.75H12.75V18C12.75 18.4142 12.4142 18.75 12 18.75C11.5858 18.75 11.25 18.4142 11.25 18V12.75H6C5.58579 12.75 5.25 12.4142 5.25 12C5.25 11.5858 5.58579 11.25 6 11.25H11.25V6C11.25 5.58579 11.5858 5.25 12 5.25Z"
  />
</svg>`;
var ViewBarIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M3.25 20C2.83579 20 2.5 19.6642 2.5 19.25V4.75C2.5 4.33579 2.83579 4 3.25 4C3.66421 4 4 4.33579 4 4.75L4 19.25C4 19.6642 3.66421 20 3.25 20Z"
  />
  <path
    d="M9.16494 8.43945C9.47453 8.71464 9.50241 9.18869 9.22722 9.49828L7.67013 11.25H16.3299L14.7728 9.49828C14.4976 9.18869 14.5255 8.71464 14.8351 8.43945C15.1446 8.16426 15.6187 8.19215 15.8939 8.50174L18.5606 11.5017C18.8131 11.7859 18.8131 12.2141 18.5606 12.4983L15.8939 15.4983C15.6187 15.8079 15.1446 15.8358 14.8351 15.5606C14.5255 15.2854 14.4976 14.8113 14.7728 14.5017L16.3299 12.75H7.67013L9.22722 14.5017C9.50241 14.8113 9.47453 15.2854 9.16494 15.5606C8.85535 15.8358 8.3813 15.8079 8.10611 15.4983L5.43944 12.4983C5.18685 12.2141 5.18685 11.7859 5.43944 11.5017L8.10611 8.50174C8.3813 8.19215 8.85535 8.16426 9.16494 8.43945Z"
  />
  <path
    d="M21.5 4.75C21.5 4.33579 21.1642 4 20.75 4C20.3358 4 20 4.33579 20 4.75V19.25C20 19.6642 20.3358 20 20.75 20C21.1642 20 21.5 19.6642 21.5 19.25V4.75Z"
  />
</svg>`;
var TransparentIcon = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M-0.939238 4.14286C-0.979281 4.4228 -1 4.70898 -1 5V6.71429H1.57143V9.28571H-1V11C-1 11.291 -0.979281 11.5772 -0.939238 11.8571H1.57143V14.4286H0.0754482C0.481795 15.0111 0.988871 15.5182 1.57143 15.9246V14.4286L4.14286 14.4286V16.9392C4.4228 16.9793 4.70898 17 5 17H6.71429V14.4286H9.28571V17H11C11.291 17 11.5772 16.9793 11.8571 16.9392V14.4286H14.4286L14.4286 15.9246C15.0111 15.5182 15.5182 15.0111 15.9246 14.4286L14.4286 14.4286V11.8571H16.9392C16.9793 11.5772 17 11.291 17 11V9.28571H14.4286V6.71429H17V5C17 4.70898 16.9793 4.4228 16.9392 4.14286H14.4286V1.57143H15.9246C15.5182 0.988871 15.0111 0.481795 14.4286 0.075448L14.4286 1.57143H11.8571V-0.939238C11.5772 -0.979281 11.291 -1 11 -1H9.28571V1.57143H6.71429V-1H5C4.70898 -1 4.4228 -0.979281 4.14286 -0.939238V1.57143H1.57143V0.0754479C0.988871 0.481795 0.481795 0.988871 0.0754479 1.57143H1.57143V4.14286H-0.939238ZM4.14286 4.14286V1.57143H6.71429V4.14286H4.14286ZM4.14286 6.71429H1.57143V4.14286H4.14286V6.71429ZM6.71429 6.71429V4.14286H9.28571V6.71429H6.71429ZM6.71429 9.28571V6.71429H4.14286V9.28571H1.57143V11.8571H4.14286V14.4286H6.71429V11.8571H9.28571V14.4286H11.8571V11.8571H14.4286V9.28571H11.8571V6.71429H14.4286V4.14286H11.8571V1.57143H9.28571V4.14286H11.8571V6.71429H9.28571V9.28571H6.71429ZM6.71429 9.28571V11.8571H4.14286V9.28571H6.71429ZM9.28571 9.28571H11.8571V11.8571H9.28571V9.28571Z"
    fill="#D9D9D9"
  />
</svg>`;
var MoreHorizontalIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M10 5.00004C9.53978 5.00004 9.16669 4.62694 9.16669 4.16671C9.16669 3.70647 9.53978 3.33337 10 3.33337C10.4603 3.33337 10.8334 3.70647 10.8334 4.16671C10.8334 4.62694 10.4603 5.00004 10 5.00004Z"
  />
  <path
    d="M10 10.8334C9.53978 10.8334 9.16669 10.4603 9.16669 10C9.16669 9.5398 9.53978 9.16671 10 9.16671C10.4603 9.16671 10.8334 9.5398 10.8334 10C10.8334 10.4603 10.4603 10.8334 10 10.8334Z"
  />
  <path
    d="M10 16.6667C9.53978 16.6667 9.16669 16.2936 9.16669 15.8334C9.16669 15.3731 9.53978 15 10 15C10.4603 15 10.8334 15.3731 10.8334 15.8334C10.8334 16.2936 10.4603 16.6667 10 16.6667Z"
  />
  <path
    d="M10 5.00004C9.53978 5.00004 9.16669 4.62694 9.16669 4.16671C9.16669 3.70647 9.53978 3.33337 10 3.33337C10.4603 3.33337 10.8334 3.70647 10.8334 4.16671C10.8334 4.62694 10.4603 5.00004 10 5.00004Z"
  />
  <path
    d="M10 10.8334C9.53978 10.8334 9.16669 10.4603 9.16669 10C9.16669 9.5398 9.53978 9.16671 10 9.16671C10.4603 9.16671 10.8334 9.5398 10.8334 10C10.8334 10.4603 10.4603 10.8334 10 10.8334Z"
  />
  <path
    d="M10 16.6667C9.53978 16.6667 9.16669 16.2936 9.16669 15.8334C9.16669 15.3731 9.53978 15 10 15C10.4603 15 10.8334 15.3731 10.8334 15.8334C10.8334 16.2936 10.4603 16.6667 10 16.6667Z"
  />
</svg>`;
var LineStyleIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.70825 3.33325C2.70825 2.98807 2.98807 2.70825 3.33325 2.70825H5.83325C6.17843 2.70825 6.45825 2.98807 6.45825 3.33325C6.45825 3.67843 6.17843 3.95825 5.83325 3.95825H3.33325C2.98807 3.95825 2.70825 3.67843 2.70825 3.33325Z"
    fill="#77757D"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.12492 3.33325C8.12492 2.98807 8.40474 2.70825 8.74992 2.70825L11.2499 2.70825C11.5951 2.70825 11.8749 2.98807 11.8749 3.33325C11.8749 3.67843 11.5951 3.95825 11.2499 3.95825L8.74992 3.95825C8.40474 3.95825 8.12492 3.67843 8.12492 3.33325Z"
    fill="#77757D"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.6666 3.95825L14.1666 3.95825C13.8214 3.95825 13.5416 3.67843 13.5416 3.33325C13.5416 2.98807 13.8214 2.70825 14.1666 2.70825L16.6666 2.70825C17.0118 2.70825 17.2916 2.98807 17.2916 3.33325C17.2916 3.67843 17.0118 3.95825 16.6666 3.95825Z"
    fill="#77757D"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.70825 9.99992C2.70825 9.65474 2.98807 9.37492 3.33325 9.37492H16.6666C17.0118 9.37492 17.2916 9.65474 17.2916 9.99992C17.2916 10.3451 17.0118 10.6249 16.6666 10.6249H3.33325C2.98807 10.6249 2.70825 10.3451 2.70825 9.99992Z"
    fill="#77757D"
  />
  <path
    d="M2.70825 16.2499C2.70825 15.6746 3.17462 15.2083 3.74992 15.2083H16.2499C16.8252 15.2083 17.2916 15.6746 17.2916 16.2499C17.2916 16.8252 16.8252 17.2916 16.2499 17.2916H3.74992C3.17462 17.2916 2.70825 16.8252 2.70825 16.2499Z"
    fill="#77757D"
  />
</svg>`;
var ConnectorXIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11.25 7C11.25 5.48122 12.4812 4.25 14 4.25H21C21.4142 4.25 21.75 4.58579 21.75 5C21.75 5.41421 21.4142 5.75 21 5.75H14C13.3096 5.75 12.75 6.30964 12.75 7V17C12.75 18.5188 11.5188 19.75 10 19.75H3C2.58579 19.75 2.25 19.4142 2.25 19C2.25 18.5858 2.58579 18.25 3 18.25H10C10.6904 18.25 11.25 17.6904 11.25 17V7Z"
  />
</svg>`;
var ConnectorLIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.5303 3.53034C20.8232 3.82323 20.8232 4.29811 20.5303 4.591L4.591 20.5303C4.29811 20.8232 3.82323 20.8232 3.53034 20.5303C3.23745 20.2374 3.23745 19.7626 3.53034 19.4697L19.4697 3.53034C19.7626 3.23745 20.2374 3.23745 20.5303 3.53034Z"
  />
</svg>`;
var DashLineIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.5303 3.53034C20.8232 3.82323 20.8232 4.29811 20.5303 4.591L17.341 7.78034C17.0481 8.07323 16.5732 8.07323 16.2803 7.78034C15.9874 7.48745 15.9874 7.01257 16.2803 6.71968L19.4697 3.53034C19.7626 3.23745 20.2374 3.23745 20.5303 3.53034Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.1553 9.90534C14.4482 10.1982 14.4482 10.6731 14.1553 10.966L10.966 14.1553C10.6731 14.4482 10.1982 14.4482 9.90534 14.1553C9.61245 13.8624 9.61245 13.3876 9.90534 13.0947L13.0947 9.90534C13.3876 9.61245 13.8624 9.61245 14.1553 9.90534Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.78034 16.2803C8.07323 16.5732 8.07323 17.0481 7.78034 17.341L4.591 20.5303C4.29811 20.8232 3.82323 20.8232 3.53034 20.5303C3.23745 20.2374 3.23745 19.7626 3.53034 19.4697L6.71968 16.2803C7.01257 15.9874 7.48745 15.9874 7.78034 16.2803Z"
  />
</svg>`;
var BanIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.72068 18.34L18.34 6.72068C19.5331 8.15171 20.25 9.99158 20.25 12C20.25 16.5563 16.5563 20.25 12 20.25C9.99158 20.25 8.15171 19.5331 6.72068 18.34ZM17.2793 5.66002L5.66002 17.2793C4.46691 15.8483 3.75 14.0084 3.75 12C3.75 7.44365 7.44365 3.75 12 3.75C14.0084 3.75 15.8483 4.46691 17.2793 5.66002ZM5.10571 18.8943C6.86929 20.6579 9.30782 21.75 12 21.75C17.3848 21.75 21.75 17.3848 21.75 12C21.75 9.30782 20.6579 6.86929 18.8943 5.10571C17.1307 3.34213 14.6922 2.25 12 2.25C6.61522 2.25 2.25 6.61522 2.25 12C2.25 14.6922 3.34213 17.1307 5.10571 18.8943Z"
  />
</svg>`;
var NoteIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 6C3.25 4.48122 4.48122 3.25 6 3.25H14C14.4142 3.25 14.75 3.58579 14.75 4C14.75 4.41421 14.4142 4.75 14 4.75H6C5.30964 4.75 4.75 5.30964 4.75 6V20C4.75 20.4142 4.41421 20.75 4 20.75C3.58579 20.75 3.25 20.4142 3.25 20V6Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.75 18C20.75 19.5188 19.5188 20.75 18 20.75H10C9.58579 20.75 9.25 20.4142 9.25 20C9.25 19.5858 9.58579 19.25 10 19.25L18 19.25C18.6904 19.25 19.25 18.6904 19.25 18L19.25 4C19.25 3.58579 19.5858 3.25 20 3.25C20.4142 3.25 20.75 3.58579 20.75 4L20.75 18Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 9C8.25 8.0335 9.0335 7.25 10 7.25H14C14.9665 7.25 15.75 8.0335 15.75 9V11C15.75 11.9665 14.9665 12.75 14 12.75H10C9.0335 12.75 8.25 11.9665 8.25 11V9ZM10 8.75C9.86193 8.75 9.75 8.86193 9.75 9V11C9.75 11.1381 9.86193 11.25 10 11.25H14C14.1381 11.25 14.25 11.1381 14.25 11V9C14.25 8.86193 14.1381 8.75 14 8.75H10Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 16C8.25 15.5858 8.58579 15.25 9 15.25H15C15.4142 15.25 15.75 15.5858 15.75 16C15.75 16.4142 15.4142 16.75 15 16.75H9C8.58579 16.75 8.25 16.4142 8.25 16Z"
  />
</svg>`;
var ImportIcon = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.00004 0.708313C8.34522 0.708313 8.62504 0.988135 8.62504 1.33331V8.71332L9.78032 7.55804C10.0244 7.31396 10.4201 7.31396 10.6642 7.55804C10.9083 7.80211 10.9083 8.19784 10.6642 8.44192L8.44198 10.6641C8.32477 10.7814 8.1658 10.8472 8.00004 10.8472C7.83428 10.8472 7.67531 10.7814 7.5581 10.6641L5.33588 8.44192C5.0918 8.19784 5.0918 7.80211 5.33588 7.55804C5.57996 7.31396 5.97568 7.31396 6.21976 7.55804L7.37504 8.71332V1.33331C7.37504 0.988135 7.65486 0.708313 8.00004 0.708313ZM3.67888 5.15276L4.29634 5.15276C4.64152 5.15276 4.92134 5.43258 4.92134 5.77776C4.92134 6.12294 4.64152 6.40276 4.29634 6.40276H3.70375C3.27858 6.40276 2.99729 6.40324 2.78161 6.42087C2.57322 6.43789 2.48168 6.46775 2.42602 6.49611C2.26486 6.57822 2.13384 6.70925 2.05173 6.8704C2.02337 6.92606 1.99351 7.0176 1.97648 7.22599C1.95886 7.44167 1.95837 7.72296 1.95837 8.14813V12.2963C1.95837 12.7214 1.95886 13.0027 1.97648 13.2184C1.99351 13.4268 2.02337 13.5183 2.05173 13.574C2.13384 13.7352 2.26486 13.8662 2.42602 13.9483C2.48168 13.9767 2.57322 14.0065 2.78161 14.0235C2.99729 14.0412 3.27858 14.0416 3.70375 14.0416H12.2963C12.7215 14.0416 13.0028 14.0412 13.2185 14.0235C13.4269 14.0065 13.5184 13.9767 13.5741 13.9483C13.7352 13.8662 13.8662 13.7352 13.9484 13.574C13.9767 13.5183 14.0066 13.4268 14.0236 13.2184C14.0412 13.0027 14.0417 12.7214 14.0417 12.2963V8.14813C14.0417 7.72296 14.0412 7.44167 14.0236 7.22599C14.0066 7.0176 13.9767 6.92607 13.9484 6.87041C13.8662 6.70925 13.7352 6.57822 13.5741 6.49611C13.5184 6.46775 13.4269 6.43789 13.2185 6.42087C13.0028 6.40324 12.7215 6.40276 12.2963 6.40276H11.7037C11.3586 6.40276 11.0787 6.12294 11.0787 5.77776C11.0787 5.43258 11.3586 5.15276 11.7037 5.15276L12.3212 5.15276C12.7149 5.15275 13.0476 5.15274 13.3203 5.17502C13.606 5.19836 13.8803 5.24924 14.1416 5.38235C14.5379 5.58431 14.8602 5.90656 15.0621 6.30292C15.1952 6.56416 15.2461 6.83851 15.2694 7.1242C15.2917 7.39687 15.2917 7.72958 15.2917 8.12324V12.3212C15.2917 12.7148 15.2917 13.0475 15.2694 13.3202C15.2461 13.6059 15.1952 13.8802 15.0621 14.1415C14.8602 14.5378 14.5379 14.8601 14.1416 15.0621C13.8803 15.1952 13.606 15.246 13.3203 15.2694C13.0476 15.2917 12.7149 15.2917 12.3212 15.2916H3.67886C3.2852 15.2917 2.95248 15.2917 2.67982 15.2694C2.39413 15.246 2.11978 15.1952 1.85853 15.0621C1.46217 14.8601 1.13992 14.5378 0.937968 14.1415C0.804856 13.8802 0.753976 13.6059 0.730635 13.3202C0.708356 13.0475 0.708365 12.7148 0.708374 12.3211V8.12326C0.708365 7.72959 0.708356 7.39687 0.730635 7.1242C0.753976 6.83851 0.804856 6.56416 0.937968 6.30292C1.13992 5.90656 1.46217 5.58431 1.85853 5.38235C2.11978 5.24924 2.39413 5.19836 2.67982 5.17502C2.95249 5.15274 3.28521 5.15275 3.67888 5.15276Z"
    fill="#77757D"
  />
</svg>`;
var AlighLeftIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <g clip-path="url(#clip0_2131_19971)">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M4.7085 6.16675C4.7085 5.82157 4.98832 5.54175 5.3335 5.54175H18.6668C19.012 5.54175 19.2918 5.82157 19.2918 6.16675C19.2918 6.51193 19.012 6.79175 18.6668 6.79175H5.3335C4.98832 6.79175 4.7085 6.51193 4.7085 6.16675Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M4.7085 12.0001C4.7085 11.6549 4.98832 11.3751 5.3335 11.3751H13.6668C14.012 11.3751 14.2918 11.6549 14.2918 12.0001C14.2918 12.3453 14.012 12.6251 13.6668 12.6251H5.3335C4.98832 12.6251 4.7085 12.3453 4.7085 12.0001Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M4.7085 17.8334C4.7085 17.4882 4.98832 17.2084 5.3335 17.2084H15.3335C15.6787 17.2084 15.9585 17.4882 15.9585 17.8334C15.9585 18.1786 15.6787 18.4584 15.3335 18.4584H5.3335C4.98832 18.4584 4.7085 18.1786 4.7085 17.8334Z"
      fill="#77757D"
    />
  </g>
  <defs>
    <clipPath id="clip0_2131_19971">
      <rect width="20" height="20" fill="white" transform="translate(2 2)" />
    </clipPath>
  </defs>
</svg>`;
var AlignCenterIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <g clip-path="url(#clip0_2131_19972)">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M4.7085 6.16675C4.7085 5.82157 4.98832 5.54175 5.3335 5.54175H18.6668C19.012 5.54175 19.2918 5.82157 19.2918 6.16675C19.2918 6.51193 19.012 6.79175 18.6668 6.79175H5.3335C4.98832 6.79175 4.7085 6.51193 4.7085 6.16675Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M7.2085 12.0001C7.2085 11.6549 7.48832 11.3751 7.8335 11.3751H16.1668C16.512 11.3751 16.7918 11.6549 16.7918 12.0001C16.7918 12.3453 16.512 12.6251 16.1668 12.6251H7.8335C7.48832 12.6251 7.2085 12.3453 7.2085 12.0001Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M6.37516 17.8334C6.37516 17.4882 6.65498 17.2084 7.00016 17.2084H17.0002C17.3453 17.2084 17.6252 17.4882 17.6252 17.8334C17.6252 18.1786 17.3453 18.4584 17.0002 18.4584H7.00016C6.65498 18.4584 6.37516 18.1786 6.37516 17.8334Z"
      fill="#77757D"
    />
  </g>
  <defs>
    <clipPath id="clip0_2131_19972">
      <rect width="20" height="20" fill="white" transform="translate(2 2)" />
    </clipPath>
  </defs>
</svg>`;
var AlignRightIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <g clip-path="url(#clip0_2131_19973)">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M4.7085 6.16675C4.7085 5.82157 4.98832 5.54175 5.3335 5.54175H18.6668C19.012 5.54175 19.2918 5.82157 19.2918 6.16675C19.2918 6.51193 19.012 6.79175 18.6668 6.79175H5.3335C4.98832 6.79175 4.7085 6.51193 4.7085 6.16675Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M9.7085 12.0001C9.7085 11.6549 9.98832 11.3751 10.3335 11.3751H18.6668C19.012 11.3751 19.2918 11.6549 19.2918 12.0001C19.2918 12.3453 19.012 12.6251 18.6668 12.6251H10.3335C9.98832 12.6251 9.7085 12.3453 9.7085 12.0001Z"
      fill="#77757D"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M8.04183 17.8334C8.04183 17.4882 8.32165 17.2084 8.66683 17.2084H18.6668C19.012 17.2084 19.2918 17.4882 19.2918 17.8334C19.2918 18.1786 19.012 18.4584 18.6668 18.4584H8.66683C8.32165 18.4584 8.04183 18.1786 8.04183 17.8334Z"
      fill="#77757D"
    />
  </g>
  <defs>
    <clipPath id="clip0_2131_19973">
      <rect width="20" height="20" fill="white" transform="translate(2 2)" />
    </clipPath>
  </defs>
</svg>`;

// node_modules/@blocksuite/global/dist/config/icons/import-export.js
var CloseIcon = html`<svg
  width="12"
  height="12"
  viewBox="0 0 12 12"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.343205 0.343144C0.636098 0.0502508 1.11097 0.0502508 1.40387 0.343144L6.00006 4.93934L10.5963 0.343144C10.8891 0.0502508 11.364 0.0502508 11.6569 0.343144C11.9498 0.636037 11.9498 1.11091 11.6569 1.4038L7.06072 6L11.6569 10.5962C11.9498 10.8891 11.9498 11.364 11.6569 11.6569C11.364 11.9497 10.8891 11.9497 10.5963 11.6569L6.00006 7.06066L1.40387 11.6569C1.11097 11.9497 0.636098 11.9497 0.343205 11.6569C0.0503118 11.364 0.0503118 10.8891 0.343205 10.5962L4.9394 6L0.343205 1.4038C0.0503118 1.11091 0.0503118 0.636037 0.343205 0.343144Z"
    fill="#77757D"
  />
</svg>`;
var ExportToMarkdownIcon = html`<svg
  width="14"
  height="18"
  viewBox="0 0 14 18"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.80805 0.875L7.83342 0.875001C7.99918 0.875001 8.15815 0.940849 8.27536 1.05806L13.2754 6.05806C13.3926 6.17527 13.4584 6.33424 13.4584 6.5V13.8587C13.4584 14.3038 13.4584 14.6754 13.4336 14.9789C13.4078 15.2955 13.3518 15.5927 13.2086 15.8737C12.9889 16.3049 12.6383 16.6555 12.2071 16.8752C11.9261 17.0184 11.6289 17.0744 11.3123 17.1002C11.0088 17.125 10.6372 17.125 10.1921 17.125H3.80804C3.36292 17.125 2.99138 17.125 2.68786 17.1002C2.37129 17.0744 2.07407 17.0184 1.79302 16.8752C1.36182 16.6555 1.01124 16.3049 0.791525 15.8737C0.648322 15.5927 0.592396 15.2955 0.566531 14.9789C0.541732 14.6754 0.541739 14.3038 0.541748 13.8587V4.1413C0.541739 3.69618 0.541732 3.32464 0.566531 3.02111C0.592396 2.70454 0.648322 2.40732 0.791525 2.12627C1.01124 1.69507 1.36182 1.34449 1.79302 1.12478C2.07407 0.981574 2.37129 0.925648 2.68786 0.899783C2.99138 0.874984 3.36292 0.874991 3.80805 0.875ZM2.78965 2.14563C2.55038 2.16518 2.43598 2.20008 2.36051 2.23854C2.16451 2.3384 2.00515 2.49776 1.90528 2.69376C1.86683 2.76923 1.83193 2.88363 1.81238 3.1229C1.79223 3.36946 1.79175 3.68964 1.79175 4.16667V13.8333C1.79175 14.3104 1.79223 14.6305 1.81238 14.8771C1.83193 15.1164 1.86683 15.2308 1.90528 15.3062C2.00515 15.5022 2.16451 15.6616 2.36051 15.7615C2.43598 15.7999 2.55038 15.8348 2.78965 15.8544C3.03621 15.8745 3.35639 15.875 3.83342 15.875H10.1667C10.6438 15.875 10.964 15.8745 11.2105 15.8544C11.4498 15.8348 11.5642 15.7999 11.6397 15.7615C11.8357 15.6616 11.995 15.5022 12.0949 15.3062C12.1333 15.2308 12.1682 15.1164 12.1878 14.8771C12.2079 14.6305 12.2084 14.3104 12.2084 13.8333V7.125H8.66675C7.86133 7.125 7.20842 6.47208 7.20842 5.66667V2.125H3.83342C3.35639 2.125 3.03621 2.12549 2.78965 2.14563ZM8.45842 3.00888L11.3245 5.875H8.66675C8.55169 5.875 8.45842 5.78173 8.45842 5.66667V3.00888Z"
    fill="#77757D"
  />
  <path
    d="M8.37009 13.1207L8.39316 10.2307H8.37585L7.31446 13.1207H6.62225L5.5897 10.2307H5.57239L5.59547 13.1207H4.66675V9.03662H6.06848L6.9972 11.6555H7.02027L7.90861 9.03662H9.33342V13.1207H8.37009Z"
    fill="#77757D"
  />
</svg>`;
var ExportToHTMLIcon = html`<svg
  width="16"
  height="18"
  viewBox="0 0 16 18"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.80797 0.875L8.83333 0.875001C8.99909 0.875001 9.15806 0.940849 9.27527 1.05806L14.2753 6.05806C14.3925 6.17527 14.4583 6.33424 14.4583 6.5V11.5C14.4583 11.8452 14.1785 12.125 13.8333 12.125C13.4882 12.125 13.2083 11.8452 13.2083 11.5V7.125H9.66667C8.86125 7.125 8.20833 6.47208 8.20833 5.66667V2.125H4.83333C4.35631 2.125 4.03613 2.12549 3.78956 2.14563C3.5503 2.16518 3.43589 2.20008 3.36043 2.23854C3.16442 2.3384 3.00507 2.49776 2.9052 2.69376C2.86675 2.76923 2.83185 2.88363 2.8123 3.1229C2.79215 3.36946 2.79167 3.68964 2.79167 4.16667V11.5C2.79167 11.8452 2.51184 12.125 2.16667 12.125C1.82149 12.125 1.54167 11.8452 1.54167 11.5L1.54167 4.1413C1.54166 3.69618 1.54165 3.32464 1.56645 3.02111C1.59231 2.70454 1.64824 2.40732 1.79144 2.12627C2.01115 1.69507 2.36173 1.34449 2.79294 1.12478C3.07399 0.981574 3.3712 0.925648 3.68777 0.899783C3.9913 0.874984 4.36284 0.874991 4.80797 0.875ZM9.45833 3.00888L12.3244 5.875H9.66667C9.55161 5.875 9.45833 5.78173 9.45833 5.66667V3.00888Z"
    fill="#77757D"
  />
  <path
    d="M3.2085 17.0607V15.4327H1.6905V17.0607H0.75V13.1667H1.6905V14.6407H3.2085V13.1667H4.149V17.0607H3.2085Z"
    fill="#77757D"
  />
  <path
    d="M6.6167 13.9697V17.0607H5.6762V13.9697H4.5762V13.1667H7.7167V13.9697H6.6167Z"
    fill="#77757D"
  />
  <path
    d="M11.677 17.0607L11.699 14.3052H11.6825L10.6705 17.0607H10.0105L9.026 14.3052H9.0095L9.0315 17.0607H8.146V13.1667H9.4825L10.368 15.6637H10.39L11.237 13.1667H12.5955V17.0607H11.677Z"
    fill="#77757D"
  />
  <path
    d="M13.3989 17.0607V13.1667H14.3449V16.2412H15.8519V17.0607H13.3989Z"
    fill="#77757D"
  />
</svg>`;
var NotionIcon = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M3.22321 3.16561C3.69638 3.54965 3.87301 3.52049 4.76102 3.46134L13.1323 2.959C13.3106 2.959 13.1623 2.78075 13.1032 2.75158L11.7128 1.74689C11.4462 1.54028 11.0914 1.30289 10.4116 1.36203L2.30522 1.9535C2.01029 1.98267 1.95114 2.13094 2.06863 2.24924L3.22321 3.16561ZM3.72555 5.11664V13.9238C3.72555 14.3978 3.96214 14.5745 4.49527 14.5453L13.6946 14.013C14.2269 13.9838 14.2861 13.6581 14.2861 13.274V4.52517C14.2861 4.14112 14.1386 3.9337 13.8129 3.96368L4.19872 4.52517C3.84384 4.55434 3.72555 4.73178 3.72555 5.11664ZM12.8082 5.589C12.8666 5.85476 12.8082 6.12133 12.5409 6.1513L12.0977 6.23962V12.7417C11.7128 12.9491 11.3579 13.0674 11.0622 13.0674C10.589 13.0674 10.4707 12.9192 10.1158 12.476L7.21602 7.92409V12.3285L8.13401 12.5351C8.13401 12.5351 8.13401 13.0674 7.39346 13.0674L5.35249 13.1857C5.29334 13.0674 5.35249 12.7725 5.55991 12.7125L6.09223 12.5651V6.74196L5.35249 6.68282C5.29334 6.41625 5.44162 6.0322 5.85564 6.00222L8.04489 5.85557L11.0622 10.4658V6.38789L10.2925 6.29958C10.2341 5.97386 10.4707 5.73809 10.7664 5.70811L12.8082 5.58981V5.589ZM1.62462 1.15542L10.0559 0.534789C11.0905 0.445664 11.3571 0.505621 12.0085 0.977985L14.6993 2.86987C15.1433 3.19477 15.2916 3.28309 15.2916 3.63797V14.013C15.2916 14.6636 15.055 15.0476 14.2269 15.1068L4.43531 15.6982C3.81386 15.7274 3.51813 15.6391 3.19242 15.2251L1.21059 12.6534C0.855714 12.1802 0.708252 11.8262 0.708252 11.4113V2.19009C0.708252 1.65777 0.944029 1.21457 1.62462 1.15542Z"
    fill="black"
  />
</svg>`;
var NewIcon = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.1851 0.708313C13.5303 0.708313 13.8101 0.988135 13.8101 1.33331V2.18979H14.6666C15.0118 2.18979 15.2916 2.46962 15.2916 2.81479C15.2916 3.15997 15.0118 3.43979 14.6666 3.43979H13.8101V4.29628C13.8101 4.64145 13.5303 4.92128 13.1851 4.92128C12.8399 4.92128 12.5601 4.64145 12.5601 4.29628V3.43979H11.7036C11.3584 3.43979 11.0786 3.15997 11.0786 2.81479C11.0786 2.46962 11.3584 2.18979 11.7036 2.18979H12.5601V1.33331C12.5601 0.988135 12.8399 0.708313 13.1851 0.708313ZM6.51844 2.18979C6.77511 2.18979 7.00568 2.34672 7.09985 2.58549L8.18874 5.34639C8.3394 5.7284 8.37968 5.81859 8.43081 5.88998C8.48542 5.96623 8.55218 6.033 8.62844 6.08761C8.69983 6.13874 8.79002 6.17902 9.17203 6.32968L11.9329 7.41856C12.1717 7.51273 12.3286 7.74331 12.3286 7.99998C12.3286 8.25665 12.1717 8.48723 11.9329 8.58139L9.17203 9.67028C8.79002 9.82094 8.69983 9.86122 8.62844 9.91235C8.55218 9.96696 8.48542 10.0337 8.43081 10.11C8.37968 10.1814 8.3394 10.2716 8.18874 10.6536L7.09985 13.4145C7.00568 13.6532 6.77511 13.8102 6.51844 13.8102C6.26177 13.8102 6.03119 13.6532 5.93702 13.4145L4.84814 10.6536C4.69748 10.2716 4.6572 10.1814 4.60607 10.11C4.55146 10.0337 4.48469 9.96696 4.40844 9.91235C4.33705 9.86122 4.24685 9.82094 3.86484 9.67028L1.10395 8.58139C0.865175 8.48723 0.708252 8.25665 0.708252 7.99998C0.708252 7.74331 0.865175 7.51273 1.10395 7.41856L3.86484 6.32968C4.24685 6.17902 4.33705 6.13874 4.40844 6.08761C4.48469 6.033 4.55146 5.96623 4.60607 5.88998C4.6572 5.81859 4.69748 5.7284 4.84814 5.34639L5.93702 2.58549C6.03119 2.34672 6.26177 2.18979 6.51844 2.18979ZM6.51844 4.5183L6.01097 5.805C6.00357 5.82375 5.99627 5.8423 5.98905 5.86065C5.87158 6.15916 5.77495 6.40469 5.62232 6.61781C5.48801 6.80535 5.3238 6.96955 5.13626 7.10386C4.92315 7.25649 4.67762 7.35312 4.3791 7.4706C4.36076 7.47782 4.34221 7.48512 4.32346 7.49251L3.03676 7.99998L4.32346 8.50745C4.34221 8.51484 4.36075 8.52214 4.3791 8.52936C4.67762 8.64684 4.92315 8.74347 5.13626 8.8961C5.3238 9.03041 5.48801 9.19461 5.62232 9.38215C5.77495 9.59527 5.87157 9.84079 5.98905 10.1393C5.99627 10.1577 6.00357 10.1762 6.01097 10.195L6.51844 11.4817L7.0259 10.195C7.0333 10.1762 7.0406 10.1577 7.04782 10.1393C7.1653 9.8408 7.26193 9.59527 7.41455 9.38215C7.54887 9.19461 7.71307 9.03041 7.90061 8.8961C8.11373 8.74347 8.35926 8.64684 8.65777 8.52936C8.67612 8.52214 8.69467 8.51484 8.71342 8.50745L10.0001 7.99998L8.71342 7.49251C8.69467 7.48512 8.67612 7.47782 8.65777 7.4706C8.35926 7.35312 8.11373 7.25649 7.90061 7.10386C7.71307 6.96955 7.54887 6.80535 7.41455 6.61781C7.26193 6.40469 7.1653 6.15916 7.04782 5.86065C7.0406 5.8423 7.0333 5.82375 7.0259 5.805L6.51844 4.5183ZM13.1851 11.0787C13.5303 11.0787 13.8101 11.3585 13.8101 11.7037V12.5602H14.6666C15.0118 12.5602 15.2916 12.84 15.2916 13.1852C15.2916 13.5303 15.0118 13.8102 14.6666 13.8102H13.8101V14.6666C13.8101 15.0118 13.5303 15.2916 13.1851 15.2916C12.8399 15.2916 12.5601 15.0118 12.5601 14.6666V13.8102H11.7036C11.3584 13.8102 11.0786 13.5303 11.0786 13.1852C11.0786 12.84 11.3584 12.5602 11.7036 12.5602H12.5601V11.7037C12.5601 11.3585 12.8399 11.0787 13.1851 11.0787Z"
    fill="#A9A9AD"
  />
</svg>`;
var OpenInNewIcon = html`<svg
  width="12"
  height="12"
  viewBox="0 0 12 12"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.83342 0.666687C7.83342 0.390545 8.05727 0.166687 8.33342 0.166687H11.3334C11.6096 0.166687 11.8334 0.390545 11.8334 0.666687V3.66669C11.8334 3.94283 11.6096 4.16669 11.3334 4.16669C11.0573 4.16669 10.8334 3.94283 10.8334 3.66669V1.87379L6.35364 6.35357C6.15837 6.54884 5.84179 6.54884 5.64653 6.35357C5.45127 6.15831 5.45127 5.84173 5.64653 5.64647L10.1263 1.16669H8.33342C8.05727 1.16669 7.83342 0.942829 7.83342 0.666687ZM2.77979 0.833353L5.66675 0.833354C5.94289 0.833354 6.16675 1.05721 6.16675 1.33335C6.16675 1.6095 5.94289 1.83335 5.66675 1.83335H2.80008C2.41846 1.83335 2.16232 1.83374 1.96507 1.84986C1.77365 1.8655 1.68213 1.89342 1.62176 1.92418C1.46495 2.00408 1.33747 2.13156 1.25758 2.28836C1.22681 2.34874 1.19889 2.44026 1.18325 2.63167C1.16714 2.82892 1.16675 3.08507 1.16675 3.46669V9.20002C1.16675 9.58164 1.16714 9.83778 1.18325 10.035C1.19889 10.2264 1.22681 10.318 1.25758 10.3783C1.33747 10.5351 1.46496 10.6626 1.62176 10.7425C1.68213 10.7733 1.77365 10.8012 1.96507 10.8168C2.16232 10.833 2.41846 10.8334 2.80008 10.8334H8.53342C8.91503 10.8334 9.17118 10.833 9.36843 10.8168C9.55985 10.8012 9.65137 10.7733 9.71174 10.7425C9.86854 10.6626 9.99603 10.5351 10.0759 10.3783C10.1067 10.318 10.1346 10.2264 10.1502 10.035C10.1664 9.83778 10.1667 9.58164 10.1667 9.20002V6.33335C10.1667 6.05721 10.3906 5.83335 10.6667 5.83335C10.9429 5.83335 11.1667 6.05721 11.1667 6.33335V9.22032C11.1668 9.57642 11.1668 9.87365 11.1469 10.1165C11.1262 10.3697 11.0815 10.6075 10.9669 10.8323C10.7912 11.1773 10.5107 11.4578 10.1657 11.6335C9.94089 11.7481 9.70312 11.7928 9.44986 11.8135C9.20704 11.8334 8.90981 11.8334 8.55372 11.8334H2.77978C2.42368 11.8334 2.12645 11.8334 1.88364 11.8135C1.63038 11.7928 1.39261 11.7481 1.16777 11.6335C0.822802 11.4578 0.542338 11.1773 0.36657 10.8323C0.252007 10.6075 0.207267 10.3697 0.186575 10.1165C0.166735 9.87364 0.166741 9.57641 0.166748 9.22031V3.4464C0.166741 3.0903 0.166735 2.79306 0.186575 2.55024C0.207267 2.29698 0.252007 2.05921 0.36657 1.83437C0.542338 1.48941 0.822802 1.20894 1.16777 1.03317C1.39261 0.918612 1.63038 0.873872 1.88364 0.85318C2.12646 0.83334 2.42369 0.833346 2.77979 0.833353Z"
    fill="#5872FB"
  />
</svg>`;
var HelpIcon = html`<svg
  width="18"
  height="18"
  viewBox="0 0 18 18"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9 2.125C5.20304 2.125 2.125 5.20304 2.125 9C2.125 12.797 5.20304 15.875 9 15.875C12.797 15.875 15.875 12.797 15.875 9C15.875 5.20304 12.797 2.125 9 2.125ZM0.875 9C0.875 4.51269 4.51269 0.875 9 0.875C13.4873 0.875 17.125 4.51269 17.125 9C17.125 13.4873 13.4873 17.125 9 17.125C4.51269 17.125 0.875 13.4873 0.875 9ZM8.97249 6.5C8.48797 6.5 8.07928 6.83137 7.96361 7.28079C7.87757 7.61507 7.53683 7.81631 7.20255 7.73027C6.86826 7.64423 6.66702 7.3035 6.75306 6.96921C7.00742 5.98094 7.90381 5.25 8.97249 5.25C10.2381 5.25 11.2642 6.27601 11.2642 7.54167C11.2642 8.23885 10.928 8.70316 10.5524 9.06572C10.3978 9.21488 10.2216 9.36095 10.0565 9.49784C10.0321 9.51805 10.008 9.53806 9.98417 9.55785C9.79133 9.71827 9.60144 9.87995 9.41445 10.0669C9.17037 10.311 8.77464 10.311 8.53057 10.0669C8.28649 9.82286 8.28649 9.42714 8.53057 9.18306C8.76025 8.95338 8.98703 8.76138 9.1848 8.59686C9.21087 8.57517 9.23619 8.55416 9.26081 8.53373C9.43034 8.39303 9.5663 8.28019 9.6843 8.1663C9.93364 7.92565 10.0142 7.76496 10.0142 7.54167C10.0142 6.96637 9.54779 6.5 8.97249 6.5ZM8.98084 12.75H8.97251C8.62733 12.75 8.34751 12.4702 8.34751 12.125C8.34751 11.7798 8.62733 11.5 8.97251 11.5H8.98084C9.32602 11.5 9.60584 11.7798 9.60584 12.125C9.60584 12.4702 9.32602 12.75 8.98084 12.75Z"
    fill="#77757D"
  />
</svg>`;

// node_modules/@blocksuite/global/dist/config/icons/utils.js
function fontIcon(svg2, baseSize = 20) {
  const size = baseSize / 16;
  const fontIconStyle = `
    width: ${size}em;
    height: ${size}em;
    vertical-align: middle;
    font-size: inherit;
    margin-bottom: 0.1em;
  `;
  return html`<svg
    viewBox="0 0 24 24"
    xmlns="http://www.w3.org/2000/svg"
    style=${fontIconStyle}
  >
    ${svg2}
  </svg>`;
}
function icon(svg2, size = 24) {
  return html`<svg
    width="${size}"
    height="${size}"
    viewBox="0 0 24 24"
    xmlns="http://www.w3.org/2000/svg"
  >
    ${svg2}
  </svg>`;
}

// node_modules/@blocksuite/global/dist/config/icons/text.js
var TextSVG = svg`<path
  fill-rule="evenodd"
  clip-rule="evenodd"
  d="M3.25 4C3.25 3.58579 3.58579 3.25 4 3.25H20C20.4142 3.25 20.75 3.58579 20.75 4V6.66667C20.75 7.08088 20.4142 7.41667 20 7.41667C19.5858 7.41667 19.25 7.08088 19.25 6.66667V4.75H12.75V19.25H16C16.4142 19.25 16.75 19.5858 16.75 20C16.75 20.4142 16.4142 20.75 16 20.75H8C7.58579 20.75 7.25 20.4142 7.25 20C7.25 19.5858 7.58579 19.25 8 19.25H11.25V4.75H4.75V6.66667C4.75 7.08088 4.41421 7.41667 4 7.41667C3.58579 7.41667 3.25 7.08088 3.25 6.66667V4Z"
/>`;
var TextIcon = icon(TextSVG, 20);
var TextIconLarge = icon(TextSVG);
var H1Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.7499 6.81081C16.7231 6.83762 16.6947 6.86599 16.6646 6.89602L14.5303 9.03033C14.2374 9.32322 13.7626 9.32322 13.4697 9.03033C13.1768 8.73744 13.1768 8.26256 13.4697 7.96967L15.604 5.83536C15.6113 5.82808 15.6185 5.82081 15.6258 5.81357C15.8211 5.61819 16.0018 5.43743 16.1578 5.30688C16.3005 5.18739 16.5575 4.98807 16.9019 4.96096C17.3008 4.92957 17.6906 5.09103 17.9505 5.3953C18.1749 5.65804 18.2157 5.98068 18.2321 6.16609C18.25 6.36867 18.25 6.62428 18.25 6.90057C18.25 6.91081 18.25 6.92108 18.25 6.93137V18.25H21C21.4142 18.25 21.75 18.5858 21.75 19C21.75 19.4142 21.4142 19.75 21 19.75H14C13.5858 19.75 13.25 19.4142 13.25 19C13.25 18.5858 13.5858 18.25 14 18.25H16.75V6.93137C16.75 6.88891 16.75 6.84878 16.7499 6.81081Z"
  />
</svg>`;
var H2Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.9057 6.75035C16.3267 6.802 15.7718 7.01946 15.3049 7.3801C14.8318 7.74548 14.4682 8.24309 14.2591 8.81605C14.1172 9.20517 13.6866 9.40552 13.2975 9.26355C12.9084 9.12157 12.708 8.69103 12.85 8.30191C13.155 7.46589 13.6877 6.73376 14.388 6.19294C15.0884 5.65199 15.927 5.32534 16.8055 5.25346L16.8277 5.25164L16.8499 5.25115C17.8967 5.22771 18.9191 5.56392 19.7537 6.20306C20.5868 6.84102 21.1843 7.74329 21.4548 8.76409C21.7891 9.97619 21.5425 11.1146 21.1354 12.0147C20.7302 12.9106 20.1448 13.6215 19.7055 14.0279L19.6986 14.0343L19.6916 14.0405C18.9491 14.6937 18.1744 15.3076 17.3705 15.88C16.4743 16.5815 15.6527 17.3759 14.9186 18.25H21.2C21.6142 18.25 21.95 18.5858 21.95 19C21.95 19.4142 21.6142 19.75 21.2 19.75H13.5917C12.9084 19.75 12.4943 18.9759 12.9002 18.4076C13.9053 16.9999 15.1041 15.7469 16.4602 14.6877L16.4735 14.6773L16.4872 14.6675C17.2512 14.1242 17.9876 13.5412 18.6934 12.9208C19.0046 12.631 19.4584 12.0827 19.7687 11.3966C20.0787 10.7111 20.2239 9.93968 20.008 9.16007L20.0056 9.15134C19.8193 8.44582 19.4083 7.82782 18.8418 7.394C18.2815 6.965 17.6006 6.73982 16.9057 6.75035Z"
  />
</svg>`;
var H3Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M17.3196 6.75154C16.8178 6.78189 16.3346 6.95347 15.926 7.24657C15.5153 7.54113 15.1968 7.94629 15.0075 8.41487C14.8523 8.79893 14.4152 8.98449 14.0312 8.82933C13.6471 8.67418 13.4616 8.23706 13.6167 7.853C13.9125 7.1209 14.4101 6.48789 15.0517 6.02769C15.6933 5.56749 16.4525 5.29903 17.2408 5.25359L17.2482 5.25316L17.2557 5.25288C18.2533 5.21525 19.2296 5.54803 19.9965 6.18714C20.7634 6.82626 21.2668 7.72652 21.4097 8.71457L21.4143 8.74618L21.4161 8.77807C21.4603 9.53257 21.2968 10.2847 20.9433 10.9528C20.6919 11.4279 20.3514 11.8475 19.9423 12.1898C20.4639 12.4619 20.9143 12.8568 21.2521 13.4177C21.8984 14.4739 21.8675 15.759 21.4573 16.838C21.0461 17.9197 20.2127 18.9107 19.0815 19.378L19.0786 19.3792C18.0333 19.8058 16.8745 19.8662 15.7905 19.5506C14.7065 19.2351 13.7612 18.5621 13.1082 17.6411C12.8686 17.3032 12.9483 16.8351 13.2862 16.5955C13.6241 16.3559 14.0923 16.4356 14.3318 16.7735C14.789 17.4183 15.4508 17.8895 16.2098 18.1104C16.9681 18.3312 17.7789 18.2891 18.5103 17.991C19.1943 17.7079 19.7645 17.0696 20.0552 16.305C20.3467 15.5381 20.3161 14.7606 19.9717 14.199L19.9682 14.1933C19.5426 13.4852 18.7016 13.1471 17.2275 13.1471C17.2201 13.1471 17.2121 13.1471 17.2038 13.1471C17.1523 13.1472 17.0876 13.1473 17.0508 13.1451C17.0439 13.1447 17.0076 13.1426 16.9647 13.1352L16.9637 13.135C16.9524 13.1332 16.865 13.1191 16.7673 13.0722L16.7655 13.0714C16.7295 13.0542 16.547 12.967 16.4309 12.7512C16.3831 12.6425 16.3413 12.3989 16.3519 12.2701C16.3793 12.1601 16.4656 11.9821 16.5164 11.914C16.6196 11.7908 16.7354 11.7347 16.7637 11.721C16.8085 11.6993 16.8465 11.6864 16.8651 11.6805C16.9035 11.6683 16.9346 11.662 16.9457 11.6597C16.9718 11.6545 16.993 11.6517 16.9996 11.6509C17.024 11.6477 17.0535 11.645 17.0677 11.6438L17.0706 11.6435C17.0761 11.643 17.082 11.6425 17.0882 11.6419C17.1709 11.6346 17.3161 11.6217 17.4965 11.597C17.9218 11.5387 18.3862 11.4336 18.6392 11.2811L18.6415 11.2798C19.0547 11.0326 19.3923 10.6769 19.6175 10.2513C19.8377 9.83509 19.9422 9.36767 19.9204 8.89772C19.8245 8.28862 19.5105 7.73468 19.0362 7.33947C18.5557 6.93905 17.9446 6.7298 17.3196 6.75154Z"
  />
</svg>`;
var H4Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M18.1928 5.85878C18.6593 5.15904 19.75 5.48927 19.75 6.33028V14.25H21C21.4142 14.25 21.75 14.5858 21.75 15C21.75 15.4142 21.4142 15.75 21 15.75H19.75V19C19.75 19.4142 19.4142 19.75 19 19.75C18.5858 19.75 18.25 19.4142 18.25 19V15.75H13.1869C12.508 15.75 12.103 14.9934 12.4796 14.4285L18.1928 5.85878ZM18.25 14.25V8.47708L14.4014 14.25H18.25Z"
  />
</svg>`;
var H5Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.9558 5.94948C14.0287 5.5446 14.381 5.25 14.7924 5.25H20.892C21.3062 5.25 21.642 5.58579 21.642 6C21.642 6.41421 21.3062 6.75 20.892 6.75H15.3359L14.677 10.4122C14.7083 10.3958 14.7397 10.3796 14.7713 10.3638C15.4506 10.0234 16.193 9.8296 16.9512 9.79502L16.9745 9.79396L16.9978 9.79435C18.0629 9.81203 19.0907 10.1881 19.9189 10.8615C20.743 11.5316 21.3224 12.4578 21.5681 13.4941C21.8521 14.5302 21.8025 15.6309 21.4262 16.6371C21.048 17.6482 20.3593 18.512 19.4591 19.1014L19.4463 19.1098L19.4332 19.1176C17.1285 20.4957 13.8824 19.5672 12.3514 16.9306C12.1434 16.5724 12.2652 16.1134 12.6234 15.9054C12.9816 15.6974 13.4406 15.8192 13.6486 16.1774C14.8123 18.1815 17.1546 18.7212 18.6504 17.838C19.2754 17.4248 19.756 16.8207 20.0213 16.1116C20.2883 15.3975 20.3225 14.6155 20.1186 13.8802L20.1145 13.8654L20.1111 13.8506C19.9425 13.1297 19.5413 12.4877 18.9726 12.0253C18.41 11.5679 17.7152 11.3117 16.996 11.2946C16.4565 11.3225 15.928 11.462 15.4433 11.7049C15.047 11.9035 14.6868 12.1677 14.3774 12.4863C14.075 12.7978 13.6591 12.7916 13.385 12.6587C13.1072 12.524 12.8336 12.1871 12.9141 11.7396L13.9558 5.94948Z"
  />
</svg>`;
var H6Icon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3 4.25C3.41421 4.25 3.75 4.58579 3.75 5V11.25H10.25V5C10.25 4.58579 10.5858 4.25 11 4.25C11.4142 4.25 11.75 4.58579 11.75 5V19C11.75 19.4142 11.4142 19.75 11 19.75C10.5858 19.75 10.25 19.4142 10.25 19V12.75H3.75V19C3.75 19.4142 3.41421 19.75 3 19.75C2.58579 19.75 2.25 19.4142 2.25 19V5C2.25 4.58579 2.58579 4.25 3 4.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M15.8428 6.08001C16.5038 5.78482 17.221 5.63827 17.9443 5.65076L17.9528 5.65091L17.9612 5.65124C18.6652 5.67922 19.3558 5.85344 19.9894 6.16278C20.6596 6.48991 21.0427 6.86843 21.4674 7.36832C21.7355 7.68402 21.697 8.15733 21.3813 8.42549C21.0656 8.69365 20.5923 8.65511 20.3241 8.33942C19.9679 7.92001 19.7421 7.71121 19.3314 7.51075C18.8869 7.29373 18.4031 7.17116 17.91 7.1504C17.4093 7.14298 16.9127 7.245 16.4544 7.44965C15.9982 7.65337 15.5906 7.95407 15.2596 8.3315C14.8157 8.89075 14.4914 9.53705 14.3076 10.2297C14.1125 10.9831 13.997 11.753 13.9617 12.5269C14.7663 11.5406 15.9873 10.9103 17.3576 10.9103C19.7888 10.9103 21.75 12.8945 21.75 15.3302C21.75 17.7659 19.7888 19.75 17.3576 19.75C15.6443 19.75 14.1643 18.7645 13.4398 17.3301C13.0351 16.5834 12.7496 15.7772 12.5937 14.9411L12.5912 14.9278L12.5892 14.9144C12.3372 13.226 12.428 11.5036 12.856 9.85144L12.8571 9.84743C13.0954 8.94816 13.5178 8.10867 14.0975 7.38296L14.1072 7.37079L14.1174 7.35903C14.5931 6.81178 15.1818 6.37518 15.8428 6.08001ZM14.821 16.7346C15.3136 17.6393 16.2672 18.25 17.3576 18.25C18.9497 18.25 20.25 16.9481 20.25 15.3302C20.25 13.7122 18.9497 12.4103 17.3576 12.4103C15.7655 12.4103 14.4652 13.7122 14.4652 15.3302C14.4652 15.7995 14.5747 16.2423 14.7689 16.6344C14.7763 16.6478 14.7836 16.6612 14.791 16.6746C14.802 16.6943 14.812 16.7143 14.821 16.7346Z"
  />
</svg>`;
var BulletedListSVG = svg`<path
  fill-rule="evenodd"
  clip-rule="evenodd"
  d="M3 6.5C3 5.83266 3.54099 5.29167 4.20833 5.29167C4.87568 5.29167 5.41667 5.83265 5.41667 6.5C5.41667 7.16734 4.87568 7.70833 4.20833 7.70833C3.54099 7.70833 3 7.16734 3 6.5ZM7.58333 6.50057C7.58336 6.08636 7.91916 5.75059 8.33337 5.75061L20.25 5.75127C20.6642 5.7513 21 6.0871 21 6.50131C21 6.91553 20.6641 7.2513 20.2499 7.25127L8.33329 7.25061C7.91908 7.25059 7.58331 6.91478 7.58333 6.50057ZM3 12C3 11.3327 3.54099 10.7917 4.20833 10.7917C4.87568 10.7917 5.41667 11.3327 5.41667 12C5.41667 12.6673 4.87568 13.2083 4.20833 13.2083C3.54099 13.2083 3 12.6673 3 12ZM7.58333 12.0006C7.58336 11.5864 7.91916 11.2506 8.33338 11.2507L20.2501 11.2514C20.6643 11.2514 21.0001 11.5872 21 12.0014C21 12.4156 20.6642 12.7514 20.25 12.7514L8.33329 12.7507C7.91907 12.7506 7.58331 12.4148 7.58333 12.0006ZM3 17.5C3 16.8327 3.54099 16.2917 4.20833 16.2917C4.87568 16.2917 5.41667 16.8327 5.41667 17.5C5.41667 18.1673 4.87568 18.7083 4.20833 18.7083C3.54099 18.7083 3 18.1673 3 17.5ZM7.58333 17.5006C7.58336 17.0864 7.91916 16.7506 8.33338 16.7507L20.2501 16.7514C20.6643 16.7514 21 17.0872 21 17.5014C21 17.9156 20.6642 18.2514 20.25 18.2514L8.33329 18.2507C7.91907 18.2506 7.58331 17.9148 7.58333 17.5006Z"
/>`;
var BulletedListIcon = icon(BulletedListSVG, 20);
var BulletedListIconLarge = icon(BulletedListSVG, 24);
var NumberedListIconLarge = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.97755 4.02864C6.19866 4.16529 6.33325 4.40669 6.33325 4.66663V9.41663H7.41659C7.8308 9.41663 8.16659 9.75241 8.16659 10.1666C8.16659 10.5808 7.8308 10.9166 7.41659 10.9166H3.74992C3.33571 10.9166 2.99992 10.5808 2.99992 10.1666C2.99992 9.75241 3.33571 9.41663 3.74992 9.41663H4.83325V5.88015L4.08533 6.25411C3.71485 6.43936 3.26434 6.28919 3.0791 5.9187C2.89386 5.54822 3.04403 5.09772 3.41451 4.91247L5.24784 3.99581C5.48033 3.87956 5.75644 3.89198 5.97755 4.02864ZM9.41659 6.49991C9.41661 6.0857 9.75242 5.74994 10.1666 5.74996L20.25 5.75057C20.6642 5.75059 20.9999 6.0864 20.9999 6.50061C20.9999 6.91483 20.6641 7.25059 20.2499 7.25057L10.1665 7.24996C9.75233 7.24994 9.41656 6.91413 9.41659 6.49991ZM9.41659 11.9999C9.41661 11.5857 9.75242 11.2499 10.1666 11.25L20.25 11.2506C20.6642 11.2506 20.9999 11.5864 20.9999 12.0006C20.9999 12.4148 20.6641 12.7506 20.2499 12.7506L10.1665 12.75C9.75233 12.7499 9.41656 12.4141 9.41659 11.9999ZM5.58325 14.5833C5.07949 14.5833 4.65431 14.9278 4.53401 15.3952C4.43076 15.7964 4.02187 16.0379 3.62073 15.9346C3.21959 15.8314 2.9781 15.4225 3.08135 15.0213C3.36809 13.9073 4.3785 13.0833 5.58325 13.0833H5.84022C7.12504 13.0833 8.16659 14.1248 8.16659 15.4097C8.16659 16.0805 7.877 16.7187 7.37215 17.1604L5.74601 18.5833H7.41659C7.8308 18.5833 8.16659 18.9191 8.16659 19.3333C8.16659 19.7475 7.8308 20.0833 7.41659 20.0833H3.74992C3.43746 20.0833 3.15774 19.8896 3.04784 19.5971C2.93794 19.3046 3.02089 18.9746 3.25604 18.7689L6.38439 16.0316C6.56372 15.8746 6.66659 15.6479 6.66659 15.4097C6.66659 14.9533 6.29661 14.5833 5.84022 14.5833H5.58325ZM9.41659 17.4999C9.41661 17.0857 9.75242 16.7499 10.1666 16.75L20.25 16.7506C20.6642 16.7506 20.9999 17.0864 20.9999 17.5006C20.9999 17.9148 20.6641 18.2506 20.2499 18.2506L10.1665 18.25C9.75233 18.2499 9.41656 17.9141 9.41659 17.4999Z"
  />
</svg>`;
var NumberedListIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.97763 4.02868C6.19874 4.16533 6.33333 4.40673 6.33333 4.66667V9.41667H7.41666C7.83088 9.41667 8.16666 9.75245 8.16666 10.1667C8.16666 10.5809 7.83088 10.9167 7.41666 10.9167H3.75C3.33578 10.9167 3 10.5809 3 10.1667C3 9.75245 3.33578 9.41667 3.75 9.41667H4.83333V5.88019L4.08541 6.25415C3.71492 6.4394 3.26442 6.28923 3.07918 5.91874C2.89393 5.54826 3.0441 5.09776 3.41459 4.91251L5.24792 3.99585C5.48041 3.8796 5.75652 3.89202 5.97763 4.02868ZM9.41666 6.49995C9.41669 6.08574 9.7525 5.74998 10.1667 5.75L20.25 5.75061C20.6643 5.75063 21 6.08644 21 6.50065C21 6.91487 20.6642 7.25063 20.25 7.25061L10.1666 7.25C9.75241 7.24998 9.41664 6.91417 9.41666 6.49995ZM9.41666 12C9.41669 11.5857 9.7525 11.25 10.1667 11.25L20.25 11.2506C20.6643 11.2506 21 11.5864 21 12.0007C21 12.4149 20.6642 12.7506 20.25 12.7506L10.1666 12.75C9.75241 12.75 9.41664 12.4142 9.41666 12ZM5.58333 14.5833C5.07957 14.5833 4.65439 14.9279 4.53408 15.3953C4.43084 15.7964 4.02195 16.0379 3.62081 15.9347C3.21967 15.8314 2.97818 15.4225 3.08143 15.0214C3.36816 13.9073 4.37857 13.0833 5.58333 13.0833H5.8403C7.12512 13.0833 8.16666 14.1249 8.16666 15.4097C8.16666 16.0805 7.87708 16.7187 7.37222 17.1605L5.74608 18.5833H7.41666C7.83088 18.5833 8.16666 18.9191 8.16666 19.3333C8.16666 19.7475 7.83088 20.0833 7.41666 20.0833H3.75C3.43754 20.0833 3.15782 19.8896 3.04792 19.5971C2.93802 19.3046 3.02097 18.9747 3.25612 18.7689L6.38446 16.0316C6.5638 15.8747 6.66666 15.648 6.66666 15.4097C6.66666 14.9533 6.29669 14.5833 5.8403 14.5833H5.58333ZM9.41666 17.5C9.41669 17.0857 9.7525 16.75 10.1667 16.75L20.25 16.7506C20.6643 16.7506 21 17.0864 21 17.5007C21 17.9149 20.6642 18.2506 20.25 18.2506L10.1666 18.25C9.75241 18.25 9.41664 17.9142 9.41666 17.5Z"
  />
</svg>`;
var DatabaseTableViewIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.1728 4.25H17.8272C18.3641 4.24999 18.8067 4.24999 19.1671 4.27575C19.5398 4.3024 19.8854 4.35951 20.2134 4.50573C20.721 4.73207 21.1527 5.10167 21.4301 5.57811C21.6157 5.89681 21.6871 6.23393 21.7195 6.58088C21.75 6.90782 21.75 7.30509 21.75 7.76685V16.2331C21.75 16.6949 21.75 17.0922 21.7195 17.4191C21.6871 17.7661 21.6157 18.1032 21.4301 18.4219C21.1527 18.8983 20.721 19.2679 20.2134 19.4943C19.8854 19.6405 19.5398 19.6976 19.1671 19.7242C18.8067 19.75 18.3641 19.75 17.8272 19.75H6.1728C5.63587 19.75 5.19332 19.75 4.83292 19.7242C4.46022 19.6976 4.1146 19.6405 3.78662 19.4943C3.27896 19.2679 2.8473 18.8983 2.56987 18.4219C2.38428 18.1032 2.31289 17.7661 2.2805 17.4191C2.24997 17.0922 2.24998 16.6949 2.25 16.2331V7.76689C2.24998 7.30511 2.24997 6.90783 2.2805 6.58088C2.31289 6.23393 2.38428 5.89681 2.56987 5.57811C2.8473 5.10167 3.27896 4.73207 3.78662 4.50573C4.1146 4.35951 4.46022 4.3024 4.83292 4.27575C5.19332 4.24999 5.63586 4.24999 6.1728 4.25ZM3.75 10.125V16.2C3.75 16.7042 3.75076 17.0308 3.774 17.2797C3.7961 17.5164 3.83371 17.6114 3.86611 17.6671C3.97217 17.8492 4.15244 18.015 4.39742 18.1243C4.49727 18.1688 4.64558 18.207 4.93989 18.2281C5.24043 18.2496 5.62911 18.25 6.2 18.25H7.25V10.125H3.75ZM3.75 8.625V7.8C3.75 7.29583 3.75076 6.96922 3.774 6.72033C3.7961 6.48364 3.83371 6.38857 3.86611 6.33293C3.97217 6.1508 4.15243 5.98497 4.39742 5.87574C4.49727 5.83123 4.64558 5.79297 4.93989 5.77193C5.24043 5.75045 5.62911 5.75 6.2 5.75H17.8C18.3709 5.75 18.7596 5.75045 19.0601 5.77193C19.3544 5.79297 19.5027 5.83123 19.6026 5.87574C19.8476 5.98497 20.0278 6.1508 20.1339 6.33293C20.1663 6.38857 20.2039 6.48364 20.226 6.72033C20.2492 6.96922 20.25 7.29583 20.25 7.8V8.625H3.75ZM8.75 10.125V18.25H17.8C18.3709 18.25 18.7596 18.2496 19.0601 18.2281C19.3544 18.207 19.5027 18.1688 19.6026 18.1243C19.8476 18.015 20.0278 17.8492 20.1339 17.6671C20.1663 17.6114 20.2039 17.5164 20.226 17.2797C20.2492 17.0308 20.25 16.7042 20.25 16.2V10.125H8.75Z"
  />
</svg>`;
var DatabaseKanbanViewIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.25 8.4C5.25 7.76487 5.76487 7.25 6.4 7.25H10.1C10.7351 7.25 11.25 7.76487 11.25 8.4V15.6C11.25 16.2351 10.7351 16.75 10.1 16.75H6.4C5.76487 16.75 5.25 16.2351 5.25 15.6V8.4ZM6.75 8.75V15.25H9.75V8.75H6.75Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12.75 8.4C12.75 7.76487 13.2649 7.25 13.9 7.25H17.6C18.2351 7.25 18.75 7.76487 18.75 8.4V13.6C18.75 14.2351 18.2351 14.75 17.6 14.75H13.9C13.2649 14.75 12.75 14.2351 12.75 13.6V8.4ZM14.25 8.75V13.25H17.25V8.75H14.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.25 7C2.25 5.48122 3.48122 4.25 5 4.25H19C20.5188 4.25 21.75 5.48122 21.75 7V17C21.75 18.5188 20.5188 19.75 19 19.75H5C3.48122 19.75 2.25 18.5188 2.25 17V7ZM5 5.75C4.30964 5.75 3.75 6.30964 3.75 7V17C3.75 17.6904 4.30964 18.25 5 18.25H19C19.6904 18.25 20.25 17.6904 20.25 17V7C20.25 6.30964 19.6904 5.75 19 5.75H5Z"
  />
</svg>`;
var TodoIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 6.28571C3.25 4.60914 4.60914 3.25 6.28571 3.25H17.7143C19.3909 3.25 20.75 4.60914 20.75 6.28571V17.7143C20.75 19.3909 19.3909 20.75 17.7143 20.75H6.28571C4.60914 20.75 3.25 19.3909 3.25 17.7143V6.28571ZM6.28571 4.75C5.43756 4.75 4.75 5.43756 4.75 6.28571V17.7143C4.75 18.5624 5.43756 19.25 6.28571 19.25H17.7143C18.5624 19.25 19.25 18.5624 19.25 17.7143V6.28571C19.25 5.43756 18.5624 4.75 17.7143 4.75H6.28571Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.5068 8.44713C16.8121 8.72703 16.8328 9.20145 16.5529 9.50679L11.0529 15.5068C10.9146 15.6576 10.7208 15.7454 10.5163 15.7498C10.3118 15.7543 10.1143 15.675 9.96967 15.5303L7.46967 13.0303C7.17678 12.7374 7.17678 12.2626 7.46967 11.9697C7.76256 11.6768 8.23744 11.6768 8.53033 11.9697L10.4764 13.9158L15.4471 8.49321C15.727 8.18787 16.2015 8.16724 16.5068 8.44713Z"
  />
</svg>`;
var CodeBlockIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.16957 4.25H17.8304C18.3646 4.24999 18.8104 4.24998 19.1747 4.27974C19.5546 4.31078 19.9112 4.37789 20.2485 4.54973C20.7659 4.81339 21.1866 5.23408 21.4503 5.75153C21.6221 6.08879 21.6892 6.44545 21.7203 6.82533C21.75 7.18956 21.75 7.6354 21.75 8.16955V15.8305C21.75 16.3646 21.75 16.8104 21.7203 17.1747C21.6892 17.5546 21.6221 17.9112 21.4503 18.2485C21.1866 18.7659 20.7659 19.1866 20.2485 19.4503C19.9112 19.6221 19.5546 19.6892 19.1747 19.7203C18.8104 19.75 18.3646 19.75 17.8305 19.75H6.16955C5.6354 19.75 5.18956 19.75 4.82533 19.7203C4.44545 19.6892 4.08879 19.6221 3.75153 19.4503C3.23408 19.1866 2.81338 18.7659 2.54973 18.2485C2.37789 17.9112 2.31078 17.5546 2.27974 17.1747C2.24998 16.8104 2.24999 16.3646 2.25 15.8304V8.16957C2.24999 7.63541 2.24998 7.18956 2.27974 6.82533C2.31078 6.44545 2.37789 6.08879 2.54973 5.75153C2.81338 5.23408 3.23408 4.81338 3.75153 4.54973C4.08879 4.37789 4.44545 4.31078 4.82533 4.27974C5.18956 4.24998 5.63541 4.24999 6.16957 4.25ZM4.94748 5.77476C4.66036 5.79822 4.52307 5.8401 4.43251 5.88624C4.19731 6.00608 4.00608 6.19731 3.88624 6.43251C3.8401 6.52307 3.79822 6.66036 3.77476 6.94748C3.75058 7.24336 3.75 7.62757 3.75 8.2V15.8C3.75 16.3724 3.75058 16.7566 3.77476 17.0525C3.79822 17.3396 3.8401 17.4769 3.88624 17.5675C4.00608 17.8027 4.19731 17.9939 4.43251 18.1138C4.52307 18.1599 4.66036 18.2018 4.94748 18.2252C5.24336 18.2494 5.62757 18.25 6.2 18.25H17.8C18.3724 18.25 18.7566 18.2494 19.0525 18.2252C19.3396 18.2018 19.4769 18.1599 19.5675 18.1138C19.8027 17.9939 19.9939 17.8027 20.1138 17.5675C20.1599 17.4769 20.2018 17.3396 20.2252 17.0525C20.2494 16.7566 20.25 16.3724 20.25 15.8V8.2C20.25 7.62757 20.2494 7.24336 20.2252 6.94748C20.2018 6.66036 20.1599 6.52307 20.1138 6.43251C19.9939 6.19731 19.8027 6.00608 19.5675 5.88624C19.4769 5.8401 19.3396 5.79822 19.0525 5.77476C18.7566 5.75058 18.3724 5.75 17.8 5.75H6.2C5.62757 5.75 5.24336 5.75058 4.94748 5.77476Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M10.5303 8.46967C10.8232 8.76256 10.8232 9.23744 10.5303 9.53033L8.06066 12L10.5303 14.4697C10.8232 14.7626 10.8232 15.2374 10.5303 15.5303C10.2374 15.8232 9.76256 15.8232 9.46967 15.5303L6.46967 12.5303C6.17678 12.2374 6.17678 11.7626 6.46967 11.4697L9.46967 8.46967C9.76256 8.17678 10.2374 8.17678 10.5303 8.46967ZM13.4697 8.46967C13.7626 8.17678 14.2374 8.17678 14.5303 8.46967L17.5303 11.4697C17.8232 11.7626 17.8232 12.2374 17.5303 12.5303L14.5303 15.5303C14.2374 15.8232 13.7626 15.8232 13.4697 15.5303C13.1768 15.2374 13.1768 14.7626 13.4697 14.4697L15.9393 12L13.4697 9.53033C13.1768 9.23744 13.1768 8.76256 13.4697 8.46967Z"
  />
</svg>`;
var QuoteIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.75 4C4.16421 4 4.5 4.33579 4.5 4.75L4.5 19.25C4.5 19.6642 4.16421 20 3.75 20C3.33579 20 3 19.6642 3 19.25L3 4.75C3 4.33579 3.33579 4 3.75 4Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M19 6.75C19 7.16421 18.6642 7.5 18.25 7.5H7.75C7.33579 7.5 7 7.16421 7 6.75C7 6.33579 7.33579 6 7.75 6H18.25C18.6642 6 19 6.33579 19 6.75Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M17 11.75C17 12.1642 16.6642 12.5 16.25 12.5H7.75C7.33579 12.5 7 12.1642 7 11.75C7 11.3358 7.33579 11 7.75 11H16.25C16.6642 11 17 11.3358 17 11.75Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M21 16.75C21 17.1642 20.6642 17.5 20.25 17.5H7.75C7.33579 17.5 7 17.1642 7 16.75C7 16.3358 7.33579 16 7.75 16H20.25C20.6642 16 21 16.3358 21 16.75Z"
  />
</svg>`;
var DividerIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 12C3.25 11.5858 3.58579 11.25 4 11.25H4.94118C5.35539 11.25 5.69118 11.5858 5.69118 12C5.69118 12.4142 5.35539 12.75 4.94118 12.75H4C3.58579 12.75 3.25 12.4142 3.25 12ZM7.01471 12C7.01471 11.5858 7.35049 11.25 7.76471 11.25H8.70588C9.1201 11.25 9.45588 11.5858 9.45588 12C9.45588 12.4142 9.1201 12.75 8.70588 12.75H7.76471C7.35049 12.75 7.01471 12.4142 7.01471 12ZM10.7794 12C10.7794 11.5858 11.1152 11.25 11.5294 11.25H12.4706C12.8848 11.25 13.2206 11.5858 13.2206 12C13.2206 12.4142 12.8848 12.75 12.4706 12.75H11.5294C11.1152 12.75 10.7794 12.4142 10.7794 12ZM14.5441 12C14.5441 11.5858 14.8799 11.25 15.2941 11.25H16.2353C16.6495 11.25 16.9853 11.5858 16.9853 12C16.9853 12.4142 16.6495 12.75 16.2353 12.75H15.2941C14.8799 12.75 14.5441 12.4142 14.5441 12ZM18.3088 12C18.3088 11.5858 18.6446 11.25 19.0588 11.25H20C20.4142 11.25 20.75 11.5858 20.75 12C20.75 12.4142 20.4142 12.75 20 12.75H19.0588C18.6446 12.75 18.3088 12.4142 18.3088 12Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4 4.25C4.41421 4.25 4.75 4.58579 4.75 5V6.59459C4.75 7.1261 5.1896 7.57432 5.75343 7.57432H18.2466C18.8104 7.57432 19.25 7.1261 19.25 6.59459V5C19.25 4.58579 19.5858 4.25 20 4.25C20.4142 4.25 20.75 4.58579 20.75 5V6.59459C20.75 7.9737 19.6195 9.07432 18.2466 9.07432H5.75343C4.38048 9.07432 3.25 7.9737 3.25 6.59459V5C3.25 4.58579 3.58579 4.25 4 4.25ZM5.75342 16.4257C5.1896 16.4257 4.75 16.8739 4.75 17.4054V19C4.75 19.4142 4.41421 19.75 4 19.75C3.58579 19.75 3.25 19.4142 3.25 19V17.4054C3.25 16.0263 4.38047 14.9257 5.75342 14.9257L18.2466 14.9257C19.6195 14.9257 20.75 16.0263 20.75 17.4054V19C20.75 19.4142 20.4142 19.75 20 19.75C19.5858 19.75 19.25 19.4142 19.25 19V17.4054C19.25 16.8739 18.8104 16.4257 18.2466 16.4257L5.75342 16.4257Z"
  />
</svg>`;
var BoldIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.25 4C6.25 3.58579 6.58579 3.25 7 3.25H12.9583C15.6288 3.25 17.8333 5.35506 17.8333 8C17.8333 9.51519 17.1099 10.8532 15.9898 11.7198C17.6162 12.484 18.75 14.1032 18.75 16C18.75 18.6449 16.5455 20.75 13.875 20.75H7C6.58579 20.75 6.25 20.4142 6.25 20V4ZM7.75 12.75V19.25H13.875C15.7609 19.25 17.25 17.7733 17.25 16C17.25 14.2267 15.7609 12.75 13.875 12.75H7.75ZM7.75 11.25H12.9583C14.8442 11.25 16.3333 9.77334 16.3333 8C16.3333 6.22666 14.8442 4.75 12.9583 4.75H7.75V11.25Z"
  />
</svg>`;
var ItalicIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.6075 3.25H10.25C9.83579 3.25 9.5 3.58579 9.5 4C9.5 4.41421 9.83579 4.75 10.25 4.75H13.5896L8.83175 19.25H5C4.58579 19.25 4.25 19.5858 4.25 20C4.25 20.4142 4.58579 20.75 5 20.75H9.35778C9.36938 20.7503 9.38095 20.7503 9.39249 20.75H13.75C14.1642 20.75 14.5 20.4142 14.5 20C14.5 19.5858 14.1642 19.25 13.75 19.25H10.4104L15.1682 4.75H19C19.4142 4.75 19.75 4.41421 19.75 4C19.75 3.58579 19.4142 3.25 19 3.25H14.6422C14.6306 3.24973 14.619 3.24973 14.6075 3.25Z"
  />
</svg>`;
var UnderlineIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.25 4C4.25 3.58579 4.58579 3.25 5 3.25H8.5C8.91421 3.25 9.25 3.58579 9.25 4C9.25 4.41421 8.91421 4.75 8.5 4.75H7.48717C7.49559 4.79501 7.5 4.84143 7.5 4.88889V11.1111C7.5 13.6536 9.52581 15.6944 12 15.6944C14.4742 15.6944 16.5 13.6536 16.5 11.1111V4.88889C16.5 4.84143 16.5044 4.79501 16.5128 4.75H15.5C15.0858 4.75 14.75 4.41421 14.75 4C14.75 3.58579 15.0858 3.25 15.5 3.25H19C19.4142 3.25 19.75 3.58579 19.75 4C19.75 4.41421 19.4142 4.75 19 4.75H17.9872C17.9956 4.79501 18 4.84143 18 4.88889V11.1111C18 14.4597 15.3248 17.1944 12 17.1944C8.6752 17.1944 6 14.4597 6 11.1111V4.88889C6 4.84143 6.00441 4.79501 6.01283 4.75H5C4.58579 4.75 4.25 4.41421 4.25 4ZM4.25 20C4.25 19.5858 4.58579 19.25 5 19.25H19C19.4142 19.25 19.75 19.5858 19.75 20C19.75 20.4142 19.4142 20.75 19 20.75H5C4.58579 20.75 4.25 20.4142 4.25 20Z"
  />
</svg>`;
var StrikethroughIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.02778 8C5.02778 5.37665 7.15442 3.25 9.77778 3.25H14.3889C16.9202 3.25 18.9722 5.30203 18.9722 7.83333V8C18.9722 8.41421 18.6364 8.75 18.2222 8.75C17.808 8.75 17.4722 8.41421 17.4722 8V7.83333C17.4722 6.13046 16.0918 4.75 14.3889 4.75H9.77778C7.98285 4.75 6.52778 6.20507 6.52778 8C6.52778 9.79493 7.98285 11.25 9.77778 11.25H20C20.4142 11.25 20.75 11.5858 20.75 12C20.75 12.4142 20.4142 12.75 20 12.75H17.6863C18.4838 13.5997 18.9722 14.7428 18.9722 16C18.9722 18.6234 16.8456 20.75 14.2222 20.75H9.69444C7.11712 20.75 5.02778 18.6607 5.02778 16.0833V16C5.02778 15.5858 5.36356 15.25 5.77778 15.25C6.19199 15.25 6.52778 15.5858 6.52778 16V16.0833C6.52778 17.8322 7.94554 19.25 9.69444 19.25H14.2222C16.0171 19.25 17.4722 17.7949 17.4722 16C17.4722 14.2051 16.0171 12.75 14.2222 12.75H4C3.58579 12.75 3.25 12.4142 3.25 12C3.25 11.5858 3.58579 11.25 4 11.25H6.31366C5.5162 10.4003 5.02778 9.25721 5.02778 8Z"
  />
</svg>`;
var InlineCodeIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.1819 3.27239C14.5837 3.37285 14.8281 3.78006 14.7276 4.1819L10.7276 20.1819C10.6271 20.5837 10.2199 20.8281 9.8181 20.7276C9.41625 20.6271 9.17193 20.2199 9.27239 19.8181L13.2724 3.8181C13.3729 3.41625 13.7801 3.17193 14.1819 3.27239ZM7.5511 7.49129C7.83206 7.79566 7.81308 8.27015 7.50871 8.5511L4.06145 11.7332L7.5496 15.4897C7.83145 15.7932 7.81387 16.2677 7.51034 16.5496C7.20681 16.8314 6.73226 16.8139 6.45041 16.5103L2.45041 12.2026C2.31479 12.0566 2.24289 11.8626 2.25056 11.6634C2.25823 11.4643 2.34485 11.2764 2.49129 11.1412L6.49129 7.4489C6.79566 7.16794 7.27015 7.18692 7.5511 7.49129ZM16.4489 7.49129C16.7299 7.18692 17.2043 7.16794 17.5087 7.4489L21.5087 11.1412C21.6552 11.2764 21.7418 11.4643 21.7494 11.6634C21.7571 11.8626 21.6852 12.0566 21.5496 12.2026L17.5496 16.5103C17.2677 16.8139 16.7932 16.8314 16.4897 16.5496C16.1861 16.2677 16.1686 15.7932 16.4504 15.4897L19.9386 11.7332L16.4913 8.5511C16.1869 8.27015 16.1679 7.79566 16.4489 7.49129Z"
  />
</svg>`;
var LinkSVG = svg`<path
  fill-rule="evenodd"
  clip-rule="evenodd"
  d="M12.8423 4.60675C14.6513 2.79775 17.5842 2.79775 19.3932 4.60676C21.2023 6.41576 21.2023 9.34874 19.3932 11.1577L17.3344 13.2166C17.0415 13.5095 16.5666 13.5095 16.2737 13.2166C15.9808 12.9237 15.9808 12.4489 16.2737 12.156L18.3326 10.0971C19.5558 8.87387 19.5558 6.89064 18.3326 5.66742C17.1094 4.4442 15.1261 4.44419 13.9029 5.66741L11.1577 8.41258C9.93453 9.6358 9.93453 11.619 11.1577 12.8423C11.3498 13.0343 11.5596 13.1955 11.7816 13.3266C12.1382 13.5373 12.2566 13.9971 12.046 14.3538C11.8353 14.7104 11.3754 14.8288 11.0188 14.6182C10.6891 14.4235 10.379 14.1849 10.0971 13.9029C8.28808 12.0939 8.28808 9.16093 10.0971 7.35192L12.8423 4.60675ZM11.954 9.64621C12.1647 9.28955 12.6246 9.17119 12.9812 9.38183C13.3109 9.57652 13.621 9.81515 13.9029 10.0971C15.7119 11.9061 15.7119 14.8391 13.9029 16.6481L11.1577 19.3932C9.34874 21.2023 6.41576 21.2023 4.60675 19.3932C2.79775 17.5842 2.79775 14.6513 4.60675 12.8423L6.66563 10.7834C6.95852 10.4905 7.4334 10.4905 7.72629 10.7834C8.01918 11.0763 8.01918 11.5511 7.72629 11.844L5.66741 13.9029C4.4442 15.1261 4.4442 17.1094 5.66742 18.3326C6.89064 19.5558 8.87387 19.5558 10.0971 18.3326L12.8423 15.5874C14.0655 14.3642 14.0655 12.381 12.8423 11.1577C12.6502 10.9657 12.4404 10.8045 12.2184 10.6734C11.8618 10.4627 11.7434 10.0029 11.954 9.64621Z"
/>`;
var LinkIcon = icon(LinkSVG, 20);
var FontLinkIcon = fontIcon(LinkSVG);
var CopyIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11.1696 3.25H16.8304C17.3646 3.24999 17.8104 3.24998 18.1747 3.27974C18.5546 3.31078 18.9112 3.37789 19.2485 3.54973C19.7659 3.81338 20.1866 4.23408 20.4503 4.75153C20.6221 5.08879 20.6892 5.44545 20.7203 5.82533C20.75 6.18956 20.75 6.6354 20.75 7.16955V12.8305C20.75 13.3646 20.75 13.8104 20.7203 14.1747C20.6892 14.5546 20.6221 14.9112 20.4503 15.2485C20.1866 15.7659 19.7659 16.1866 19.2485 16.4503C18.9112 16.6221 18.5546 16.6892 18.1747 16.7203C17.8104 16.75 17.3646 16.75 16.8305 16.75H16.75V16.8305C16.75 17.3646 16.75 17.8104 16.7203 18.1747C16.6892 18.5546 16.6221 18.9112 16.4503 19.2485C16.1866 19.7659 15.7659 20.1866 15.2485 20.4503C14.9112 20.6221 14.5546 20.6892 14.1747 20.7203C13.8104 20.75 13.3646 20.75 12.8305 20.75H7.16955C6.6354 20.75 6.18956 20.75 5.82533 20.7203C5.44545 20.6892 5.08879 20.6221 4.75153 20.4503C4.23408 20.1866 3.81338 19.7659 3.54973 19.2485C3.37789 18.9112 3.31078 18.5546 3.27974 18.1747C3.24998 17.8104 3.24999 17.3646 3.25 16.8304V11.1696C3.24999 10.6354 3.24998 10.1896 3.27974 9.82533C3.31078 9.44545 3.37789 9.08879 3.54973 8.75153C3.81338 8.23408 4.23408 7.81339 4.75153 7.54973C5.08879 7.37789 5.44545 7.31078 5.82533 7.27974C6.18957 7.24998 6.63542 7.24999 7.16957 7.25L7.25 7.25L7.25 7.16957C7.24999 6.63542 7.24998 6.18957 7.27974 5.82533C7.31078 5.44545 7.37789 5.08879 7.54973 4.75153C7.81339 4.23408 8.23408 3.81338 8.75153 3.54973C9.08879 3.37789 9.44545 3.31078 9.82533 3.27974C10.1896 3.24998 10.6354 3.24999 11.1696 3.25ZM7.25 8.75H7.2C6.62757 8.75 6.24336 8.75058 5.94748 8.77476C5.66036 8.79822 5.52307 8.8401 5.43251 8.88624C5.19731 9.00608 5.00608 9.19731 4.88624 9.43251C4.8401 9.52307 4.79822 9.66036 4.77476 9.94748C4.75058 10.2434 4.75 10.6276 4.75 11.2V16.8C4.75 17.3724 4.75058 17.7566 4.77476 18.0525C4.79822 18.3396 4.8401 18.4769 4.88624 18.5675C5.00608 18.8027 5.19731 18.9939 5.43251 19.1138C5.52307 19.1599 5.66036 19.2018 5.94748 19.2252C6.24336 19.2494 6.62757 19.25 7.2 19.25H12.8C13.3724 19.25 13.7566 19.2494 14.0525 19.2252C14.3396 19.2018 14.4769 19.1599 14.5675 19.1138C14.8027 18.9939 14.9939 18.8027 15.1138 18.5675C15.1599 18.4769 15.2018 18.3396 15.2252 18.0525C15.2494 17.7566 15.25 17.3724 15.25 16.8V16.75H11.1695C10.6354 16.75 10.1896 16.75 9.82533 16.7203C9.44545 16.6892 9.08879 16.6221 8.75153 16.4503C8.23408 16.1866 7.81339 15.7659 7.54973 15.2485C7.37789 14.9112 7.31078 14.5546 7.27974 14.1747C7.24998 13.8104 7.24999 13.3646 7.25 12.8304L7.25 8.75ZM11.2 15.25C10.6276 15.25 10.2434 15.2494 9.94748 15.2252C9.66036 15.2018 9.52307 15.1599 9.43251 15.1138C9.19731 14.9939 9.00608 14.8027 8.88624 14.5675C8.8401 14.4769 8.79822 14.3396 8.77476 14.0525C8.75058 13.7566 8.75 13.3724 8.75 12.8V7.2C8.75 6.62757 8.75058 6.24336 8.77476 5.94748C8.79822 5.66036 8.8401 5.52307 8.88624 5.43251C9.00608 5.19731 9.19731 5.00608 9.43251 4.88624C9.52307 4.8401 9.66036 4.79822 9.94748 4.77476C10.2434 4.75058 10.6276 4.75 11.2 4.75H16.8C17.3724 4.75 17.7566 4.75058 18.0525 4.77476C18.3396 4.79822 18.4769 4.8401 18.5675 4.88624C18.8027 5.00608 18.9939 5.19731 19.1138 5.43251C19.1599 5.52307 19.2018 5.66036 19.2252 5.94748C19.2494 6.24336 19.25 6.62757 19.25 7.2V12.8C19.25 13.3724 19.2494 13.7566 19.2252 14.0525C19.2018 14.3396 19.1599 14.4769 19.1138 14.5675C18.9939 14.8027 18.8027 14.9939 18.5675 15.1138C18.4769 15.1599 18.3396 15.2018 18.0525 15.2252C17.7566 15.2494 17.3724 15.25 16.8 15.25H11.2Z"
  />
</svg>`;
var PasteIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.96967 2.96967C8.43047 2.50887 9.05544 2.25 9.70711 2.25H14.2929C14.9446 2.25 15.5695 2.50887 16.0303 2.96967C16.3835 3.32285 16.6181 3.77248 16.7084 4.25665C16.9029 4.26164 17.0816 4.27042 17.245 4.28594C17.5984 4.31952 17.9317 4.38831 18.2485 4.54973C18.7659 4.81338 19.1866 5.23408 19.4503 5.75153C19.6221 6.08879 19.6892 6.44545 19.7203 6.82533C19.75 7.18956 19.75 7.6354 19.75 8.16955V17.8305C19.75 18.3646 19.75 18.8104 19.7203 19.1747C19.6892 19.5546 19.6221 19.9112 19.4503 20.2485C19.1866 20.7659 18.7659 21.1866 18.2485 21.4503C17.9112 21.6221 17.5546 21.6892 17.1747 21.7203C16.8104 21.75 16.3646 21.75 15.8305 21.75H8.16955C7.6354 21.75 7.18956 21.75 6.82533 21.7203C6.44545 21.6892 6.08879 21.6221 5.75153 21.4503C5.23408 21.1866 4.81339 20.7659 4.54973 20.2485C4.37789 19.9112 4.31078 19.5546 4.27974 19.1747C4.24998 18.8104 4.24999 18.3646 4.25 17.8304V8.16957C4.24999 7.63541 4.24998 7.18956 4.27974 6.82533C4.31078 6.44545 4.37789 6.08879 4.54973 5.75153C4.81338 5.23408 5.23408 4.81338 5.75153 4.54973C6.06834 4.38831 6.40164 4.31952 6.75503 4.28594C6.91838 4.27042 7.09706 4.26164 7.29163 4.25665C7.38193 3.77248 7.61649 3.32285 7.96967 2.96967ZM7.25 5.75845C7.11656 5.76281 7.00058 5.76937 6.8969 5.77922C6.64378 5.80327 6.51726 5.84306 6.43251 5.88624C6.19731 6.00608 6.00608 6.19731 5.88624 6.43251C5.8401 6.52307 5.79822 6.66035 5.77476 6.94748C5.75058 7.24336 5.75 7.62757 5.75 8.2V17.8C5.75 18.3724 5.75058 18.7566 5.77476 19.0525C5.79822 19.3396 5.8401 19.4769 5.88624 19.5675C6.00608 19.8027 6.19731 19.9939 6.43251 20.1138C6.52307 20.1599 6.66036 20.2018 6.94748 20.2252C7.24336 20.2494 7.62757 20.25 8.2 20.25H15.8C16.3724 20.25 16.7566 20.2494 17.0525 20.2252C17.3396 20.2018 17.4769 20.1599 17.5675 20.1138C17.8027 19.9939 17.9939 19.8027 18.1138 19.5675C18.1599 19.4769 18.2018 19.3396 18.2252 19.0525C18.2494 18.7566 18.25 18.3724 18.25 17.8V8.2C18.25 7.62757 18.2494 7.24336 18.2252 6.94748C18.2018 6.66035 18.1599 6.52307 18.1138 6.43251C17.9939 6.19731 17.8027 6.00608 17.5675 5.88624C17.4827 5.84306 17.3562 5.80327 17.1031 5.77922C16.9994 5.76937 16.8834 5.76281 16.75 5.75845V7C16.75 7.41421 16.4142 7.75 16 7.75H8C7.58579 7.75 7.25 7.41421 7.25 7V5.75845ZM9.70711 3.75C9.45327 3.75 9.20982 3.85084 9.03033 4.03033C8.85084 4.20982 8.75 4.45327 8.75 4.70711V6.25H15.25V4.70711C15.25 4.45327 15.1492 4.20982 14.9697 4.03033C14.7902 3.85084 14.5467 3.75 14.2929 3.75H9.70711Z"
  />
</svg>`;
var DuplicateIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M11.25 9C11.25 9.41421 11.5858 9.75 12 9.75H13.1893L7.46967 15.4697C7.17678 15.7626 7.17678 16.2374 7.46967 16.5303C7.76256 16.8232 8.23744 16.8232 8.53033 16.5303L14.25 10.8107V12C14.25 12.4142 14.5858 12.75 15 12.75C15.4142 12.75 15.75 12.4142 15.75 12V9.1C15.75 9.08264 15.7495 9.0654 15.7485 9.04829C15.7618 8.84059 15.6891 8.62841 15.5303 8.46967C15.3716 8.31093 15.1594 8.23823 14.9517 8.25155C14.9346 8.25052 14.9174 8.25 14.9 8.25H12C11.5858 8.25 11.25 8.58579 11.25 9Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.8304 3.25H11.1696C10.6354 3.24999 10.1896 3.24998 9.82533 3.27974C9.44545 3.31078 9.08879 3.37789 8.75153 3.54973C8.23408 3.81338 7.81339 4.23408 7.54973 4.75153C7.37789 5.08879 7.31078 5.44545 7.27974 5.82533C7.24998 6.18956 7.24999 6.63541 7.25 7.16956L7.25 7.25L7.16957 7.25C6.63542 7.24999 6.18956 7.24998 5.82533 7.27974C5.44545 7.31078 5.08879 7.37789 4.75153 7.54973C4.23408 7.81339 3.81338 8.23408 3.54973 8.75153C3.37789 9.08879 3.31078 9.44545 3.27974 9.82533C3.24998 10.1896 3.24999 10.6354 3.25 11.1696V16.8304C3.24999 17.3646 3.24998 17.8104 3.27974 18.1747C3.31078 18.5546 3.37789 18.9112 3.54973 19.2485C3.81338 19.7659 4.23408 20.1866 4.75153 20.4503C5.08879 20.6221 5.44545 20.6892 5.82533 20.7203C6.18956 20.75 6.6354 20.75 7.16955 20.75H12.8305C13.3646 20.75 13.8104 20.75 14.1747 20.7203C14.5546 20.6892 14.9112 20.6221 15.2485 20.4503C15.7659 20.1866 16.1866 19.7659 16.4503 19.2485C16.6221 18.9112 16.6892 18.5546 16.7203 18.1747C16.75 17.8105 16.75 17.3646 16.75 16.8305V16.75H16.8305C17.3646 16.75 17.8105 16.75 18.1747 16.7203C18.5546 16.6892 18.9112 16.6221 19.2485 16.4503C19.7659 16.1866 20.1866 15.7659 20.4503 15.2485C20.6221 14.9112 20.6892 14.5546 20.7203 14.1747C20.75 13.8104 20.75 13.3646 20.75 12.8305V7.16955C20.75 6.6354 20.75 6.18956 20.7203 5.82533C20.6892 5.44545 20.6221 5.08879 20.4503 4.75153C20.1866 4.23408 19.7659 3.81338 19.2485 3.54973C18.9112 3.37789 18.5546 3.31078 18.1747 3.27974C17.8104 3.24998 17.3646 3.24999 16.8304 3.25ZM7.25 11V8.75H7.2C6.62757 8.75 6.24336 8.75058 5.94748 8.77476C5.66036 8.79822 5.52307 8.8401 5.43251 8.88624C5.19731 9.00608 5.00608 9.19731 4.88624 9.43251C4.8401 9.52307 4.79822 9.66036 4.77476 9.94748C4.75058 10.2434 4.75 10.6276 4.75 11.2V16.8C4.75 17.3724 4.75058 17.7566 4.77476 18.0525C4.79822 18.3396 4.8401 18.4769 4.88624 18.5675C5.00608 18.8027 5.19731 18.9939 5.43251 19.1138C5.52307 19.1599 5.66036 19.2018 5.94748 19.2252C6.24336 19.2494 6.62757 19.25 7.2 19.25H12.8C13.3724 19.25 13.7566 19.2494 14.0525 19.2252C14.3396 19.2018 14.4769 19.1599 14.5675 19.1138C14.8027 18.9939 14.9939 18.8027 15.1138 18.5675C15.1599 18.4769 15.2018 18.3396 15.2252 18.0525C15.2494 17.7566 15.25 17.3724 15.25 16.8V16.75H13C12.5858 16.75 12.25 16.4142 12.25 16C12.25 15.5858 12.5858 15.25 13 15.25H16.8C17.3724 15.25 17.7566 15.2494 18.0525 15.2252C18.3396 15.2018 18.4769 15.1599 18.5675 15.1138C18.8027 14.9939 18.9939 14.8027 19.1138 14.5675C19.1599 14.4769 19.2018 14.3396 19.2252 14.0525C19.2494 13.7566 19.25 13.3724 19.25 12.8V7.2C19.25 6.62757 19.2494 6.24336 19.2252 5.94748C19.2018 5.66036 19.1599 5.52307 19.1138 5.43251C18.9939 5.19731 18.8027 5.00608 18.5675 4.88624C18.4769 4.8401 18.3396 4.79822 18.0525 4.77476C17.7566 4.75058 17.3724 4.75 16.8 4.75H11.2C10.6276 4.75 10.2434 4.75058 9.94748 4.77476C9.66036 4.79822 9.52307 4.8401 9.43251 4.88624C9.19731 5.00608 9.00608 5.19731 8.88624 5.43251C8.8401 5.52307 8.79822 5.66036 8.77476 5.94748C8.75058 6.24336 8.75 6.62757 8.75 7.2V11C8.75 11.4142 8.41422 11.75 8 11.75C7.58579 11.75 7.25 11.4142 7.25 11Z"
  />
</svg>`;
var DeleteIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11.1799 2.24992C11.2215 2.24996 11.2637 2.25 11.3064 2.25H12.6936C12.7363 2.25 12.7785 2.24996 12.8201 2.24992C13.5245 2.24927 14.0767 2.24875 14.565 2.44082C14.9934 2.60932 15.3727 2.88268 15.668 3.23585C16.0047 3.6384 16.1788 4.1624 16.4009 4.83082C16.4141 4.87034 16.4274 4.91036 16.4409 4.9509L16.5406 5.25H20C20.4142 5.25 20.75 5.58579 20.75 6C20.75 6.41421 20.4142 6.75 20 6.75H18.75V16.2321C18.75 17.045 18.75 17.7006 18.7066 18.2315C18.662 18.7781 18.5676 19.2582 18.3413 19.7025C17.9817 20.4081 17.4081 20.9818 16.7025 21.3413C16.2582 21.5676 15.7781 21.662 15.2315 21.7066C14.7006 21.75 14.045 21.75 13.2321 21.75H10.7679C9.95505 21.75 9.29944 21.75 8.76853 21.7066C8.2219 21.662 7.74175 21.5676 7.29754 21.3413C6.59193 20.9818 6.01825 20.4081 5.65873 19.7025C5.43238 19.2582 5.33803 18.7781 5.29336 18.2315C5.24999 17.7006 5.24999 17.0449 5.25 16.2321L5.25 6.75H4C3.58579 6.75 3.25 6.41421 3.25 6C3.25 5.58579 3.58579 5.25 4 5.25H7.45943L7.55913 4.9509C7.57264 4.91036 7.58594 4.87034 7.59908 4.83081C7.82119 4.1624 7.99532 3.6384 8.33195 3.23585C8.62729 2.88269 9.00657 2.60932 9.435 2.44082C9.92335 2.24875 10.4755 2.24927 11.1799 2.24992ZM7.9827 6.75C7.99433 6.75027 8.00594 6.75027 8.01751 6.75H15.9825C15.9941 6.75027 16.0057 6.75027 16.0173 6.75H17.25V16.2C17.25 17.0525 17.2494 17.6467 17.2116 18.1093C17.1745 18.5632 17.1054 18.824 17.0048 19.0215C16.7891 19.4448 16.4448 19.789 16.0215 20.0048C15.824 20.1054 15.5632 20.1745 15.1093 20.2116C14.6467 20.2494 14.0525 20.25 13.2 20.25H10.8C9.94755 20.25 9.35331 20.2494 8.89068 20.2116C8.4368 20.1745 8.17604 20.1054 7.97852 20.0048C7.55516 19.789 7.21095 19.4448 6.99524 19.0215C6.8946 18.824 6.82546 18.5632 6.78838 18.1093C6.75058 17.6467 6.75 17.0525 6.75 16.2V6.75H7.9827ZM14.9592 5.25H9.0408C9.27769 4.54546 9.36214 4.34218 9.48262 4.19811C9.61687 4.03758 9.78927 3.91333 9.98401 3.83674C10.1725 3.76261 10.4131 3.75 11.3064 3.75H12.6936C13.5869 3.75 13.8275 3.76261 14.016 3.83674C14.2107 3.91333 14.3831 4.03759 14.5174 4.19811C14.6379 4.34218 14.7223 4.54546 14.9592 5.25ZM10 9.25C10.4142 9.25 10.75 9.58579 10.75 10V17C10.75 17.4142 10.4142 17.75 10 17.75C9.58579 17.75 9.25 17.4142 9.25 17V10C9.25 9.58579 9.58579 9.25 10 9.25ZM14 9.25C14.4142 9.25 14.75 9.58579 14.75 10V17C14.75 17.4142 14.4142 17.75 14 17.75C13.5858 17.75 13.25 17.4142 13.25 17V10C13.25 9.58579 13.5858 9.25 14 9.25Z"
  />
</svg>`;
var TodayIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M8.5 13.75C8.5 13.3358 8.16421 13 7.75 13C7.33579 13 7 13.3358 7 13.75L7 15.25C7 15.6642 7.33579 16 7.75 16C8.16421 16 8.5 15.6642 8.5 15.25V13.75Z"
  />
  <path
    d="M12 11C12.4142 11 12.75 11.3358 12.75 11.75V17.25C12.75 17.6642 12.4142 18 12 18C11.5858 18 11.25 17.6642 11.25 17.25V11.75C11.25 11.3358 11.5858 11 12 11Z"
  />
  <path
    d="M15.5 15.25C15.5 15.6642 15.8358 16 16.25 16C16.6642 16 17 15.6642 17 15.25V13.75C17 13.3358 16.6642 13 16.25 13C15.8358 13 15.5 13.3358 15.5 13.75V15.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.30556 4C8.30556 3.58579 7.96977 3.25 7.55556 3.25C7.14134 3.25 6.80556 3.58579 6.80556 4V5.02778C6.33711 5.02777 5.94085 5.02793 5.61573 5.05449C5.2729 5.0825 4.94369 5.14356 4.63019 5.30329C4.15456 5.54564 3.76786 5.93234 3.52551 6.40797C3.36578 6.72146 3.30472 7.05068 3.27671 7.39351C3.24998 7.72071 3.24999 8.11996 3.25 8.59235V17.1854C3.24999 17.6578 3.24998 18.0571 3.27671 18.3843C3.30472 18.7271 3.36578 19.0563 3.52551 19.3698C3.76786 19.8454 4.15456 20.2321 4.63019 20.4745C4.94369 20.6342 5.2729 20.6953 5.61573 20.7233C5.94291 20.75 6.34214 20.75 6.81449 20.75H17.1854C17.6578 20.75 18.0571 20.75 18.3843 20.7233C18.7271 20.6953 19.0563 20.6342 19.3698 20.4745C19.8454 20.2321 20.2321 19.8454 20.4745 19.3698C20.6342 19.0563 20.6953 18.7271 20.7233 18.3843C20.75 18.0571 20.75 17.6579 20.75 17.1855V8.59236C20.75 8.12001 20.75 7.72069 20.7233 7.39351C20.6953 7.05068 20.6342 6.72146 20.4745 6.40797C20.2321 5.93234 19.8454 5.54564 19.3698 5.30329C19.0563 5.14356 18.7271 5.0825 18.3843 5.05449C18.0592 5.02793 17.6629 5.02777 17.1944 5.02778V4C17.1944 3.58579 16.8587 3.25 16.4444 3.25C16.0302 3.25 15.6944 3.58579 15.6944 4V5.02778H8.30556V4ZM5.73788 6.54951C5.9967 6.52836 6.33425 6.52778 6.84445 6.52778H17.1556C17.6658 6.52778 18.0033 6.52836 18.2621 6.54951C18.5122 6.56994 18.622 6.60577 18.6888 6.6398C18.8822 6.73833 19.0394 6.89556 19.138 7.08895C19.172 7.15575 19.2078 7.26559 19.2283 7.51566C19.2489 7.76785 19.25 8.09477 19.25 8.58333H4.75C4.75004 8.09477 4.75113 7.76785 4.77173 7.51566C4.79216 7.26559 4.82799 7.15575 4.86202 7.08895C4.96056 6.89557 5.11779 6.73834 5.31118 6.6398C5.37797 6.60577 5.48781 6.56994 5.73788 6.54951ZM4.75 10.0833H19.25V17.1556C19.25 17.6658 19.2494 18.0033 19.2283 18.2621C19.2078 18.5122 19.172 18.622 19.138 18.6888C19.0394 18.8822 18.8822 19.0394 18.6888 19.138C18.622 19.172 18.5122 19.2078 18.2621 19.2283C18.0033 19.2494 17.6658 19.25 17.1556 19.25H6.84445C6.33425 19.25 5.9967 19.2494 5.73788 19.2283C5.48781 19.2078 5.37797 19.172 5.31118 19.138C5.11779 19.0394 4.96056 18.8822 4.86202 18.6888C4.82799 18.622 4.79216 18.5122 4.77173 18.2621C4.75058 18.0033 4.75 17.6658 4.75 17.1556V10.0833Z"
  />
</svg>`;
var TomorrowIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M8.5 13.75C8.5 13.3358 8.16421 13 7.75 13C7.33579 13 7 13.3358 7 13.75L7 15.25C7 15.6642 7.33579 16 7.75 16C8.16421 16 8.5 15.6642 8.5 15.25V13.75Z"
  />
  <path
    d="M12 13C12.4142 13 12.75 13.3358 12.75 13.75V15.25C12.75 15.6642 12.4142 16 12 16C11.5858 16 11.25 15.6642 11.25 15.25V13.75C11.25 13.3358 11.5858 13 12 13Z"
  />
  <path
    d="M15.5 17.25C15.5 17.6642 15.8358 18 16.25 18C16.6642 18 17 17.6642 17 17.25V11.75C17 11.3358 16.6642 11 16.25 11C15.8358 11 15.5 11.3358 15.5 11.75V17.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.30556 4C8.30556 3.58579 7.96977 3.25 7.55556 3.25C7.14134 3.25 6.80556 3.58579 6.80556 4V5.02778C6.33711 5.02777 5.94085 5.02793 5.61573 5.05449C5.2729 5.0825 4.94369 5.14356 4.63019 5.30329C4.15456 5.54564 3.76786 5.93234 3.52551 6.40797C3.36578 6.72146 3.30472 7.05068 3.27671 7.39351C3.24998 7.72071 3.24999 8.11996 3.25 8.59235V17.1854C3.24999 17.6578 3.24998 18.0571 3.27671 18.3843C3.30472 18.7271 3.36578 19.0563 3.52551 19.3698C3.76786 19.8454 4.15456 20.2321 4.63019 20.4745C4.94369 20.6342 5.2729 20.6953 5.61573 20.7233C5.94291 20.75 6.34214 20.75 6.81449 20.75H17.1854C17.6578 20.75 18.0571 20.75 18.3843 20.7233C18.7271 20.6953 19.0563 20.6342 19.3698 20.4745C19.8454 20.2321 20.2321 19.8454 20.4745 19.3698C20.6342 19.0563 20.6953 18.7271 20.7233 18.3843C20.75 18.0571 20.75 17.6579 20.75 17.1855V8.59236C20.75 8.12001 20.75 7.72069 20.7233 7.39351C20.6953 7.05068 20.6342 6.72146 20.4745 6.40797C20.2321 5.93234 19.8454 5.54564 19.3698 5.30329C19.0563 5.14356 18.7271 5.0825 18.3843 5.05449C18.0592 5.02793 17.6629 5.02777 17.1944 5.02778V4C17.1944 3.58579 16.8587 3.25 16.4444 3.25C16.0302 3.25 15.6944 3.58579 15.6944 4V5.02778H8.30556V4ZM5.73788 6.54951C5.9967 6.52836 6.33425 6.52778 6.84445 6.52778H17.1556C17.6658 6.52778 18.0033 6.52836 18.2621 6.54951C18.5122 6.56994 18.622 6.60577 18.6888 6.6398C18.8822 6.73833 19.0394 6.89556 19.138 7.08895C19.172 7.15575 19.2078 7.26559 19.2283 7.51566C19.2489 7.76785 19.25 8.09477 19.25 8.58333H4.75C4.75004 8.09477 4.75113 7.76785 4.77173 7.51566C4.79216 7.26559 4.82799 7.15575 4.86202 7.08895C4.96056 6.89557 5.11779 6.73834 5.31118 6.6398C5.37797 6.60577 5.48781 6.56994 5.73788 6.54951ZM4.75 10.0833H19.25V17.1556C19.25 17.6658 19.2494 18.0033 19.2283 18.2621C19.2078 18.5122 19.172 18.622 19.138 18.6888C19.0394 18.8822 18.8822 19.0394 18.6888 19.138C18.622 19.172 18.5122 19.2078 18.2621 19.2283C18.0033 19.2494 17.6658 19.25 17.1556 19.25H6.84445C6.33425 19.25 5.9967 19.2494 5.73788 19.2283C5.48781 19.2078 5.37797 19.172 5.31118 19.138C5.11779 19.0394 4.96056 18.8822 4.86202 18.6888C4.82799 18.622 4.79216 18.5122 4.77173 18.2621C4.75058 18.0033 4.75 17.6658 4.75 17.1556V10.0833Z"
  />
</svg>`;
var YesterdayIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.55556 3.25C7.96977 3.25 8.30556 3.58579 8.30556 4V5.02778H15.6944V4C15.6944 3.58579 16.0302 3.25 16.4444 3.25C16.8587 3.25 17.1944 3.58579 17.1944 4V5.02778C17.6629 5.02777 18.0592 5.02793 18.3843 5.05449C18.7271 5.0825 19.0563 5.14356 19.3698 5.30329C19.8454 5.54564 20.2321 5.93234 20.4745 6.40797C20.6342 6.72146 20.6953 7.05068 20.7233 7.39351C20.75 7.72071 20.75 8.11997 20.75 8.59236V17.1854C20.75 17.6578 20.75 18.0571 20.7233 18.3843C20.6953 18.7271 20.6342 19.0563 20.4745 19.3698C20.2321 19.8454 19.8454 20.2321 19.3698 20.4745C19.0563 20.6342 18.7271 20.6953 18.3843 20.7233C18.0571 20.75 17.6578 20.75 17.1854 20.75H6.81458C6.34219 20.75 5.94293 20.75 5.61573 20.7233C5.2729 20.6953 4.94369 20.6342 4.63019 20.4745C4.15456 20.2321 3.76786 19.8454 3.52551 19.3698C3.36578 19.0563 3.30472 18.7271 3.27671 18.3843C3.24998 18.0571 3.24999 17.6578 3.25 17.1854V8.59238C3.24999 8.11998 3.24998 7.72071 3.27671 7.39351C3.30472 7.05068 3.36578 6.72146 3.52551 6.40797C3.76786 5.93234 4.15456 5.54564 4.63019 5.30329C4.94369 5.14356 5.2729 5.0825 5.61573 5.05449C5.94085 5.02793 6.33711 5.02777 6.80556 5.02778V4C6.80556 3.58579 7.14134 3.25 7.55556 3.25ZM6.84445 6.52778C6.33425 6.52778 5.9967 6.52836 5.73788 6.54951C5.48781 6.56994 5.37797 6.60577 5.31118 6.6398C5.11779 6.73834 4.96056 6.89557 4.86202 7.08895C4.82799 7.15575 4.79216 7.26559 4.77173 7.51566C4.75113 7.76785 4.75004 8.09477 4.75 8.58333H19.25C19.25 8.09477 19.2489 7.76785 19.2283 7.51566C19.2078 7.26559 19.172 7.15575 19.138 7.08895C19.0394 6.89556 18.8822 6.73833 18.6888 6.6398C18.622 6.60577 18.5122 6.56994 18.2621 6.54951C18.0033 6.52836 17.6658 6.52778 17.1556 6.52778H6.84445ZM19.25 10.0833H4.75V17.1556C4.75 17.6658 4.75058 18.0033 4.77173 18.2621C4.79216 18.5122 4.82799 18.622 4.86202 18.6888C4.96056 18.8822 5.11779 19.0394 5.31118 19.138C5.37797 19.172 5.48781 19.2078 5.73788 19.2283C5.9967 19.2494 6.33425 19.25 6.84445 19.25H17.1556C17.6658 19.25 18.0033 19.2494 18.2621 19.2283C18.5122 19.2078 18.622 19.172 18.6888 19.138C18.8822 19.0394 19.0394 18.8822 19.138 18.6888C19.172 18.622 19.2078 18.5122 19.2283 18.2621C19.2494 18.0033 19.25 17.6658 19.25 17.1556V10.0833Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M16.25 13C15.8358 13 15.5 13.3358 15.5 13.75V15.25C15.5 15.6642 15.8358 16 16.25 16C16.6642 16 17 15.6642 17 15.25V13.75C17 13.3358 16.6642 13 16.25 13Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 13C11.5858 13 11.25 13.3358 11.25 13.75V15.25C11.25 15.6642 11.5858 16 12 16C12.4142 16 12.75 15.6642 12.75 15.25V13.75C12.75 13.3358 12.4142 13 12 13Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.75 18C8.16421 18 8.5 17.6642 8.5 17.25L8.5 11.75C8.5 11.3358 8.16421 11 7.75 11C7.33579 11 7 11.3358 7 11.75L7 17.25C7 17.6642 7.33579 18 7.75 18Z"
  />
</svg>`;
var NowIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.11366 3.678C6.40656 3.9709 6.40656 4.44577 6.11366 4.73866L4.28033 6.572C3.98744 6.86489 3.51256 6.86489 3.21967 6.572C2.92678 6.2791 2.92678 5.80423 3.21967 5.51134L5.053 3.678C5.3459 3.38511 5.82077 3.38511 6.11366 3.678ZM17.8863 3.678C18.1792 3.38511 18.6541 3.38511 18.947 3.678L20.7803 5.51134C21.0732 5.80423 21.0732 6.2791 20.7803 6.572C20.4874 6.86489 20.0126 6.86489 19.7197 6.572L17.8863 4.73866C17.5934 4.44577 17.5934 3.9709 17.8863 3.678ZM12 5.875C8.36413 5.875 5.41667 8.82246 5.41667 12.4583C5.41667 16.0942 8.36413 19.0417 12 19.0417C15.6359 19.0417 18.5833 16.0942 18.5833 12.4583C18.5833 8.82246 15.6359 5.875 12 5.875ZM3.91667 12.4583C3.91667 7.99403 7.5357 4.375 12 4.375C16.4643 4.375 20.0833 7.99403 20.0833 12.4583C20.0833 16.9226 16.4643 20.5417 12 20.5417C7.5357 20.5417 3.91667 16.9226 3.91667 12.4583Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M15.197 10.3586C15.4899 10.6515 15.4899 11.1264 15.197 11.4192L11.6415 14.9748C11.3486 15.2677 10.8737 15.2677 10.5808 14.9748L8.80301 13.197C8.51012 12.9041 8.51012 12.4293 8.80301 12.1364C9.09591 11.8435 9.57078 11.8435 9.86367 12.1364L11.1111 13.3838L14.1363 10.3586C14.4292 10.0657 14.9041 10.0657 15.197 10.3586Z"
  />
</svg>`;
var CrossIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.34315 6.34314C6.63604 6.05025 7.11091 6.05025 7.40381 6.34314L12 10.9393L16.5962 6.34314C16.8891 6.05025 17.364 6.05025 17.6569 6.34314C17.9497 6.63604 17.9497 7.11091 17.6569 7.4038L13.0607 12L17.6569 16.5962C17.9497 16.8891 17.9497 17.364 17.6569 17.6569C17.364 17.9497 16.8891 17.9497 16.5962 17.6569L12 13.0607L7.40381 17.6569C7.11091 17.9497 6.63604 17.9497 6.34315 17.6569C6.05025 17.364 6.05025 16.8891 6.34315 16.5962L10.9393 12L6.34315 7.4038C6.05025 7.11091 6.05025 6.63604 6.34315 6.34314Z"
  />
</svg>`;
var InsertBlocksIcon = svg`<path
  fill-rule="evenodd"
  clip-rule="evenodd"
  d="M5.57378 3.25C5.5825 3.25 5.59124 3.25 5.6 3.25L8.42622 3.25C8.68371 3.24998 8.92019 3.24996 9.11787 3.26612C9.33101 3.28353 9.56418 3.32339 9.79449 3.44074C10.1238 3.60852 10.3915 3.87623 10.5593 4.20552C10.6766 4.43582 10.7165 4.669 10.7339 4.88213C10.75 5.07982 10.75 5.3163 10.75 5.57379V8.42621C10.75 8.6837 10.75 8.92019 10.7339 9.11787C10.7165 9.33101 10.6766 9.56418 10.5593 9.79448C10.3915 10.1238 10.1238 10.3915 9.79449 10.5593C9.56418 10.6766 9.33101 10.7165 9.11787 10.7339C8.92019 10.75 8.6837 10.75 8.42622 10.75H5.57379C5.3163 10.75 5.07982 10.75 4.88213 10.7339C4.669 10.7165 4.43583 10.6766 4.20552 10.5593C3.87624 10.3915 3.60852 10.1238 3.44074 9.79448C3.32339 9.56418 3.28353 9.33101 3.26612 9.11787C3.24997 8.92019 3.24998 8.6837 3.25 8.42622L3.25 5.6C3.25 5.59124 3.25 5.5825 3.25 5.57378C3.24998 5.3163 3.24997 5.07981 3.26612 4.88213C3.28353 4.669 3.32339 4.43582 3.44074 4.20552C3.60852 3.87623 3.87624 3.60852 4.20552 3.44074C4.43583 3.32339 4.669 3.28353 4.88213 3.26612C5.07982 3.24996 5.3163 3.24998 5.57378 3.25ZM4.88088 4.77973C4.88085 4.77972 4.88132 4.77952 4.88239 4.77917L4.88088 4.77973ZM4.88346 4.77882C4.89234 4.77607 4.92547 4.76757 5.00428 4.76113C5.13341 4.75058 5.3076 4.75 5.6 4.75H8.4C8.6924 4.75 8.8666 4.75058 8.99573 4.76113C9.07454 4.76757 9.10766 4.77607 9.11654 4.77882C9.16118 4.80234 9.19766 4.83882 9.22118 4.88346C9.22393 4.89234 9.23243 4.92547 9.23887 5.00428C9.24942 5.1334 9.25 5.3076 9.25 5.6V8.4C9.25 8.6924 9.24942 8.8666 9.23887 8.99572C9.23243 9.07453 9.22393 9.10766 9.22118 9.11654C9.19766 9.16118 9.16118 9.19766 9.11654 9.22118C9.10767 9.22393 9.07454 9.23243 8.99573 9.23887C8.8666 9.24942 8.6924 9.25 8.4 9.25H5.6C5.3076 9.25 5.13341 9.24942 5.00428 9.23887C4.92547 9.23243 4.89234 9.22393 4.88347 9.22118C4.83883 9.19766 4.80235 9.16118 4.77883 9.11654C4.77607 9.10766 4.76757 9.07453 4.76114 8.99572C4.75059 8.8666 4.75 8.6924 4.75 8.4V5.6C4.75 5.3076 4.75059 5.1334 4.76114 5.00428C4.76757 4.92547 4.77607 4.89234 4.77883 4.88346C4.80235 4.83882 4.83883 4.80234 4.88346 4.77882ZM4.77973 4.88088C4.77974 4.8809 4.77956 4.88144 4.77917 4.88239L4.77973 4.88088ZM4.77973 9.11913C4.77972 9.11915 4.77953 9.11869 4.77918 9.11764L4.77973 9.11913ZM4.88088 9.22027C4.88091 9.22026 4.88143 9.22044 4.88236 9.22082L4.88088 9.22027ZM9.11913 9.22027C9.11916 9.22028 9.11869 9.22048 9.11764 9.22082L9.11913 9.22027ZM9.22028 9.11913C9.22027 9.11909 9.22044 9.11856 9.22084 9.11761L9.22028 9.11913ZM9.22028 4.88088C9.22029 4.88085 9.22048 4.88132 9.22084 4.88239L9.22028 4.88088ZM9.11764 4.77918C9.11869 4.77952 9.11916 4.77972 9.11913 4.77973L9.11764 4.77918ZM15.5738 3.25H18.4262C18.6837 3.24998 18.9202 3.24996 19.1179 3.26612C19.331 3.28353 19.5642 3.32339 19.7945 3.44074C20.1238 3.60852 20.3915 3.87623 20.5593 4.20552C20.6766 4.43582 20.7165 4.669 20.7339 4.88213C20.75 5.07981 20.75 5.31629 20.75 5.57377V8.42623C20.75 8.68371 20.75 8.92019 20.7339 9.11787C20.7165 9.33101 20.6766 9.56418 20.5593 9.79448C20.3915 10.1238 20.1238 10.3915 19.7945 10.5593C19.5642 10.6766 19.331 10.7165 19.1179 10.7339C18.9202 10.75 18.6837 10.75 18.4262 10.75H15.5738C15.3163 10.75 15.0798 10.75 14.8821 10.7339C14.669 10.7165 14.4358 10.6766 14.2055 10.5593C13.8762 10.3915 13.6085 10.1238 13.4407 9.79448C13.3234 9.56418 13.2835 9.33101 13.2661 9.11787C13.25 8.92019 13.25 8.68371 13.25 8.42623V5.57377C13.25 5.31629 13.25 5.07981 13.2661 4.88213C13.2835 4.669 13.3234 4.43582 13.4407 4.20552C13.6085 3.87623 13.8762 3.60852 14.2055 3.44074C14.4358 3.32339 14.669 3.28353 14.8821 3.26612C15.0798 3.24996 15.3163 3.24998 15.5738 3.25ZM14.8809 4.77973C14.8808 4.77972 14.8813 4.77953 14.8824 4.77918L14.8809 4.77973ZM14.8835 4.77882C14.8923 4.77607 14.9255 4.76757 15.0043 4.76113C15.1334 4.75058 15.3076 4.75 15.6 4.75H18.4C18.6924 4.75 18.8666 4.75058 18.9957 4.76113C19.0745 4.76757 19.1077 4.77607 19.1165 4.77882C19.1612 4.80234 19.1977 4.83882 19.2212 4.88346C19.2239 4.89234 19.2324 4.92547 19.2389 5.00428C19.2494 5.1334 19.25 5.3076 19.25 5.6V8.4C19.25 8.6924 19.2494 8.8666 19.2389 8.99572C19.2324 9.07453 19.2239 9.10766 19.2212 9.11654C19.1977 9.16118 19.1612 9.19766 19.1165 9.22118C19.1077 9.22393 19.0745 9.23243 18.9957 9.23887C18.8666 9.24942 18.6924 9.25 18.4 9.25H15.6C15.3076 9.25 15.1334 9.24942 15.0043 9.23887C14.9255 9.23243 14.8923 9.22393 14.8835 9.22118C14.8388 9.19766 14.8023 9.16118 14.7788 9.11654C14.7761 9.10766 14.7676 9.07453 14.7611 8.99572C14.7506 8.8666 14.75 8.6924 14.75 8.4V5.6C14.75 5.3076 14.7506 5.1334 14.7611 5.00428C14.7676 4.92547 14.7761 4.89234 14.7788 4.88346C14.8023 4.83882 14.8388 4.80234 14.8835 4.77882ZM14.7797 4.88088C14.7797 4.8809 14.7796 4.88143 14.7792 4.88236L14.7797 4.88088ZM14.7797 9.11913C14.7797 9.11915 14.7795 9.11867 14.7792 9.11761L14.7797 9.11913ZM14.8809 9.22027C14.8809 9.22026 14.8814 9.22044 14.8824 9.22082L14.8809 9.22027ZM19.1191 9.22027C19.1192 9.22028 19.1187 9.22048 19.1176 9.22082L19.1191 9.22027ZM19.2203 9.11913C19.2203 9.11911 19.2204 9.11857 19.2208 9.11761L19.2203 9.11913ZM19.2203 4.88088C19.2203 4.88085 19.2205 4.88131 19.2208 4.88236L19.2203 4.88088ZM19.1176 4.77917C19.1187 4.77952 19.1192 4.77972 19.1191 4.77973L19.1176 4.77917ZM5.57377 13.25H8.42623C8.68372 13.25 8.92019 13.25 9.11787 13.2661C9.33101 13.2835 9.56418 13.3234 9.79449 13.4407C10.1238 13.6085 10.3915 13.8762 10.5593 14.2055C10.6766 14.4358 10.7165 14.669 10.7339 14.8821C10.75 15.0798 10.75 15.3163 10.75 15.5738V18.4262C10.75 18.6837 10.75 18.9202 10.7339 19.1179C10.7165 19.331 10.6766 19.5642 10.5593 19.7945C10.3915 20.1238 10.1238 20.3915 9.79449 20.5593C9.56418 20.6766 9.33101 20.7165 9.11787 20.7339C8.92019 20.75 8.68372 20.75 8.42623 20.75H5.57377C5.31629 20.75 5.07981 20.75 4.88213 20.7339C4.669 20.7165 4.43583 20.6766 4.20552 20.5593C3.87624 20.3915 3.60852 20.1238 3.44074 19.7945C3.32339 19.5642 3.28353 19.331 3.26612 19.1179C3.24997 18.9202 3.24998 18.6837 3.25 18.4262V15.5738C3.24998 15.3163 3.24997 15.0798 3.26612 14.8821C3.28353 14.669 3.32339 14.4358 3.44074 14.2055C3.60852 13.8762 3.87624 13.6085 4.20552 13.4407C4.43583 13.3234 4.669 13.2835 4.88213 13.2661C5.07981 13.25 5.31629 13.25 5.57377 13.25ZM4.88088 14.7797C4.88085 14.7797 4.88131 14.7795 4.88237 14.7792L4.88088 14.7797ZM4.88346 14.7788C4.89234 14.7761 4.92546 14.7676 5.00428 14.7611C5.13341 14.7506 5.3076 14.75 5.6 14.75H8.4C8.6924 14.75 8.8666 14.7506 8.99573 14.7611C9.07453 14.7676 9.10766 14.7761 9.11654 14.7788C9.16118 14.8023 9.19766 14.8388 9.22118 14.8835C9.22393 14.8923 9.23243 14.9255 9.23887 15.0043C9.24942 15.1334 9.25 15.3076 9.25 15.6V18.4C9.25 18.6924 9.24942 18.8666 9.23887 18.9957C9.23243 19.0745 9.22393 19.1077 9.22118 19.1165C9.19766 19.1612 9.16118 19.1977 9.11654 19.2212C9.10767 19.2239 9.07454 19.2324 8.99573 19.2389C8.8666 19.2494 8.6924 19.25 8.4 19.25H5.6C5.3076 19.25 5.13341 19.2494 5.00428 19.2389C4.92547 19.2324 4.89235 19.2239 4.88347 19.2212C4.83883 19.1977 4.80235 19.1612 4.77883 19.1165C4.77607 19.1077 4.76757 19.0745 4.76114 18.9957C4.75059 18.8666 4.75 18.6924 4.75 18.4V15.6C4.75 15.3076 4.75059 15.1334 4.76114 15.0043C4.76757 14.9255 4.77607 14.8923 4.77883 14.8835C4.80234 14.8388 4.83882 14.8023 4.88346 14.7788ZM4.77973 14.8809C4.77974 14.8809 4.77956 14.8814 4.77918 14.8824L4.77973 14.8809ZM4.77973 19.1191C4.77972 19.1192 4.77953 19.1187 4.77918 19.1176L4.77973 19.1191ZM4.88088 19.2203C4.8809 19.2203 4.88143 19.2204 4.88236 19.2208L4.88088 19.2203ZM9.11913 19.2203C9.11917 19.2203 9.1187 19.2205 9.11762 19.2208L9.11913 19.2203ZM9.22028 19.1191C9.22026 19.1191 9.22044 19.1185 9.22087 19.1175L9.22028 19.1191ZM9.22027 14.8809C9.22028 14.8808 9.22048 14.8813 9.22084 14.8824L9.22027 14.8809ZM9.11761 14.7792C9.11868 14.7795 9.11915 14.7797 9.11913 14.7797L9.11761 14.7792ZM17 13.25C17.4142 13.25 17.75 13.5858 17.75 14V16.25H20C20.4142 16.25 20.75 16.5858 20.75 17C20.75 17.4142 20.4142 17.75 20 17.75H17.75V20C17.75 20.4142 17.4142 20.75 17 20.75C16.5858 20.75 16.25 20.4142 16.25 20V17.75H14C13.5858 17.75 13.25 17.4142 13.25 17C13.25 16.5858 13.5858 16.25 14 16.25H16.25V14C16.25 13.5858 16.5858 13.25 17 13.25Z"
/>`;
var BlockHubIcon20 = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  ${InsertBlocksIcon}
</svg>`;
var BlockHubIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.57378 3.25C5.5825 3.25 5.59124 3.25 5.6 3.25L8.42622 3.25C8.68371 3.24998 8.92019 3.24996 9.11787 3.26612C9.33101 3.28353 9.56418 3.32339 9.79449 3.44074C10.1238 3.60852 10.3915 3.87623 10.5593 4.20552C10.6766 4.43582 10.7165 4.669 10.7339 4.88213C10.75 5.07982 10.75 5.3163 10.75 5.57379V8.42621C10.75 8.6837 10.75 8.92019 10.7339 9.11787C10.7165 9.33101 10.6766 9.56418 10.5593 9.79448C10.3915 10.1238 10.1238 10.3915 9.79449 10.5593C9.56418 10.6766 9.33101 10.7165 9.11787 10.7339C8.92019 10.75 8.6837 10.75 8.42622 10.75H5.57379C5.3163 10.75 5.07982 10.75 4.88213 10.7339C4.669 10.7165 4.43583 10.6766 4.20552 10.5593C3.87624 10.3915 3.60852 10.1238 3.44074 9.79448C3.32339 9.56418 3.28353 9.33101 3.26612 9.11787C3.24997 8.92019 3.24998 8.6837 3.25 8.42622L3.25 5.6C3.25 5.59124 3.25 5.5825 3.25 5.57378C3.24998 5.3163 3.24997 5.07981 3.26612 4.88213C3.28353 4.669 3.32339 4.43582 3.44074 4.20552C3.60852 3.87623 3.87624 3.60852 4.20552 3.44074C4.43583 3.32339 4.669 3.28353 4.88213 3.26612C5.07982 3.24996 5.3163 3.24998 5.57378 3.25ZM4.88088 4.77973C4.88085 4.77972 4.88132 4.77952 4.88239 4.77917L4.88088 4.77973ZM4.88346 4.77882C4.89234 4.77607 4.92547 4.76757 5.00428 4.76113C5.13341 4.75058 5.3076 4.75 5.6 4.75H8.4C8.6924 4.75 8.8666 4.75058 8.99573 4.76113C9.07454 4.76757 9.10766 4.77607 9.11654 4.77882C9.16118 4.80234 9.19766 4.83882 9.22118 4.88346C9.22393 4.89234 9.23243 4.92547 9.23887 5.00428C9.24942 5.1334 9.25 5.3076 9.25 5.6V8.4C9.25 8.6924 9.24942 8.8666 9.23887 8.99572C9.23243 9.07453 9.22393 9.10766 9.22118 9.11654C9.19766 9.16118 9.16118 9.19766 9.11654 9.22118C9.10767 9.22393 9.07454 9.23243 8.99573 9.23887C8.8666 9.24942 8.6924 9.25 8.4 9.25H5.6C5.3076 9.25 5.13341 9.24942 5.00428 9.23887C4.92547 9.23243 4.89234 9.22393 4.88347 9.22118C4.83883 9.19766 4.80235 9.16118 4.77883 9.11654C4.77607 9.10766 4.76757 9.07453 4.76114 8.99572C4.75059 8.8666 4.75 8.6924 4.75 8.4V5.6C4.75 5.3076 4.75059 5.1334 4.76114 5.00428C4.76757 4.92547 4.77607 4.89234 4.77883 4.88346C4.80235 4.83882 4.83883 4.80234 4.88346 4.77882ZM4.77973 4.88088C4.77974 4.8809 4.77956 4.88144 4.77917 4.88239L4.77973 4.88088ZM4.77973 9.11913C4.77972 9.11915 4.77953 9.11869 4.77918 9.11764L4.77973 9.11913ZM4.88088 9.22027C4.88091 9.22026 4.88143 9.22044 4.88236 9.22082L4.88088 9.22027ZM9.11913 9.22027C9.11916 9.22028 9.11869 9.22048 9.11764 9.22082L9.11913 9.22027ZM9.22028 9.11913C9.22027 9.11909 9.22044 9.11856 9.22084 9.11761L9.22028 9.11913ZM9.22028 4.88088C9.22029 4.88085 9.22048 4.88132 9.22084 4.88239L9.22028 4.88088ZM9.11764 4.77918C9.11869 4.77952 9.11916 4.77972 9.11913 4.77973L9.11764 4.77918ZM15.5738 3.25H18.4262C18.6837 3.24998 18.9202 3.24996 19.1179 3.26612C19.331 3.28353 19.5642 3.32339 19.7945 3.44074C20.1238 3.60852 20.3915 3.87623 20.5593 4.20552C20.6766 4.43582 20.7165 4.669 20.7339 4.88213C20.75 5.07981 20.75 5.31629 20.75 5.57377V8.42623C20.75 8.68371 20.75 8.92019 20.7339 9.11787C20.7165 9.33101 20.6766 9.56418 20.5593 9.79448C20.3915 10.1238 20.1238 10.3915 19.7945 10.5593C19.5642 10.6766 19.331 10.7165 19.1179 10.7339C18.9202 10.75 18.6837 10.75 18.4262 10.75H15.5738C15.3163 10.75 15.0798 10.75 14.8821 10.7339C14.669 10.7165 14.4358 10.6766 14.2055 10.5593C13.8762 10.3915 13.6085 10.1238 13.4407 9.79448C13.3234 9.56418 13.2835 9.33101 13.2661 9.11787C13.25 8.92019 13.25 8.68371 13.25 8.42623V5.57377C13.25 5.31629 13.25 5.07981 13.2661 4.88213C13.2835 4.669 13.3234 4.43582 13.4407 4.20552C13.6085 3.87623 13.8762 3.60852 14.2055 3.44074C14.4358 3.32339 14.669 3.28353 14.8821 3.26612C15.0798 3.24996 15.3163 3.24998 15.5738 3.25ZM14.8809 4.77973C14.8808 4.77972 14.8813 4.77953 14.8824 4.77918L14.8809 4.77973ZM14.8835 4.77882C14.8923 4.77607 14.9255 4.76757 15.0043 4.76113C15.1334 4.75058 15.3076 4.75 15.6 4.75H18.4C18.6924 4.75 18.8666 4.75058 18.9957 4.76113C19.0745 4.76757 19.1077 4.77607 19.1165 4.77882C19.1612 4.80234 19.1977 4.83882 19.2212 4.88346C19.2239 4.89234 19.2324 4.92547 19.2389 5.00428C19.2494 5.1334 19.25 5.3076 19.25 5.6V8.4C19.25 8.6924 19.2494 8.8666 19.2389 8.99572C19.2324 9.07453 19.2239 9.10766 19.2212 9.11654C19.1977 9.16118 19.1612 9.19766 19.1165 9.22118C19.1077 9.22393 19.0745 9.23243 18.9957 9.23887C18.8666 9.24942 18.6924 9.25 18.4 9.25H15.6C15.3076 9.25 15.1334 9.24942 15.0043 9.23887C14.9255 9.23243 14.8923 9.22393 14.8835 9.22118C14.8388 9.19766 14.8023 9.16118 14.7788 9.11654C14.7761 9.10766 14.7676 9.07453 14.7611 8.99572C14.7506 8.8666 14.75 8.6924 14.75 8.4V5.6C14.75 5.3076 14.7506 5.1334 14.7611 5.00428C14.7676 4.92547 14.7761 4.89234 14.7788 4.88346C14.8023 4.83882 14.8388 4.80234 14.8835 4.77882ZM14.7797 4.88088C14.7797 4.8809 14.7796 4.88143 14.7792 4.88236L14.7797 4.88088ZM14.7797 9.11913C14.7797 9.11915 14.7795 9.11867 14.7792 9.11761L14.7797 9.11913ZM14.8809 9.22027C14.8809 9.22026 14.8814 9.22044 14.8824 9.22082L14.8809 9.22027ZM19.1191 9.22027C19.1192 9.22028 19.1187 9.22048 19.1176 9.22082L19.1191 9.22027ZM19.2203 9.11913C19.2203 9.11911 19.2204 9.11857 19.2208 9.11761L19.2203 9.11913ZM19.2203 4.88088C19.2203 4.88085 19.2205 4.88131 19.2208 4.88236L19.2203 4.88088ZM19.1176 4.77917C19.1187 4.77952 19.1192 4.77972 19.1191 4.77973L19.1176 4.77917ZM5.57377 13.25H8.42623C8.68372 13.25 8.92019 13.25 9.11787 13.2661C9.33101 13.2835 9.56418 13.3234 9.79449 13.4407C10.1238 13.6085 10.3915 13.8762 10.5593 14.2055C10.6766 14.4358 10.7165 14.669 10.7339 14.8821C10.75 15.0798 10.75 15.3163 10.75 15.5738V18.4262C10.75 18.6837 10.75 18.9202 10.7339 19.1179C10.7165 19.331 10.6766 19.5642 10.5593 19.7945C10.3915 20.1238 10.1238 20.3915 9.79449 20.5593C9.56418 20.6766 9.33101 20.7165 9.11787 20.7339C8.92019 20.75 8.68372 20.75 8.42623 20.75H5.57377C5.31629 20.75 5.07981 20.75 4.88213 20.7339C4.669 20.7165 4.43583 20.6766 4.20552 20.5593C3.87624 20.3915 3.60852 20.1238 3.44074 19.7945C3.32339 19.5642 3.28353 19.331 3.26612 19.1179C3.24997 18.9202 3.24998 18.6837 3.25 18.4262V15.5738C3.24998 15.3163 3.24997 15.0798 3.26612 14.8821C3.28353 14.669 3.32339 14.4358 3.44074 14.2055C3.60852 13.8762 3.87624 13.6085 4.20552 13.4407C4.43583 13.3234 4.669 13.2835 4.88213 13.2661C5.07981 13.25 5.31629 13.25 5.57377 13.25ZM4.88088 14.7797C4.88085 14.7797 4.88131 14.7795 4.88237 14.7792L4.88088 14.7797ZM4.88346 14.7788C4.89234 14.7761 4.92546 14.7676 5.00428 14.7611C5.13341 14.7506 5.3076 14.75 5.6 14.75H8.4C8.6924 14.75 8.8666 14.7506 8.99573 14.7611C9.07453 14.7676 9.10766 14.7761 9.11654 14.7788C9.16118 14.8023 9.19766 14.8388 9.22118 14.8835C9.22393 14.8923 9.23243 14.9255 9.23887 15.0043C9.24942 15.1334 9.25 15.3076 9.25 15.6V18.4C9.25 18.6924 9.24942 18.8666 9.23887 18.9957C9.23243 19.0745 9.22393 19.1077 9.22118 19.1165C9.19766 19.1612 9.16118 19.1977 9.11654 19.2212C9.10767 19.2239 9.07454 19.2324 8.99573 19.2389C8.8666 19.2494 8.6924 19.25 8.4 19.25H5.6C5.3076 19.25 5.13341 19.2494 5.00428 19.2389C4.92547 19.2324 4.89235 19.2239 4.88347 19.2212C4.83883 19.1977 4.80235 19.1612 4.77883 19.1165C4.77607 19.1077 4.76757 19.0745 4.76114 18.9957C4.75059 18.8666 4.75 18.6924 4.75 18.4V15.6C4.75 15.3076 4.75059 15.1334 4.76114 15.0043C4.76757 14.9255 4.77607 14.8923 4.77883 14.8835C4.80234 14.8388 4.83882 14.8023 4.88346 14.7788ZM4.77973 14.8809C4.77974 14.8809 4.77956 14.8814 4.77918 14.8824L4.77973 14.8809ZM4.77973 19.1191C4.77972 19.1192 4.77953 19.1187 4.77918 19.1176L4.77973 19.1191ZM4.88088 19.2203C4.8809 19.2203 4.88143 19.2204 4.88236 19.2208L4.88088 19.2203ZM9.11913 19.2203C9.11917 19.2203 9.1187 19.2205 9.11762 19.2208L9.11913 19.2203ZM9.22028 19.1191C9.22026 19.1191 9.22044 19.1185 9.22087 19.1175L9.22028 19.1191ZM9.22027 14.8809C9.22028 14.8808 9.22048 14.8813 9.22084 14.8824L9.22027 14.8809ZM9.11761 14.7792C9.11868 14.7795 9.11915 14.7797 9.11913 14.7797L9.11761 14.7792ZM17 13.25C17.4142 13.25 17.75 13.5858 17.75 14V16.25H20C20.4142 16.25 20.75 16.5858 20.75 17C20.75 17.4142 20.4142 17.75 20 17.75H17.75V20C17.75 20.4142 17.4142 20.75 17 20.75C16.5858 20.75 16.25 20.4142 16.25 20V17.75H14C13.5858 17.75 13.25 17.4142 13.25 17C13.25 16.5858 13.5858 16.25 14 16.25H16.25V14C16.25 13.5858 16.5858 13.25 17 13.25Z"
  />
</svg>`;
var BlockHubRoundedRectangleIcon = html`<svg
  width="24"
  height="24"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.25 7C2.25 5.48122 3.48122 4.25 5 4.25H19C20.5188 4.25 21.75 5.48122 21.75 7V17C21.75 18.5188 20.5188 19.75 19 19.75H5C3.48122 19.75 2.25 18.5188 2.25 17V7ZM5 5.75C4.30964 5.75 3.75 6.30964 3.75 7V17C3.75 17.6904 4.30964 18.25 5 18.25H19C19.6904 18.25 20.25 17.6904 20.25 17V7C20.25 6.30964 19.6904 5.75 19 5.75H5Z"
  />
</svg>`;
var SearchIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M11 3.75C6.99594 3.75 3.75 6.99594 3.75 11C3.75 15.0041 6.99594 18.25 11 18.25C13.0026 18.25 14.8156 17.4381 16.1276 16.1254C16.128 16.1251 16.1284 16.1247 16.1287 16.1243C16.1288 16.1243 16.1289 16.1242 16.1289 16.1241C17.4395 14.8123 18.25 13.0008 18.25 11C18.25 6.99594 15.0041 3.75 11 3.75ZM17.6965 16.6324C18.9779 15.1104 19.75 13.1453 19.75 11C19.75 6.16751 15.8325 2.25 11 2.25C6.16751 2.25 2.25 6.16751 2.25 11C2.25 15.8325 6.16751 19.75 11 19.75C13.1471 19.75 15.1136 18.9767 16.6361 17.6933L20.4694 21.5301C20.7622 21.8231 21.2371 21.8233 21.5301 21.5306C21.8231 21.2378 21.8233 20.7629 21.5306 20.4699L17.6965 16.6324ZM10.25 6C10.25 5.58579 10.5858 5.25 11 5.25C14.1756 5.25 16.75 7.82436 16.75 11C16.75 11.4142 16.4142 11.75 16 11.75C15.5858 11.75 15.25 11.4142 15.25 11C15.25 8.65279 13.3472 6.75 11 6.75C10.5858 6.75 10.25 6.41421 10.25 6Z"
  />
</svg>`;
var ConfirmIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M17.6726 6.0059L7.49998 16.1785L2.32739 11.0059L3.5059 9.82739L7.49998 13.8215L16.4941 4.82739L17.6726 6.0059Z"
  />
</svg>`;
var EditIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.245 4.43531L12.543 5.16181L14.8382 7.45701L15.5647 6.75504C16.2018 6.11419 16.2006 5.07822 15.5612 4.4388C14.9218 3.7994 13.8859 3.79823 13.245 4.43531ZM13.9392 8.32572L11.6743 6.06086L5.13833 12.8251L4.2655 15.7345L7.17493 14.8617L13.9392 8.32572ZM12.3576 3.55492C13.4863 2.42619 15.3164 2.42619 16.4451 3.55492C17.5738 4.68365 17.5738 6.51369 16.4451 7.64242L16.4375 7.65L7.93429 15.8662C7.86252 15.9355 7.77518 15.9867 7.67959 16.0153L3.51292 17.2654C3.29269 17.3314 3.05397 17.2712 2.89139 17.1087C2.7288 16.9461 2.66862 16.7073 2.73469 16.4871L3.98469 12.3204C4.01337 12.2249 4.06452 12.1375 4.13387 12.0657L12.3576 3.55492Z"
  />
</svg>`;
var UnlinkIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12.8423 4.60675C14.6513 2.79775 17.5843 2.79775 19.3933 4.60675C21.2023 6.41576 21.2023 9.34874 19.3933 11.1577L17.3344 13.2166C17.0415 13.5095 16.5666 13.5095 16.2737 13.2166C15.9808 12.9237 15.9808 12.4489 16.2737 12.156L18.3326 10.0971C19.5558 8.87386 19.5558 6.89063 18.3326 5.66741C17.1094 4.44419 15.1261 4.44419 13.9029 5.66741L11.1578 8.41258C9.93454 9.6358 9.93454 11.619 11.1578 12.8423C11.3498 13.0343 11.5596 13.1955 11.7816 13.3266C12.1383 13.5372 12.2566 13.9971 12.046 14.3538C11.8353 14.7104 11.3755 14.8288 11.0188 14.6182C10.6892 14.4235 10.379 14.1849 10.0971 13.9029C8.28809 12.0939 8.28809 9.16093 10.0971 7.35192L12.8423 4.60675ZM11.954 9.64621C12.1647 9.28955 12.6246 9.17119 12.9812 9.38183C13.3109 9.57652 13.621 9.81514 13.9029 10.0971C15.7119 11.9061 15.7119 14.8391 13.9029 16.6481L11.1578 19.3932C9.34875 21.2023 6.41577 21.2023 4.60677 19.3932C2.79776 17.5842 2.79776 14.6513 4.60677 12.8423L6.66564 10.7834C6.95854 10.4905 7.43341 10.4905 7.7263 10.7834C8.0192 11.0763 8.0192 11.5511 7.7263 11.844L5.66743 13.9029C4.44421 15.1261 4.44421 17.1094 5.66743 18.3326C6.89065 19.5558 8.87388 19.5558 10.0971 18.3326L12.8423 15.5874C14.0655 14.3642 14.0655 12.381 12.8423 11.1577C12.6503 10.9657 12.4404 10.8045 12.2184 10.6734C11.8618 10.4627 11.7434 10.0029 11.954 9.64621Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.19501 3.26921C8.59861 3.17607 9.0013 3.42775 9.09444 3.83135L9.53081 5.72226C9.62395 6.12587 9.37227 6.52856 8.96866 6.6217C8.56505 6.71484 8.16236 6.46316 8.06922 6.05955L7.63286 4.16864C7.53972 3.76504 7.7914 3.36234 8.19501 3.26921ZM3.26922 8.19499C3.36236 7.79138 3.76505 7.5397 4.16866 7.63284L6.05957 8.06921C6.46317 8.16235 6.71486 8.56504 6.62172 8.96864C6.52858 9.37225 6.12588 9.62393 5.72228 9.53079L3.83137 9.09443C3.42776 9.00129 3.17608 8.5986 3.26922 8.19499ZM17.3783 15.0314C17.4715 14.6277 17.8741 14.3761 18.2777 14.4692L20.1687 14.9056C20.5723 14.9987 20.8239 15.4014 20.7308 15.805C20.6377 16.2086 20.235 16.4603 19.8314 16.3672L17.9405 15.9308C17.5369 15.8377 17.2852 15.435 17.3783 15.0314ZM15.0314 17.3783C15.435 17.2852 15.8377 17.5368 15.9308 17.9404L16.3672 19.8314C16.4603 20.235 16.2086 20.6377 15.805 20.7308C15.4014 20.8239 14.9987 20.5723 14.9056 20.1686L14.4692 18.2777C14.3761 17.8741 14.6278 17.4714 15.0314 17.3783Z"
  />
</svg>`;
var LinkToCardIcon = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77516)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M6.16667 6.79166C5.59137 6.79166 5.125 7.25803 5.125 7.83333V16.1667C5.125 16.742 5.59137 17.2083 6.16667 17.2083H17.8333C18.4086 17.2083 18.875 16.742 18.875 16.1667V12C18.875 11.6548 19.1548 11.375 19.5 11.375C19.8452 11.375 20.125 11.6548 20.125 12V16.1667C20.125 17.4323 19.099 18.4583 17.8333 18.4583H6.16667C4.90101 18.4583 3.875 17.4323 3.875 16.1667V7.83333C3.875 6.56768 4.90101 5.54166 6.16667 5.54166H12C12.3452 5.54166 12.625 5.82148 12.625 6.16666C12.625 6.51184 12.3452 6.79166 12 6.79166H6.16667Z"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M15.6063 5.48362C16.64 4.4499 18.316 4.4499 19.3497 5.48362C20.3834 6.51734 20.3834 8.19333 19.3497 9.22705L18.2774 10.2994C18.0333 10.5435 17.6376 10.5435 17.3935 10.2994C17.3371 10.243 17.2937 10.1784 17.2634 10.1096C17.2915 10.8217 17.0338 11.5429 16.4902 12.0866L15.0604 13.5164C14.0267 14.5501 12.3507 14.5501 11.317 13.5164C10.2832 12.4827 10.2832 10.8067 11.317 9.77294L12.3893 8.70061C12.6334 8.45653 13.0291 8.45653 13.2732 8.70061C13.3296 8.75703 13.373 8.82155 13.4033 8.89042C13.3751 8.17833 13.6329 7.45704 14.1765 6.91339L15.6063 5.48362ZM13.4445 9.2633C13.4215 9.38098 13.3643 9.49332 13.2732 9.58449L12.2008 10.6568C11.6553 11.2024 11.6553 12.0869 12.2008 12.6325C12.7464 13.1781 13.6309 13.1781 14.1765 12.6325L15.6063 11.2027C16.1518 10.6571 16.1518 9.77261 15.6063 9.22705C15.5203 9.1411 15.4267 9.0692 15.3279 9.01086C15.0307 8.83532 14.932 8.45209 15.1076 8.15487C15.2831 7.85766 15.6664 7.75902 15.9636 7.93456C16.1521 8.0459 16.3293 8.18227 16.4902 8.34317C16.8849 8.73787 17.1289 9.22622 17.2221 9.73669C17.2452 9.619 17.3023 9.50667 17.3935 9.4155L18.4658 8.34317C19.0114 7.7976 19.0114 6.91307 18.4658 6.3675C17.9203 5.82194 17.0357 5.82194 16.4902 6.3675L15.0604 7.79728C14.5148 8.34284 14.5148 9.22738 15.0604 9.77294C15.1463 9.85889 15.24 9.93079 15.3388 9.98913C15.636 10.1647 15.7346 10.5479 15.5591 10.8451C15.3835 11.1423 15.0003 11.241 14.7031 11.0654C14.5146 10.9541 14.3374 10.8177 14.1765 10.6568C13.7818 10.2621 13.5378 9.77377 13.4445 9.2633Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77516">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var CaptionIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.70831 4.16671C2.70831 3.36129 3.36123 2.70837 4.16665 2.70837H7.49998C8.30539 2.70837 8.95831 3.36129 8.95831 4.16671V7.50004C8.95831 8.30546 8.30539 8.95837 7.49998 8.95837H4.16665C3.36123 8.95837 2.70831 8.30546 2.70831 7.50004V4.16671ZM4.16665 3.95837C4.05159 3.95837 3.95831 4.05165 3.95831 4.16671V7.50004C3.95831 7.6151 4.05159 7.70837 4.16665 7.70837H7.49998C7.61504 7.70837 7.70831 7.6151 7.70831 7.50004V4.16671C7.70831 4.05165 7.61504 3.95837 7.49998 3.95837H4.16665Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.70831 16.6667C2.70831 16.3215 2.98814 16.0417 3.33331 16.0417L13.3333 16.0417C13.6785 16.0417 13.9583 16.3215 13.9583 16.6667C13.9583 17.0119 13.6785 17.2917 13.3333 17.2917L3.33331 17.2917C2.98813 17.2917 2.70831 17.0119 2.70831 16.6667Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M2.70831 12.5C2.70831 12.1549 2.98814 11.875 3.33331 11.875L16.6666 11.875C17.0118 11.875 17.2916 12.1549 17.2916 12.5C17.2916 12.8452 17.0118 13.125 16.6666 13.125L3.33331 13.125C2.98813 13.125 2.70831 12.8452 2.70831 12.5Z"
  />
</svg>`;
var DownloadIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.99997 2.70837C10.3452 2.70837 10.625 2.9882 10.625 3.33337V10.7134L12.197 9.14138C12.4411 8.8973 12.8368 8.8973 13.0809 9.14138C13.3249 9.38546 13.3249 9.78119 13.0809 10.0253L10.4419 12.6642C10.1978 12.9083 9.80211 12.9083 9.55803 12.6642L6.91909 10.0253C6.67502 9.78119 6.67502 9.38546 6.91909 9.14138C7.16317 8.8973 7.5589 8.8973 7.80298 9.14138L9.37498 10.7134V3.33337C9.37498 2.9882 9.6548 2.70837 9.99997 2.70837ZM16.6666 11.212C17.0118 11.212 17.2916 11.4918 17.2916 11.837V14.9104C17.2916 15.5317 17.0577 16.1337 16.6318 16.5825C16.2049 17.0324 15.6186 17.2917 15 17.2917H4.99998C4.38132 17.2917 3.79506 17.0324 3.36812 16.5825C2.94223 16.1337 2.70831 15.5317 2.70831 14.9104L2.70831 11.837C2.70831 11.4918 2.98813 11.212 3.33331 11.212C3.67849 11.212 3.95831 11.4918 3.95831 11.837L3.95831 14.9104C3.95831 15.2207 4.07559 15.5121 4.27482 15.722C4.473 15.9309 4.73459 16.0417 4.99998 16.0417H15C15.2654 16.0417 15.527 15.9309 15.7251 15.722C15.9244 15.5121 16.0416 15.2207 16.0416 14.9104V11.837C16.0416 11.4918 16.3215 11.212 16.6666 11.212Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.0787 13.6458C13.0787 13.3007 13.3585 13.0208 13.7037 13.0208H13.7111C14.0563 13.0208 14.3361 13.3007 14.3361 13.6458C14.3361 13.991 14.0563 14.2708 13.7111 14.2708H13.7037C13.3585 14.2708 13.0787 13.991 13.0787 13.6458Z"
  />
</svg>`;
var WrapIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 20 20"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.16665 2.5C3.53484 2.5 3.83331 2.79848 3.83331 3.16667L3.83331 16.8333C3.83331 17.2015 3.53484 17.5 3.16665 17.5C2.79846 17.5 2.49998 17.2015 2.49998 16.8333L2.49998 3.16667C2.49998 2.79848 2.79846 2.5 3.16665 2.5ZM9.31209 14.6598C9.58453 14.4121 9.60461 13.9905 9.35694 13.7181L8.85553 13.1665H11.8939C13.5757 13.1665 14.8333 11.6875 14.8333 9.99983C14.8333 8.31215 13.5757 6.83317 11.8939 6.83317H5.83334C5.46515 6.83317 5.16668 7.13164 5.16668 7.49983C5.16668 7.86802 5.46515 8.1665 5.83334 8.1665H11.8939C12.7226 8.1665 13.5 8.92609 13.5 9.99983C13.5 11.0736 12.7226 11.8332 11.8939 11.8332H8.85553L9.35694 11.2816C9.60461 11.0092 9.58453 10.5875 9.31209 10.3399C9.03966 10.0922 8.61802 10.1123 8.37035 10.3847L6.8552 12.0514C6.62404 12.3057 6.62404 12.694 6.8552 12.9483L8.37035 14.6149C8.61802 14.8874 9.03966 14.9075 9.31209 14.6598ZM16.1666 16.8333C16.1666 17.2015 16.4651 17.5 16.8333 17.5C17.2015 17.5 17.5 17.2015 17.5 16.8333L17.5 3.16667C17.5 2.79848 17.2015 2.5 16.8333 2.5C16.4651 2.5 16.1666 2.79848 16.1666 3.16667V16.8333Z"
  />
</svg>`;
var CancelWrapIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4 3.25C4.41421 3.25 4.75 3.58579 4.75 4L4.75 20C4.75 20.4142 4.41421 20.75 4 20.75C3.58579 20.75 3.25 20.4142 3.25 20L3.25 4C3.25 3.58579 3.58579 3.25 4 3.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20 3.25C20.4142 3.25 20.75 3.58579 20.75 4V20C20.75 20.4142 20.4142 20.75 20 20.75C19.5858 20.75 19.25 20.4142 19.25 20V4C19.25 3.58579 19.5858 3.25 20 3.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M10.6437 12.408C10.3168 12.7053 10.2927 13.2112 10.5899 13.5381L11.1916 14.2H7C6.55817 14.2 6.2 14.5582 6.2 15C6.2 15.4418 6.55817 15.8 7 15.8L11.1916 15.8L10.5899 16.4619C10.2927 16.7888 10.3168 17.2947 10.6437 17.592C10.9706 17.8892 11.4766 17.8651 11.7738 17.5381L13.592 15.5381C13.8693 15.233 13.8693 14.767 13.592 14.4619L11.7738 12.4619C11.4766 12.1349 10.9706 12.1108 10.6437 12.408Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.6437 6.40805C14.3168 6.70525 14.2927 7.21121 14.5899 7.53814L15.1916 8.2H7C6.55817 8.2 6.2 8.55817 6.2 9C6.2 9.44183 6.55817 9.8 7 9.8H15.1916L14.5899 10.4619C14.2927 10.7888 14.3168 11.2947 14.6437 11.592C14.9706 11.8892 15.4766 11.8651 15.7738 11.5381L17.592 9.53814C17.8693 9.233 17.8693 8.767 17.592 8.46186L15.7738 6.46186C15.4766 6.13494 14.9706 6.11084 14.6437 6.40805Z"
  />
</svg>`;
var RectIcon = html`<svg
  width="36"
  height="36"
  viewBox="0 0 36 36"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 14C8.25 11.9289 9.92893 10.25 12 10.25H24C26.0711 10.25 27.75 11.9289 27.75 14V22C27.75 24.0711 26.0711 25.75 24 25.75H12C9.92893 25.75 8.25 24.0711 8.25 22V14ZM12 11.75C10.7574 11.75 9.75 12.7574 9.75 14V22C9.75 23.2426 10.7574 24.25 12 24.25H24C25.2426 24.25 26.25 23.2426 26.25 22V14C26.25 12.7574 25.2426 11.75 24 11.75H12Z"
  />
</svg>`;
var ArrowDownIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M6.46967 9.46967C6.76256 9.17678 7.23744 9.17678 7.53033 9.46967L11.6464 13.5858C11.8417 13.781 12.1583 13.781 12.3536 13.5858L16.4697 9.46967C16.7626 9.17678 17.2374 9.17678 17.5303 9.46967C17.8232 9.76256 17.8232 10.2374 17.5303 10.5303L13.4142 14.6464C12.6332 15.4275 11.3668 15.4275 10.5858 14.6464L6.46967 10.5303C6.17678 10.2374 6.17678 9.76256 6.46967 9.46967Z"
  />
</svg>`;
var PageIconSVG = svg`
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 6C3.25 4.48122 4.48122 3.25 6 3.25H14C14.4142 3.25 14.75 3.58579 14.75 4C14.75 4.41421 14.4142 4.75 14 4.75H6C5.30964 4.75 4.75 5.30964 4.75 6V20C4.75 20.4142 4.41421 20.75 4 20.75C3.58579 20.75 3.25 20.4142 3.25 20V6Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20.75 18C20.75 19.5188 19.5188 20.75 18 20.75H10C9.58579 20.75 9.25 20.4142 9.25 20C9.25 19.5858 9.58579 19.25 10 19.25L18 19.25C18.6904 19.25 19.25 18.6904 19.25 18L19.25 4C19.25 3.58579 19.5858 3.25 20 3.25C20.4142 3.25 20.75 3.58579 20.75 4L20.75 18Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 9C8.25 8.0335 9.0335 7.25 10 7.25H14C14.9665 7.25 15.75 8.0335 15.75 9V11C15.75 11.9665 14.9665 12.75 14 12.75H10C9.0335 12.75 8.25 11.9665 8.25 11V9ZM10 8.75C9.86193 8.75 9.75 8.86193 9.75 9V11C9.75 11.1381 9.86193 11.25 10 11.25H14C14.1381 11.25 14.25 11.1381 14.25 11V9C14.25 8.86193 14.1381 8.75 14 8.75H10Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 16C8.25 15.5858 8.58579 15.25 9 15.25H15C15.4142 15.25 15.75 15.5858 15.75 16C15.75 16.4142 15.4142 16.75 15 16.75H9C8.58579 16.75 8.25 16.4142 8.25 16Z"
  />`;
var LinkedPageSVG = svg`<path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 6C3.25 4.48122 4.48122 3.25 6 3.25H14C14.4142 3.25 14.75 3.58579 14.75 4C14.75 4.41421 14.4142 4.75 14 4.75H6C5.30964 4.75 4.75 5.30964 4.75 6V20C4.75 20.4142 4.41421 20.75 4 20.75C3.58579 20.75 3.25 20.4142 3.25 20V6Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M20 10.75C19.5858 10.75 19.25 10.4142 19.25 10V4C19.25 3.58579 19.5858 3.25 20 3.25C20.4142 3.25 20.75 3.58579 20.75 4V10C20.75 10.4142 20.4142 10.75 20 10.75Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 9C8.25 8.0335 9.0335 7.25 10 7.25H14C14.9665 7.25 15.75 8.0335 15.75 9V11C15.75 11.9665 14.9665 12.75 14 12.75H10C9.0335 12.75 8.25 11.9665 8.25 11V9ZM10 8.75C9.86193 8.75 9.75 8.86193 9.75 9V11C9.75 11.1381 9.86193 11.25 10 11.25H14C14.1381 11.25 14.25 11.1381 14.25 11V9C14.25 8.86193 14.1381 8.75 14 8.75H10Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M8.25 16C8.25 15.5858 8.58579 15.25 9 15.25H12C12.4142 15.25 12.75 15.5858 12.75 16C12.75 16.4142 12.4142 16.75 12 16.75H9C8.58579 16.75 8.25 16.4142 8.25 16Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M18 14.75C17.5858 14.75 17.25 14.4142 17.25 14C17.25 13.5858 17.5858 13.25 18 13.25H20.9C20.9174 13.25 20.9346 13.2505 20.9517 13.2515C21.1594 13.2382 21.3716 13.3109 21.5303 13.4697C21.6891 13.6284 21.7618 13.8406 21.7485 14.0483C21.7495 14.0654 21.75 14.0826 21.75 14.1V17C21.75 17.4142 21.4142 17.75 21 17.75C20.5858 17.75 20.25 17.4142 20.25 17V15.8107L14.5303 21.5303C14.2374 21.8232 13.7626 21.8232 13.4697 21.5303C13.1768 21.2374 13.1768 20.7626 13.4697 20.4697L19.1893 14.75H18Z"
  />`;
var FontPageIcon = fontIcon(PageIconSVG);
var FontLinkedPageIcon = fontIcon(LinkedPageSVG);
var PageIcon = icon(PageIconSVG, 20);
var LinkedPageIcon = icon(LinkedPageSVG, 20);
var NewPageIcon = html`<svg
  width="20"
  height="20"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M12 3.25C12.4142 3.25 12.75 3.58579 12.75 4V20C12.75 20.4142 12.4142 20.75 12 20.75C11.5858 20.75 11.25 20.4142 11.25 20V4C11.25 3.58579 11.5858 3.25 12 3.25Z"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M3.25 12C3.25 11.5858 3.58579 11.25 4 11.25H20C20.4142 11.25 20.75 11.5858 20.75 12C20.75 12.4142 20.4142 12.75 20 12.75H4C3.58579 12.75 3.25 12.4142 3.25 12Z"
  />
</svg>`;
var DualLinkSVG = svg`<path
  fill-rule="evenodd"
  clip-rule="evenodd"
  d="M11 4.75C10.5858 4.75 10.25 4.41421 10.25 4C10.25 3.58579 10.5858 3.25 11 3.25H19.9C19.9174 3.25 19.9346 3.25052 19.9517 3.25155C20.1594 3.23823 20.3716 3.31093 20.5303 3.46967C20.6891 3.62841 20.7618 3.84059 20.7485 4.04829C20.7495 4.0654 20.75 4.08264 20.75 4.1V13C20.75 13.4142 20.4142 13.75 20 13.75C19.5858 13.75 19.25 13.4142 19.25 13V5.81066L4.53033 20.5303C4.23744 20.8232 3.76256 20.8232 3.46967 20.5303C3.17678 20.2374 3.17678 19.7626 3.46967 19.4697L18.1893 4.75H11Z"
/>`;
var DualLinkIcon = icon(DualLinkSVG, 20);
var DualLinkIcon16 = icon(DualLinkSVG, 16);

// node_modules/@blocksuite/global/dist/config/consts/block-hub.js
var paragraphConfig = [
  {
    flavour: "affine:paragraph",
    type: "text",
    name: "Text",
    hotkey: `${SHORT_KEY}+option+0,${SHORT_KEY}+shift+0`,
    icon: TextIcon
  },
  {
    flavour: "affine:paragraph",
    type: "h1",
    name: "Heading 1",
    hotkey: `${SHORT_KEY}+option+1,${SHORT_KEY}+shift+1`,
    icon: H1Icon
  },
  {
    flavour: "affine:paragraph",
    type: "h2",
    name: "Heading 2",
    hotkey: `${SHORT_KEY}+option+2,${SHORT_KEY}+shift+2`,
    icon: H2Icon
  },
  {
    flavour: "affine:paragraph",
    type: "h3",
    name: "Heading 3",
    hotkey: `${SHORT_KEY}+option+3,${SHORT_KEY}+shift+3`,
    icon: H3Icon
  },
  {
    flavour: "affine:paragraph",
    type: "h4",
    name: "Heading 4",
    hotkey: `${SHORT_KEY}+option+4,${SHORT_KEY}+shift+4`,
    icon: H4Icon
  },
  {
    flavour: "affine:paragraph",
    type: "h5",
    name: "Heading 5",
    hotkey: `${SHORT_KEY}+option+5,${SHORT_KEY}+shift+5`,
    icon: H5Icon
  },
  {
    flavour: "affine:paragraph",
    type: "h6",
    name: "Heading 6",
    hotkey: `${SHORT_KEY}+option+6,${SHORT_KEY}+shift+6`,
    icon: H6Icon
  },
  {
    flavour: "affine:list",
    type: "bulleted",
    name: "Bulleted List",
    hotkey: `${SHORT_KEY}+option+8,${SHORT_KEY}+shift+8`,
    icon: BulletedListIcon
  },
  {
    flavour: "affine:list",
    type: "numbered",
    name: "Numbered List",
    hotkey: `${SHORT_KEY}+option+9,${SHORT_KEY}+shift+9`,
    icon: NumberedListIcon
  },
  {
    flavour: "affine:list",
    type: "todo",
    name: "To-do List",
    hotkey: null,
    icon: TodoIcon
  },
  {
    flavour: "affine:code",
    type: void 0,
    name: "Code Block",
    // Use `alt` instead of `shift` because `ctrl+shift+c` will open chrome devtools on Windows.
    // Use `command` / `ctrl` instead of `${SHORT_KEY}` because `option` and `alt` are the same key on Mac, they will trigger twice.
    hotkey: `command+option+c,ctrl+alt+c`,
    icon: CodeBlockIcon
  },
  {
    flavour: "affine:paragraph",
    type: "quote",
    name: "Quote",
    hotkey: null,
    icon: QuoteIcon
  },
  {
    flavour: "affine:divider",
    type: "divider",
    name: "Divider",
    hotkey: `${SHORT_KEY}+option+d,${SHORT_KEY}+shift+d`,
    icon: DividerIcon
  }
  // {
  //   flavour: 'affine:',
  //   type: 'callout',
  //   name: 'Callout',
  //   icon: CalloutIcon,
  // },
];
var BLOCKHUB_TEXT_ITEMS = [
  {
    flavour: "affine:paragraph",
    type: "text",
    name: "Text",
    description: "Start typing with plain text.",
    icon: TextIcon,
    tooltip: "Drag/Click to insert Text block"
  },
  {
    flavour: "affine:paragraph",
    type: "h1",
    name: "Heading 1",
    description: "Headings in the largest font.",
    icon: H1Icon,
    tooltip: "Drag/Click to insert Heading 1"
  },
  {
    flavour: "affine:paragraph",
    type: "h2",
    name: "Heading 2",
    description: "Headings in the 2nd font size.",
    icon: H2Icon,
    tooltip: "Drag/Click to insert Heading 2"
  },
  {
    flavour: "affine:paragraph",
    type: "h3",
    name: "Heading 3",
    description: "Headings in the 3rd font size.",
    icon: H3Icon,
    tooltip: "Drag/Click to insert Heading 3"
  },
  {
    flavour: "affine:paragraph",
    type: "h4",
    name: "Heading 4",
    description: "Heading in the 4th font size.",
    icon: H4Icon,
    tooltip: "Drag/Click to insert Heading 4"
  },
  {
    flavour: "affine:paragraph",
    type: "h5",
    name: "Heading 5",
    description: "Heading in the 5th font size.",
    icon: H5Icon,
    tooltip: "Drag/Click to insert Heading 5"
  },
  {
    flavour: "affine:paragraph",
    type: "h6",
    name: "Heading 6",
    description: "Heading in the 6th font size.",
    icon: H6Icon,
    tooltip: "Drag/Click to insert Heading 6"
  },
  {
    flavour: "affine:code",
    type: null,
    name: "Code Block",
    description: "Capture a code snippet.",
    icon: CodeBlockIcon,
    tooltip: "Drag/Click to insert Code Block"
  },
  {
    flavour: "affine:paragraph",
    type: "quote",
    name: "Quote",
    description: "Capture a quote.",
    icon: QuoteIcon,
    tooltip: "Drag/Click to insert Quote"
  },
  {
    flavour: "affine:divider",
    type: null,
    name: "Divider",
    description: "A visual divider.",
    icon: DividerIcon,
    tooltip: "A visual divider"
  }
];
var BLOCKHUB_LIST_ITEMS = [
  {
    flavour: "affine:list",
    type: "bulleted",
    name: "Bulleted List",
    description: "A simple bulleted list.",
    icon: BulletedListIcon,
    tooltip: "Drag/Click to insert Bulleted List"
  },
  {
    flavour: "affine:list",
    type: "numbered",
    name: "Numbered List",
    description: "A list with numbering.",
    icon: NumberedListIcon,
    tooltip: "Drag/Click to insert Numbered List"
  },
  {
    flavour: "affine:list",
    type: "todo",
    name: "To-do List",
    description: "Track tasks with a to-do list.",
    icon: TodoIcon,
    tooltip: "Drag/Click to insert To-do List"
  }
];
var BLOCKHUB_FILE_ITEMS = [
  {
    flavour: "affine:embed",
    type: "image",
    name: "Image",
    description: "Upload images.",
    icon: ImageIcon,
    tooltip: "Drag/Click to insert Image"
  },
  {
    flavour: "affine:bookmark",
    type: "bookmark",
    name: "Bookmark",
    description: "Insert a link in card view.",
    icon: BookmarkIcon,
    tooltip: "Drag/Click to insert Bookmark"
  }
];

// node_modules/@blocksuite/global/dist/config/consts.js
var BLOCK_ID_ATTR = "data-block-id";
var BLOCK_SERVICE_LOADING_ATTR = "data-service-loading";
var PREVENT_DEFAULT = false;
var ALLOW_DEFAULT = true;
var HOTKEYS = {
  ANY_KEY: "*",
  UNDO: `${SHORT_KEY}+z`,
  REDO: `${SHORT_KEY}+shift+z,ctrl+y`,
  BACKSPACE: "backspace",
  DELETE: "delete",
  SELECT_ALL: `${SHORT_KEY}+a`,
  SHIFT_UP: "shift+up",
  SHIFT_DOWN: "shift+down",
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  ENTER: "enter",
  TAB: "tab",
  SPACE: "space",
  ESC: "esc"
};
var SCROLL_THRESHOLD = 100;
var EDITOR_WIDTH = 800;
var BLOCK_CHILDREN_CONTAINER_PADDING_LEFT = 26;
var PAGE_BLOCK_PADDING_BOTTOM = 150;
var PAGE_BLOCK_CHILD_PADDING = 24;
var DRAG_HANDLE_OFFSET_LEFT = 1;
var EDGELESS_BLOCK_CHILD_PADDING = 24;
var FRAME_BACKGROUND_COLORS = [
  "--affine-background-secondary-color",
  "--affine-tag-yellow",
  "--affine-tag-red",
  "--affine-tag-green",
  "--affine-tag-blue",
  "--affine-tag-purple"
];

// node_modules/@blocksuite/global/dist/utils/disposable.js
var DisposableGroup = class {
  constructor() {
    this._disposed = false;
    this._disposables = [];
  }
  get disposed() {
    return this._disposed;
  }
  /**
   * Add to group to be disposed with others.
   * This will be immediately disposed if this group has already been disposed.
   */
  add(d3) {
    if (typeof d3 === "function") {
      if (this._disposed)
        d3();
      else
        this._disposables.push({ dispose: d3 });
    } else {
      if (this._disposed)
        d3.dispose();
      else
        this._disposables.push(d3);
    }
  }
  addFromEvent(target, type, handler, eventOptions) {
    this.add({
      dispose: () => {
        target.removeEventListener(type, handler, eventOptions);
      }
    });
    target.addEventListener(type, handler, eventOptions);
  }
  dispose() {
    disposeAll(this._disposables);
    this._disposables = [];
    this._disposed = true;
  }
};
function flattenDisposables(disposables) {
  return {
    dispose: () => disposeAll(disposables)
  };
}
function disposeAll(disposables) {
  for (const disposable of disposables) {
    try {
      disposable.dispose();
    } catch (err) {
      console.error(err);
    }
  }
}

// node_modules/@blocksuite/global/dist/utils/slot.js
var Slot = class _Slot {
  constructor() {
    this._emitting = false;
    this._callbacks = [];
    this._disposables = [];
    this.subscribe = (selector, callback, config) => {
      let prevState;
      const { filter: filter2, equalityFn = Object.is } = config ?? {};
      return this.on((state2) => {
        if (filter2 && !filter2(state2)) {
          return;
        }
        const nextState = selector(state2);
        if (prevState === void 0 || !equalityFn(prevState, nextState)) {
          callback(nextState);
          prevState = nextState;
        }
      });
    };
  }
  filter(testFun) {
    const result = new _Slot();
    result._disposables.push({ dispose: () => this.dispose() });
    this.on((v2) => {
      if (testFun(v2)) {
        result.emit(v2);
      }
    });
    return result;
  }
  on(callback) {
    if (this._emitting) {
      const newCallback = [...this._callbacks, callback];
      this._callbacks = newCallback;
    } else {
      this._callbacks.push(callback);
    }
    return {
      dispose: () => {
        if (this._emitting) {
          this._callbacks = this._callbacks.filter((v2) => v2 !== callback);
        } else {
          const index = this._callbacks.indexOf(callback);
          if (index > -1) {
            this._callbacks.splice(index, 1);
          }
        }
      }
    };
  }
  once(callback) {
    let dispose = void 0;
    const handler = (v2) => {
      callback(v2);
      if (dispose) {
        dispose();
      }
    };
    const disposable = this.on(handler);
    dispose = disposable.dispose;
    return disposable;
  }
  unshift(callback) {
    if (this._emitting) {
      const newCallback = [callback, ...this._callbacks];
      this._callbacks = newCallback;
    } else {
      this._callbacks.unshift(callback);
    }
    return {
      dispose: () => {
        if (this._emitting) {
          this._callbacks = this._callbacks.filter((v2) => v2 !== callback);
        } else {
          const index = this._callbacks.indexOf(callback);
          if (index > -1) {
            this._callbacks.splice(index, 1);
          }
        }
      }
    };
  }
  emit(v2) {
    const prevEmitting = this._emitting;
    this._emitting = true;
    this._callbacks.forEach((f) => {
      try {
        f(v2);
      } catch (err) {
        console.error(err);
      }
    });
    this._emitting = prevEmitting;
  }
  pipe(that) {
    this._callbacks.push((v2) => that.emit(v2));
    return this;
  }
  dispose() {
    flattenDisposables(this._disposables).dispose();
    this._callbacks = [];
    this._disposables = [];
  }
  toDispose(disposables) {
    disposables.push(this);
    return this;
  }
};

// node_modules/@blocksuite/global/dist/utils/web.js
var isWeb = typeof window !== "undefined";
var isFirefox = isWeb && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
var withHidePopup = (fn) => {
  const map2 = /* @__PURE__ */ new Map();
  const formatBar = document.querySelector("format-quick-bar");
  if (formatBar) {
    map2.set(formatBar, formatBar.style.visibility);
    formatBar.style.visibility = "hidden";
  }
  try {
    return fn();
  } finally {
    map2.forEach((visibility, node) => {
      node.style.visibility = visibility;
    });
  }
};
function caretRangeFromPoint(clientX, clientY) {
  if (isFirefox) {
    const caret = document.caretPositionFromPoint(clientX, clientY);
    const range2 = document.createRange();
    range2.setStart(caret.offsetNode, caret.offset);
    return range2;
  }
  const range = document.caretRangeFromPoint(clientX, clientY);
  if (!range) {
    return null;
  }
  const rangeRects = range == null ? void 0 : range.getClientRects();
  if (rangeRects && rangeRects.length === 2 && range.startOffset === range.endOffset && clientY < rangeRects[0].y + rangeRects[0].height) {
    const deltaX = (rangeRects[0].x | 0) - (rangeRects[1].x | 0);
    if (deltaX > 0) {
      range.setStart(range.startContainer, range.startOffset - 1);
      range.setEnd(range.endContainer, range.endOffset - 1);
    }
  }
  if (range.startContainer === document.body && range.endContainer === document.body) {
    const retryRange = withHidePopup(() => document.caretRangeFromPoint(clientX, clientY));
    return retryRange;
  }
  return range;
}

// node_modules/@blocksuite/global/dist/utils.js
var SYS_KEYS = /* @__PURE__ */ new Set(["id", "flavour", "children"]);
function isPrimitive2(a2) {
  return a2 !== Object(a2);
}
function assertExists(val, message = "val does not exist") {
  if (val === null || val === void 0) {
    if (message instanceof Error) {
      throw message;
    }
    throw new Error(message);
  }
}
function assertNotExists(val, message = "val exists") {
  if (val !== null && val !== void 0) {
    throw new Error(message);
  }
}
function assertFlavours(model, allowed) {
  if (!allowed.includes(model.flavour)) {
    throw new Error(`model flavour ${model.flavour} is not allowed`);
  }
}
function matchFlavours(model, expected) {
  return expected.includes(model.flavour);
}
var nonTextBlock = [
  "affine:database",
  "affine:divider",
  "affine:embed",
  "affine:code"
];
function assertEquals(val, expected, message = "val is not same as expected") {
  if (!isEqual(val, expected)) {
    throw new Error(message);
  }
}
function isEqual(val, expected) {
  const a2 = isPrimitive2(val);
  const b2 = isPrimitive2(expected);
  if (a2 && b2) {
    if (!Object.is(val, expected)) {
      return false;
    }
  } else if (a2 !== b2) {
    return false;
  } else {
    if (Array.isArray(val) && Array.isArray(expected)) {
      if (val.length !== expected.length) {
        return false;
      }
      return val.every((x2, i) => isEqual(x2, expected[i]));
    } else if (typeof val === "object" && typeof expected === "object") {
      const obj1 = Object.entries(val);
      const obj2 = Object.entries(expected);
      if (obj1.length !== obj2.length) {
        return false;
      }
      return obj1.every((x2, i) => isEqual(x2, obj2[i]));
    }
  }
  return true;
}
async function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
function diffArray(before, after, compare = (a2, b2) => a2 === b2) {
  const add = [];
  const remove = [];
  const unchanged = [];
  for (const elem of before) {
    if (!after.some((afterElem) => compare(afterElem, elem))) {
      remove.push(elem);
    } else {
      unchanged.push(elem);
    }
  }
  for (const elem of after) {
    if (!before.some((beforeElem) => compare(beforeElem, elem))) {
      add.push(elem);
    }
  }
  return { changed: add.length || remove.length, add, remove, unchanged };
}

// node_modules/@blocksuite/store/dist/awareness.js
var import_merge = __toESM(require_src(), 1);

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a2, b2) => a2 < b2 ? a2 : b2;
var max = (a2, b2) => a2 > b2 ? a2 : b2;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c2) => (c2 ^ uint32() & 15 >> c2 / 4).toString(16)
);

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, "");

// node_modules/@blocksuite/store/dist/utils/id-generator.js
function createAutoIncrementIdGenerator() {
  let i = 0;
  return () => (i++).toString();
}
function createAutoIncrementIdGeneratorByClientId(clientId) {
  let i = 0;
  return () => `${clientId}:${i++}`;
}
function uuidv42() {
  return uuidv4();
}
function nanoid2() {
  return nanoid(10);
}

// node_modules/@blocksuite/store/dist/awareness.js
var AwarenessStore = class {
  constructor(store, awareness, defaultFlags) {
    var _a10;
    this.slots = {
      update: new Slot()
    };
    this._onAwarenessChange = (diff) => {
      const { added, removed, updated } = diff;
      const states = this.awareness.getStates();
      added.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "add",
          state: states.get(id2)
        });
      });
      updated.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "update",
          state: states.get(id2)
        });
      });
      removed.forEach((id2) => {
        this.slots.update.emit({
          id: id2,
          type: "remove"
        });
      });
    };
    this._onAwarenessMessage = (awMsg) => {
      if (this.getFlag("enable_set_remote_flag") === true) {
        this._handleRemoteFlags();
      }
    };
    this.store = store;
    this.awareness = awareness;
    this.awareness.on("change", this._onAwarenessChange);
    this.slots.update.on(this._onAwarenessMessage);
    const upstreamFlags = (_a10 = awareness.getLocalState()) == null ? void 0 : _a10.flags;
    if (upstreamFlags) {
      this.awareness.setLocalStateField("flags", (0, import_merge.merge)(true, defaultFlags, upstreamFlags));
    } else {
      this.awareness.setLocalStateField("flags", { ...defaultFlags });
    }
  }
  setFlag(field, value) {
    var _a10;
    const oldFlags = ((_a10 = this.awareness.getLocalState()) == null ? void 0 : _a10.flags) ?? {};
    this.awareness.setLocalStateField("flags", { ...oldFlags, [field]: value });
  }
  getFlag(field) {
    var _a10;
    const flags = ((_a10 = this.awareness.getLocalState()) == null ? void 0 : _a10.flags) ?? {};
    return flags[field];
  }
  setReadonly(space, value) {
    const flags = this.getFlag("readonly") ?? {};
    this.setFlag("readonly", {
      ...flags,
      [space.prefixedId]: value
    });
  }
  isReadonly(space) {
    const rd = this.getFlag("readonly");
    if (rd && typeof rd === "object") {
      return Boolean(rd[space.prefixedId]);
    } else {
      return false;
    }
  }
  setRemoteFlag(clientId, field, value) {
    var _a10;
    if (!this.getFlag("enable_set_remote_flag")) {
      console.error("set remote flag feature disabled");
      return;
    }
    const oldRequest = ((_a10 = this.awareness.getLocalState()) == null ? void 0 : _a10.request) ?? [];
    this.awareness.setLocalStateField("request", [
      ...oldRequest,
      {
        id: uuidv42(),
        clientId,
        field,
        value
      }
    ]);
  }
  setLocalRange(space, range) {
    var _a10;
    const rangeMap = ((_a10 = this.awareness.getLocalState()) == null ? void 0 : _a10.rangeMap) ?? {};
    if (range === null) {
      delete rangeMap[space.prefixedId];
      this.awareness.setLocalStateField("rangeMap", rangeMap);
    } else {
      this.awareness.setLocalStateField("rangeMap", {
        ...rangeMap,
        [space.prefixedId]: range
      });
    }
  }
  getLocalRange(space) {
    var _a10, _b6;
    return (_b6 = (_a10 = this.awareness.getLocalState()) == null ? void 0 : _a10["rangeMap"]) == null ? void 0 : _b6[space.prefixedId];
  }
  getStates() {
    return this.awareness.getStates();
  }
  _handleRemoteFlags() {
    const nextTick = [];
    const localState = this.awareness.getLocalState();
    const request = (localState == null ? void 0 : localState.request) ?? [];
    const selfResponse = [];
    const fakeDirtyResponse = [];
    if (localState && Array.isArray(localState.response)) {
      selfResponse.push(...localState.response);
      fakeDirtyResponse.push(...localState.response);
    }
    const response = [];
    for (const [clientId, state2] of this.awareness.getStates()) {
      if (clientId === this.awareness.clientID) {
        continue;
      }
      if (Array.isArray(state2.response)) {
        response.push(...state2.response);
      }
      if (Array.isArray(state2.request)) {
        const remoteRequest = state2.request;
        selfResponse.forEach((response2, idx) => {
          if (response2 === null) {
            return;
          }
          const index = remoteRequest.findIndex((request2) => request2.id === response2.id);
          if (index === -1) {
            fakeDirtyResponse[idx].id = "remove";
          }
        });
        remoteRequest.forEach((request2) => {
          if (request2.clientId === this.awareness.clientID) {
            nextTick.push(() => {
              this.setFlag(request2.field, request2.value);
            });
            selfResponse.push({
              id: request2.id
            });
          }
        });
      }
    }
    response.forEach((response2) => {
      const idx = request.findIndex((request2) => request2.id === response2.id);
      if (idx !== -1) {
        request.splice(idx, 1);
      }
    });
    nextTick.push(() => {
      this.awareness.setLocalStateField("request", request);
      this.awareness.setLocalStateField("response", selfResponse.filter((response2, idx) => fakeDirtyResponse[idx] ? fakeDirtyResponse[idx].id !== "remove" : true));
    });
    setTimeout(() => {
      nextTick.forEach((fn) => fn());
    }, 100);
  }
  destroy() {
    if (this.awareness) {
      this.awareness.off("change", this._onAwarenessChange);
      this.slots.update.dispose();
    }
  }
};

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params2) => {
  const { data, path: path2, errorMaps, issueData } = params2;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params2) {
    const result = this.safeParse(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params2) {
    var _a10;
    const ctx = {
      common: {
        issues: [],
        async: (_a10 = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a10 !== void 0 ? _a10 : false,
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params2) {
    const result = await this.safeParseAsync(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params2) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
        async: true
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args2) => {
  if (args2.precision) {
    if (args2.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args2.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args2.precision}}Z$`);
    }
  } else if (args2.precision === 0) {
    if (args2.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args2.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a10) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a10;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a10 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a10 !== void 0 ? _a10 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodString.create = (params2) => {
  var _a10;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a10 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a10 !== void 0 ? _a10 : false,
    ...processCreateParams(params2)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
};
ZodNumber.create = (params2) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodBigInt.create = (params2) => {
  var _a10;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a10 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a10 !== void 0 ? _a10 : false,
    ...processCreateParams(params2)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params2) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
};
ZodDate.create = (params2) => {
  return new ZodDate({
    checks: [],
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params2)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params2) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params2)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params2) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params2)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params2) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params2)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params2) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params2)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params2) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params2)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params2) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params2)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params2) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params2)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params2) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params2)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a10, _b6, _c4, _d3;
          const defaultError = (_c4 = (_b6 = (_a10 = this._def).errorMap) === null || _b6 === void 0 ? void 0 : _b6.call(_a10, issue, ctx).message) !== null && _c4 !== void 0 ? _c4 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d3 = errorUtil.errToObj(message).message) !== null && _d3 !== void 0 ? _d3 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.strictCreate = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.lazycreate = (shape, params2) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types2, params2) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params2)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params2) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params2)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params2) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params2)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params2) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params2)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params2) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params2)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params2) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params2)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args2, error) {
      return makeIssue({
        data: args2,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params2 = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args2) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args2, params2).catch((e) => {
          error.addIssue(makeArgsIssue(args2, e));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args2) => {
        const parsedArgs = this._def.args.safeParse(args2, params2);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args2, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params2);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args2, returns, params2) {
    return new _ZodFunction({
      args: args2 ? args2 : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params2)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params2) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params2)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params2) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params2)
  });
};
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params2) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params2)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params2) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params2)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params2) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params2)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params2)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params2) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params2)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params2) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params2)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params2) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
    ...processCreateParams(params2)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params2) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
    ...processCreateParams(params2)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params2) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params2)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = (check, params2 = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a10, _b6;
      if (!check(data)) {
        const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
        const _fatal = (_b6 = (_a10 = p.fatal) !== null && _a10 !== void 0 ? _a10 : fatal) !== null && _b6 !== void 0 ? _b6 : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params2 = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params2);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/yjs/dist/yjs.mjs
var yjs_exports = {};
__export(yjs_exports, {
  AbsolutePosition: () => AbsolutePosition,
  AbstractConnector: () => AbstractConnector,
  AbstractStruct: () => AbstractStruct,
  AbstractType: () => AbstractType,
  Array: () => YArray,
  ContentAny: () => ContentAny,
  ContentBinary: () => ContentBinary,
  ContentDeleted: () => ContentDeleted,
  ContentEmbed: () => ContentEmbed,
  ContentFormat: () => ContentFormat,
  ContentJSON: () => ContentJSON,
  ContentString: () => ContentString,
  ContentType: () => ContentType,
  Doc: () => Doc,
  GC: () => GC,
  ID: () => ID,
  Item: () => Item,
  Map: () => YMap,
  PermanentUserData: () => PermanentUserData,
  RelativePosition: () => RelativePosition,
  Snapshot: () => Snapshot,
  Text: () => YText,
  Transaction: () => Transaction,
  UndoManager: () => UndoManager,
  UpdateEncoderV1: () => UpdateEncoderV1,
  XmlElement: () => YXmlElement,
  XmlFragment: () => YXmlFragment,
  XmlHook: () => YXmlHook,
  XmlText: () => YXmlText,
  YArrayEvent: () => YArrayEvent,
  YEvent: () => YEvent,
  YMapEvent: () => YMapEvent,
  YTextEvent: () => YTextEvent,
  YXmlEvent: () => YXmlEvent,
  applyUpdate: () => applyUpdate,
  applyUpdateV2: () => applyUpdateV2,
  cleanupYTextFormatting: () => cleanupYTextFormatting,
  compareIDs: () => compareIDs,
  compareRelativePositions: () => compareRelativePositions,
  convertUpdateFormatV1ToV2: () => convertUpdateFormatV1ToV2,
  convertUpdateFormatV2ToV1: () => convertUpdateFormatV2ToV1,
  createAbsolutePositionFromRelativePosition: () => createAbsolutePositionFromRelativePosition,
  createDeleteSet: () => createDeleteSet,
  createDeleteSetFromStructStore: () => createDeleteSetFromStructStore,
  createDocFromSnapshot: () => createDocFromSnapshot,
  createID: () => createID,
  createRelativePositionFromJSON: () => createRelativePositionFromJSON,
  createRelativePositionFromTypeIndex: () => createRelativePositionFromTypeIndex,
  createSnapshot: () => createSnapshot,
  decodeRelativePosition: () => decodeRelativePosition,
  decodeSnapshot: () => decodeSnapshot,
  decodeSnapshotV2: () => decodeSnapshotV2,
  decodeStateVector: () => decodeStateVector,
  decodeUpdate: () => decodeUpdate,
  decodeUpdateV2: () => decodeUpdateV2,
  diffUpdate: () => diffUpdate,
  diffUpdateV2: () => diffUpdateV2,
  emptySnapshot: () => emptySnapshot,
  encodeRelativePosition: () => encodeRelativePosition,
  encodeSnapshot: () => encodeSnapshot,
  encodeSnapshotV2: () => encodeSnapshotV2,
  encodeStateAsUpdate: () => encodeStateAsUpdate,
  encodeStateAsUpdateV2: () => encodeStateAsUpdateV2,
  encodeStateVector: () => encodeStateVector,
  encodeStateVectorFromUpdate: () => encodeStateVectorFromUpdate,
  encodeStateVectorFromUpdateV2: () => encodeStateVectorFromUpdateV2,
  equalDeleteSets: () => equalDeleteSets,
  equalSnapshots: () => equalSnapshots,
  findIndexSS: () => findIndexSS,
  findRootTypeKey: () => findRootTypeKey,
  getItem: () => getItem,
  getState: () => getState,
  getTypeChildren: () => getTypeChildren,
  isDeleted: () => isDeleted,
  isParentOf: () => isParentOf,
  iterateDeletedStructs: () => iterateDeletedStructs,
  logType: () => logType,
  logUpdate: () => logUpdate,
  logUpdateV2: () => logUpdateV2,
  mergeUpdates: () => mergeUpdates,
  mergeUpdatesV2: () => mergeUpdatesV2,
  obfuscateUpdate: () => obfuscateUpdate,
  obfuscateUpdateV2: () => obfuscateUpdateV2,
  parseUpdateMeta: () => parseUpdateMeta,
  parseUpdateMetaV2: () => parseUpdateMetaV2,
  readUpdate: () => readUpdate,
  readUpdateV2: () => readUpdateV2,
  relativePositionToJSON: () => relativePositionToJSON,
  snapshot: () => snapshot,
  snapshotContainsUpdate: () => snapshotContainsUpdate,
  transact: () => transact,
  tryGc: () => tryGc,
  typeListToArraySnapshot: () => typeListToArraySnapshot,
  typeMapGetSnapshot: () => typeMapGetSnapshot
});

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v2, k) => {
    r.set(k, v2);
  });
  return r;
};
var setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
};
var from2 = Array.from;
var some = (arr, f) => {
  for (let i = 0; i < arr.length; i++) {
    if (f(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};
var unfold = (len, f) => {
  const array = new Array(len);
  for (let i = 0; i < len; i++) {
    array[i] = f(i, array);
  }
  return array;
};
var isArray2 = Array.isArray;

// node_modules/lib0/observable.js
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f2 = (...args2) => {
      this.off(name, _f2);
      f(...args2);
    };
    this.on(name, _f2);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match2) => `${separator}${toLowerCase(match2)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
var repeat = (source, n) => unfold(n, () => source).join("");

// node_modules/lib0/conditions.js
var undefinedToNull = (v2) => v2 === void 0 ? null : v2;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined") {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a2, b2) => a2 === b2 || length2(a2) === length2(b2) && every(a2, (val, key) => (val !== void 0 || hasProperty(b2, key)) && b2[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
};
var nop = () => {
};
var id = (a2) => a2;
var equalityStrict = (a2, b2) => a2 === b2;
var equalityDeep = (a2, b2) => {
  if (a2 == null || b2 == null) {
    return equalityStrict(a2, b2);
  }
  if (a2.constructor !== b2.constructor) {
    return false;
  }
  if (a2 === b2) {
    return true;
  }
  switch (a2.constructor) {
    case ArrayBuffer:
      a2 = new Uint8Array(a2);
      b2 = new Uint8Array(b2);
    case Uint8Array: {
      if (a2.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i = 0; i < a2.length; i++) {
        if (a2[i] !== b2[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a2.size !== b2.size) {
        return false;
      }
      for (const value of a2) {
        if (!b2.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a2.size !== b2.size) {
        return false;
      }
      for (const key of a2.keys()) {
        if (!b2.has(key) || !equalityDeep(a2.get(key), b2.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a2) !== length2(b2)) {
        return false;
      }
      for (const key in a2) {
        if (!hasProperty(a2, key) || !equalityDeep(a2[key], b2[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a2.length !== b2.length) {
        return false;
      }
      for (let i = 0; i < a2.length; i++) {
        if (!equalityDeep(a2[i], b2[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase()]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/error.js
var create3 = (s) => new Error(s);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length4) => new Uint8Array(buffer, byteOffset, length4);
var toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s) => {
  const a2 = atob(s);
  const bytes = createUint8ArrayFromLen(a2.length);
  for (let i = 0; i < a2.length; i++) {
    bytes[i] = a2.charCodeAt(i);
  }
  return bytes;
};
var fromBase64Node = (s) => {
  const buf = Buffer.from(s, "base64");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length3 = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length3(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d3 = encoder.bufs[i];
    uint8arr.set(d3, curPos);
    curPos += d3.length;
  }
  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeBinaryEncoder = (encoder, append2) => writeUint8Array(encoder, toUint8Array(append2));
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray2(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v2);
      this.s = v2;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v2;
    }
  }
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.diff === v2 - this.s) {
      this.s = v2;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v2 - this.s;
      this.s = v2;
    }
  }
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
var nextColor = 0;
var lastLoggingTime = getUnixTime();
var createModuleLogger = (_print, moduleName) => {
  const color2 = loggingColors[nextColor];
  const debugRegexVar = getVariable("log");
  const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
  nextColor = (nextColor + 1) % loggingColors.length;
  moduleName += ": ";
  return !doLogging ? nop : (...args2) => {
    const timeNow = getUnixTime();
    const timeDiff = timeNow - lastLoggingTime;
    lastLoggingTime = timeNow;
    _print(
      color2,
      moduleName,
      UNCOLOR,
      ...args2.map(
        (arg) => typeof arg === "string" || typeof arg === "symbol" ? arg : JSON.stringify(arg)
      ),
      color2,
      " +" + timeDiff + "ms"
    );
  };
};

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create2();
var createModuleLogger2 = (moduleName) => createModuleLogger(print, moduleName);

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var AbstractConnector = class extends Observable {
  /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */
  constructor(ydoc, awareness) {
    super();
    this.doc = ydoc;
    this.awareness = awareness;
  }
};
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i = 0; i < deletes.length; i++) {
    const del = deletes[i];
    iterateStructs(transaction, structs, del.clock, del.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a2, b2) => a2.clock - b2.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length4) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length4));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state2 = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state2) {
        if (state2 < clockEnd) {
          addToDeleteSet(unappliedDS, client, state2, clockEnd - state2);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var equalDeleteSets = (ds1, ds2) => {
  if (ds1.clients.size !== ds2.clients.size)
    return false;
  for (const [client, deleteItems1] of ds1.clients.entries()) {
    const deleteItems2 = (
      /** @type {Array<import('../internals.js').DeleteItem>} */
      ds2.clients.get(client)
    );
    if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length)
      return false;
    for (let i = 0; i < deleteItems1.length; i++) {
      const di1 = deleteItems1[i];
      const di2 = deleteItems2[i];
      if (di1.clock !== di2.clock || di1.len !== di2.len) {
        return false;
      }
    }
  }
  return true;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends Observable {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve2) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve2(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve2) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve2();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (!this.isLoaded) {
        this.emit("load", []);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = AbstractType) {
    const type = setIfUndefined(this.share, name, () => {
      const t2 = new TypeConstructor();
      t2._integrate(this, null);
      return t2;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t2 = new TypeConstructor();
        t2._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t2;
            }
          }
        );
        t2._start = type._start;
        for (let n = t2._start; n !== null; n = n.right) {
          n.parent = t2;
        }
        t2._length = type._length;
        this.share.set(name, t2);
        t2._integrate(this, null);
        return t2;
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return type;
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return this.get(name, YArray);
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return this.get(name, YMap);
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
  /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */
  on(eventName, f) {
    super.on(eventName, f);
  }
  /**
   * @param {string} eventName
   * @param {function} f
   */
  off(eventName, f) {
    super.off(eventName, f);
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // leftd
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a2, b2) => a2 - b2);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null && stack.length === 0) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state2 = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c2) => c2 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state2, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state2.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.client === b2.client && a2.clock === b2.clock;
var createID = (client, clock) => new ID(client, clock);
var writeID = (encoder, id2) => {
  writeVarUint(encoder, id2.client);
  writeVarUint(encoder, id2.clock);
};
var readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var logType = (type) => {
  const res = [];
  let n = type._start;
  while (n) {
    res.push(n);
    n = n.right;
  }
  console.log("Children: ", res);
  console.log("Children content: ", res.filter((m) => !m.deleted).map((m) => m.content));
};
var PermanentUserData = class {
  /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */
  constructor(doc2, storeType = doc2.getMap("users")) {
    const dss = /* @__PURE__ */ new Map();
    this.yusers = storeType;
    this.doc = doc2;
    this.clients = /* @__PURE__ */ new Map();
    this.dss = dss;
    const initUser = (user, userDescription) => {
      const ds = user.get("ds");
      const ids = user.get("ids");
      const addClientId = (
        /** @param {number} clientid */
        (clientid) => this.clients.set(clientid, userDescription)
      );
      ds.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => {
          event.changes.added.forEach((item) => {
            item.content.getContent().forEach((encodedDs) => {
              if (encodedDs instanceof Uint8Array) {
                this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));
              }
            });
          });
        }
      );
      this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));
      ids.observe(
        /** @param {YArrayEvent<any>} event */
        (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))
      );
      ids.forEach(addClientId);
    };
    storeType.observe((event) => {
      event.keysChanged.forEach(
        (userDescription) => initUser(storeType.get(userDescription), userDescription)
      );
    });
    storeType.forEach(initUser);
  }
  /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */
  setUserMapping(doc2, clientid, userDescription, { filter: filter2 = () => true } = {}) {
    const users = this.yusers;
    let user = users.get(userDescription);
    if (!user) {
      user = new YMap();
      user.set("ids", new YArray());
      user.set("ds", new YArray());
      users.set(userDescription, user);
    }
    user.get("ids").push([clientid]);
    users.observe((_event) => {
      setTimeout(() => {
        const userOverwrite = users.get(userDescription);
        if (userOverwrite !== user) {
          user = userOverwrite;
          this.clients.forEach((_userDescription, clientid2) => {
            if (userDescription === _userDescription) {
              user.get("ids").push([clientid2]);
            }
          });
          const encoder = new DSEncoderV1();
          const ds = this.dss.get(userDescription);
          if (ds) {
            writeDeleteSet(encoder, ds);
            user.get("ds").push([encoder.toUint8Array()]);
          }
        }
      }, 0);
    });
    doc2.on(
      "afterTransaction",
      /** @param {Transaction} transaction */
      (transaction) => {
        setTimeout(() => {
          const yds = user.get("ds");
          const ds = transaction.deleteSet;
          if (transaction.local && ds.clients.size > 0 && filter2(transaction, ds)) {
            const encoder = new DSEncoderV1();
            writeDeleteSet(encoder, ds);
            yds.push([encoder.toUint8Array()]);
          }
        });
      }
    );
  }
  /**
   * @param {number} clientid
   * @return {any}
   */
  getUserByClientId(clientid) {
    return this.clients.get(clientid) || null;
  }
  /**
   * @param {ID} id
   * @return {string | null}
   */
  getUserByDeletedId(id2) {
    for (const [userDescription, ds] of this.dss.entries()) {
      if (isDeleted(ds, id2)) {
        return userDescription;
      }
    }
    return null;
  }
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var relativePositionToJSON = (rpos) => {
  const json = {};
  if (rpos.type) {
    json.type = rpos.type;
  }
  if (rpos.tname) {
    json.tname = rpos.tname;
  }
  if (rpos.item) {
    json.item = rpos.item;
  }
  if (rpos.assoc != null) {
    json.assoc = rpos.assoc;
  }
  return json;
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {
  let t2 = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t2 !== null) {
    if (!t2.deleted && t2.countable) {
      if (t2.length > index) {
        return createRelativePosition(type, createID(t2.id.client, t2.id.clock + index), assoc);
      }
      index -= t2.length;
    }
    if (t2.right === null && assoc < 0) {
      return createRelativePosition(type, t2.lastId, assoc);
    }
    t2 = t2.right;
  }
  return createRelativePosition(type, null, assoc);
};
var writeRelativePosition = (encoder, rpos) => {
  const { type, tname, item, assoc } = rpos;
  if (item !== null) {
    writeVarUint(encoder, 0);
    writeID(encoder, item);
  } else if (tname !== null) {
    writeUint8(encoder, 1);
    writeVarString(encoder, tname);
  } else if (type !== null) {
    writeUint8(encoder, 2);
    writeID(encoder, type);
  } else {
    throw unexpectedCase();
  }
  writeVarInt(encoder, assoc);
  return encoder;
};
var encodeRelativePosition = (rpos) => {
  const encoder = createEncoder();
  writeRelativePosition(encoder, rpos);
  return toUint8Array(encoder);
};
var readRelativePosition = (decoder) => {
  let type = null;
  let tname = null;
  let itemID = null;
  switch (readVarUint(decoder)) {
    case 0:
      itemID = readID(decoder);
      break;
    case 1:
      tname = readVarString(decoder);
      break;
    case 2: {
      type = readID(decoder);
    }
  }
  const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;
  return new RelativePosition(type, tname, itemID, assoc);
};
var decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));
var createAbsolutePositionFromRelativePosition = (rpos, doc2) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followRedone(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followRedone(store, typeID);
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
};
var compareRelativePositions = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.tname === b2.tname && compareIDs(a2.item, b2.item) && compareIDs(a2.type, b2.type) && a2.assoc === b2.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var equalSnapshots = (snap1, snap2) => {
  const ds1 = snap1.ds.clients;
  const ds2 = snap2.ds.clients;
  const sv1 = snap1.sv;
  const sv2 = snap2.sv;
  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {
    return false;
  }
  for (const [key, value] of sv1.entries()) {
    if (sv2.get(key) !== value) {
      return false;
    }
  }
  for (const [client, dsitems1] of ds1.entries()) {
    const dsitems2 = ds2.get(client) || [];
    if (dsitems1.length !== dsitems2.length) {
      return false;
    }
    for (let i = 0; i < dsitems1.length; i++) {
      const dsitem1 = dsitems1[i];
      const dsitem2 = dsitems2[i];
      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {
        return false;
      }
    }
  }
  return true;
};
var encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {
  writeDeleteSet(encoder, snapshot2.ds);
  writeStateVector(encoder, snapshot2.sv);
  return encoder.toUint8Array();
};
var encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());
var decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {
  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
var decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));
var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot2)) {
    snapshot2.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
    });
    meta.add(snapshot2);
  }
};
var createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {
  if (originDoc.gc) {
    throw new Error("Garbage-collection must be disabled in `originDoc`!");
  }
  const { sv, ds } = snapshot2;
  const encoder = new UpdateEncoderV2();
  originDoc.transact((transaction) => {
    let size = 0;
    sv.forEach((clock) => {
      if (clock > 0) {
        size++;
      }
    });
    writeVarUint(encoder.restEncoder, size);
    for (const [client, clock] of sv) {
      if (clock === 0) {
        continue;
      }
      if (clock < getState(originDoc.store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
      const structs = originDoc.store.clients.get(client) || [];
      const lastStructIndex = findIndexSS(structs, clock - 1);
      writeVarUint(encoder.restEncoder, lastStructIndex + 1);
      encoder.writeClient(client);
      writeVarUint(encoder.restEncoder, 0);
      for (let i = 0; i <= lastStructIndex; i++) {
        structs[i].write(encoder, 0);
      }
    }
    writeDeleteSet(encoder, ds);
  });
  applyUpdateV2(newDoc, encoder.toUint8Array(), "snapshot");
  return newDoc;
};
var snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
      return false;
    }
  }
  const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);
  return equalDeleteSets(snapshot2.ds, mergedDS);
};
var snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
};
var tryToMergeWithLeft = (structs, pos) => {
  const left = structs[pos - 1];
  const right = structs[pos];
  if (left.deleted === right.deleted && left.constructor === right.constructor) {
    if (left.mergeWith(right)) {
      structs.splice(pos, 1);
      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
      right.parent._map.get(right.parentSub) === right) {
        right.parent._map.set(
          right.parentSub,
          /** @type {Item} */
          left
        );
      }
    }
  }
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[--si]) {
        tryToMergeWithLeft(structs, si);
      }
    }
  });
};
var tryGc = (ds, store, gcFilter) => {
  tryGcDeleteSet(ds, store, gcFilter);
  tryMergeDeleteSet(ds, store);
};
var cleanupTransactions = (transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; i2--) {
            tryToMergeWithLeft(structs, i2);
          }
        }
      });
      for (let i2 = 0; i2 < mergeStructs.length; i2++) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          tryToMergeWithLeft(structs, replacedStructPos + 1);
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLeft(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type) => isParentOf(type, item))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let result = null;
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && result === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type) => isParentOf(
            type,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type) => isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i = itemsToDelete.length - 1; i >= 0; i--) {
        const item = itemsToDelete[i];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      result = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type) => {
      if (subProps.has(null) && type._searchMarker) {
        type._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  if (result != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);
  }
  return result;
};
var UndoManager = class extends Observable {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray2(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.doc = doc2;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type) => isParentOf(type, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray2(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);
var logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
  const structs = [];
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    structs.push(curr);
  }
  print("Structs: ", structs);
  const ds = readDeleteSet(updateDecoder);
  print("DeleteSet: ", ds);
};
var decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);
var decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
  const structs = [];
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    structs.push(curr);
  }
  return {
    structs,
    ds: readDeleteSet(updateDecoder)
  };
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
  const encoder = new YEncoder();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let size = 0;
    let currClient = curr.id.client;
    let stopCounting = curr.id.clock !== 0;
    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        if (currClock !== 0) {
          size++;
          writeVarUint(encoder.restEncoder, currClient);
          writeVarUint(encoder.restEncoder, currClock);
        }
        currClient = curr.id.client;
        currClock = 0;
        stopCounting = curr.id.clock !== 0;
      }
      if (curr.constructor === Skip) {
        stopCounting = true;
      }
      if (!stopCounting) {
        currClock = curr.id.clock + curr.length;
      }
    }
    if (currClock !== 0) {
      size++;
      writeVarUint(encoder.restEncoder, currClient);
      writeVarUint(encoder.restEncoder, currClock);
    }
    const enc = createEncoder();
    writeVarUint(enc, size);
    writeBinaryEncoder(enc, encoder.restEncoder);
    encoder.restEncoder = enc;
    return encoder.toUint8Array();
  } else {
    writeVarUint(encoder.restEncoder, 0);
    return encoder.toUint8Array();
  }
};
var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
var parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {
  const from3 = /* @__PURE__ */ new Map();
  const to = /* @__PURE__ */ new Map();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let currClient = curr.id.client;
    let currClock = curr.id.clock;
    from3.set(currClient, currClock);
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        to.set(currClient, currClock);
        from3.set(curr.id.client, curr.id.clock);
        currClient = curr.id.client;
      }
      currClock = curr.id.clock + curr.length;
    }
    to.set(currClient, currClock);
  }
  return { from: from3, to };
};
var parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state2 = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state2.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {
  let i = 0;
  const mapKeyCache = create();
  const nodeNameCache = create();
  const formattingKeyCache = create();
  const formattingValueCache = create();
  formattingValueCache.set(null, null);
  return (block) => {
    switch (block.constructor) {
      case GC:
      case Skip:
        return block;
      case Item: {
        const item = (
          /** @type {Item} */
          block
        );
        const content = item.content;
        switch (content.constructor) {
          case ContentDeleted:
            break;
          case ContentType: {
            if (yxml) {
              const type = (
                /** @type {ContentType} */
                content.type
              );
              if (type instanceof YXmlElement) {
                type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => "node-" + i);
              }
              if (type instanceof YXmlHook) {
                type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => "hook-" + i);
              }
            }
            break;
          }
          case ContentAny: {
            const c2 = (
              /** @type {ContentAny} */
              content
            );
            c2.arr = c2.arr.map(() => i);
            break;
          }
          case ContentBinary: {
            const c2 = (
              /** @type {ContentBinary} */
              content
            );
            c2.content = new Uint8Array([i]);
            break;
          }
          case ContentDoc: {
            const c2 = (
              /** @type {ContentDoc} */
              content
            );
            if (subdocs) {
              c2.opts = {};
              c2.doc.guid = i + "";
            }
            break;
          }
          case ContentEmbed: {
            const c2 = (
              /** @type {ContentEmbed} */
              content
            );
            c2.embed = {};
            break;
          }
          case ContentFormat: {
            const c2 = (
              /** @type {ContentFormat} */
              content
            );
            if (formatting) {
              c2.key = setIfUndefined(formattingKeyCache, c2.key, () => i + "");
              c2.value = setIfUndefined(formattingValueCache, c2.value, () => ({ i }));
            }
            break;
          }
          case ContentJSON: {
            const c2 = (
              /** @type {ContentJSON} */
              content
            );
            c2.arr = c2.arr.map(() => i);
            break;
          }
          case ContentString: {
            const c2 = (
              /** @type {ContentString} */
              content
            );
            c2.str = repeat(i % 10 + "", c2.str.length);
            break;
          }
          default:
            unexpectedCase();
        }
        if (item.parentSub) {
          item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i + "");
        }
        i++;
        return block;
      }
      default:
        unexpectedCase();
    }
  };
};
var obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
var obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
var convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      const keys2 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys2.set(key, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c2 = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c2 !== child._item && c2 !== null) {
        if (!c2.deleted) {
          i++;
        }
        c2 = c2.right;
      }
      path2.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path2;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker2) => {
  marker2.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker2, p, index) => {
  marker2.p.marker = false;
  marker2.p = p;
  p.marker = true;
  marker2.index = index;
  marker2.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker2 = searchMarker.reduce((a2, b2) => a2.timestamp < b2.timestamp ? a2 : b2);
    overwriteMarker(marker2, p, index);
    return marker2;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker2 = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b2) => abs(index - a2.index) < abs(index - b2.index) ? a2 : b2);
  let p = yarray._start;
  let pindex = 0;
  if (marker2 !== null) {
    p = marker2.p;
    pindex = marker2.index;
    refreshMarkerTimestamp(marker2);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker2 !== null && abs(marker2.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker2, p, pindex);
    return marker2;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var getTypeChildren = (t2) => {
  let s = t2._start;
  const arr = [];
  while (s) {
    arr.push(s);
    s = s.right;
  }
  return arr;
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c2 = n.content.getContent();
      if (c2.length <= start) {
        start -= c2.length;
      } else {
        for (let i = start; i < c2.length && len > 0; i++) {
          cs.push(c2[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c2 = n.content.getContent();
      for (let i = 0; i < c2.length; i++) {
        cs.push(c2[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArraySnapshot = (type, snapshot2) => {
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && isVisible(n, snapshot2)) {
      const c2 = n.content.getContent();
      for (let i = 0; i < c2.length; i++) {
        cs.push(c2[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type, f) => {
  let index = 0;
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c2 = n.content.getContent();
      for (let i = 0; i < c2.length; i++) {
        f(c2[i], index++, type);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type, f) => {
  const result = [];
  typeListForEach(type, (c2, i) => {
    result.push(f(c2, i, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  const marker2 = findMarker(type, index);
  let n = type._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c2) => {
    if (c2 === null) {
      jsonContent.push(c2);
    } else {
      switch (c2.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c2);
          break;
        default:
          packJsonContent();
          switch (c2.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c2
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c2
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c2 instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c2));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded;
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker2 = findMarker(parent, index);
  let n = parent._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker2 = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker2.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length4) => {
  if (length4 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length4;
  const marker2 = findMarker(parent, index);
  let n = parent._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length4 > 0 && n !== null) {
    if (!n.deleted) {
      if (length4 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length4));
      }
      n.delete(transaction);
      length4 -= n.length;
    }
    n = n.right;
  }
  if (length4 > 0) {
    throw lengthExceeded;
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length4
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c2 = parent._map.get(key);
  if (c2 !== void 0) {
    c2.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetSnapshot = (parent, key, snapshot2) => {
  let v2 = parent._map.get(key) || null;
  while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
    v2 = v2.left;
  }
  return v2 !== null && isVisible(v2, snapshot2) ? v2.content.getContent()[v2.length - 1] : void 0;
};
var createMapIterator = (map2) => iteratorFilter(
  map2.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(yarray, transaction) {
    super(yarray, transaction);
    this._transaction = transaction;
  }
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a2 = new _YArray();
    a2.push(items);
    return a2;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c2) => c2 instanceof AbstractType ? c2.toJSON() : c2);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * @return {YMap<MapType>}
   */
  clone() {
    const map2 = new _YMap();
    this.forEach((value, key) => {
      map2.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map2;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map2 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v2 = item.content.getContent()[item.length - 1];
        map2[key] = v2 instanceof AbstractType ? v2.toJSON() : v2;
      }
    });
    return map2;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v2) => v2[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<any>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v2) => v2[1].content.getContent()[v2[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v2) => [v2[0], v2[1].content.getContent()[v2[1].length - 1]]
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map2) {
          typeMapDelete(transaction, map2, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a2, b2) => a2 === b2 || typeof a2 === "object" && typeof b2 === "object" && a2 && b2 && equalFlat(a2, b2);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker2 = findMarker(parent, index);
  if (marker2) {
    const pos = new ItemTextListPosition(marker2.p.left, marker2.p, marker2.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker2.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] || null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) || null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length4, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key];
            if (attr !== void 0) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length4 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length4 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
            }
            length4 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length4 > 0) {
    let newlines = "";
    for (; length4 > 0; length4--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) || null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t2) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t2, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length4) => {
  const startLength = length4;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length4 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length4 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));
          }
          length4 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) || null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) || null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * @return {YText}
   */
  clone() {
    const text2 = new _YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot2, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot2)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot2 || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot2) {
          splitSnapshotAffectedStructs(transaction, snapshot2);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v2, k) => {
            attributes[k] = v2;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes = {}) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        insertText(transaction, this, pos, embed, attributes);
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index), length4);
      });
    } else {
      this._pending.push(() => this.delete(index, length4));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length4, attributes) {
    if (length4 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length4, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length4, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query2) {
    query2 = query2.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query2);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query2) {
    query2 = query2.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query2));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length4 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length4);
      });
    } else {
      this._prelimContent.splice(index, length4);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys2[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return (
      /** @type {any} */
      typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * @return {YXmlText}
   */
  clone() {
    const text2 = new _YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a2, b2) => a2.key < b2.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a2, b2) => a2.nodeName < b2.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length4) {
    this.id = id2;
    this.length = length4;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c2 = this.arr[i];
      encoder.writeString(c2 === void 0 ? "undefined" : JSON.stringify(c2));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c2 = decoder.readString();
    if (c2 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c2));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c2 = this.arr[i];
      encoder.writeAny(c2);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "�";
      right.str = "�" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s) => isDeleted(s.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone)
          left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    }
    if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker2) => {
          if (marker2.p === right) {
            marker2.p = this;
            if (!this.deleted && this.countable) {
              marker2.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// node_modules/@blocksuite/store/dist/text-adapter.js
var Text2 = class _Text {
  constructor(input) {
    this._shouldTransact = true;
    if (typeof input === "string") {
      this._yText = new YText(input);
    } else if (input instanceof YText) {
      this._yText = input;
    } else {
      this._yText = new YText();
    }
  }
  static fromDelta(delta) {
    const result = new YText();
    result.applyDelta(delta);
    return new _Text(result);
  }
  get length() {
    return this._yText.length;
  }
  get yText() {
    return this._yText;
  }
  _transact(callback) {
    if (this._shouldTransact) {
      const doc2 = this._yText.doc;
      if (!doc2) {
        throw new Error("Failed to transact text! yText is not attached to a doc");
      }
      doc2.transact(() => {
        callback();
      }, doc2.clientID);
    } else {
      callback();
    }
  }
  clone() {
    return new _Text(this._yText.clone());
  }
  /**
   * NOTE: The string included in [index, index + length) will be deleted.
   *
   * Here are three cases for point position(index + length):
   * [{insert: 'abc', ...}, {insert: 'def', ...}, {insert: 'ghi', ...}]
   * 1. abc|de|fghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'f', ...}, {insert: 'ghi', ...}]
   * 2. abc|def|ghi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'ghi', ...}]
   * 3. abc|defg|hi
   *    left: [{insert: 'abc', ...}]
   *    right: [{insert: 'hi', ...}]
   */
  split(index, length4 = 0) {
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new Error("Failed to split text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    const deltas = this._yText.toDelta();
    if (!(deltas instanceof Array)) {
      throw new Error("This text cannot be split because we failed to get the deltas of it.");
    }
    let tmpIndex = 0;
    const rightDeltas = [];
    for (let i = 0; i < deltas.length; i++) {
      const insert = deltas[i].insert;
      if (typeof insert === "string") {
        if (tmpIndex + insert.length >= index + length4) {
          const insertRight = insert.slice(index + length4 - tmpIndex);
          rightDeltas.push({
            insert: insertRight,
            attributes: deltas[i].attributes
          });
          rightDeltas.push(...deltas.slice(i + 1));
          break;
        }
        tmpIndex += insert.length;
      } else {
        throw new Error("This text cannot be split because it contains non-string insert.");
      }
    }
    this.delete(index, this.length - index);
    const rightYText = new YText();
    rightYText.applyDelta(rightDeltas);
    const rightText = new _Text(rightYText);
    return rightText;
  }
  insert(content, index, attributes) {
    if (!content.length) {
      return;
    }
    if (index < 0 || index > this._yText.length) {
      throw new Error("Failed to insert text! Index or length out of range, index: " + index + ", length: " + length + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.insert(index, content, attributes);
    });
  }
  /**
   * @deprecated Use {@link insert} or {@link applyDelta} instead.
   */
  insertList(insertTexts, index) {
    if (!insertTexts.length) {
      return;
    }
    this._transact(() => {
      for (let i = insertTexts.length - 1; i >= 0; i--) {
        this._yText.insert(
          index,
          insertTexts[i].insert || "",
          // eslint-disable-next-line @typescript-eslint/ban-types
          insertTexts[i].attributes
        );
      }
    });
  }
  join(other) {
    if (!other.toDelta().length) {
      return;
    }
    this._transact(() => {
      const yOther = other._yText;
      const delta = yOther.toDelta();
      delta.unshift({ retain: this._yText.length });
      this._yText.applyDelta(delta);
    });
  }
  format(index, length4, format) {
    if (length4 === 0) {
      return;
    }
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new Error("Failed to format text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.format(index, length4, format);
    });
  }
  delete(index, length4) {
    if (length4 === 0) {
      return;
    }
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new Error("Failed to delete text! Index or length out of range, index: " + index + ", length: " + length4 + ", text length: " + this._yText.length);
    }
    this._transact(() => {
      this._yText.delete(index, length4);
    });
  }
  replace(index, length4, content, attributes) {
    if (index < 0 || length4 < 0 || index + length4 > this._yText.length) {
      throw new Error("Failed to replace text! The length of the text is" + this._yText.length + ", but you are trying to replace from" + index + "to" + index + length4);
    }
    this._transact(() => {
      this._yText.delete(index, length4);
      this._yText.insert(index, content, attributes);
    });
  }
  clear() {
    if (!this._yText.length) {
      return;
    }
    this._transact(() => {
      this._yText.delete(0, this._yText.length);
    });
  }
  applyDelta(delta) {
    this._transact(() => {
      var _a10;
      (_a10 = this._yText) == null ? void 0 : _a10.applyDelta(delta);
    });
  }
  toDelta() {
    var _a10;
    return ((_a10 = this._yText) == null ? void 0 : _a10.toDelta()) || [];
  }
  sliceToDelta(begin, end) {
    const result = [];
    if (end && begin >= end) {
      return result;
    }
    const delta = this.toDelta();
    if (begin < 1 && !end) {
      return delta;
    }
    if (delta && delta instanceof Array) {
      let charNum = 0;
      for (let i = 0; i < delta.length; i++) {
        const content = delta[i];
        let contentText = content.insert || "";
        const contentLen = contentText.length;
        const isLastOp = end && charNum + contentLen > end;
        const isFirstOp = charNum + contentLen > begin && result.length === 0;
        if (isFirstOp && isLastOp) {
          contentText = contentText.slice(begin - charNum, end - charNum);
          result.push({
            ...content,
            insert: contentText
          });
          break;
        } else if (isFirstOp || isLastOp) {
          contentText = isLastOp ? contentText.slice(0, end - charNum) : contentText.slice(begin - charNum);
          result.push({
            ...content,
            insert: contentText
          });
        } else {
          result.length > 0 && result.push(content);
        }
        if (end && charNum + contentLen > end) {
          break;
        }
        charNum = charNum + contentLen;
      }
    }
    return result;
  }
  toString() {
    var _a10;
    return ((_a10 = this._yText) == null ? void 0 : _a10.toString()) || "";
  }
};

// node_modules/@blocksuite/store/dist/base.js
var FlavourSchema = z.string();
var ElementTagSchema = z.object({
  _$litStatic$: z.string(),
  r: z.symbol()
});
var ParentSchema = z.array(z.string()).optional();
var ContentSchema = z.array(z.string()).optional();
var role = ["root", "hub", "content"];
var RoleSchema = z.enum(role);
var internalPrimitives = Object.freeze({
  Text: (input = "") => new Text2(input)
});
var BlockSchema = z.object({
  version: z.number(),
  model: z.object({
    role: RoleSchema,
    flavour: FlavourSchema,
    tag: ElementTagSchema,
    parent: ParentSchema,
    children: ContentSchema,
    props: z.function().args(z.custom()).returns(z.record(z.any())).optional(),
    toModel: z.function().args().returns(z.custom()).optional()
  })
});
function defineBlockSchema({ flavour, props, metadata, toModel }) {
  const schema = {
    version: metadata.version,
    model: {
      tag: metadata.tag,
      role: metadata.role,
      parent: metadata.parent,
      children: metadata.children,
      flavour,
      props,
      toModel
    }
  };
  BlockSchema.parse(schema);
  return schema;
}
function MagicProps() {
  return class {
  };
}
var BaseBlockModel = class extends MagicProps() {
  constructor() {
    super(...arguments);
    this.propsUpdated = new Slot();
    this.childrenUpdated = new Slot();
    this.childMap = /* @__PURE__ */ new Map();
    this.children = [];
  }
  isEmpty() {
    return this.children.length === 0;
  }
  firstChild() {
    return this.children[0] || null;
  }
  lastChild() {
    if (!this.children.length) {
      return this;
    }
    return this.children[this.children.length - 1].lastChild();
  }
  lastItem() {
    if (!this.children.length) {
      return this;
    }
    return this.children[this.children.length - 1];
  }
  dispose() {
    this.propsUpdated.dispose();
    this.childrenUpdated.dispose();
  }
  onCreated() {
  }
};

// node_modules/@blocksuite/store/dist/persistence/blob/memory-storage.js
var createMemoryStorage = () => {
  const memoryStorage = /* @__PURE__ */ new Map();
  return {
    crud: {
      get: async (key) => {
        return memoryStorage.get(key) ?? null;
      },
      set: async (key, value) => {
        memoryStorage.set(key, value);
        return key;
      },
      delete: async (key) => {
        memoryStorage.delete(key);
      },
      list: async () => {
        return [...memoryStorage.keys()];
      }
    }
  };
};

// node_modules/y-webrtc/src/y-webrtc.js
var import_simplepeer_min = __toESM(require_simplepeer_min());

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state2) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state2 === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state2);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state2 === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state2 != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state2)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state2 = this.getLocalState();
    if (state2 !== null) {
      this.setLocalState({
        ...state2,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};

// node_modules/y-webrtc/src/y-webrtc.js
var log = createModuleLogger2("y-webrtc");

// node_modules/@blocksuite/store/dist/persistence/doc/debug-provider.js
var isLocalhost = isWeb && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1");

// node_modules/@blocksuite/store/dist/space.js
var Space = class {
  constructor(id2, doc2, awarenessStore) {
    this.id = id2;
    this.doc = doc2;
    this.awarenessStore = awarenessStore;
    const prefixedId = this.id.startsWith("space:") ? this.id : this.prefixedId;
    this._ySpace = this.doc.getMap(prefixedId);
    this._proxy = this.doc.getMapProxy(prefixedId);
  }
  get prefixedId() {
    return `space:${this.id}`;
  }
  /**
   * If `shouldTransact` is `false`, the transaction will not be push to the history stack.
   */
  transact(fn, shouldTransact = true) {
    this.doc.transact(fn, shouldTransact ? this.doc.clientID : void 0);
  }
};

// node_modules/@blocksuite/store/dist/store.js
var import_merge2 = __toESM(require_src(), 1);

// node_modules/@blocksuite/store/dist/utils/jsx.js
var testSymbol = Symbol.for("react.test.json");
function isValidRecord(data) {
  if (typeof data !== "object" || data === null) {
    return false;
  }
  return true;
}
var IGNORED_PROPS = [
  "sys:id",
  "sys:flavour",
  "sys:children",
  "prop:xywh",
  "prop:cells"
];
function yDocToJSXNode(serializedDoc, nodeId) {
  if (!isValidRecord(serializedDoc)) {
    throw new Error("Failed to parse doc record! Invalid data.");
  }
  const node = serializedDoc[nodeId];
  if (!node) {
    throw new Error(`Failed to parse doc record! Node not found! id: ${nodeId}.`);
  }
  const flavour = node["sys:flavour"];
  const children = node["sys:children"];
  const props = Object.fromEntries(Object.entries(node).filter(([key]) => !IGNORED_PROPS.includes(key)));
  if ("prop:text" in props && props["prop:text"] instanceof Array) {
    props["prop:text"] = parseDelta(props["prop:text"]);
  }
  if ("prop:title" in props && props["prop:title"] instanceof Array) {
    props["prop:title"] = parseDelta(props["prop:title"]);
  }
  if ("prop:columns" in props && props["prop:columns"] instanceof Array) {
    props["prop:columns"] = `Array [${props["prop:columns"].length}]`;
  }
  return {
    $$typeof: testSymbol,
    type: flavour,
    props,
    children: (children == null ? void 0 : children.map((id2) => yDocToJSXNode(serializedDoc, id2))) ?? []
  };
}
function serializeYDoc(doc2) {
  const json = {};
  doc2.share.forEach((value, key) => {
    if (value instanceof YMap) {
      json[key] = serializeYMap(value);
    } else {
      json[key] = value.toJSON();
    }
  });
  return json;
}
function serializeYMap(map2) {
  const json = {};
  map2.forEach((value, key) => {
    if (value instanceof YMap) {
      json[key] = serializeYMap(value);
    } else if (value instanceof YText) {
      json[key] = serializeYText(value);
    } else if (value instanceof YArray) {
      json[key] = value.toArray();
    } else if (value instanceof AbstractType) {
      json[key] = value.toJSON();
    } else {
      json[key] = value;
    }
  });
  return json;
}
function serializeYText(text2) {
  const delta = text2.toDelta();
  return delta;
}
function parseDelta(text2) {
  if (!text2.length) {
    return void 0;
  }
  if (text2.length === 1 && !text2[0].attributes) {
    return text2[0].insert;
  }
  return {
    // The `Symbol.for('react.fragment')` will render as `<React.Fragment>`
    // so we use a empty string to render it as `<>`.
    // But it will empty children ad `< />`
    // so we return `undefined` directly if not delta text.
    $$typeof: testSymbol,
    type: "",
    props: {},
    children: text2 == null ? void 0 : text2.map(({ insert, attributes }) => ({
      $$typeof: testSymbol,
      type: "text",
      props: {
        // Not place at `children` to avoid the trailing whitespace be trim by formatter.
        insert,
        ...attributes
      }
    }))
  };
}

// node_modules/@blocksuite/store/dist/yjs/utils.js
function isPureObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value) && !(value instanceof YMap) && !(value instanceof YArray) && !(value instanceof YText);
}
function native2Y(value, deep) {
  if (Array.isArray(value)) {
    const yArray = new YArray();
    const result = value.map((item) => {
      return deep ? native2Y(item, deep) : item;
    });
    yArray.insert(0, result);
    return yArray;
  }
  if (isPureObject(value)) {
    const yMap = new YMap();
    Object.entries(value).forEach(([key, value2]) => {
      yMap.set(key, deep ? native2Y(value2, deep) : value2);
    });
    return yMap;
  }
  return value;
}
function toPlainValue(v2) {
  if (v2 instanceof YMap) {
    const obj = {};
    v2.forEach((value, key) => {
      obj[key] = toPlainValue(value);
    });
    return obj;
  }
  if (v2 instanceof YArray) {
    return v2.toArray().map((x2) => toPlainValue(x2));
  }
  return v2;
}

// node_modules/@blocksuite/store/dist/yjs/array.js
function subscribeYArray(arr, yArray, config) {
  const { deep = false } = config;
  yArray.observe((event) => {
    if (event.changes.keys.size === 0) {
      return;
    }
    let retain = 0;
    event.changes.delta.forEach((change) => {
      if (change.retain) {
        retain += change.retain;
      }
      if (change.delete) {
        arr.splice(retain, change.delete);
      }
      if (change.insert) {
        if (Array.isArray(change.insert)) {
          const value = deep ? change.insert.map(toPlainValue) : change.insert;
          arr.splice(retain, 0, ...value);
        } else {
          arr.splice(retain, 0, deep ? toPlainValue(change.insert) : change.insert);
        }
        retain += change.insert.length;
      }
    });
  });
}

// node_modules/@blocksuite/global/dist/debug.js
var import_ansi_colors = __toESM(require_ansi_colors());
var enabled = false;
var showStack = false;
var removeStackHeader = (stack) => String(stack).replace(/^.+\n.+\n/, "");
var debugLog = function(info = { arguments: [], callerIdx: 1 }) {
  var _a10, _b6;
  if (!enabled) {
    return;
  }
  const { callerIdx } = info;
  const error = new Error();
  const stackInfo = removeStackHeader(error.stack).split("\n");
  const upperStackInfo = stackInfo.slice(1).join("\n");
  const message = stackInfo[callerIdx].trim();
  const method = ((_a10 = /at\s(\S*)(?=\s)/.exec(message)) == null ? void 0 : _a10[1]) ?? message;
  const subsystem = ((_b6 = /\/packages\/([a-z]+)/.exec(message)) == null ? void 0 : _b6[1]) ?? "unknown";
  console.log(`[packages/${import_ansi_colors.default.blue(subsystem)}] ${import_ansi_colors.default.magenta(method)}(${info.arguments.map(() => "%o").join(", ")})
`, ...info.arguments, showStack ? upperStackInfo : "");
};
var whitelist = /* @__PURE__ */ new Set();
var all2 = /* @__PURE__ */ new Set();
var debug = (tag2) => {
  all2.add(tag2);
  return (target, name, descriptor) => {
    const original = descriptor.value;
    assertExists(original);
    assertEquals(typeof original, "function");
    descriptor.value = function debugWrapper(...args2) {
      if (tag2 ? whitelist.has(tag2) : true) {
        debugLog({
          arguments: args2,
          callerIdx: 2
        });
      }
      return original.apply(this, args2);
    };
    return descriptor;
  };
};

// node_modules/@blocksuite/store/dist/yjs/map.js
function subscribeYMap(object, yMap, config) {
  const { deep = false } = config;
  yMap.observe((event) => {
    if (event.changes.keys.size === 0) {
      return;
    }
    event.keysChanged.forEach((key) => {
      const type = event.changes.keys.get(key);
      if (!type) {
        console.error("impossible event", event);
        return;
      }
      if (type.action === "delete") {
        delete object[key];
      } else if (type.action === "add" || type.action === "update") {
        object[key] = deep ? toPlainValue(yMap.get(key)) : yMap.get(key);
      }
    });
  });
}

// node_modules/@blocksuite/store/dist/yjs/proxy.js
function initialize(target, yAbstract, config) {
  const { deep } = config;
  if (!(yAbstract instanceof YArray || yAbstract instanceof YMap)) {
    return;
  }
  yAbstract.forEach((value, key) => {
    const result = deep && (value instanceof YMap || value instanceof YArray) ? createYProxy(value, config) : value;
    target[key] = result;
  });
}
function createYProxy(yAbstract, config = {}) {
  if (yAbstract instanceof YArray) {
    return createYArrayProxy(yAbstract, config);
  }
  if (yAbstract instanceof YMap) {
    return createYMapProxy(yAbstract, config);
  }
  throw new TypeError();
}
function createYMapProxy(yMap, config = {}) {
  const { readonly = false, deep = false } = config;
  const object = {};
  if (!(yMap instanceof YMap)) {
    throw new TypeError();
  }
  initialize(object, yMap, config);
  subscribeYMap(object, yMap, config);
  return new Proxy(object, {
    has: (target, p) => {
      return Reflect.has(target, p);
    },
    set: (target, p, value, receiver) => {
      if (readonly) {
        throw new Error("Modify data is not allowed");
      }
      if (typeof p !== "string") {
        throw new Error("key cannot be a symbol");
      }
      if (deep && (isPureObject(value) || Array.isArray(value))) {
        const _y = native2Y(value, deep);
        yMap.set(p, _y);
        const _value = createYProxy(_y, config);
        return Reflect.set(target, p, _value, receiver);
      }
      yMap.set(p, value);
      return Reflect.set(target, p, value, receiver);
    },
    get: (target, p, receiver) => {
      return Reflect.get(target, p, receiver);
    },
    deleteProperty(target, p) {
      if (readonly) {
        throw new Error("Modify data is not allowed");
      }
      if (typeof p !== "string") {
        throw new Error("key cannot be a symbol");
      }
      yMap.delete(p);
      return Reflect.deleteProperty(target, p);
    }
  });
}
function createYArrayProxy(yArray, config = {}) {
  const { readonly = false, deep = false } = config;
  const array = [];
  if (!(yArray instanceof YArray)) {
    throw new TypeError();
  }
  initialize(array, yArray, config);
  subscribeYArray(array, yArray, config);
  return new Proxy(array, {
    has: (target, p) => {
      return Reflect.has(target, p);
    },
    set: (target, p, value, receiver) => {
      if (readonly) {
        throw new Error("Modify data is not allowed");
      }
      if (typeof p !== "string") {
        throw new Error("key cannot be a symbol");
      }
      const index = Number(p);
      if (Number.isNaN(index)) {
        return Reflect.set(target, p, value, receiver);
      }
      const apply = (value2) => {
        if (index < yArray.length) {
          yArray.delete(index, 1);
        }
        yArray.insert(index, [value2]);
      };
      if (deep && (isPureObject(value) || Array.isArray(value))) {
        const y = native2Y(value, deep);
        apply(y);
        const _value = createYProxy(y, config);
        return Reflect.set(target, p, _value, receiver);
      }
      apply(value);
      return Reflect.set(target, p, value, receiver);
    },
    get: (target, p, receiver) => {
      return Reflect.get(target, p, receiver);
    },
    deleteProperty(target, p) {
      if (readonly) {
        throw new Error("Modify data is not allowed");
      }
      if (typeof p !== "string") {
        throw new Error("key cannot be a symbol");
      }
      const index = Number(p);
      if (!Number.isNaN(index)) {
        yArray.delete(index, 1);
      }
      return Reflect.deleteProperty(target, p);
    }
  });
}

// node_modules/@blocksuite/store/dist/yjs/doc.js
var __decorate = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var BlockSuiteDoc = class extends Doc {
  getMapProxy(key, config = {}) {
    const map2 = super.getMap(key);
    return createYMapProxy(map2, config);
  }
  getArrayProxy(key, config = {}) {
    const array = super.getArray(key);
    return createYArrayProxy(array, config);
  }
  transact(f, origin) {
    return super.transact(f, origin);
  }
};
__decorate([
  debug("transact")
], BlockSuiteDoc.prototype, "transact", null);

// node_modules/@blocksuite/store/dist/store.js
var Generator;
(function(Generator2) {
  Generator2["NanoID"] = "nanoID";
  Generator2["UUIDv4"] = "uuidV4";
  Generator2["AutoIncrementByClientId"] = "autoIncrementByClientId";
  Generator2["AutoIncrement"] = "autoIncrement";
})(Generator || (Generator = {}));
var flagsPreset = {
  enable_set_remote_flag: true,
  enable_drag_handle: true,
  enable_block_hub: true,
  enable_surface: true,
  enable_edgeless_toolbar: true,
  enable_slash_menu: true,
  enable_database: false,
  enable_toggle_block: false,
  enable_block_selection_format_bar: true,
  enable_linked_page: false,
  enable_bookmark_operation: false,
  readonly: {}
};
var Store = class {
  // TODO: The user cursor should be spread by the spaceId in awareness
  constructor({ id: id2, providers = [], awareness, idGenerator, defaultFlags } = { id: nanoid2() }) {
    this.providers = [];
    this.spaces = /* @__PURE__ */ new Map();
    this.id = id2;
    this.doc = new BlockSuiteDoc({ guid: id2 });
    this.awarenessStore = new AwarenessStore(this, awareness ?? new Awareness(this.doc), (0, import_merge2.merge)(true, flagsPreset, defaultFlags));
    switch (idGenerator) {
      case Generator.AutoIncrement: {
        this.idGenerator = createAutoIncrementIdGenerator();
        break;
      }
      case Generator.AutoIncrementByClientId: {
        this.idGenerator = createAutoIncrementIdGeneratorByClientId(this.doc.clientID);
        break;
      }
      case Generator.UUIDv4: {
        this.idGenerator = uuidv42;
        break;
      }
      case Generator.NanoID:
      default: {
        this.idGenerator = nanoid2;
        break;
      }
    }
    this.providers = providers.map((ProviderConstructor) => new ProviderConstructor(id2, this.doc, {
      awareness: this.awarenessStore.awareness
    }));
  }
  addSpace(space) {
    this.spaces.set(space.prefixedId, space);
  }
  removeSpace(space) {
    this.spaces.delete(space.prefixedId);
  }
  /**
   * @internal Only for testing, 'page0' should be replaced by props 'spaceId'
   */
  exportJSX(pageId, blockId) {
    const json = serializeYDoc(this.doc);
    const prefixedPageId = pageId.startsWith("space:") ? pageId : `space:${pageId}`;
    const pageJson = json[prefixedPageId];
    if (!pageJson) {
      throw new Error(`Page ${pageId} doesn't exist`);
    }
    if (!blockId) {
      const pageBlockId = Object.keys(pageJson).at(0);
      if (!pageBlockId) {
        return null;
      }
      blockId = pageBlockId;
    }
    if (!pageJson[blockId]) {
      return null;
    }
    return yDocToJSXNode(pageJson, blockId);
  }
};

// node_modules/@blocksuite/store/dist/utils/utils.js
var utils_exports = {};
__export(utils_exports, {
  applyYjsUpdateV2: () => applyYjsUpdateV2,
  assertValidChildren: () => assertValidChildren,
  encodeWorkspaceAsYjsUpdateV2: () => encodeWorkspaceAsYjsUpdateV2,
  initInternalProps: () => initInternalProps,
  isInsideBlockByFlavour: () => isInsideBlockByFlavour,
  syncBlockProps: () => syncBlockProps,
  toBlockProps: () => toBlockProps
});
function assertValidChildren(yBlocks, props) {
  if (!Array.isArray(props.children))
    return;
  props.children.forEach((child) => {
    if (!yBlocks.has(child.id)) {
      throw new Error("Invalid child id: " + child.id);
    }
  });
}
function initInternalProps(yBlock, props) {
  yBlock.set("sys:id", props.id);
  yBlock.set("sys:flavour", props.flavour);
  const yChildren = new YArray();
  yBlock.set("sys:children", yChildren);
  if (Array.isArray(props.children)) {
    props.children.forEach((child) => yChildren.push([child.id]));
  }
}
function syncBlockProps(schema, yBlock, props, ignoredKeys) {
  var _a10, _b6;
  const propSchema = ((_b6 = (_a10 = schema.model).props) == null ? void 0 : _b6.call(_a10, internalPrimitives)) ?? {};
  Object.entries(props).forEach(([key, value]) => {
    if (SYS_KEYS.has(key) || ignoredKeys.has(key))
      return;
    const isText = propSchema[key] instanceof Text2;
    if (isText) {
      if (value instanceof Text2) {
        yBlock.set(`prop:${key}`, value.yText);
      } else {
        yBlock.set(`prop:${key}`, new YText(value));
      }
      return;
    }
    if (!isPrimitive2(value) && !Array.isArray(value) && typeof value !== "object") {
      throw new Error("Only top level primitives are supported for now");
    }
    const isSurface2 = schema.model.flavour === "affine:surface";
    if (value !== void 0) {
      if (Array.isArray(value) || isPureObject(value)) {
        if (isSurface2 && key === "elements") {
          const elementsMap = new YMap();
          for (const element2 of Object.values(value)) {
            elementsMap.set(element2.id, native2Y(element2, false));
          }
          yBlock.set(key, elementsMap);
        } else {
          yBlock.set(`prop:${key}`, native2Y(value, true));
        }
      } else {
        yBlock.set(`prop:${key}`, value);
      }
    }
  });
  Object.entries(propSchema).forEach(([key, value]) => {
    if (!yBlock.has(`prop:${key}`) || yBlock.get(`prop:${key}`) === void 0) {
      if (value instanceof Text2) {
        yBlock.set(`prop:${key}`, value.yText);
      } else if (Array.isArray(value) || isPureObject(value)) {
        yBlock.set(`prop:${key}`, native2Y(value, true));
      } else {
        yBlock.set(`prop:${key}`, value);
      }
    }
  });
}
function toBlockProps(yBlock) {
  const prefixedProps = yBlock.toJSON();
  const props = {};
  Object.keys(prefixedProps).forEach((key) => {
    if (prefixedProps[key]) {
      props[key.replace("sys:", "")] = prefixedProps[key];
    }
  });
  Object.keys(prefixedProps).forEach((prefixedKey) => {
    if (SYS_KEYS.has(prefixedKey))
      return;
    const key = prefixedKey.replace("prop:", "");
    const realValue = yBlock.get(prefixedKey);
    if (realValue instanceof YMap) {
      const value = createYProxy(realValue, {
        deep: true
      });
      props[key] = value;
    } else if (realValue instanceof YArray) {
      const value = createYProxy(realValue, {
        deep: true
      });
      props[key] = value;
    } else {
      props[key] = prefixedProps[prefixedKey];
    }
  });
  return props;
}
function encodeWorkspaceAsYjsUpdateV2(workspace) {
  return toBase64(encodeStateAsUpdateV2(workspace.doc));
}
function applyYjsUpdateV2(workspace, update) {
  applyUpdateV2(workspace.doc, fromBase64(update));
}
function isInsideBlockByFlavour(page, block, flavour) {
  const parent = page.getParent(block);
  if (parent === null) {
    return false;
  } else if (matchFlavours(parent, [flavour])) {
    return true;
  }
  return isInsideBlockByFlavour(page, parent, flavour);
}

// node_modules/@blocksuite/global/dist/error/code.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["MIGRATION_ERROR"] = 100] = "MIGRATION_ERROR";
  ErrorCode2[ErrorCode2["SCHEMA_VALIDATE_ERROR"] = 101] = "SCHEMA_VALIDATE_ERROR";
})(ErrorCode || (ErrorCode = {}));

// node_modules/@blocksuite/global/dist/error/error.js
var _a7;
var kInternalError = Symbol("internal_error");
var BlockSuiteError = class extends Error {
  constructor(code, message) {
    super(message);
    this[_a7] = true;
    this.code = code;
  }
};
_a7 = kInternalError;
var MigrationError = class extends BlockSuiteError {
  constructor(description) {
    super(ErrorCode.MIGRATION_ERROR, `Migration ${description} error. Please report to https://github.com/toeverything/blocksuite/issues`);
  }
};
var SchemaValidateError = class extends BlockSuiteError {
  constructor(flavour, message) {
    super(ErrorCode.SCHEMA_VALIDATE_ERROR, `Invalid schema for ${flavour}: ${message}`);
  }
};

// node_modules/@blocksuite/store/dist/workspace/migrations.js
var migrations = [
  {
    desc: "convert affine:group to affine:frame",
    condition: (doc2) => {
      const yVersions = doc2.getMap("space:meta").get("versions");
      if (!yVersions)
        return false;
      return yVersions.get("affine:group") === 1;
    },
    migrate: (doc2) => {
      const pageIds = doc2.getMap("space:meta").get("pages").map((a2) => a2.get("id"));
      for (const pageId of pageIds) {
        const spaceId = `space:${pageId}`;
        const yBlocks = doc2.getMap(spaceId);
        yBlocks.forEach((yBlock) => {
          if (yBlock.get("sys:flavour") === "affine:group") {
            yBlock.set("sys:flavour", "affine:frame");
          }
        });
      }
      const yVersions = doc2.getMap("space:meta").get("versions");
      yVersions.delete("affine:group");
      yVersions.set("affine:frame", 1);
    }
  },
  {
    desc: "add affine:surface",
    condition: (doc2) => {
      const yVersions = doc2.getMap("space:meta").get("versions");
      if (!yVersions)
        return false;
      return yVersions.get("affine:shape") === 1;
    },
    migrate: (doc2) => {
      const pageIds = doc2.getMap("space:meta").get("pages").map((a2) => a2.get("id"));
      const yVersions = doc2.getMap("space:meta").get("versions");
      yVersions.delete("affine:shape");
      yVersions.set("affine:surface", 1);
      for (const pageId of pageIds) {
        const spaceId = `space:${pageId}`;
        const yBlocks = doc2.getMap(spaceId);
        const yBlock = new YMap();
        const id2 = uuidv42();
        initInternalProps(yBlock, {
          id: id2,
          flavour: "affine:surface"
        });
        yBlocks.set(id2, yBlock);
        yBlocks.forEach((yBlock2, id3) => {
          if (yBlock2.get("sys:flavour") === "affine:shape") {
            yBlocks.delete(id3);
          }
        });
      }
    }
  },
  {
    desc: "update affine:page title type from string to Text",
    condition: (doc2) => {
      const yVersions = doc2.getMap("space:meta").get("versions");
      if (!yVersions)
        return false;
      const pageVersion = yVersions.get("affine:page");
      if (!pageVersion) {
        throw new MigrationError("affine:page version not found");
      }
      return pageVersion < 2;
    },
    migrate: (doc2) => {
      const pageIds = doc2.getMap("space:meta").get("pages").map((a2) => a2.get("id"));
      const yVersions = doc2.getMap("space:meta").get("versions");
      yVersions.delete("affine:page");
      yVersions.set("affine:page", 2);
      for (const pageId of pageIds) {
        const spaceId = `space:${pageId}`;
        const yBlocks = doc2.getMap(spaceId);
        for (const yBlock of yBlocks.values()) {
          if (yBlock.get("sys:flavour") === "affine:page") {
            const title = yBlock.get("prop:title");
            const yTitle = new YText(title);
            yBlock.set("prop:title", yTitle);
            break;
          }
        }
      }
    }
  },
  {
    desc: "add seed property in surface element",
    condition: (doc2) => {
      const yVersions = doc2.getMap("space:meta").get("versions");
      if (!yVersions)
        return false;
      const surfaceVersion = yVersions.get("affine:surface");
      if (!surfaceVersion) {
        throw new MigrationError("affine:surface version not found");
      }
      return surfaceVersion < 2;
    },
    migrate: (doc2) => {
      const pageIds = doc2.getMap("space:meta").get("pages").map((a2) => a2.get("id"));
      const yVersions = doc2.getMap("space:meta").get("versions");
      yVersions.set("affine:surface", 2);
      for (const pageId of pageIds) {
        const spaceId = `space:${pageId}`;
        const yBlocks = doc2.getMap(spaceId);
        for (const yBlock of yBlocks.values()) {
          if (yBlock.get("sys:flavour") === "affine:surface") {
            const elements = yBlock.get("elements");
            if (!elements)
              break;
            for (const element2 of elements.values()) {
              if (!element2.get("seed")) {
                element2.set("seed", Math.floor(Math.random() * 2 ** 31));
              }
            }
            break;
          }
        }
      }
    }
  },
  {
    desc: "move surface block into children of page block",
    condition: (doc2) => {
      const yVersions = doc2.getMap("space:meta").get("versions");
      if (!yVersions)
        return false;
      const surfaceVersion = yVersions.get("affine:surface");
      if (!surfaceVersion) {
        throw new MigrationError("affine:surface version not found");
      }
      return surfaceVersion < 3;
    },
    migrate: (doc2) => {
      const pageIds = doc2.getMap("space:meta").get("pages").map((a2) => a2.get("id"));
      const yVersions = doc2.getMap("space:meta").get("versions");
      yVersions.set("affine:surface", 3);
      let pageBlock;
      let surfaceId;
      pageIds.forEach((pageId) => {
        const spaceId = `space:${pageId}`;
        const yBlocks = doc2.getMap(spaceId);
        Array.from(yBlocks.entries()).forEach(([yId, yBlock]) => {
          if (yBlock.get("sys:flavour") === "affine:page") {
            pageBlock = yBlock;
          }
          if (yBlock.get("sys:flavour") === "affine:surface") {
            surfaceId = yId;
          }
        });
      });
      if (!pageBlock || !surfaceId) {
        return;
      }
      const yChildren = pageBlock.get("sys:children");
      if (yChildren.toArray().includes(surfaceId)) {
        return;
      }
      yChildren.insert(0, [surfaceId]);
    }
  }
];
function tryMigrate(doc2) {
  for (const migration of migrations) {
    try {
      if (migration.condition(doc2)) {
        migration.migrate(doc2);
      }
    } catch (err) {
      console.error(err);
      throw new MigrationError(migration.desc);
    }
  }
}

// node_modules/@blocksuite/store/dist/workspace/page.js
var __decorate2 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var isWeb2 = typeof window !== "undefined";
function createChildMap(yChildIds) {
  return new Map(yChildIds.map((child, index) => [child, index]));
}
var Page = class extends Space {
  constructor({ id: id2, workspace, doc: doc2, awarenessStore, idGenerator = uuidv4 }) {
    super(id2, doc2, awarenessStore);
    this._root = null;
    this._blockMap = /* @__PURE__ */ new Map();
    this._synced = false;
    this._shouldTransact = true;
    this._ignoredKeys = new Set(Object.keys(new BaseBlockModel()));
    this.slots = {
      historyUpdated: new Slot(),
      rootAdded: new Slot(),
      rootDeleted: new Slot(),
      textUpdated: new Slot(),
      yUpdated: new Slot(),
      onYEvent: new Slot(),
      blockUpdated: new Slot(),
      copied: new Slot(),
      pasted: new Slot()
    };
    this._historyAddObserver = (event) => {
      if (isWeb2) {
        event.stackItem.meta.set("cursor-location", this.awarenessStore.getLocalRange(this));
      }
      this._historyObserver();
    };
    this._historyPopObserver = (event) => {
      const range = event.stackItem.meta.get("cursor-location");
      if (!range) {
        return;
      }
      this.awarenessStore.setLocalRange(this, range);
      this._historyObserver();
    };
    this._historyObserver = () => {
      this.slots.historyUpdated.emit();
    };
    this._handleYEvents = (events) => {
      for (const event of events) {
        this._handleYEvent(event);
      }
      this.slots.yUpdated.emit();
    };
    this._workspace = workspace;
    this._idGenerator = idGenerator;
  }
  get readonly() {
    return this.awarenessStore.isReadonly(this);
  }
  get history() {
    return this._history;
  }
  get workspace() {
    return this._workspace;
  }
  get schema() {
    return this._workspace.schema;
  }
  get meta() {
    return this.workspace.meta.getPageMeta(this.id);
  }
  get blobs() {
    return this.workspace.blobs;
  }
  /** key-value store of blocks */
  get _yBlocks() {
    return this._ySpace;
  }
  get root() {
    return this._root;
  }
  getYBlockById(id2) {
    return this._yBlocks.get(id2);
  }
  get isEmpty() {
    return this._yBlocks.size === 0;
  }
  get canUndo() {
    if (this.readonly) {
      return false;
    }
    return this._history.canUndo();
  }
  get canRedo() {
    if (this.readonly) {
      return false;
    }
    return this._history.canRedo();
  }
  get YText() {
    return YText;
  }
  get YMap() {
    return YMap;
  }
  get Text() {
    return Text2;
  }
  withoutTransact(callback) {
    this._shouldTransact = false;
    callback();
    this._shouldTransact = true;
  }
  transact(fn, shouldTransact = this._shouldTransact) {
    super.transact(fn, shouldTransact);
  }
  undo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.undo();
  }
  redo() {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    this._history.redo();
  }
  /** Capture current operations to undo stack synchronously. */
  captureSync() {
    this._history.stopCapturing();
  }
  resetHistory() {
    this._history.clear();
  }
  generateId() {
    return this._idGenerator();
  }
  getBlockById(id2) {
    return this._blockMap.get(id2) ?? null;
  }
  getBlockByFlavour(blockFlavour) {
    return [...this._blockMap.values()].filter(({ flavour }) => flavour === blockFlavour);
  }
  hasFlavour(flavour) {
    return this.getBlockByFlavour(flavour).length > 0;
  }
  getParent(target) {
    const root = this._root;
    const targetId = typeof target === "string" ? target : target.id;
    if (!root || root.id === targetId)
      return null;
    const findParent = (parentId) => {
      const parentModel = this._blockMap.get(parentId);
      if (!parentModel)
        return null;
      for (const [childId] of parentModel.childMap) {
        if (childId === targetId)
          return parentModel;
        const parent2 = findParent(childId);
        if (parent2 !== null)
          return parent2;
      }
      return null;
    };
    const parent = findParent(root.id);
    if (parent !== null)
      return parent;
    return null;
  }
  getPreviousSibling(block) {
    const parent = this.getParent(block);
    if (!parent) {
      return null;
    }
    const index = parent.children.indexOf(block);
    if (index === -1) {
      throw new Error("Failed to getPreviousSiblings! Block not found in parent's children");
    }
    return parent.children[index - 1] ?? null;
  }
  getPreviousSiblings(block) {
    const parent = this.getParent(block);
    if (!parent) {
      return [];
    }
    const index = parent.children.indexOf(block);
    if (index === -1) {
      throw new Error("Failed to getPreviousSiblings! Block not found in parent's children");
    }
    return parent.children.slice(0, index);
  }
  getNextSibling(block) {
    const parent = this.getParent(block);
    if (!parent) {
      return null;
    }
    const index = parent.children.indexOf(block);
    if (index === -1) {
      throw new Error("Failed to getPreviousSiblings! Block not found in parent's children");
    }
    return parent.children[index + 1] ?? null;
  }
  getNextSiblings(block) {
    const parent = this.getParent(block);
    if (!parent) {
      return [];
    }
    const index = parent.children.indexOf(block);
    if (index === -1) {
      throw new Error("Failed to getNextSiblings! Block not found in parent's children");
    }
    return parent.children.slice(index + 1);
  }
  getSchemaByFlavour(flavour) {
    return this.schema.flavourSchemaMap.get(flavour);
  }
  getInitialPropsByFlavour(flavour) {
    var _a10, _b6;
    const schema = this.schema.flavourSchemaMap.get(flavour);
    assertExists(schema);
    return ((_b6 = (_a10 = schema.model).props) == null ? void 0 : _b6.call(_a10, internalPrimitives)) ?? {};
  }
  addBlocks(blocks, parent, parentIndex) {
    const ids = [];
    blocks.forEach((block) => {
      const id2 = this.addBlock(block.flavour, block.blockProps ?? {}, parent, parentIndex);
      ids.push(id2);
      typeof parentIndex === "number" && parentIndex++;
    });
    return ids;
  }
  addBlock(flavour, blockProps = {}, parent, parentIndex) {
    var _a10;
    if (this.readonly) {
      throw new Error("cannot modify data in readonly mode");
    }
    if (!flavour) {
      throw new Error("Block props must contain flavour");
    }
    if (!this.awarenessStore.getFlag("enable_database") && flavour === "affine:database") {
      throw new Error("database is not enabled");
    }
    const parentModel = typeof parent === "string" ? this.getBlockById(parent) : parent;
    this.schema.validate(flavour, parentModel == null ? void 0 : parentModel.flavour, (_a10 = blockProps.children) == null ? void 0 : _a10.map((child) => child.flavour));
    const clonedProps = { flavour, ...blockProps };
    const id2 = blockProps.id ?? this._idGenerator();
    clonedProps.id = id2;
    this.transact(() => {
      var _a11;
      const yBlock = new YMap();
      this._yBlocks.set(id2, yBlock);
      assertValidChildren(this._yBlocks, clonedProps);
      const schema = this.getSchemaByFlavour(flavour);
      assertExists(schema);
      initInternalProps(yBlock, clonedProps);
      syncBlockProps(schema, yBlock, clonedProps, this._ignoredKeys);
      const parentModel2 = typeof parent === "string" ? this._blockMap.get(parent) : parent;
      const parentId = (parentModel2 == null ? void 0 : parentModel2.id) ?? ((_a11 = this._root) == null ? void 0 : _a11.id);
      if (parentId) {
        const yParent = this._yBlocks.get(parentId);
        const yChildren = yParent.get("sys:children");
        const index = parentIndex ?? yChildren.length;
        yChildren.insert(index, [id2]);
      }
    });
    this.slots.blockUpdated.emit({ type: "add", id: id2 });
    return id2;
  }
  _populateParentChildrenMap(blocksToMove, childBlocksPerParent, newParent) {
    blocksToMove.forEach((block) => {
      const parentBlock = this.getParent(block);
      if (!parentBlock) {
        throw new Error("Can't find parent block for the current block");
      }
      this.schema.validate(block.flavour, newParent.flavour);
      const childrenBlocksOfCurrentParent = childBlocksPerParent.get(parentBlock);
      if (childrenBlocksOfCurrentParent) {
        if (this.getNextSibling(childrenBlocksOfCurrentParent[childrenBlocksOfCurrentParent.length - 1]) !== block) {
          throw new Error("The blocks to move are not contiguous under their parent");
        }
        childrenBlocksOfCurrentParent.push(block);
      } else {
        childBlocksPerParent.set(parentBlock, [block]);
      }
    });
  }
  _repositionBlocks(childBlocksPerParent, targetParentChildren, targetSibling, shouldInsertBeforeSibling, insertionOffset) {
    for (const [parentBlock, blocksToMove] of childBlocksPerParent) {
      const sourceParentBlock = this._yBlocks.get(parentBlock.id);
      const sourceParentChildren = sourceParentBlock.get("sys:children");
      const idsOfBlocksToMove = blocksToMove.map(({ id: id2 }) => id2);
      const startIndex = sourceParentChildren.toArray().findIndex((id2) => id2 === idsOfBlocksToMove[0]);
      sourceParentChildren.delete(startIndex, idsOfBlocksToMove.length);
      let insertIndex = 0;
      if (targetSibling) {
        insertIndex = targetParentChildren.toArray().findIndex((id2) => id2 === targetSibling.id);
      }
      if (shouldInsertBeforeSibling) {
        targetParentChildren.insert(insertIndex, idsOfBlocksToMove);
      } else {
        targetParentChildren.insert(insertIndex + insertionOffset, idsOfBlocksToMove);
        insertionOffset += idsOfBlocksToMove.length;
      }
    }
  }
  // Moves blocks to a new parent. Optionally inserts blocks before a given sibling.
  moveBlocks(blocksToMove, newParent, targetSibling = null, shouldInsertBeforeSibling = true) {
    if (this.readonly) {
      console.error("Cannot modify data in read-only mode");
      return;
    }
    if (!newParent) {
      throw new Error("Can't find new parent block");
    }
    const childBlocksPerParent = /* @__PURE__ */ new Map();
    this._populateParentChildrenMap(blocksToMove, childBlocksPerParent, newParent);
    this.transact(() => {
      const targetParentBlock = this._yBlocks.get(newParent.id);
      const targetParentChildren = targetParentBlock.get("sys:children");
      const insertionOffset = 1;
      this._repositionBlocks(childBlocksPerParent, targetParentChildren, targetSibling, shouldInsertBeforeSibling, insertionOffset);
    });
    Array.from(childBlocksPerParent.keys()).forEach((parent) => parent.childrenUpdated.emit());
    newParent.childrenUpdated.emit();
  }
  updateBlock(model, props) {
    var _a10;
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    const parent = this.getParent(model);
    this.schema.validate(model.flavour, parent == null ? void 0 : parent.flavour, (_a10 = props.children) == null ? void 0 : _a10.map((child) => child.flavour));
    const yBlock = this._yBlocks.get(model.id);
    assertExists(yBlock);
    this.transact(() => {
      if (props.children) {
        const yChildren = new YArray();
        yChildren.insert(0, props.children.map((child) => child.id));
        yBlock.set("sys:children", yChildren);
      }
      const schema = this.schema.flavourSchemaMap.get(model.flavour);
      assertExists(schema);
      syncBlockProps(schema, yBlock, props, this._ignoredKeys);
    });
    model.propsUpdated.emit();
    this.slots.blockUpdated.emit({
      type: "update",
      id: model.id
    });
  }
  addSiblingBlocks(targetModel, props, place = "after") {
    const parent = this.getParent(targetModel);
    assertExists(parent);
    const targetIndex = parent.children.findIndex(({ id: id2 }) => id2 === targetModel.id) ?? 0;
    const insertIndex = place === "before" ? targetIndex : targetIndex + 1;
    if (props.length > 1) {
      const blocks = [];
      props.forEach((prop) => {
        const { flavour, ...blockProps } = prop;
        assertExists(flavour);
        blocks.push({ flavour, blockProps });
      });
      return this.addBlocks(blocks, parent.id, insertIndex);
    } else {
      assertExists(props[0].flavour);
      const { flavour, ...blockProps } = props[0];
      const id2 = this.addBlock(flavour, blockProps, parent.id, insertIndex);
      return [id2];
    }
  }
  deleteBlock(model, options = {
    bringChildrenTo: false
  }) {
    if (this.readonly) {
      console.error("cannot modify data in readonly mode");
      return;
    }
    const parent = this.getParent(model);
    const index = (parent == null ? void 0 : parent.children.indexOf(model)) ?? -1;
    const { bringChildrenTo } = options;
    if (index > -1) {
      parent == null ? void 0 : parent.children.splice(parent.children.indexOf(model), 1);
    }
    if (bringChildrenTo === "parent" && parent) {
      model.children.forEach((child) => {
        this.schema.validate(child.flavour, parent.flavour);
      });
      parent.children.unshift(...model.children);
    } else if (bringChildrenTo instanceof BaseBlockModel) {
      model.children.forEach((child) => {
        this.schema.validate(child.flavour, bringChildrenTo.flavour);
      });
      if (bringChildrenTo === parent && index > -1) {
        parent.children.splice(index, 0, ...model.children);
      } else {
        bringChildrenTo.children.push(...model.children);
      }
    }
    this._blockMap.delete(model.id);
    model.propsUpdated.emit();
    this.transact(() => {
      this._yBlocks.delete(model.id);
      const children = model.children.map((model2) => model2.id);
      model.dispose();
      if (parent) {
        const yParent = this._yBlocks.get(parent.id);
        const yChildren = yParent.get("sys:children");
        if (index > -1) {
          yChildren.delete(index, 1);
        }
        if (options.bringChildrenTo === "parent") {
          yChildren.unshift(children);
        } else if (options.bringChildrenTo instanceof BaseBlockModel) {
          this.updateBlock(options.bringChildrenTo, {
            children: options.bringChildrenTo.children
          });
        }
      }
    });
    this.slots.blockUpdated.emit({ type: "delete", id: model.id });
  }
  trySyncFromExistingDoc() {
    var _a10;
    if (this._synced) {
      throw new Error("Cannot sync from existing doc more than once");
    }
    if ((((_a10 = this.workspace.meta.pages) == null ? void 0 : _a10.length) ?? 0) <= 1) {
      tryMigrate(this.doc);
      this._handleVersion();
    }
    this._initYBlocks();
    const visited = /* @__PURE__ */ new Set();
    this._yBlocks.forEach((_, id2) => {
      if (visited.has(id2))
        return;
      visited.add(id2);
      this._handleYBlockAdd(visited, id2);
    });
    this._synced = true;
  }
  dispose() {
    this.slots.historyUpdated.dispose();
    this.slots.rootAdded.dispose();
    this.slots.rootDeleted.dispose();
    this.slots.textUpdated.dispose();
    this.slots.yUpdated.dispose();
    this.slots.blockUpdated.dispose();
    this.slots.onYEvent.dispose();
    this._yBlocks.unobserveDeep(this._handleYEvents);
    this._yBlocks.clear();
  }
  _initYBlocks() {
    const { _yBlocks } = this;
    _yBlocks.observeDeep(this._handleYEvents);
    this._history = new UndoManager([_yBlocks], {
      trackedOrigins: /* @__PURE__ */ new Set([this.doc.clientID]),
      doc: this.doc
    });
    this._history.on("stack-cleared", this._historyObserver);
    this._history.on("stack-item-added", this._historyAddObserver);
    this._history.on("stack-item-popped", this._historyPopObserver);
    this._history.on("stack-item-updated", this._historyObserver);
  }
  _getYBlock(id2) {
    const yBlock = this._yBlocks.get(id2);
    if (!yBlock) {
      throw new Error(`Block with id ${id2} does not exist`);
    }
    return yBlock;
  }
  _createBlockModel(props, block) {
    var _a10, _b6;
    const schema = this.schema.flavourSchemaMap.get(props.flavour);
    if (!schema) {
      throw new Error(`Block flavour ${props.flavour} is not registered`);
    } else if (!props.id) {
      throw new Error("Block id is not defined");
    }
    const blockModel = schema.model.toModel ? schema.model.toModel() : new BaseBlockModel();
    blockModel.id = props.id;
    const modelProps = ((_b6 = (_a10 = schema.model).props) == null ? void 0 : _b6.call(_a10, internalPrimitives)) ?? {};
    Object.entries(modelProps).forEach(([key, value]) => {
      blockModel[key] = value instanceof Text2 ? new Text2(block.get(`prop:${key}`)) : props[key] ?? value;
    });
    blockModel.page = this;
    blockModel.yBlock = block;
    blockModel.flavour = schema.model.flavour;
    blockModel.role = schema.model.role;
    blockModel.tag = schema.model.tag;
    blockModel.onCreated();
    return blockModel;
  }
  _handleYBlockAdd(visited, id2) {
    const yBlock = this._getYBlock(id2);
    const props = toBlockProps(yBlock);
    const model = this._createBlockModel({ ...props, id: id2 }, yBlock);
    this._blockMap.set(id2, model);
    const yChildren = yBlock.get("sys:children");
    if (yChildren instanceof YArray) {
      model.childMap = createChildMap(yChildren);
      yChildren.forEach((id3) => {
        const index2 = model.childMap.get(id3);
        if (Number.isInteger(index2)) {
          const hasChild = this._blockMap.has(id3);
          if (!hasChild) {
            visited.add(id3);
            this._handleYBlockAdd(visited, id3);
          }
          model.children[index2] = this._blockMap.get(id3);
        }
      });
    }
    if (model.role === "root") {
      this._root = model;
      this.slots.rootAdded.emit(this._root);
      this.workspace.slots.pageAdded.emit(this.id);
      return;
    }
    const parent = this.getParent(model);
    const index = parent == null ? void 0 : parent.childMap.get(model.id);
    if (parent && index !== void 0) {
      parent.children[index] = model;
      parent.childrenUpdated.emit();
    }
  }
  _handleYBlockDelete(id2) {
    const model = this._blockMap.get(id2);
    if (model === this._root) {
      this.slots.rootDeleted.emit(id2);
    } else {
    }
    this._blockMap.delete(id2);
  }
  _handleYBlockUpdate(event) {
    const id2 = event.target.get("sys:id");
    const model = this.getBlockById(id2);
    if (!model)
      return;
    const props = {};
    let hasPropsUpdate = false;
    let hasChildrenUpdate = false;
    for (const key of event.keysChanged) {
      if (key === "prop:text")
        continue;
      if (key === "sys:children") {
        hasChildrenUpdate = true;
        const yChildren = event.target.get("sys:children");
        if (!(yChildren instanceof YArray)) {
          console.error("Failed to update block children!, sys:children is not an Y array", event, yChildren);
          continue;
        }
        model.childMap = createChildMap(yChildren);
        model.children = yChildren.map((id3) => this._blockMap.get(id3));
        continue;
      }
      const value = event.target.get(key);
      hasPropsUpdate = true;
      if (value instanceof YMap || value instanceof YArray) {
        props[key.replace("prop:", "")] = createYProxy(value, {
          deep: true
        });
      } else {
        props[key.replace("prop:", "")] = value;
      }
    }
    if (hasPropsUpdate) {
      Object.assign(model, props);
      model.propsUpdated.emit();
    }
    hasChildrenUpdate && model.childrenUpdated.emit();
  }
  _handleYEvent(event) {
    if (event.target === this._yBlocks) {
      const visited = /* @__PURE__ */ new Set();
      event.keys.forEach((value, id2) => {
        if (value.action === "add") {
          if (visited.has(id2))
            return;
          visited.add(id2);
          this._handleYBlockAdd(visited, id2);
        } else if (value.action === "delete") {
          this._handleYBlockDelete(id2);
        } else {
        }
      });
    } else if (event.target.parent === this._yBlocks) {
      if (event instanceof YTextEvent) {
        this.slots.textUpdated.emit(event);
      } else if (event instanceof YMapEvent) {
        this._handleYBlockUpdate(event);
      }
    } else if (event.target.parent instanceof YMap && event.target.parent.has("sys:id")) {
      if (event instanceof YArrayEvent) {
        const id2 = event.target.parent.get("sys:id");
        const model = this._blockMap.get(id2);
        if (!model) {
          throw new Error(`Block with id ${id2} does not exist`);
        }
        const key = event.path[event.path.length - 1];
        if (key === "sys:children") {
          const childIds = event.target.toArray();
          model.children = childIds.map((id3) => this._blockMap.get(id3));
          model.childMap = createChildMap(event.target);
          model.childrenUpdated.emit();
        }
      }
    }
    this.slots.onYEvent.emit({ event });
  }
  _handleVersion() {
    if (this._yBlocks.size === 0) {
      this.workspace.meta.writeVersion(this.workspace);
    } else {
      this.workspace.meta.validateVersion(this.workspace);
    }
  }
};
__decorate2([
  debug("CRUD")
], Page.prototype, "addBlocks", null);
__decorate2([
  debug("CRUD")
], Page.prototype, "addBlock", null);
__decorate2([
  debug("CRUD")
], Page.prototype, "moveBlocks", null);
__decorate2([
  debug("CRUD")
], Page.prototype, "updateBlock", null);
__decorate2([
  debug("CRUD")
], Page.prototype, "deleteBlock", null);

// node_modules/@blocksuite/store/dist/persistence/blob/utils.js
var import_buffer2 = __toESM(require_buffer(), 1);
async function sha(input) {
  const hash = await crypto.subtle.digest("SHA-256", input);
  const buffer = import_buffer2.Buffer.from(hash);
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@blocksuite/store/dist/workspace/indexer/backlink.js
function isSubpageDelta(delta, pageId) {
  return delta.attributes && delta.attributes.reference && delta.attributes.reference.type === "Subpage" && delta.attributes.reference.pageId === pageId;
}
var BacklinkIndexer = class {
  constructor(blockIndexer) {
    this._linkIndexMap = {};
    this._disposables = new DisposableGroup();
    this.slots = {
      /**
       * Note: sys:children update will not trigger event
       */
      indexUpdated: new Slot()
    };
    this._backlinkIndexMapCache = null;
    this._disposables.add(blockIndexer.slots.refreshIndex.on(() => this._onRefreshIndex()));
    this._disposables.add(blockIndexer.slots.pageRemoved.on((pageId) => this._onPageRemoved(pageId)));
    this._disposables.add(blockIndexer.slots.blockUpdated.on((e) => this._onBlockUpdated(e)));
    this.slots.indexUpdated.on(() => {
      this._backlinkIndexMapCache = null;
    });
  }
  /**
   * Get the list of backlinks for a given page
   */
  getBacklink(targetPageId) {
    if (this._backlinkIndexMapCache) {
      return this._backlinkIndexMapCache[targetPageId] ?? [];
    }
    const backlinkIndexMapCache = {};
    for (const [fromPageId, blockMap] of Object.entries(this._linkIndexMap)) {
      for (const [fromBlockId, links] of Object.entries(blockMap)) {
        links.forEach(({ pageId, type }) => {
          if (!(pageId in backlinkIndexMapCache)) {
            backlinkIndexMapCache[pageId] = [];
          }
          backlinkIndexMapCache[pageId].push({
            pageId: fromPageId,
            blockId: fromBlockId,
            type
          });
        });
      }
    }
    this._backlinkIndexMapCache = backlinkIndexMapCache;
    return this._backlinkIndexMapCache[targetPageId] ?? [];
  }
  /**
   * Returns all valid subpage nodes in the given page.
   *
   * Note: this method will ignore invalid subpage nodes.
   *
   * @example
   * ```ts
   * const subpages = workspace.indexer.backlink
   *   .getSubpageNodes(pageId)
   *   .map(node => node.pageId);
   * ```
   */
  getSubpageNodes(pageId) {
    if (!(pageId in this._linkIndexMap)) {
      return [];
    }
    return Object.values(this._linkIndexMap[pageId]).flat().filter((link) => link.type === "Subpage").filter((link) => this.getParentPage(link.pageId) === pageId);
  }
  getParentPage(pageId) {
    const parentPage = this.getBacklink(pageId).filter((node) => node.type === "Subpage").map((node) => node.pageId);
    if (!parentPage.length) {
      return null;
    }
    if (parentPage.length > 1) {
      console.error("Unexpected multiple parent page", parentPage, pageId);
    }
    return parentPage[0];
  }
  /**
   * Delete the specified subpage nodes from the workspace.
   */
  removeSubpageNode(workspace, subpageId) {
    const backlinks = this.getBacklink(subpageId);
    const subpageNodes = backlinks.filter((link) => link.type === "Subpage");
    if (subpageNodes.length > 1) {
      console.warn("Unexpected subpage node count", subpageId, subpageNodes);
    }
    subpageNodes.forEach(({ pageId, blockId }) => {
      const page = workspace.getPage(pageId);
      if (!page) {
        console.warn("Failed to remove subpage node from page! page not found!");
        return;
      }
      const block = page.getBlockById(blockId);
      if (!block) {
        console.warn(block, `Failed to remove subpage node from page! block not found! pageId: ${page.id}, blockId: ${blockId}`);
        return;
      }
      const text2 = block.text;
      assertExists(text2);
      page.transact(() => {
        let accIdx = 0;
        text2.toDelta().forEach((delta) => {
          var _a10;
          const deltaLen = ((_a10 = delta.insert) == null ? void 0 : _a10.length) ?? 0;
          if (isSubpageDelta(delta, subpageId)) {
            text2.format(accIdx, deltaLen, { reference: null });
          }
          accIdx += deltaLen ?? 0;
        });
      }, false);
    });
  }
  _onRefreshIndex() {
    this._linkIndexMap = {};
  }
  _onPageRemoved(pageId) {
    if (!this._linkIndexMap[pageId]) {
      return;
    }
    this._linkIndexMap[pageId] = {};
    this.slots.indexUpdated.emit({ action: "delete", pageId });
  }
  _onBlockUpdated({ action, pageId, block, blockId }) {
    switch (action) {
      case "add":
      case "update": {
        const text2 = block.get("prop:text");
        if (!(text2 instanceof YText)) {
          if (text2) {
            console.warn("Unexpected prop:text type", text2);
          }
          return;
        }
        const deltas = text2.toDelta();
        this._indexDelta({ action, pageId, blockId, deltas });
        return;
      }
      case "delete": {
        this._removeIndex(pageId, blockId);
        break;
      }
    }
  }
  _indexDelta({ action, pageId, blockId, deltas }) {
    var _a10;
    const links = deltas.filter((delta) => delta.attributes && delta.attributes.reference).map((delta) => ({ ...delta.attributes.reference, blockId }));
    const before = ((_a10 = this._linkIndexMap[pageId]) == null ? void 0 : _a10[blockId]) ?? [];
    const diff = diffArray(before, links);
    if (!diff.changed)
      return;
    this._linkIndexMap[pageId] = {
      ...this._linkIndexMap[pageId],
      [blockId]: links
    };
    this.slots.indexUpdated.emit({ action, pageId, blockId });
  }
  _removeIndex(pageId, blockId) {
    if (!this._linkIndexMap[pageId] || !this._linkIndexMap[pageId][blockId]) {
      return;
    }
    const previousLink = this._linkIndexMap[pageId][blockId];
    delete this._linkIndexMap[pageId][blockId];
    if (previousLink.length) {
      this.slots.indexUpdated.emit({
        action: "delete",
        pageId,
        blockId
      });
    }
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/@blocksuite/store/dist/workspace/indexer/base.js
var BlockIndexer = class {
  constructor(doc2, { immediately = false, slots }) {
    this._disposables = new DisposableGroup();
    this.slots = {
      pageRemoved: new Slot(),
      /**
       * Note: sys:children update will not trigger event
       */
      blockUpdated: new Slot(),
      refreshIndex: new Slot()
    };
    this._yPageObserver = (events, transaction, { pageId, yPage }) => {
      events.forEach((e) => {
        if (e instanceof YArrayEvent) {
          return;
        }
        if (e instanceof YMapEvent) {
          if (e.target !== e.currentTarget) {
            if (e.keysChanged.has("prop:text")) {
              const blockId = e.path[0];
              const block = yPage.get(blockId);
              assertExists(block);
              this._indexBlock({
                action: "update",
                pageId,
                blockId,
                block
              });
            }
            return;
          }
          Array.from(e.changes.keys.entries()).forEach(([blockId, { action }]) => {
            if (action === "delete") {
              this._indexBlock({
                action,
                pageId,
                blockId
              });
              return;
            }
            const block = yPage.get(blockId);
            assertExists(block);
            this._indexBlock({
              action,
              pageId,
              blockId,
              block
            });
          });
          return;
        }
        if (e instanceof YTextEvent) {
          const blockId = e.path[0];
          if (!blockId || typeof blockId !== "string") {
            throw new Error("Failed to update index! Unexpected YText Event!");
          }
          const block = yPage.get(blockId);
          assertExists(block);
          this._indexBlock({
            action: "update",
            pageId,
            blockId,
            block
          });
          return;
        }
      });
    };
    this._doc = doc2;
    this._workspaceSlots = slots;
    if (immediately) {
      this._initIndex();
      return;
    }
    if ("requestIdleCallback" in globalThis) {
      requestIdleCallback(() => {
        this._initIndex();
      });
      return;
    }
    setTimeout(() => {
      this._initIndex();
    }, 0);
  }
  _initIndex() {
    const doc2 = this._doc;
    const share = doc2.share;
    if (!share.has("space:meta")) {
      throw new Error("Failed to initialize indexer: 'space:meta' not found");
    }
    let disposeMap = {};
    this._disposables.add(() => {
      Object.values(disposeMap).forEach((fn) => fn == null ? void 0 : fn());
      disposeMap = {};
    });
    Array.from(doc2.share.keys()).filter((pageId) => pageId !== "space:meta").map((pageId) => pageId.startsWith("space:") ? pageId.slice("space:".length) : pageId).map((pageId) => ({ pageId, page: this._getPage(pageId) })).forEach(({ pageId, page }) => {
      assertExists(page, `Failed to find page '${pageId}'`);
      if (disposeMap[pageId]) {
        console.warn(`Duplicated pageAdded event! ${pageId} already observed`, disposeMap);
        return;
      }
      const dispose = this._indexPage(pageId, page);
      disposeMap[pageId] = dispose;
    });
    this._workspaceSlots.pageAdded.on((pageId) => {
      const page = this._getPage(pageId);
      assertExists(page, `Failed to find page '${pageId}'`);
      if (disposeMap[pageId]) {
        return;
      }
      const dispose = this._indexPage(pageId, page);
      disposeMap[pageId] = dispose;
    });
    this._workspaceSlots.pageRemoved.on((pageId) => {
      var _a10;
      (_a10 = disposeMap[pageId]) == null ? void 0 : _a10.call(disposeMap);
      disposeMap[pageId] = null;
      this.slots.pageRemoved.emit(pageId);
    });
  }
  _indexPage(pageId, yPage) {
    yPage.forEach((block, blockId) => {
      this._indexBlock({ action: "add", pageId, blockId, block });
    });
    const observer = (events, transaction) => this._yPageObserver(events, transaction, { pageId, yPage });
    yPage.observeDeep(observer);
    return () => {
      yPage.unobserveDeep(observer);
    };
  }
  _indexBlock(indexEvent) {
    this.slots.blockUpdated.emit(indexEvent);
  }
  _getPage(pageId) {
    if (pageId.startsWith("space:")) {
      console.warn("Unexpected page prefix", pageId);
    }
    pageId = `space:${pageId}`;
    return this._doc.getMap(pageId);
  }
  refreshIndex() {
    this.slots.refreshIndex.emit();
    this._initIndex();
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/@blocksuite/store/dist/workspace/indexer/search.js
var import_flexsearch = __toESM(require_flexsearch_bundle(), 1);
var DocumentIndexer = import_flexsearch.default.Document;
var Index = import_flexsearch.default.Index;
function tokenize(locale) {
  const tokenizer = Intl == null ? void 0 : Intl.Segmenter;
  if (tokenizer) {
    const latinIndexer = new Index({ charset: "latin:advanced" });
    const latinEncoder = latinIndexer.encode.bind(latinIndexer);
    const latinChecker = /^[\p{Script=Latin}\p{Mark}\d]+$/u;
    const segmenter = new tokenizer([locale], { granularity: "word" });
    return (text2) => {
      const latinChars = [];
      const cjkChars = Array.from(segmenter.segment(text2)).filter((s) => {
        if (s.isWordLike) {
          if (!latinChecker.test(s.segment)) {
            return true;
          }
          latinChars.push(s.segment);
        }
        return false;
      }).map((s) => s.segment);
      return [...cjkChars, ...latinEncoder(latinChars.join(" "))];
    };
  }
  return (text2) => {
    return text2.replace(/[\x00-\x7F]/g, "").split("");
  };
}
var SearchIndexer = class {
  constructor(doc2, locale = "en-US") {
    this._doc = doc2;
    this._indexer = new DocumentIndexer({
      document: {
        id: "id",
        index: ["content", "reference", "space"],
        tag: "tags",
        store: ["space"]
      },
      encode: tokenize(locale),
      tokenize: "forward",
      context: true
    });
    Array.from(doc2.share.keys()).filter((pageId) => pageId !== "space:meta").map((k) => [k, this._getPage(k)]).forEach(([pageId, page]) => this._handlePageIndexing(pageId, page));
  }
  // TODO: remove this method, observe page meta instead
  onPageCreated(pageId) {
    this._handlePageIndexing(pageId, this._getPage(pageId));
  }
  search(query2) {
    return new Map(this._search(query2).flatMap(({ result }) => result.map((r) => [r.id, r.doc.space])));
  }
  _search(query2) {
    if (typeof query2 === "object") {
      return this._indexer.search({
        ...query2,
        enrich: true
      });
    } else {
      return this._indexer.search(query2, {
        enrich: true
      });
    }
  }
  _handlePageIndexing(pageId, page) {
    if (page) {
      page.forEach((_, key) => {
        this._refreshIndex(pageId, key, "add", page.get(key));
      });
      page.observeDeep((events) => {
        const keys2 = events.flatMap((e) => {
          var _a10;
          if ((((_a10 = e.path) == null ? void 0 : _a10.length) | 0) > 0) {
            return [[e.path[0], "update"]];
          }
          return Array.from(e.changes.keys.entries()).map(([k, { action }]) => [k, action]);
        });
        if (keys2.length) {
          keys2.forEach(([key, action]) => {
            this._refreshIndex(pageId, key, action, page.get(key));
          });
        }
      });
    }
  }
  _refreshIndex(page, id2, action, block) {
    switch (action) {
      case "add":
      case "update": {
        if (block) {
          const content = this._toContent(block.get("prop:title") || block.get("prop:text"));
          if (content) {
            this._indexer.add(id2, {
              content,
              space: page,
              tags: [page]
            });
          }
        }
        break;
      }
      case "delete": {
        this._indexer.remove(id2);
        break;
      }
    }
  }
  _toContent(obj) {
    if (obj) {
      if (typeof obj === "string") {
        return obj;
      } else if (obj instanceof YText) {
        return obj.toJSON();
      }
    }
    return void 0;
  }
  _getPage(key) {
    try {
      if (!key.startsWith("space:")) {
        key = `space:${key}`;
      }
      return this._doc.getMap(key);
    } catch (_) {
      return void 0;
    }
  }
};

// node_modules/@blocksuite/store/dist/workspace/meta.js
var WorkspaceMeta = class extends Space {
  constructor(id2, doc2, awarenessStore) {
    super(id2, doc2, awarenessStore);
    this._prevPages = /* @__PURE__ */ new Set();
    this.pageMetaAdded = new Slot();
    this.pageMetaRemoved = new Slot();
    this.pageMetasUpdated = new Slot();
    this.commonFieldsUpdated = new Slot();
    this._handleWorkspaceMetaEvents = (events) => {
      events.forEach((e) => {
        const hasKey = (k) => e.target === this._ySpace && e.changes.keys.has(k);
        if (e.target === this.pages || e.target.parent === this.pages || hasKey("pages")) {
          this._handlePageMetaEvent();
        }
        if (hasKey("name") || hasKey("avatar")) {
          this._handleCommonFieldsEvent();
        }
      });
    };
    this._ySpace.observeDeep(this._handleWorkspaceMetaEvents);
  }
  get pages() {
    return this._proxy.pages;
  }
  get name() {
    return this._proxy.name;
  }
  get avatar() {
    return this._proxy.avatar;
  }
  setName(name) {
    this.doc.transact(() => {
      this._proxy.name = name;
    });
  }
  setAvatar(avatar) {
    this.doc.transact(() => {
      this._proxy.avatar = avatar;
    });
  }
  get pageMetas() {
    var _a10;
    return ((_a10 = this._proxy.pages) == null ? void 0 : _a10.toJSON()) ?? [];
  }
  getPageMeta(id2) {
    return this.pageMetas.find((page) => page.id === id2);
  }
  addPageMeta(page, index) {
    this.doc.transact(() => {
      const pages = this.pages ?? new YArray();
      const yPage = this._transformObjectToYMap(page);
      if (index === void 0) {
        pages.push([yPage]);
      } else {
        pages.insert(index, [yPage]);
      }
      if (!this.pages) {
        this._ySpace.set("pages", pages);
      }
    });
  }
  /**
   * @internal Use {@link Workspace.setPageMeta} instead
   */
  setPageMeta(id2, props) {
    var _a10;
    const pages = ((_a10 = this.pages) == null ? void 0 : _a10.toJSON()) ?? [];
    const index = pages.findIndex((page) => id2 === page.id);
    this.doc.transact(() => {
      if (!this.pages) {
        this._ySpace.set("pages", new YArray());
      }
      if (index === -1)
        return;
      assertExists(this.pages);
      const yPage = this.pages.get(index);
      Object.entries(props).forEach(([key, value]) => {
        yPage.set(key, value);
      });
    });
  }
  /**
   * Adjust the index of a page inside the pageMetss list
   *
   * @deprecated
   */
  shiftPageMeta(pageId, newIndex) {
    const pageMetas = (this.pages ?? new YArray()).toJSON();
    const index = pageMetas.findIndex((page) => pageId === page.id);
    if (index === -1)
      return;
    const yPage = this._transformObjectToYMap(pageMetas[index]);
    this.doc.transact(() => {
      assertExists(this.pages);
      this.pages.delete(index, 1);
      if (newIndex > this.pages.length) {
        this.pages.push([yPage]);
      } else {
        this.pages.insert(newIndex, [yPage]);
      }
    });
  }
  removePageMeta(id2) {
    assertExists(this.pages);
    const pageMetas = this.pages.toJSON();
    const index = pageMetas.findIndex((page) => id2 === page.id);
    if (index === -1) {
      return;
    }
    this.doc.transact(() => {
      assertExists(this.pages);
      this.pages.delete(index, 1);
    });
  }
  /**
   * @internal Only for page initialization
   */
  writeVersion(workspace) {
    let versions = this._proxy.versions;
    if (!versions) {
      versions = new YMap();
      workspace.schema.flavourSchemaMap.forEach((schema, flavour) => {
        versions.set(flavour, schema.version);
      });
      this._ySpace.set("versions", versions);
      return;
    } else {
      console.error(`Workspace versions already set.`);
    }
  }
  /**
   * @internal Only for page initialization
   */
  validateVersion(workspace) {
    var _a10;
    const versions = (_a10 = this._proxy.versions) == null ? void 0 : _a10.toJSON();
    if (!versions) {
      throw new Error("Invalid workspace data, versions data is missing. Please make sure the data is valid");
    }
    const dataFlavours = Object.keys(versions);
    if (dataFlavours.length === 0) {
      throw new Error("Invalid workspace data, missing versions field. Please make sure the data is valid.");
    }
    dataFlavours.forEach((dataFlavour) => {
      var _a11;
      const dataVersion = versions[dataFlavour];
      const editorVersion = (_a11 = workspace.schema.flavourSchemaMap.get(dataFlavour)) == null ? void 0 : _a11.version;
      if (!editorVersion) {
        throw new Error(`Editor missing ${dataFlavour} flavour. Please make sure this block flavour is registered.`);
      } else if (dataVersion > editorVersion) {
        throw new Error(`Editor doesn't support ${dataFlavour}@${dataVersion}. Please upgrade the editor.`);
      } else if (dataVersion < editorVersion) {
        throw new Error(`In workspace data, the block flavour ${dataFlavour}@${dataVersion} is outdated. Please downgrade the editor or try data migration.`);
      }
    });
  }
  _handlePageMetaEvent() {
    const { pageMetas, _prevPages } = this;
    pageMetas.forEach((pageMeta) => {
      this.doc.getMap("space:" + pageMeta.id);
      if (!_prevPages.has(pageMeta.id)) {
        this.pageMetaAdded.emit(pageMeta.id);
      }
    });
    _prevPages.forEach((prevPageId) => {
      const isRemoved = !pageMetas.find((p) => p.id === prevPageId);
      if (isRemoved) {
        this.pageMetaRemoved.emit(prevPageId);
      }
    });
    _prevPages.clear();
    pageMetas.forEach((page) => _prevPages.add(page.id));
    this.pageMetasUpdated.emit();
  }
  _handleCommonFieldsEvent() {
    this.commonFieldsUpdated.emit();
  }
  _transformObjectToYMap(obj) {
    const yMap = new YMap();
    Object.entries(obj).forEach(([key, value]) => {
      yMap.set(key, value);
    });
    return yMap;
  }
};

// node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion());

// node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob.length) {
      const c2 = glob.charAt(i);
      if ((c2 === "!" || c2 === "^") && i === pos + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c2 === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c2 === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c2 === "[" && !escaping) {
        for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u2;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c2 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
        } else if (c2 === rangeStart) {
          ranges.push(braceEscape(c2));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c2 + "-"));
        i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c2;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c2));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/mjs/unescape.js
var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/mjs/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
var _AST = class _AST {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    var _a10;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a10 = __privateGet(this, _parent)) == null ? void 0 : _a10.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a10;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a10 = __privateGet(this, _parent)) == null ? void 0 : _a10.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
      const pp = __privateGet(p, _parts)[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a10, _b6, _c4;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a10 = __privateGet(this, _parent)) == null ? void 0 : _a10.type) === "!")
      return true;
    if (!((_b6 = __privateGet(this, _parent)) == null ? void 0 : _b6.isEnd()))
      return false;
    if (!this.type)
      return (_c4 = __privateGet(this, _parent)) == null ? void 0 : _c4.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c2.copyIn(p);
    }
    return c2;
  }
  static fromGlob(pattern, options = {}) {
    var _a10;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a10 = _AST, _parseAST, parseAST_fn).call(_a10, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a10;
    const dot = allowDot ?? !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p) => {
        var _a11;
        const [re, _, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a11 = _AST, _parseGlob, parseGlob_fn).call(_a11, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a10 = __privateGet(this, _parent)) == null ? void 0 : _a10.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      __privateSet(this, _parts, [s]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_fillNegs = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n;
  while (n = __privateGet(this, _negs).pop()) {
    if (n.type !== "!")
      continue;
    let p = n;
    let pp = __privateGet(p, _parent);
    while (pp) {
      for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
        for (const part of __privateGet(n, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i]);
        }
      }
      p = pp;
      pp = __privateGet(p, _parent);
    }
  }
  return this;
};
_parseAST = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a10, _b6;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i2 = pos;
    let acc2 = "";
    while (i2 < str.length) {
      const c2 = str.charAt(i2++);
      if (escaping || c2 === "\\") {
        escaping = !escaping;
        acc2 += c2;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c2 === "^" || c2 === "!") {
            braceNeg = true;
          }
        } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc2 += c2;
        continue;
      }
      if (!opt.noext && isExtglobType(c2) && str.charAt(i2) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c2, ast);
        i2 = __privateMethod(_a10 = _AST, _parseAST, parseAST_fn).call(_a10, str, ext2, i2, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c2;
    }
    ast.push(acc2);
    return i2;
  }
  let i = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i < str.length) {
    const c2 = str.charAt(i++);
    if (escaping || c2 === "\\") {
      escaping = !escaping;
      acc += c2;
      continue;
    }
    if (inBrace) {
      if (i === braceStart + 1) {
        if (c2 === "^" || c2 === "!") {
          braceNeg = true;
        }
      } else if (c2 === "]" && !(i === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c2;
      continue;
    } else if (c2 === "[") {
      inBrace = true;
      braceStart = i;
      braceNeg = false;
      acc += c2;
      continue;
    }
    if (isExtglobType(c2) && str.charAt(i) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c2, part);
      part.push(ext2);
      i = __privateMethod(_b6 = _AST, _parseAST, parseAST_fn).call(_b6, str, ext2, i, opt);
      continue;
    }
    if (c2 === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c2 === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i;
    }
    acc += c2;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i;
};
_partsToRegExp = new WeakSet();
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
_parseGlob = new WeakSet();
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i = 0; i < glob.length; i++) {
    const c2 = glob.charAt(i);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c2) ? "\\" : "") + c2;
      continue;
    }
    if (c2 === "\\") {
      if (i === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c2 === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c2 === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c2 === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c2);
  }
  return [re, unescape2(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _parseAST);
__privateAdd(_AST, _parseGlob);
var AST = _AST;

// node_modules/minimatch/dist/mjs/escape.js
var escape2 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/mjs/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a2, b2 = {}) => Object.assign({}, a2, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args2) => console.error(...args2);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b2.length) {
      if (a2[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b2[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a2[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a2[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest ? Object.assign(re, { test: fastTest }) : re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape2;
minimatch.unescape = unescape2;

// node_modules/@blocksuite/store/dist/workspace/schema.js
var SCHEMA_NOT_FOUND_MESSAGE = "Schema not found. The block flavour may not be registered.";
var Schema = class {
  constructor(workspace) {
    this.flavourSchemaMap = /* @__PURE__ */ new Map();
    this.validate = (flavour, parentFlavour, childFlavours) => {
      const schema = this.flavourSchemaMap.get(flavour);
      assertExists(schema, new SchemaValidateError(flavour, SCHEMA_NOT_FOUND_MESSAGE));
      const validateChildren = () => {
        childFlavours == null ? void 0 : childFlavours.forEach((childFlavour) => {
          const childSchema = this.flavourSchemaMap.get(childFlavour);
          assertExists(childSchema, new SchemaValidateError(childFlavour, SCHEMA_NOT_FOUND_MESSAGE));
          this.validateSchema(childSchema, schema);
        });
      };
      if (schema.model.role === "root") {
        if (parentFlavour) {
          throw new SchemaValidateError(schema.model.flavour, "Root block cannot have parent.");
        }
        validateChildren();
        return;
      }
      if (!parentFlavour) {
        throw new SchemaValidateError(schema.model.flavour, "Hub/Content must have parent.");
      }
      const parentSchema = this.flavourSchemaMap.get(parentFlavour);
      assertExists(parentSchema, new SchemaValidateError(parentFlavour, SCHEMA_NOT_FOUND_MESSAGE));
      this.validateSchema(schema, parentSchema);
      validateChildren();
    };
    this.workspace = workspace;
  }
  toJSON() {
    return Object.fromEntries(Array.from(this.flavourSchemaMap.values()).map((schema) => [
      schema.model.flavour,
      {
        role: schema.model.role,
        parent: schema.model.parent,
        children: schema.model.children
      }
    ]));
  }
  validateSchema(child, parent) {
    this._validateRole(child, parent);
    const relationCheckSuccess = this._validateParent(child, parent);
    if (!relationCheckSuccess) {
      throw new SchemaValidateError(child.model.flavour, `Block cannot have parent: ${parent.model.flavour}.`);
    }
  }
  _validateRole(child, parent) {
    const childRole = child.model.role;
    const parentRole = parent.model.role;
    const childFlavour = child.model.flavour;
    const parentFlavour = parent.model.flavour;
    if (childRole === "root") {
      throw new SchemaValidateError(childFlavour, `Root block cannot have parent: ${parentFlavour}.`);
    }
    if (childRole === "hub" && parentRole === "content") {
      throw new SchemaValidateError(childFlavour, `Hub block cannot be child of content block: ${parentFlavour}.`);
    }
    if (childRole === "content" && parentRole === "root") {
      throw new SchemaValidateError(childFlavour, `Content block can only be child of hub block or itself. But get: ${parentFlavour}.`);
    }
  }
  _matchFlavour(childFlavour, parentFlavour) {
    return minimatch(childFlavour, parentFlavour) || minimatch(parentFlavour, childFlavour);
  }
  _validateParent(child, parent) {
    const _childFlavour = child.model.flavour;
    const _parentFlavour = parent.model.flavour;
    const childValidFlavours = child.model.parent || ["*"];
    const parentValidFlavours = parent.model.children || ["*"];
    return parentValidFlavours.some((parentValidFlavour) => {
      return childValidFlavours.some((childValidFlavour) => {
        if (parentValidFlavour === "*" && childValidFlavour === "*") {
          return true;
        }
        if (parentValidFlavour === "*") {
          return this._matchFlavour(childValidFlavour, _parentFlavour);
        }
        if (childValidFlavour === "*") {
          return this._matchFlavour(_childFlavour, parentValidFlavour);
        }
        return this._matchFlavour(_childFlavour, parentValidFlavour) && this._matchFlavour(childValidFlavour, _parentFlavour);
      });
    });
  }
};

// node_modules/@blocksuite/store/dist/workspace/workspace.js
var Workspace = class {
  constructor({ experimentalInlineSuggestionProvider, ...storeOptions }) {
    this._storages = [];
    this.slots = {
      pagesUpdated: new Slot(),
      pageAdded: new Slot(),
      pageRemoved: new Slot(),
      // call this when a blob is updated, deleted or created
      //  workspace will update re-fetch the blob and update the page
      blobUpdate: new Slot()
    };
    this.inlineSuggestionProvider = experimentalInlineSuggestionProvider;
    this._schema = new Schema(this);
    this._store = new Store(storeOptions);
    this._storages = (storeOptions.blobStorages ?? [createMemoryStorage]).map((fn) => fn(storeOptions.id));
    this._blobStorage = {
      get: async (id2) => {
        let found = false;
        let count = 0;
        return new Promise((res) => {
          this._storages.forEach((storage) => storage.crud.get(id2).then((result) => {
            if (result && !found) {
              found = true;
              res(result);
            }
            if (++count === this._storages.length && !found) {
              res(null);
            }
          }).catch((e) => {
            console.error(e);
            if (++count === this._storages.length && !found) {
              res(null);
            }
          }));
        });
      },
      set: async (value) => {
        const key = await sha(await value.arrayBuffer());
        await Promise.all(this._storages.map((s) => s.crud.set(key, value)));
        return key;
      },
      delete: async (key) => {
        await Promise.all(this._storages.map((s) => s.crud.delete(key)));
      },
      list: async () => {
        const keys2 = /* @__PURE__ */ new Set();
        await Promise.all(this._storages.map(async (s) => {
          const list = await s.crud.list();
          list.forEach((key) => keys2.add(key));
        }));
        return Array.from(keys2);
      }
    };
    this.meta = new WorkspaceMeta("space:meta", this.doc, this.awarenessStore);
    this._bindPageMetaEvents();
    const blockIndexer = new BlockIndexer(this.doc, { slots: this.slots });
    const backlinkIndexer = new BacklinkIndexer(blockIndexer);
    this.indexer = {
      search: new SearchIndexer(this.doc),
      backlink: backlinkIndexer
    };
    this.slots.pageAdded.on((id2) => {
      queueMicrotask(() => this.indexer.search.onPageCreated(id2));
    });
  }
  get id() {
    return this._store.id;
  }
  get isEmpty() {
    if (this.doc.store.clients.size === 0)
      return true;
    let flag = false;
    if (this.doc.store.clients.size === 1) {
      const items = [...this.doc.store.clients.values()][0];
      if (items.length <= 1) {
        flag = true;
      }
    }
    return flag;
  }
  get awarenessStore() {
    return this._store.awarenessStore;
  }
  get providers() {
    return this._store.providers;
  }
  get blobs() {
    return this._blobStorage;
  }
  get _pages() {
    return this._store.spaces;
  }
  getPageNameList() {
    return [...this._pages.keys()];
  }
  get doc() {
    return this._store.doc;
  }
  get idGenerator() {
    return this._store.idGenerator;
  }
  get schema() {
    return this._schema;
  }
  register(blockSchema) {
    blockSchema.forEach((schema) => {
      BlockSchema.parse(schema);
      this.schema.flavourSchemaMap.set(schema.model.flavour, schema);
    });
    return this;
  }
  _hasPage(pageId) {
    return this._pages.has(`space:${pageId}`);
  }
  getPage(pageId) {
    const prefixedPageId = pageId.startsWith("space:") ? pageId : `space:${pageId}`;
    return this._pages.get(prefixedPageId) ?? null;
  }
  _bindPageMetaEvents() {
    this.meta.pageMetaAdded.on((pageId) => {
      const page = new Page({
        id: pageId,
        workspace: this,
        doc: this.doc,
        awarenessStore: this.awarenessStore,
        idGenerator: this._store.idGenerator
      });
      this._store.addSpace(page);
      page.trySyncFromExistingDoc();
    });
    this.meta.pageMetasUpdated.on(() => this.slots.pagesUpdated.emit());
    this.meta.pageMetaRemoved.on((id2) => {
      const page = this.getPage(id2);
      this._store.removeSpace(page);
      this.slots.pageRemoved.emit(id2);
    });
  }
  /**
   * By default, only an empty page will be created.
   * If the `init` parameter is passed, a `surface`, `frame`, and `paragraph` block
   * will be created in the page simultaneously.
   */
  createPage(options = {}) {
    if (typeof options === "string") {
      options = { id: options };
      console.warn("`createPage(pageId)` is deprecated, use `createPage()` directly or `createPage({ id: pageId })` instead");
      console.warn("More details see https://github.com/toeverything/blocksuite/pull/2272");
    }
    const { id: pageId = this.idGenerator(), init } = options;
    if (this._hasPage(pageId)) {
      throw new Error("page already exists");
    }
    this.meta.addPageMeta({
      id: pageId,
      title: "",
      createDate: +/* @__PURE__ */ new Date(),
      subpageIds: []
    });
    const page = this.getPage(pageId);
    let pageBlockId = pageId;
    if (init) {
      pageBlockId = page.addBlock("affine:page", typeof init === "boolean" ? void 0 : {
        title: new page.Text(init.title)
      });
      page.addBlock("affine:surface", {}, pageBlockId);
      const frameId = page.addBlock("affine:frame", {}, pageBlockId);
      page.addBlock("affine:paragraph", {}, frameId);
    }
    return page;
  }
  /** Update page meta state. Note that this intentionally does not mutate page state. */
  setPageMeta(pageId, props) {
    this.meta.setPageMeta(pageId, props);
  }
  /**
   * @deprecated
   */
  shiftPage(pageId, newIndex) {
    this.meta.shiftPageMeta(pageId, newIndex);
  }
  removePage(pageId) {
    const pageMeta = this.meta.getPageMeta(pageId);
    assertExists(pageMeta);
    if (pageMeta.subpageIds.length) {
      pageMeta.subpageIds.forEach((subpageId) => {
        if (subpageId === pageId) {
          console.error("Unexpected subpage found when remove page! A page cannot be its own subpage", pageMeta);
          return;
        }
        this.removePage(subpageId);
      });
    }
    const page = this.getPage(pageId);
    if (!page)
      return;
    page.dispose();
    this.indexer.backlink.removeSubpageNode(this, pageId);
    this.meta.removePageMeta(pageId);
    this._store.removeSpace(page);
  }
  search(query2) {
    return this.indexer.search.search(query2);
  }
  /**
   * @internal Only for testing
   */
  exportYDoc() {
    const binary = encodeStateAsUpdate(this.doc);
    const file = new Blob([binary], { type: "application/octet-stream" });
    const fileUrl = URL.createObjectURL(file);
    const link = document.createElement("a");
    link.href = fileUrl;
    link.download = "workspace.ydoc";
    link.click();
    URL.revokeObjectURL(fileUrl);
  }
  /** @internal Only for testing */
  async importYDoc() {
    return new Promise((resolve2, reject2) => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".ydoc";
      input.multiple = false;
      input.onchange = async () => {
        var _a10;
        const file = (_a10 = input.files) == null ? void 0 : _a10.item(0);
        if (!file) {
          return reject2();
        }
        const buffer = await file.arrayBuffer();
        applyUpdate(this.doc, new Uint8Array(buffer));
        resolve2();
      };
      input.onerror = reject2;
      input.click();
    });
  }
  /**
   * @internal
   * Import an object expression of a page.
   * Specify the page you want to update by passing the `pageId` parameter and it will
   * create a new page if it does not exist.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async importPageSnapshot(json, pageId) {
    const unprefix = (str) => str.replace("sys:", "").replace("prop:", "").replace("space:", "");
    const visited = /* @__PURE__ */ new Set();
    let page = this.getPage(pageId);
    if (!page) {
      page = this.createPage({ id: pageId });
    }
    const sanitize = async (props) => {
      const result = {};
      if (props["sys:flavour"] === "affine:surface" && props["elements"]) {
        for (const [, element2] of Object.entries(
          props["elements"]
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        )) {
          if (element2["type"] === "text") {
            const yText = new YText();
            yText.applyDelta(element2["text"]);
            element2["text"] = yText;
          }
        }
      }
      if (props["sys:flavour"] === "affine:embed") {
        let resp;
        try {
          resp = await fetch(props["prop:sourceId"], {
            cache: "no-cache",
            mode: "cors",
            headers: {
              Origin: window.location.origin
            }
          });
        } catch (error) {
          throw new Error(`Failed to fetch embed source. error: ${error}`);
        }
        const imgBlob = await resp.blob();
        if (!imgBlob.type.startsWith("image/")) {
          throw new Error("Embed source is not an image");
        }
        assertExists(page);
        const storage = page.blobs;
        assertExists(storage);
        const id2 = await storage.set(imgBlob);
        props["prop:sourceId"] = id2;
      }
      for (const key of Object.keys(props)) {
        if (key === "sys:children" || key === "sys:flavour") {
          continue;
        }
        result[unprefix(key)] = props[key];
        if (key === "prop:text" || key === "prop:title") {
          const yText = new YText();
          yText.applyDelta(props[key]);
          result[unprefix(key)] = new Text2(yText);
        }
      }
      return result;
    };
    const addBlockByProps = async (page2, props, parent) => {
      if (visited.has(props["sys:id"]))
        return;
      const sanitizedProps = await sanitize(props);
      page2.addBlock(props["sys:flavour"], sanitizedProps, parent);
      for (const id2 of props["sys:children"]) {
        addBlockByProps(page2, json[id2], props["sys:id"]);
        visited.add(id2);
      }
    };
    for (const block of Object.values(json)) {
      assertExists(json);
      await addBlockByProps(page, block, null);
    }
  }
  /** @internal Only for testing */
  exportSnapshot() {
    return serializeYDoc(this.doc);
  }
  /** @internal Only for testing */
  exportJSX(blockId, pageId = ((_a10) => (_a10 = this.meta.pageMetas.at(0)) == null ? void 0 : _a10.id)()) {
    assertExists(pageId);
    return this._store.exportJSX(pageId, blockId);
  }
};
Workspace.Y = yjs_exports;

// node_modules/@blocksuite/store/dist/utils/formatter.js
function isBaseBlockModel(a2) {
  return a2 instanceof BaseBlockModel;
}
function initCustomFormatter() {
  if (typeof window === "undefined") {
    return;
  }
  const bannerStyle = {
    style: "color: #eee; background: #3F6FDB; margin-right: 5px; padding: 2px; border-radius: 4px"
  };
  const typeStyle = {
    style: "color: #eee; background: #DB6D56; margin-right: 5px; padding: 2px; border-radius: 4px"
  };
  const formatter = {
    header(obj, config = { expand: false }) {
      var _a10;
      if (!isBaseBlockModel(obj) || config.expand) {
        return null;
      }
      return [
        "div",
        {},
        ["span", bannerStyle, "BaseBlockModel"],
        ["span", typeStyle, obj.flavour],
        (_a10 = obj.text) == null ? void 0 : _a10.toString()
      ];
    },
    hasBody(obj) {
      return true;
    },
    body(obj) {
      return ["object", { object: obj, config: { expand: true } }];
    }
  };
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
initCustomFormatter();

// node_modules/@blocksuite/store/dist/index.js
var env = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : (
  // @ts-ignore
  typeof global !== "undefined" ? (
    // @ts-ignore
    global
  ) : {}
);
var importIdentifier2 = "__ $BLOCKSUITE_STORE$ __";
if (env[importIdentifier2] === true) {
  console.error("@blocksuite/store was already imported. This breaks constructor checks and will lead to issues!");
}
env[importIdentifier2] = true;

// node_modules/@blocksuite/blocks/dist/__internal__/utils/check-line.js
function findTextNode(node) {
  if (node.nodeType === Node.TEXT_NODE) {
    return node;
  }
  for (let i = 0; i < node.childNodes.length; i++) {
    const textNode = findTextNode(node.childNodes[i]);
    if (textNode) {
      return textNode;
    }
  }
  return null;
}
function findNextTextNode(node, checkWalkBoundary = (node2) => node2 === document.body) {
  while (node.parentNode) {
    const parentNode = node.parentNode;
    if (!parentNode) {
      console.warn("Failed to find text node from node! no parent node", node);
      return null;
    }
    const nodeIdx = Array.from(parentNode.childNodes).indexOf(node);
    if (nodeIdx === -1) {
      console.warn("Failed to find text node from node! no node index", node);
      return null;
    }
    for (let i = nodeIdx + 1; i < parentNode.childNodes.length; i++) {
      const textNode = findTextNode(parentNode.childNodes[i]);
      if (textNode) {
        return textNode;
      }
    }
    if (checkWalkBoundary(parentNode)) {
      return null;
    }
    node = parentNode;
  }
  return null;
}
function shiftRange(range) {
  if (!range.collapsed) {
    throw new Error("Failed to shift range! expected a collapsed range");
  }
  const startContainer = range.startContainer;
  const isTextLikeNode = startContainer.nodeType === Node.TEXT_NODE || startContainer.nodeType === Node.COMMENT_NODE || startContainer.nodeType === Node.CDATA_SECTION_NODE;
  if (!isTextLikeNode) {
    return null;
  }
  const textContent = startContainer.textContent;
  if (typeof textContent !== "string") {
    throw new Error("Failed to shift range! unexpected startContainer");
  }
  const maxOffset = textContent.length;
  if (maxOffset > range.startOffset) {
    const nextRange2 = range.cloneRange();
    nextRange2.setStart(range.startContainer, range.startOffset + 1);
    nextRange2.setEnd(range.startContainer, range.startOffset + 1);
    return nextRange2;
  }
  const nextTextNode = findNextTextNode(startContainer, (node) => (
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/contentEditable
    node instanceof HTMLElement && node.contentEditable === "true"
  ));
  if (!nextTextNode) {
    return null;
  }
  const nextRange = range.cloneRange();
  nextRange.setStart(nextTextNode, 0);
  nextRange.setEnd(nextTextNode, 0);
  return nextRange;
}
function isAtLineEdge(range) {
  if (!range.collapsed) {
    return false;
  }
  const nextRange = shiftRange(range);
  if (!nextRange) {
    return false;
  }
  const nextRangeRect = nextRange.getBoundingClientRect();
  const noLineEdge = range.getBoundingClientRect().top === nextRangeRect.top;
  if (noLineEdge) {
    return false;
  }
  return nextRange;
}
function checkFirstLine(range, container) {
  if (!range.collapsed) {
    throw new Error("Failed to determine if the caret is at the first line! expected a collapsed range but got" + range);
  }
  if (!container.contains(range.commonAncestorContainer)) {
    throw new Error("Failed to determine if the caret is at the first line! expected the range to be inside the container but got" + range + " and " + container);
  }
  const containerRect = container.getBoundingClientRect();
  const rangeRect = range.getBoundingClientRect();
  if (rangeRect.left === 0 && rangeRect.top === 0) {
    return true;
  }
  const lineHeight = rangeRect.height;
  const isFirstLine = containerRect.top > rangeRect.top - lineHeight / 2 && !isAtLineEdge(range);
  return isFirstLine;
}
function checkLastLine(range, container) {
  if (!range.collapsed) {
    throw new Error("Failed to determine if the caret is at the last line! expected a collapsed range but got" + range);
  }
  if (!container.contains(range.commonAncestorContainer)) {
    throw new Error("Failed to determine if the caret is at the first line! expected the range to be inside the container but got" + range + " and " + container);
  }
  const containerRect = container.getBoundingClientRect();
  const rangeRect = range.getBoundingClientRect();
  if (rangeRect.left === 0 && rangeRect.bottom === 0) {
    return true;
  }
  const lineHeight = rangeRect.height;
  const isLastLineWithoutEdge = rangeRect.bottom + lineHeight / 2 > containerRect.bottom;
  if (isLastLineWithoutEdge) {
    return true;
  }
  const atLineEdgeRange = isAtLineEdge(range);
  if (!atLineEdgeRange) {
    return false;
  }
  const nextRangeRect = atLineEdgeRange.getBoundingClientRect();
  const nextLineHeight = nextRangeRect.height;
  return nextRangeRect.bottom + nextLineHeight / 2 > containerRect.bottom;
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/active-editor-manager.js
var ActiveEditorManager = class {
  constructor() {
    this.activeSlot = new Slot();
    this.clearActive = () => {
      if (this.activeElement != void 0) {
        this.activeElement = void 0;
        this.activeSlot.emit(void 0);
      }
    };
  }
  isActive(ele) {
    if (!this.activeElement) {
      return false;
    }
    return this.activeElement.contains(ele);
  }
  setActive(ele) {
    if (ele !== this.activeElement) {
      this.activeElement = ele;
      this.activeSlot.emit(ele);
    }
  }
  setIfNoActive(ele) {
    if (!this.activeElement) {
      this.setActive(ele);
    }
  }
  getActiveEditor() {
    return this.activeElement;
  }
};
var activeEditorManager = new ActiveEditorManager();

// node_modules/@blocksuite/blocks/dist/__internal__/utils/types.js
var BrushSize;
(function(BrushSize2) {
  BrushSize2[BrushSize2["Thin"] = 4] = "Thin";
  BrushSize2[BrushSize2["Thick"] = 10] = "Thick";
})(BrushSize || (BrushSize = {}));
var AbstractSelectionManager = class {
  constructor(container, dispatcher) {
    this._disposables = new DisposableGroup();
    this.container = container;
    this._dispatcher = dispatcher;
  }
  get page() {
    return this.container.page;
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/utils/std.js
function supportsChildren(model) {
  if (matchFlavours(model, [
    // 'affine:database',
    "affine:embed",
    "affine:divider",
    "affine:code"
  ])) {
    return false;
  }
  if (matchFlavours(model, ["affine:paragraph"]) && ["h1", "h2", "h3", "h4", "h5", "h6", "quote"].includes(model.type ?? "")) {
    return false;
  }
  return true;
}
function isEmpty2(model) {
  var _a10;
  if (model.children.length !== 0) {
    const found = model.children.find((c2) => !isEmpty2(c2));
    return !found;
  }
  return !((_a10 = model.text) == null ? void 0 : _a10.length) && !model.sourceId && model.flavour !== "affine:code";
}
function almostEqual(a2, b2, epsilon = 1e-4) {
  return Math.abs(a2 - b2) < epsilon;
}
function createEvent(type, detail) {
  return new CustomEvent(type, { detail });
}
function noop() {
  return;
}
function throttle(fn, limit, { leading = true, trailing = true } = {}) {
  let timer = null;
  let lastArgs = null;
  const setTimer = () => {
    if (lastArgs && trailing) {
      fn(...lastArgs);
      lastArgs = null;
      timer = setTimeout(setTimer, limit);
    } else {
      timer = null;
    }
  };
  return function(...args2) {
    if (timer) {
      lastArgs = args2;
      return;
    }
    if (leading) {
      fn.apply(this, args2);
    }
    timer = setTimeout(setTimer, limit);
  };
}
var debounce = (fn, limit, { leading = true, trailing = true } = {}) => {
  let timer = null;
  let lastArgs = null;
  const setTimer = () => {
    if (lastArgs && trailing) {
      fn(...lastArgs);
      lastArgs = null;
      timer = setTimeout(setTimer, limit);
    } else {
      timer = null;
    }
  };
  return function(...args2) {
    if (timer) {
      lastArgs = args2;
      clearTimeout(timer);
    }
    if (leading && !timer) {
      fn(...args2);
    }
    timer = setTimeout(setTimer, limit);
  };
};
var clamp = (value, min2, max2) => {
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
};
function countBy(items, key) {
  const count = {};
  items.forEach((item) => {
    const k = key(item);
    if (!count[k]) {
      count[k] = 0;
    }
    count[k] += 1;
  });
  return count;
}
function maxBy(items, value) {
  if (!items.length) {
    return null;
  }
  let maxItem = items[0];
  let max2 = value(maxItem);
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    const v2 = value(item);
    if (v2 > max2) {
      max2 = v2;
      maxItem = item;
    }
  }
  return maxItem;
}
function isControlledKeyboardEvent(e) {
  return e.ctrlKey || e.metaKey || e.altKey;
}
function isPrintableKeyEvent(event) {
  return event.key.length === 1 && !isControlledKeyboardEvent(event);
}
function atLeastNMatches(arr, matchFn, n) {
  let count = 0;
  for (let i = 0; i < arr.length; i++) {
    if (matchFn(arr[i])) {
      count++;
      if (count >= n) {
        return true;
      }
    }
  }
  return false;
}
function groupBy(arr, key) {
  const result = {};
  for (const item of arr) {
    const groupKey = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      typeof key === "function" ? key(item) : item[key]
    );
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    result[groupKey].push(item);
  }
  return result;
}
function escapeRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function isFuzzyMatch(name, query2) {
  const pureName = name.trim().toLowerCase().split("").filter((char) => char !== " ").join("");
  const regex = new RegExp(query2.split("").filter((char) => char !== " ").map((item) => `${escapeRegExp(item)}.*`).join(""), "i");
  return regex.test(pureName);
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/rect.js
var Point = class _Point {
  constructor(x2 = 0, y = 0) {
    this.x = x2;
    this.y = y;
  }
  static from(point, y) {
    if (Array.isArray(point)) {
      return new _Point(point[0], point[1]);
    }
    if (typeof point === "number") {
      return new _Point(point, y ?? point);
    }
    return new _Point(point.x, point.y);
  }
  set(x2, y) {
    this.x = x2;
    this.y = y;
  }
  equals({ x: x2, y }) {
    return this.x === x2 && this.y === y;
  }
  add(point) {
    return new _Point(this.x + point.x, this.y + point.y);
  }
  scale(factor) {
    return new _Point(this.x * factor, this.y * factor);
  }
  subtract(point) {
    return new _Point(this.x - point.x, this.y - point.y);
  }
  /**
   * Returns a copy of the point.
   */
  clone() {
    return new _Point(this.x, this.y);
  }
  cross(point) {
    return this.x * point.y - this.y * point.x;
  }
  lerp(point, t2) {
    return new _Point(this.x + (point.x - this.x) * t2, this.y + (point.y - this.y) * t2);
  }
  toArray() {
    return [this.x, this.y];
  }
  /**
   * Compares and returns the minimum of two points.
   */
  static min(a2, b2) {
    return new _Point(Math.min(a2.x, b2.x), Math.min(a2.y, b2.y));
  }
  /**
   * Compares and returns the maximum of two points.
   */
  static max(a2, b2) {
    return new _Point(Math.max(a2.x, b2.x), Math.max(a2.y, b2.y));
  }
  /**
   * Restrict a value to a certain interval.
   */
  static clamp(p, min2, max2) {
    return new _Point(clamp(p.x, min2.x, max2.x), clamp(p.y, min2.y, max2.y));
  }
};
var Rect = class _Rect {
  constructor(left, top, right, bottom) {
    const [minX, maxX] = left <= right ? [left, right] : [right, left];
    const [minY, maxY] = top <= bottom ? [top, bottom] : [bottom, top];
    this.min = new Point(minX, minY);
    this.max = new Point(maxX, maxY);
  }
  get width() {
    return this.max.x - this.min.x;
  }
  set width(w) {
    this.max.x = this.min.x + w;
  }
  get height() {
    return this.max.y - this.min.y;
  }
  set height(h) {
    this.max.y = this.min.y + h;
  }
  get left() {
    return this.min.x;
  }
  set left(x2) {
    this.min.x = x2;
  }
  get top() {
    return this.min.y;
  }
  set top(y) {
    this.min.y = y;
  }
  get right() {
    return this.max.x;
  }
  set right(x2) {
    this.max.x = x2;
  }
  get bottom() {
    return this.max.y;
  }
  set bottom(y) {
    this.max.y = y;
  }
  center() {
    return new Point((this.left + this.right) / 2, (this.top + this.bottom) / 2);
  }
  extend_with(point) {
    this.min = Point.min(this.min, point);
    this.max = Point.max(this.max, point);
  }
  extend_with_x(x2) {
    this.min.x = Math.min(this.min.x, x2);
    this.max.x = Math.max(this.max.x, x2);
  }
  extend_with_y(y) {
    this.min.y = Math.min(this.min.y, y);
    this.max.y = Math.max(this.max.y, y);
  }
  equals({ min: min2, max: max2 }) {
    return this.min.equals(min2) && this.max.equals(max2);
  }
  contains({ min: min2, max: max2 }) {
    return this.isPointIn(min2) && this.isPointIn(max2);
  }
  intersects({ left, top, right, bottom }) {
    return this.left <= right && left <= this.right && this.top <= bottom && top <= this.bottom;
  }
  isPointIn({ x: x2, y }) {
    return this.left <= x2 && x2 <= this.right && this.top <= y && y <= this.bottom;
  }
  isPointDown({ x: x2, y }) {
    return this.bottom < y && this.left <= x2 && this.right >= x2;
  }
  isPointUp({ x: x2, y }) {
    return y < this.top && this.left <= x2 && this.right >= x2;
  }
  isPointLeft({ x: x2, y }) {
    return x2 < this.left && this.top <= y && this.bottom >= y;
  }
  isPointRight({ x: x2, y }) {
    return x2 > this.right && this.top <= y && this.bottom >= y;
  }
  intersect(other) {
    return _Rect.fromPoints(Point.max(this.min, other.min), Point.min(this.max, other.max));
  }
  clamp(p) {
    return Point.clamp(p, this.min, this.max);
  }
  clone() {
    const { left, top, right, bottom } = this;
    return new _Rect(left, top, right, bottom);
  }
  toDOMRect() {
    const { left, top, width, height } = this;
    return new DOMRect(left, top, width, height);
  }
  static fromLTRB(left, top, right, bottom) {
    return new _Rect(left, top, right, bottom);
  }
  static fromLWTH(left, width, top, height) {
    return new _Rect(left, top, left + width, top + height);
  }
  static fromXY(x2, y) {
    return _Rect.fromPoint(new Point(x2, y));
  }
  static fromPoint(point) {
    return _Rect.fromPoints(point.clone(), point);
  }
  static fromPoints(start, end) {
    const width = Math.abs(end.x - start.x);
    const height = Math.abs(end.y - start.y);
    const left = Math.min(end.x, start.x);
    const top = Math.min(end.y, start.y);
    return _Rect.fromLWTH(left, width, top, height);
  }
  static fromDOMRect({ left, top, right, bottom }) {
    return _Rect.fromLTRB(left, top, right, bottom);
  }
  static fromDOM(dom) {
    return _Rect.fromDOMRect(dom.getBoundingClientRect());
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/utils/selection.js
var selection_exports = {};
__export(selection_exports, {
  clearSelection: () => clearSelection,
  focusBlockByModel: () => focusBlockByModel,
  focusNextBlock: () => focusNextBlock,
  focusPreviousBlock: () => focusPreviousBlock,
  focusRichText: () => focusRichText,
  focusTitle: () => focusTitle,
  getClosestEditor: () => getClosestEditor,
  getClosestFrame: () => getClosestFrame,
  getCurrentNativeRange: () => getCurrentNativeRange,
  getFirstTextNode: () => getFirstTextNode,
  getHorizontalClosestElement: () => getHorizontalClosestElement,
  getLastTextNode: () => getLastTextNode,
  getSplicedTitle: () => getSplicedTitle,
  handleNativeRangeAtPoint: () => handleNativeRangeAtPoint,
  handleNativeRangeClick: () => handleNativeRangeClick,
  handleNativeRangeDblClick: () => handleNativeRangeDblClick,
  handleNativeRangeDragMove: () => handleNativeRangeDragMove,
  handleNativeRangeTripleClick: () => handleNativeRangeTripleClick,
  hasNativeSelection: () => hasNativeSelection,
  isBlankArea: () => isBlankArea,
  isCollapsedNativeSelection: () => isCollapsedNativeSelection,
  isDatabase: () => isDatabase,
  isEmbed: () => isEmbed,
  isMultiBlockRange: () => isMultiBlockRange,
  isMultiLineRange: () => isMultiLineRange,
  isRangeNativeSelection: () => isRangeNativeSelection,
  leftFirstSearchLeafNodes: () => leftFirstSearchLeafNodes,
  resetNativeSelection: () => resetNativeSelection
});

// node_modules/@lit/reactive-element/development/decorators/custom-element.js
var legacyCustomElement = (tagName, clazz) => {
  customElements.define(tagName, clazz);
  return clazz;
};
var standardCustomElement = (tagName, descriptor) => {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    // This callback is called once the class is otherwise fully defined
    finisher(clazz) {
      customElements.define(tagName, clazz);
    }
  };
};
var customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);

// node_modules/@lit/reactive-element/development/decorators/property.js
var standardProperty = (options, element2) => {
  if (element2.kind === "method" && element2.descriptor && !("value" in element2.descriptor)) {
    return {
      ...element2,
      finisher(clazz) {
        clazz.createProperty(element2.key, options);
      }
    };
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      // store the original key so subsequent decorators have access to it.
      originalKey: element2.key,
      // When @babel/plugin-proposal-decorators implements initializers,
      // do this instead of the initializer below. See:
      // https://github.com/babel/babel/issues/9260 extras: [
      //   {
      //     kind: 'initializer',
      //     placement: 'own',
      //     initializer: descriptor.initializer,
      //   }
      // ],
      initializer() {
        if (typeof element2.initializer === "function") {
          this[element2.key] = element2.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element2.key, options);
      }
    };
  }
};
var legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
function property(options) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}

// node_modules/@lit/reactive-element/development/decorators/state.js
function state(options) {
  return property({
    ...options,
    state: true
  });
}

// node_modules/@lit/reactive-element/development/decorators/base.js
var decorateProperty = ({ finisher, descriptor }) => (protoOrDescriptor, name) => {
  var _a10;
  if (name !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor !== void 0) {
      Object.defineProperty(protoOrDescriptor, name, descriptor(name));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
  } else {
    const key = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (_a10 = protoOrDescriptor.originalKey) !== null && _a10 !== void 0 ? _a10 : protoOrDescriptor.key
    );
    const info = descriptor != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor(protoOrDescriptor.key)
    } : { ...protoOrDescriptor, key };
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};

// node_modules/@lit/reactive-element/development/decorators/query.js
function query(selector, cache) {
  return decorateProperty({
    descriptor: (name) => {
      const descriptor = {
        get() {
          var _a10, _b6;
          return (_b6 = (_a10 = this.renderRoot) === null || _a10 === void 0 ? void 0 : _a10.querySelector(selector)) !== null && _b6 !== void 0 ? _b6 : null;
        },
        enumerable: true,
        configurable: true
      };
      if (cache) {
        const key = typeof name === "symbol" ? Symbol() : `__${name}`;
        descriptor.get = function() {
          var _a10, _b6;
          if (this[key] === void 0) {
            this[key] = (_b6 = (_a10 = this.renderRoot) === null || _a10 === void 0 ? void 0 : _a10.querySelector(selector)) !== null && _b6 !== void 0 ? _b6 : null;
          }
          return this[key];
        };
      }
      return descriptor;
    }
  });
}

// node_modules/@lit/reactive-element/development/decorators/query-all.js
function queryAll(selector) {
  return decorateProperty({
    descriptor: (_name) => ({
      get() {
        var _a10, _b6;
        return (_b6 = (_a10 = this.renderRoot) === null || _a10 === void 0 ? void 0 : _a10.querySelectorAll(selector)) !== null && _b6 !== void 0 ? _b6 : [];
      },
      enumerable: true,
      configurable: true
    })
  });
}

// node_modules/@lit/reactive-element/development/decorators/query-assigned-elements.js
var _a8;
var NODE_MODE4 = false;
var global5 = NODE_MODE4 ? globalThis : window;
var slotAssignedElements = ((_a8 = global5.HTMLSlotElement) === null || _a8 === void 0 ? void 0 : _a8.prototype.assignedElements) != null ? (slot, opts) => slot.assignedElements(opts) : (slot, opts) => slot.assignedNodes(opts).filter((node) => node.nodeType === Node.ELEMENT_NODE);

// node_modules/@blocksuite/virgo/dist/consts.js
var ZERO_WIDTH_SPACE = "​";
var ZERO_WIDTH_NON_JOINER = "‌";

// node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
var directive = (c2) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c2,
  values
});
var Directive = class {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
};

// node_modules/lit-html/development/directives/style-map.js
var important = "important";
var importantFlag = " !" + important;
var flagTrim = 0 - importantFlag.length;
var StyleMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a10;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "style" || ((_a10 = partInfo.strings) === null || _a10 === void 0 ? void 0 : _a10.length) > 2) {
      throw new Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
    }
  }
  render(styleInfo) {
    return Object.keys(styleInfo).reduce((style, prop) => {
      const value = styleInfo[prop];
      if (value == null) {
        return style;
      }
      prop = prop.includes("-") ? prop : prop.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase();
      return style + `${prop}:${value};`;
    }, "");
  }
  update(part, [styleInfo]) {
    const { style } = part.element;
    if (this._previousStyleProperties === void 0) {
      this._previousStyleProperties = /* @__PURE__ */ new Set();
      for (const name in styleInfo) {
        this._previousStyleProperties.add(name);
      }
      return this.render(styleInfo);
    }
    this._previousStyleProperties.forEach((name) => {
      if (styleInfo[name] == null) {
        this._previousStyleProperties.delete(name);
        if (name.includes("-")) {
          style.removeProperty(name);
        } else {
          style[name] = "";
        }
      }
    });
    for (const name in styleInfo) {
      const value = styleInfo[name];
      if (value != null) {
        this._previousStyleProperties.add(name);
        const isImportant = typeof value === "string" && value.endsWith(importantFlag);
        if (name.includes("-") || isImportant) {
          style.setProperty(name, isImportant ? value.slice(0, flagTrim) : value, isImportant ? important : "");
        } else {
          style[name] = value;
        }
      }
    }
    return noChange;
  }
};
var styleMap = directive(StyleMapDirective);

// node_modules/@blocksuite/virgo/dist/utils/attribute-renderer.js
function virgoTextStyles(props) {
  let textDecorations = "";
  if (props.underline) {
    textDecorations += "underline";
  }
  if (props.strike) {
    textDecorations += " line-through";
  }
  let inlineCodeStyle = {};
  if (props.code) {
    inlineCodeStyle = {
      "font-family": '"SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace',
      "line-height": "normal",
      background: "rgba(135,131,120,0.15)",
      color: "#EB5757",
      "border-radius": "3px",
      "font-size": "85%",
      padding: "0.2em 0.4em"
    };
  }
  return styleMap({
    "word-wrap": "break-word",
    "white-space": "break-spaces",
    "font-weight": props.bold ? "bold" : "normal",
    "font-style": props.italic ? "italic" : "normal",
    "text-decoration": textDecorations.length > 0 ? textDecorations : "none",
    ...inlineCodeStyle
  });
}
var getDefaultAttributeRenderer = () => (delta) => {
  const style = delta.attributes ? virgoTextStyles(delta.attributes) : styleMap({});
  return html`<span style=${style}
      ><v-text .str=${delta.insert}></v-text
    ></span>`;
};

// node_modules/@blocksuite/virgo/dist/components/virgo-element.js
var __decorate3 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var VirgoElement = class VirgoElement2 extends LitElement {
  constructor() {
    super(...arguments);
    this.delta = {
      insert: ZERO_WIDTH_SPACE
    };
    this.attributeRenderer = getDefaultAttributeRenderer();
  }
  render() {
    return html`<span data-virgo-element="true"
      >${this.attributeRenderer(this.delta)}</span
    >`;
  }
  createRenderRoot() {
    return this;
  }
};
__decorate3([
  property({ type: Object })
], VirgoElement.prototype, "delta", void 0);
__decorate3([
  property({ type: Function, attribute: false })
], VirgoElement.prototype, "attributeRenderer", void 0);
VirgoElement = __decorate3([
  customElement("v-element")
], VirgoElement);

// node_modules/@blocksuite/virgo/dist/components/virgo-line.js
var __decorate4 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var VirgoLine = class VirgoLine2 extends LitElement {
  constructor() {
    super(...arguments);
    this.elements = [];
  }
  get vElements() {
    return Array.from(this.querySelectorAll("v-element"));
  }
  get textLength() {
    return this.vElements.reduce((acc, el) => acc + el.delta.insert.length, 0);
  }
  get textContent() {
    return this.vElements.reduce((acc, el) => acc + el.delta.insert, "");
  }
  async getUpdateComplete() {
    const result = await super.getUpdateComplete();
    await Promise.all(this.vElements.map((el) => el.updateComplete));
    return result;
  }
  firstUpdated() {
    this.style.display = "block";
  }
  render() {
    if (this.elements.length === 0) {
      return html`<div><v-text .str=${ZERO_WIDTH_SPACE}></v-text></div>`;
    }
    return html`<div>${this.elements}</div>`;
  }
  createRenderRoot() {
    return this;
  }
};
__decorate4([
  property({ attribute: false })
], VirgoLine.prototype, "elements", void 0);
VirgoLine = __decorate4([
  customElement("v-line")
], VirgoLine);

// node_modules/@blocksuite/virgo/dist/components/virgo-text.js
var __decorate5 = function(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d3 = decorators[i])
        r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
};
var VText = class VText2 extends LitElement {
  constructor() {
    super(...arguments);
    this.str = ZERO_WIDTH_SPACE;
    this.styles = styleMap({
      "word-wrap": "break-word",
      "white-space": "break-spaces"
    });
  }
  render() {
    return html`<span style=${this.styles} data-virgo-text="true"
      >${this.str}</span
    >`;
  }
  createRenderRoot() {
    return this;
  }
};
__decorate5([
  property()
], VText.prototype, "str", void 0);
__decorate5([
  property()
], VText.prototype, "styles", void 0);
VText = __decorate5([
  customElement("v-text")
], VText);

// node_modules/@blocksuite/virgo/dist/utils/base-attributes.js
var baseTextAttributes = z.object({
  bold: z.literal(true).optional().catch(void 0),
  italic: z.literal(true).optional().catch(void 0),
  underline: z.literal(true).optional().catch(void 0),
  strike: z.literal(true).optional().catch(void 0),
  code: z.literal(true).optional().catch(void 0),
  link: z.string().optional().catch(void 0)
});

// node_modules/@blocksuite/virgo/dist/utils/delta-convert.js
function transformDelta(delta) {
  const result = [];
  let tmpString = delta.insert;
  while (tmpString.length > 0) {
    const index = tmpString.indexOf("\n");
    if (index === -1) {
      result.push({
        insert: tmpString,
        attributes: delta.attributes
      });
      break;
    }
    if (tmpString.slice(0, index).length > 0) {
      result.push({
        insert: tmpString.slice(0, index),
        attributes: delta.attributes
      });
    }
    result.push("\n");
    tmpString = tmpString.slice(index + 1);
  }
  return result;
}
function deltaInsertsToChunks(delta) {
  if (delta.length === 0) {
    return [[]];
  }
  const transformedDelta = delta.flatMap(transformDelta);
  function* chunksGenerator(arr) {
    let start = 0;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === "\n") {
        const chunk = arr.slice(start, i);
        start = i + 1;
        yield chunk;
      } else if (i === arr.length - 1) {
        yield arr.slice(start);
      }
    }
    if (arr.at(-1) === "\n") {
      yield [];
    }
  }
  return [...chunksGenerator(transformedDelta)];
}

// node_modules/@blocksuite/virgo/dist/utils/guard.js
function isVText(text2) {
  var _a10;
  return text2 instanceof Text && ((_a10 = text2.parentElement) == null ? void 0 : _a10.dataset.virgoText) === "true";
}
function isVElement(element2) {
  return element2 instanceof HTMLElement && element2.dataset.virgoElement === "true";
}
function isVLine(element2) {
  return element2 instanceof HTMLElement && (element2 instanceof VirgoLine || element2.parentElement instanceof VirgoLine);
}
function isVRoot(element2) {
  return element2 instanceof HTMLElement && element2.dataset.virgoRoot === "true";
}

// node_modules/@blocksuite/virgo/dist/utils/text.js
function calculateTextLength(text2) {
  if (text2.wholeText === ZERO_WIDTH_SPACE) {
    return 0;
  } else {
    return text2.wholeText.length;
  }
}
function getTextNodesFromElement(element2) {
  const textSpanElements = Array.from(element2.querySelectorAll('[data-virgo-text="true"]'));
  const textNodes = textSpanElements.map((textSpanElement) => {
    const textNode = Array.from(textSpanElement.childNodes).find((node) => node instanceof Text);
    if (!textNode) {
      throw new Error("text node not found");
    }
    return textNode;
  });
  return textNodes;
}

// node_modules/@blocksuite/virgo/dist/utils/point-conversion.js
function nativePointToTextPoint(node, offset) {
  if (isVText(node)) {
    return [node, offset];
  }
  if (isVElement(node)) {
    const texts = getTextNodesFromElement(node);
    let textOffset = offset;
    for (const text2 of texts) {
      if (offset <= text2.length) {
        return [text2, textOffset];
      }
      textOffset -= text2.length;
    }
    return null;
  }
  if (isVLine(node) || isVRoot(node)) {
    return getTextPointFromElementByOffset(node, offset, true);
  }
  if (!(node instanceof Node)) {
    return null;
  }
  const vNodes = getVNodesFromNode(node);
  if (vNodes) {
    return getTextPointFromVNodes(vNodes, node, offset);
  }
  return null;
}
function textPointToDomPoint(text2, offset, rootElement) {
  if (rootElement.dataset.virgoRoot !== "true") {
    throw new Error("textRangeToDomPoint should be called with editor root element");
  }
  if (!rootElement.contains(text2)) {
    return null;
  }
  const texts = getTextNodesFromElement(rootElement);
  const goalIndex = texts.indexOf(text2);
  let index = 0;
  for (const text3 of texts.slice(0, goalIndex)) {
    index += calculateTextLength(text3);
  }
  if (text2.wholeText !== ZERO_WIDTH_SPACE) {
    index += offset;
  }
  const textParentElement = text2.parentElement;
  if (!textParentElement) {
    throw new Error("text element parent not found");
  }
  const lineElement = textParentElement.closest("v-line");
  if (!lineElement) {
    throw new Error("line element not found");
  }
  const lineIndex = Array.from(rootElement.querySelectorAll("v-line")).indexOf(lineElement);
  return { text: text2, index: index + lineIndex };
}
function getVNodesFromNode(node) {
  var _a10, _b6;
  const vLine = (_a10 = node.parentElement) == null ? void 0 : _a10.closest("v-line");
  if (vLine) {
    return Array.from(vLine.querySelectorAll("v-element"));
  }
  const container = node instanceof Element ? node.closest('[data-virgo-root="true"]') : (_b6 = node.parentElement) == null ? void 0 : _b6.closest('[data-virgo-root="true"]');
  if (container) {
    return Array.from(container.querySelectorAll("v-line"));
  }
  return null;
}
function getTextPointFromVNodes(vNodes, node, offset) {
  const first = vNodes[0];
  for (let i = 0; i < vNodes.length; i++) {
    const vLine = vNodes[i];
    if (i === 0 && AFollowedByB(node, vLine)) {
      return getTextPointFromElementByOffset(first, offset, true);
    }
    if (AInsideB(node, vLine)) {
      return getTextPointFromElementByOffset(first, offset, false);
    }
    if (i === vNodes.length - 1 && APrecededByB(node, vLine)) {
      return getTextPointFromElement(vLine);
    }
    if (i < vNodes.length - 1 && APrecededByB(node, vLine) && AFollowedByB(node, vNodes[i + 1])) {
      return getTextPointFromElement(vLine);
    }
  }
  return null;
}
function getTextPointFromElement(element2) {
  const texts = getTextNodesFromElement(element2);
  if (texts.length === 0)
    return null;
  const text2 = texts[texts.length - 1];
  return [text2, calculateTextLength(text2)];
}
function getTextPointFromElementByOffset(element2, offset, fromStart) {
  const texts = getTextNodesFromElement(element2);
  if (texts.length === 0)
    return null;
  const text2 = fromStart ? texts[0] : texts[texts.length - 1];
  return [text2, offset === 0 ? offset : text2.length];
}
function AInsideB(a2, b2) {
  return b2.compareDocumentPosition(a2) === Node.DOCUMENT_POSITION_CONTAINED_BY || b2.compareDocumentPosition(a2) === (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING);
}
function AFollowedByB(a2, b2) {
  return a2.compareDocumentPosition(b2) === Node.DOCUMENT_POSITION_FOLLOWING;
}
function APrecededByB(a2, b2) {
  return a2.compareDocumentPosition(b2) === Node.DOCUMENT_POSITION_PRECEDING;
}

// node_modules/@blocksuite/virgo/dist/utils/query.js
function findDocumentOrShadowRoot(editor) {
  const el = editor.rootElement;
  if (!el) {
    throw new Error("editor root element not found");
  }
  const root = el.getRootNode();
  if ((root instanceof Document || root instanceof ShadowRoot) && "getSelection" in root) {
    return root;
  }
  return el.ownerDocument;
}

// node_modules/@blocksuite/virgo/dist/utils/selection.js
function isSelectionBackwards(selection) {
  let backwards = false;
  if (!selection.isCollapsed && selection.anchorNode && selection.focusNode) {
    const range = document.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    backwards = range.collapsed;
    range.detach();
  }
  return backwards;
}

// node_modules/@blocksuite/virgo/dist/utils/range-conversion.js
var rangeHasAnchorAndFocus = ({ rootElement, anchorText, focusText }) => {
  return rootElement.contains(anchorText) && rootElement.contains(focusText);
};
var rangeHasAnchorAndFocusHandler = ({ rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset }) => {
  const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);
  const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);
  if (!anchorDomPoint || !focusDomPoint) {
    return null;
  }
  return {
    index: Math.min(anchorDomPoint.index, focusDomPoint.index),
    length: Math.abs(anchorDomPoint.index - focusDomPoint.index)
  };
};
var rangeOnlyHasFocus = ({ rootElement, anchorText, focusText }) => {
  return !rootElement.contains(anchorText) && rootElement.contains(focusText);
};
var rangeOnlyHasFocusHandler = ({ selection, yText, rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset }) => {
  if (isSelectionBackwards(selection)) {
    const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);
    if (!anchorDomPoint) {
      return null;
    }
    return {
      index: anchorDomPoint.index,
      length: yText.length - anchorDomPoint.index
    };
  } else {
    const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);
    if (!focusDomPoint) {
      return null;
    }
    return {
      index: 0,
      length: focusDomPoint.index
    };
  }
};
var rangeOnlyHasAnchor = ({ rootElement, anchorText, focusText }) => {
  return rootElement.contains(anchorText) && !rootElement.contains(focusText);
};
var rangeOnlyHasAnchorHandler = ({ selection, yText, rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset }) => {
  if (isSelectionBackwards(selection)) {
    const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);
    if (!focusDomPoint) {
      return null;
    }
    return {
      index: 0,
      length: focusDomPoint.index
    };
  } else {
    const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);
    if (!anchorDomPoint) {
      return null;
    }
    return {
      index: anchorDomPoint.index,
      length: yText.length - anchorDomPoint.index
    };
  }
};
var rangeHasNoAnchorAndFocus = ({ rootElement, anchorText, focusText }) => {
  return !rootElement.contains(anchorText) && !rootElement.contains(focusText);
};
var rangeHasNoAnchorAndFocusHandler = ({ yText }) => {
  return {
    index: 0,
    length: yText.length
  };
};
var buildContext = (selection, rootElement, yText) => {
  const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
  const anchorTextPoint = nativePointToTextPoint(anchorNode, anchorOffset);
  const focusTextPoint = nativePointToTextPoint(focusNode, focusOffset);
  if (!anchorTextPoint || !focusTextPoint) {
    return null;
  }
  const [anchorText, anchorTextOffset] = anchorTextPoint;
  const [focusText, focusTextOffset] = focusTextPoint;
  return {
    rootElement,
    selection,
    yText,
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset,
    anchorText,
    anchorTextOffset,
    focusText,
    focusTextOffset
  };
};
function domRangeToVirgoRange(selection, rootElement, yText) {
  const context = buildContext(selection, rootElement, yText);
  if (!context)
    return null;
  if (rangeHasAnchorAndFocus(context)) {
    return rangeHasAnchorAndFocusHandler(context);
  }
  if (rangeOnlyHasFocus(context)) {
    return rangeOnlyHasFocusHandler(context);
  }
  if (rangeOnlyHasAnchor(context)) {
    return rangeOnlyHasAnchorHandler(context);
  }
  if (rangeHasNoAnchorAndFocus(context)) {
    return rangeHasNoAnchorAndFocusHandler(context);
  }
  return null;
}
function virgoRangeToDomRange(rootElement, vRange) {
  const lineElements = Array.from(rootElement.querySelectorAll("v-line"));
  let anchorText = null;
  let focusText = null;
  let anchorOffset = 0;
  let focusOffset = 0;
  let index = 0;
  for (let i = 0; i < lineElements.length; i++) {
    if (anchorText && focusText) {
      break;
    }
    const texts = getTextNodesFromElement(lineElements[i]);
    for (const text2 of texts) {
      const textLength = calculateTextLength(text2);
      if (!anchorText && index + textLength >= vRange.index) {
        anchorText = text2;
        anchorOffset = vRange.index - index;
      }
      if (!focusText && index + textLength >= vRange.index + vRange.length) {
        focusText = text2;
        focusOffset = vRange.index + vRange.length - index;
      }
      if (anchorText && focusText) {
        break;
      }
      index += textLength;
    }
    index += 1;
  }
  if (!anchorText || !focusText) {
    return null;
  }
  const range = document.createRange();
  range.setStart(anchorText, anchorOffset);
  range.setEnd(focusText, focusOffset);
  return range;
}

// node_modules/@blocksuite/virgo/dist/utils/renderer.js
function renderElement(delta, parseAttributes, attributeRenderer) {
  return html`<v-element
    .delta=${{
    insert: delta.insert,
    attributes: parseAttributes(delta.attributes)
  }}
    .attributeRenderer=${attributeRenderer}
  ></v-element>`;
}

// node_modules/@blocksuite/virgo/dist/utils/transform-input.js
function handleInsertText(vRange, data, editor, attributes) {
  if (vRange.index >= 0 && data) {
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index + data.length,
        length: 0
      },
      "input"
    ]);
    editor.insertText(vRange, data, attributes);
  }
}
function handleInsertParagraph(vRange, editor) {
  if (vRange.index >= 0) {
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index + 1,
        length: 0
      },
      "input"
    ]);
    editor.insertLineBreak(vRange);
  }
}
function handleDelete(vRange, editor) {
  if (vRange.index >= 0) {
    if (vRange.length > 0) {
      editor.slots.vRangeUpdated.emit([
        {
          index: vRange.index,
          length: 0
        },
        "input"
      ]);
      editor.deleteText(vRange);
      return;
    }
    if (vRange.index > 0) {
      const originalString = editor.yText.toString().slice(0, vRange.index);
      const segments = [...new Intl.Segmenter().segment(originalString)];
      const deletedLength = segments[segments.length - 1].segment.length;
      editor.slots.vRangeUpdated.emit([
        {
          index: vRange.index - deletedLength,
          length: 0
        },
        "input"
      ]);
      editor.deleteText({
        index: vRange.index - deletedLength,
        length: deletedLength
      });
    }
  }
}
function handleWordDelete(editor, vRange) {
  const matches = /\S+\s*$/.exec(editor.yText.toString().slice(0, vRange.index));
  if (matches) {
    const deleteLength = matches[0].length;
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index - deleteLength,
        length: 0
      },
      "input"
    ]);
    editor.deleteText({
      index: vRange.index - deleteLength,
      length: deleteLength
    });
  }
}
function handleLineDelete(editor, vRange) {
  if (vRange.length > 0) {
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index,
        length: 0
      },
      "input"
    ]);
    editor.deleteText(vRange);
    return;
  }
  if (vRange.index > 0) {
    const str = editor.yText.toString();
    const deleteLength = vRange.index - Math.max(0, str.slice(0, vRange.index).lastIndexOf("\n"));
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index - deleteLength,
        length: 0
      },
      "input"
    ]);
    editor.deleteText({
      index: vRange.index - deleteLength,
      length: deleteLength
    });
  }
}
function handleForwardDelete(editor, vRange) {
  if (vRange.index < editor.yText.length) {
    const originalString = editor.yText.toString();
    const segments = [...new Intl.Segmenter().segment(originalString)];
    const slicedString = originalString.slice(0, vRange.index);
    const slicedSegments = [...new Intl.Segmenter().segment(slicedString)];
    const deletedLength = segments[slicedSegments.length].segment.length;
    editor.slots.vRangeUpdated.emit([
      {
        index: vRange.index,
        length: 0
      },
      "input"
    ]);
    editor.deleteText({
      index: vRange.index,
      length: deletedLength
    });
  }
}
function transformInput(inputType, data, attributes, vRange, editor) {
  switch (inputType) {
    case "insertText": {
      handleInsertText(vRange, data, editor, attributes);
      return;
    }
    case "insertParagraph": {
      handleInsertParagraph(vRange, editor);
      return;
    }
    case "deleteContentBackward":
    case "deleteByCut": {
      handleDelete(vRange, editor);
      return;
    }
    case "deleteWordBackward": {
      handleWordDelete(editor, vRange);
      return;
    }
    case "deleteHardLineBackward":
    case "deleteSoftLineBackward": {
      handleLineDelete(editor, vRange);
      return;
    }
    case "deleteContentForward": {
      handleForwardDelete(editor, vRange);
      return;
    }
  }
}

// node_modules/@blocksuite/virgo/dist/services/attribute.js
var VirgoAttributeService = class {
  constructor(editor) {
    this._marks = null;
    this._attributeRenderer = getDefaultAttributeRenderer();
    this._attributeSchema = baseTextAttributes;
    this.setMarks = (marks) => {
      this._marks = marks;
    };
    this.resetMarks = () => {
      this._marks = null;
    };
    this.setAttributeSchema = (schema) => {
      this._attributeSchema = schema;
    };
    this.setAttributeRenderer = (renderer) => {
      this._attributeRenderer = renderer;
    };
    this.getFormat = (vRange, loose = false) => {
      const deltas = this._editor.deltaService.getDeltasByVRange(vRange).filter(([delta, position]) => position.index + position.length > vRange.index && position.index <= vRange.index + vRange.length);
      const maybeAttributesList = deltas.map(([delta]) => delta.attributes);
      if (loose) {
        return maybeAttributesList.reduce((acc, cur) => ({ ...acc, ...cur }), {});
      }
      if (!maybeAttributesList.length || // some text does not have any attribute
      maybeAttributesList.some((attributes) => !attributes)) {
        return {};
      }
      const attributesList = maybeAttributesList;
      return attributesList.reduce((acc, cur) => {
        const newFormat = {};
        for (const key in acc) {
          const typedKey = key;
          if (acc[typedKey] === cur[typedKey]) {
            newFormat[typedKey] = acc[typedKey];
          }
        }
        return newFormat;
      });
    };
    this.normalizeAttributes = (textAttributes) => {
      if (!textAttributes) {
        return void 0;
      }
      const attributeResult = this._attributeSchema.safeParse(textAttributes);
      if (!attributeResult.success) {
        console.error(attributeResult.error);
        return void 0;
      }
      return Object.fromEntries(
        // filter out undefined values
        Object.entries(attributeResult.data).filter(([k, v2]) => v2)
      );
    };
    this._editor = editor;
  }
  get marks() {
    return this._marks;
  }
  get attributeRenderer() {
    return this._attributeRenderer;
  }
};

// node_modules/lit-html/development/directive-helpers.js
var _a9;
var _b5;
var { _ChildPart: ChildPart2 } = _$LH;
var ENABLE_SHADYDOM_NOPATCH2 = true;
var wrap2 = ENABLE_SHADYDOM_NOPATCH2 && ((_a9 = window.ShadyDOM) === null || _a9 === void 0 ? void 0 : _a9.inUse) && ((_b5 = window.ShadyDOM) === null || _b5 === void 0 ? void 0 : _b5.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var createMarker2 = () => document.createComment("");
var insertPart = (containerPart, refPart, part) => {
  var _a10;
  const container = wrap2(containerPart._$startNode).parentNode;
  const refNode = refPart === void 0 ? containerPart._$endNode : refPart._$startNode;
  if (part === void 0) {
    const startNode = wrap2(container).insertBefore(createMarker2(), refNode);
    const endNode = wrap2(container).insertBefore(createMarker2(), refNode);
    part = new ChildPart2(startNode, endNode, containerPart, containerPart.options);
  } else {
    const endNode = wrap2(part._$endNode).nextSibling;
    const oldParent = part._$parent;
    const parentChanged = oldParent !== containerPart;
    if (parentChanged) {
      (_a10 = part._$reparentDisconnectables) === null || _a10 === void 0 ? void 0 : _a10.call(part, containerPart);
      part._$parent = containerPart;
      let newConnectionState;
      if (part._$notifyConnectionChanged !== void 0 && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {
        part._$notifyConnectionChanged(newConnectionState);
      }
    }
    if (endNode !== refNode || parentChanged) {
      let start = part._$startNode;
      while (start !== endNode) {
        const n = wrap2(start).nextSibling;
        wrap2(container).insertBefore(start, refNode);
        start = n;
      }
    }
  }
  return part;
};
var setChildPartValue = (part, value, directiveParent = part) => {
  part._$setValue(value, directiveParent);
  return part;
};
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
var getCommittedValue = (part) => part._$committedValue;
var removePart = (part) => {
  var _a10;
  (_a10 = part._$notifyConnectionChanged) === null || _a10 === void 0 ? void 0 : _a10.call(part, false, true);
  let start = part._$startNode;
  const end = wrap2(part._$endNode).nextSibling;
  while (start !== end) {
    const n = wrap2(start).nextSibling;
    wrap2(start).remove();
    start = n;
  }
};

// node_modules/lit-html/development/directives/repeat.js
var generateMap = (list, start, end) => {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = start; i <= end; i++) {
    map2.set(list[i], i);
  }
  return map2;
};
var RepeatDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error("repeat() can only be used in text expressions");
    }
  }
  _getValuesAndKeys(items, keyFnOrTemplate, template) {
    let keyFn;
    if (template === void 0) {
      template = keyFnOrTemplate;
    } else if (keyFnOrTemplate !== void 0) {
      keyFn = keyFnOrTemplate;
    }
    const keys2 = [];
    const values = [];
    let index = 0;
    for (const item of items) {
      keys2[index] = keyFn ? keyFn(item, index) : index;
      values[index] = template(item, index);
      index++;
    }
    return {
      values,
      keys: keys2
    };
  }
  render(items, keyFnOrTemplate, template) {
    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
  }
  update(containerPart, [items, keyFnOrTemplate, template]) {
    var _a10;
    const oldParts = getCommittedValue(containerPart);
    const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
    if (!Array.isArray(oldParts)) {
      this._itemKeys = newKeys;
      return newValues;
    }
    const oldKeys = (_a10 = this._itemKeys) !== null && _a10 !== void 0 ? _a10 : this._itemKeys = [];
    const newParts = [];
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);
        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);
        insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = insertPart(containerPart, oldParts[oldHead]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
            insertPart(containerPart, oldParts[oldHead], oldPart);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = insertPart(containerPart, newParts[newTail + 1]);
      setChildPartValue(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    this._itemKeys = newKeys;
    setCommittedValue(containerPart, newParts);
    return noChange;
  }
};
var repeat2 = directive(RepeatDirective);

// node_modules/@blocksuite/virgo/dist/services/delta.js
var VirgoDeltaService = class {
  constructor(editor) {
    this.mapDeltasInVRange = (vRange, callback) => {
      const deltas = this.deltas;
      const result = [];
      deltas.reduce((index, delta) => {
        const length4 = delta.insert.length;
        const from3 = vRange.index - length4;
        const to = vRange.index + vRange.length;
        const deltaInRange = index >= from3 && (index < to || vRange.length === 0 && index === vRange.index);
        if (deltaInRange) {
          const value = callback(delta, index);
          result.push(value);
        }
        return index + length4;
      }, 0);
      return result;
    };
    this.getDeltaByRangeIndex = (rangeIndex) => {
      const deltas = this.deltas;
      let index = 0;
      for (const delta of deltas) {
        if (index + delta.insert.length >= rangeIndex) {
          return delta;
        }
        index += delta.insert.length;
      }
      return null;
    };
    this.getDeltasByVRange = (vRange) => {
      return this.mapDeltasInVRange(vRange, (delta, index) => [
        delta,
        { index, length: delta.insert.length }
      ]);
    };
    this.render = async () => {
      const rootElement = this._editor.rootElement;
      const deltas = this.deltas;
      const chunks = deltaInsertsToChunks(deltas);
      const lines = chunks.map((chunk) => {
        const elementTs = [];
        if (chunk.length > 0) {
          chunk.forEach((delta) => {
            const element2 = renderElement(delta, this._editor.attributeService.normalizeAttributes, this._editor.attributeService.attributeRenderer);
            elementTs.push(element2);
          });
        }
        return html`<v-line .elements=${elementTs}></v-line>`;
      });
      try {
        render(repeat2(lines.map((line, i) => ({ line, index: i })), (entry) => entry.index, (entry) => entry.line), rootElement);
      } catch (error) {
        render(html`<div></div>`, rootElement);
        this._editor.requestUpdate();
      }
      const vLines = Array.from(rootElement.querySelectorAll("v-line"));
      await Promise.all(vLines.map((line) => line.updateComplete));
      this._editor.rangeService.syncVRange();
      this._editor.slots.updated.emit();
    };
    this._editor = editor;
  }
  get deltas() {
    return this._editor.yText.toDelta();
  }
};

// node_modules/@blocksuite/virgo/dist/services/event.js
var VirgoEventService = class {
  constructor(editor) {
    this._mountAbortController = null;
    this._handlerAbortController = null;
    this._isComposing = false;
    this._handlers = {};
    this._previousAnchor = null;
    this._previousFocus = null;
    this.defaultHandlers = {
      paste: (event) => {
        var _a10;
        const data = (_a10 = event.clipboardData) == null ? void 0 : _a10.getData("text/plain");
        if (data) {
          const vRange = this._editor.getVRange();
          const text2 = data.replace(/(\r\n|\r|\n)/g, "\n");
          if (vRange) {
            this._editor.insertText(vRange, text2);
            this._editor.setVRange({
              index: vRange.index + text2.length,
              length: 0
            });
          }
        }
      }
    };
    this.mount = () => {
      const rootElement = this._editor.rootElement;
      this._mountAbortController = new AbortController();
      document.addEventListener("selectionchange", this._onSelectionChange);
      const signal = this._mountAbortController.signal;
      rootElement.addEventListener("beforeinput", this._onBeforeInput, {
        signal
      });
      rootElement.querySelectorAll('[data-virgo-text="true"]').forEach((textNode) => {
        textNode.addEventListener("dragstart", (event) => {
          event.preventDefault();
        });
      });
      rootElement.addEventListener("compositionstart", this._onCompositionStart, {
        signal
      });
      rootElement.addEventListener("compositionend", this._onCompositionEnd, {
        signal
      });
      rootElement.addEventListener("scroll", this._onScroll);
      this.bindHandlers();
    };
    this.unmount = () => {
      document.removeEventListener("selectionchange", this._onSelectionChange);
      if (this._mountAbortController) {
        this._mountAbortController.abort();
        this._mountAbortController = null;
      }
      if (this._handlerAbortController) {
        this._handlerAbortController.abort();
        this._handlerAbortController = null;
      }
      this._handlers = this.defaultHandlers;
    };
    this.bindHandlers = (handlers = this.defaultHandlers) => {
      this._handlers = handlers;
      if (this._handlerAbortController) {
        this._handlerAbortController.abort();
      }
      this._handlerAbortController = new AbortController();
      if (this._handlers.paste) {
        this._editor.rootElement.addEventListener("paste", this._handlers.paste, {
          signal: this._handlerAbortController.signal
        });
      }
      if (this._handlers.keydown) {
        this._editor.rootElement.addEventListener("keydown", this._handlers.keydown, {
          signal: this._handlerAbortController.signal
        });
      }
    };
    this._onSelectionChange = () => {
      const rootElement = this._editor.rootElement;
      if (this._isComposing) {
        return;
      }
      const selectionRoot = findDocumentOrShadowRoot(this._editor);
      const selection = selectionRoot.getSelection();
      if (!selection)
        return;
      if (selection.rangeCount === 0)
        return;
      const range = selection.getRangeAt(0);
      if (range.startContainer === range.endContainer && range.startContainer.textContent === ZERO_WIDTH_SPACE && range.startOffset === 1) {
        range.setStart(range.startContainer, 0);
        range.setEnd(range.endContainer, 0);
        selection.removeAllRanges();
        selection.addRange(range);
        return;
      }
      if (!range)
        return;
      if (!range.intersectsNode(rootElement)) {
        if (range.endContainer.contains(rootElement) && Array.from(range.endContainer.childNodes).filter((node) => node instanceof HTMLElement).length === 1 && range.startContainer.contains(rootElement) && Array.from(range.startContainer.childNodes).filter((node) => node instanceof HTMLElement).length === 1) {
          this._editor.focusEnd();
        } else {
          return;
        }
      }
      this._previousAnchor = [range.startContainer, range.startOffset];
      this._previousFocus = [range.endContainer, range.endOffset];
      const vRange = this._editor.toVRange(selection);
      if (vRange) {
        this._editor.slots.vRangeUpdated.emit([vRange, "native"]);
      }
      if ((range.startContainer.nodeType !== Node.TEXT_NODE || range.endContainer.nodeType !== Node.TEXT_NODE) && range.startContainer !== this._previousAnchor[0] && range.endContainer !== this._previousFocus[0] && range.startOffset !== this._previousAnchor[1] && range.endOffset !== this._previousFocus[1] || range.startContainer.nodeType === Node.COMMENT_NODE || range.endContainer.nodeType === Node.COMMENT_NODE) {
        this._editor.syncVRange();
      }
    };
    this._onCompositionStart = () => {
      this._isComposing = true;
    };
    this._onCompositionEnd = (event) => {
      var _a10, _b6, _c4;
      this._isComposing = false;
      if (this._editor.isReadonly)
        return;
      const vRange = this._editor.getVRange();
      if (!vRange)
        return;
      let ctx = {
        event,
        data: event.data,
        vRange,
        skipDefault: false,
        attributes: null
      };
      if (this._handlers.virgoCompositionEnd) {
        ctx = this._handlers.virgoCompositionEnd(ctx);
      }
      if (ctx.skipDefault)
        return;
      const { data, vRange: newVRange } = ctx;
      if (newVRange.index >= 0) {
        const selection = window.getSelection();
        if (selection && selection.rangeCount !== 0) {
          const range = selection.getRangeAt(0);
          const container = range.startContainer;
          if (container instanceof Text) {
            if (((_a10 = container.parentElement) == null ? void 0 : _a10.dataset.virgoText) !== "true") {
              container.remove();
            } else {
              const [text2] = this._editor.getTextPoint(newVRange.index);
              const vText = (_b6 = text2.parentElement) == null ? void 0 : _b6.closest("v-text");
              if (vText) {
                if (vText.str !== text2.textContent) {
                  text2.textContent = vText.str;
                }
              } else {
                const forgedVText = (_c4 = text2.parentElement) == null ? void 0 : _c4.closest('[data-virgo-text="true"]');
                if (forgedVText instanceof HTMLElement) {
                  if (forgedVText.dataset.virgoTextValue) {
                    if (forgedVText.dataset.virgoTextValue !== text2.textContent) {
                      text2.textContent = forgedVText.dataset.virgoTextValue;
                    }
                  } else {
                    throw new Error("We detect a forged v-text node but it has no data-virgo-text-value attribute.");
                  }
                }
              }
            }
            const newRange = this._editor.toDomRange(newVRange);
            if (newRange) {
              assertExists(newRange);
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          }
        }
        if (data && data.length > 0) {
          this._editor.insertText(newVRange, data, ctx.attributes ?? {});
          this._editor.slots.vRangeUpdated.emit([
            {
              index: newVRange.index + data.length,
              length: 0
            },
            "input"
          ]);
        }
      }
    };
    this._firstRecomputeInFrame = true;
    this._onBeforeInput = (event) => {
      event.preventDefault();
      if (this._editor.isReadonly || this._isComposing)
        return;
      if (this._firstRecomputeInFrame) {
        this._firstRecomputeInFrame = false;
        this._onSelectionChange();
        requestAnimationFrame(() => {
          this._firstRecomputeInFrame = true;
        });
      }
      const vRange = this._editor.getVRange();
      if (!vRange)
        return;
      let ctx = {
        event,
        data: event.data,
        vRange,
        skipDefault: false,
        attributes: null
      };
      if (this._handlers.virgoInput) {
        ctx = this._handlers.virgoInput(ctx);
      }
      if (ctx.skipDefault)
        return;
      const { event: newEvent, data, vRange: newVRange } = ctx;
      transformInput(newEvent.inputType, data, ctx.attributes ?? {}, newVRange, this._editor);
    };
    this._onScroll = (event) => {
      this._editor.slots.scrollUpdated.emit(this._editor.rootElement.scrollLeft);
    };
    this._editor = editor;
  }
};

// node_modules/@blocksuite/virgo/dist/services/range.js
var VirgoRangeService = class {
  constructor(editor) {
    this._vRange = null;
    this._lastScrollLeft = 0;
    this.onVRangeUpdated = ([newVRange, origin]) => {
      this._vRange = newVRange;
      document.dispatchEvent(new CustomEvent("virgo-vrange-updated"));
      if (origin !== "other") {
        return;
      }
      const fn = () => {
        if (this._vRange) {
          this._applyVRange(this._vRange);
        }
      };
      requestAnimationFrame(fn);
    };
    this.getVRange = () => {
      return this._vRange;
    };
    this.setVRange = (vRange) => {
      this._editor.slots.vRangeUpdated.emit([vRange, "other"]);
    };
    this.syncVRange = () => {
      if (this._vRange) {
        this._applyVRange(this._vRange);
      }
    };
    this.toDomRange = (vRange) => {
      const rootElement = this._editor.rootElement;
      return virgoRangeToDomRange(rootElement, vRange);
    };
    this.toVRange = (selection) => {
      const { rootElement, yText } = this._editor;
      return domRangeToVirgoRange(selection, rootElement, yText);
    };
    this.mergeRanges = (range1, range2) => {
      return {
        index: Math.max(range1.index, range2.index),
        length: Math.min(range1.index + range1.length, range2.index + range2.length) - Math.max(range1.index, range2.index)
      };
    };
    this.onScrollUpdated = (scrollLeft) => {
      this._lastScrollLeft = scrollLeft;
    };
    this._applyVRange = (vRange) => {
      if (!this._editor.isActive) {
        return;
      }
      const selectionRoot = findDocumentOrShadowRoot(this._editor);
      const selection = selectionRoot.getSelection();
      if (!selection) {
        return;
      }
      const newRange = this.toDomRange(vRange);
      if (!newRange) {
        return;
      }
      selection.removeAllRanges();
      selection.addRange(newRange);
      this._scrollLineIntoViewIfNeeded(newRange);
      this._scrollCursorIntoViewIfNeeded(newRange);
      this._editor.slots.rangeUpdated.emit(newRange);
    };
    this._scrollLineIntoViewIfNeeded = (range) => {
      if (this._editor.shouldLineScrollIntoView) {
        let lineElement = range.endContainer.parentElement;
        while (!(lineElement instanceof VirgoLine)) {
          lineElement = (lineElement == null ? void 0 : lineElement.parentElement) ?? null;
        }
        lineElement == null ? void 0 : lineElement.scrollIntoView({
          block: "nearest"
        });
      }
    };
    this._scrollCursorIntoViewIfNeeded = (range) => {
      if (this._editor.shouldCursorScrollIntoView) {
        const root = this._editor.rootElement;
        const rootRect = root.getBoundingClientRect();
        const rangeRect = range.getBoundingClientRect();
        let moveX = 0;
        if (rangeRect.left > rootRect.left) {
          moveX = Math.max(this._lastScrollLeft, rangeRect.left - rootRect.right);
        }
        root.scrollLeft = moveX;
        this._lastScrollLeft = moveX;
      }
    };
    this._editor = editor;
  }
};

// node_modules/@blocksuite/virgo/dist/virgo.js
var VEditor = class _VEditor {
  get yText() {
    return this._yText;
  }
  get rootElement() {
    assertExists(this._rootElement);
    return this._rootElement;
  }
  get eventService() {
    return this._eventService;
  }
  get rangeService() {
    return this._rangeService;
  }
  get attributeService() {
    return this._attributeService;
  }
  get deltaService() {
    return this._deltaService;
  }
  // Expose attribute service API
  get marks() {
    return this._attributeService.marks;
  }
  constructor(yText, ops) {
    this._rootElement = null;
    this._isReadonly = false;
    this._eventService = new VirgoEventService(this);
    this._rangeService = new VirgoRangeService(this);
    this._attributeService = new VirgoAttributeService(this);
    this._deltaService = new VirgoDeltaService(this);
    this.shouldLineScrollIntoView = true;
    this.shouldCursorScrollIntoView = true;
    this.setAttributeSchema = this._attributeService.setAttributeSchema;
    this.setAttributeRenderer = this._attributeService.setAttributeRenderer;
    this.setMarks = this._attributeService.setMarks;
    this.resetMarks = this._attributeService.resetMarks;
    this.getFormat = this._attributeService.getFormat;
    this.bindHandlers = this._eventService.bindHandlers;
    this.toDomRange = this.rangeService.toDomRange;
    this.toVRange = this.rangeService.toVRange;
    this.getVRange = this.rangeService.getVRange;
    this.setVRange = this.rangeService.setVRange;
    this.syncVRange = this.rangeService.syncVRange;
    this.getDeltasByVRange = this.deltaService.getDeltasByVRange;
    this.getDeltaByRangeIndex = this.deltaService.getDeltaByRangeIndex;
    this.mapDeltasInVRange = this.deltaService.mapDeltasInVRange;
    this._onYTextChange = () => {
      if (this.yText.toString().includes("\r")) {
        throw new Error("yText must not contain \r because it will break the range synchronization");
      }
      Promise.resolve().then(() => {
        assertExists(this._rootElement);
        this.deltaService.render();
      });
    };
    if (!yText.doc) {
      throw new Error("yText must be attached to a Y.Doc");
    }
    if (yText.toString().includes("\r")) {
      throw new Error("yText must not contain \r because it will break the range synchronization");
    }
    this._yText = yText;
    this._isActive = (ops == null ? void 0 : ops.active) ?? (() => true);
    this.slots = {
      mounted: new Slot(),
      unmounted: new Slot(),
      updated: new Slot(),
      vRangeUpdated: new Slot(),
      rangeUpdated: new Slot(),
      scrollUpdated: new Slot()
    };
    this.slots.vRangeUpdated.on(this.rangeService.onVRangeUpdated);
    this.slots.scrollUpdated.on(this.rangeService.onScrollUpdated);
  }
  mount(rootElement) {
    const virgoElement = rootElement;
    virgoElement.virgoEditor = this;
    this._rootElement = virgoElement;
    this._rootElement.replaceChildren();
    this._rootElement.contentEditable = "true";
    this._rootElement.dataset.virgoRoot = "true";
    this.yText.observe(this._onYTextChange);
    this._deltaService.render();
    this._eventService.mount();
    this.slots.mounted.emit();
  }
  unmount() {
    var _a10;
    this._eventService.unmount();
    this.yText.unobserve(this._onYTextChange);
    (_a10 = this._rootElement) == null ? void 0 : _a10.replaceChildren();
    this._rootElement = null;
    this.slots.unmounted.emit();
  }
  requestUpdate() {
    Promise.resolve().then(() => {
      assertExists(this._rootElement);
      this._deltaService.render();
    });
  }
  getNativeSelection() {
    const selectionRoot = findDocumentOrShadowRoot(this);
    const selection = selectionRoot.getSelection();
    if (!selection)
      return null;
    if (selection.rangeCount === 0)
      return null;
    return selection;
  }
  getTextPoint(rangeIndex) {
    assertExists(this._rootElement);
    const vLines = Array.from(this._rootElement.querySelectorAll("v-line"));
    let index = 0;
    for (const vLine of vLines) {
      const texts = _VEditor.getTextNodesFromElement(vLine);
      for (const text2 of texts) {
        if (!text2.textContent) {
          throw new Error("text element should have textContent");
        }
        if (index + text2.textContent.length >= rangeIndex) {
          return [text2, rangeIndex - index];
        }
        index += calculateTextLength(text2);
      }
      index += 1;
    }
    throw new Error("failed to find leaf");
  }
  // the number is related to the VirgoLine's textLength
  getLine(rangeIndex) {
    assertExists(this._rootElement);
    const lineElements = Array.from(this._rootElement.querySelectorAll("v-line"));
    let index = 0;
    for (const lineElement of lineElements) {
      if (rangeIndex >= index && rangeIndex <= index + lineElement.textLength) {
        return [lineElement, rangeIndex - index];
      }
      if (rangeIndex === index + lineElement.textLength && rangeIndex === this.yText.length) {
        return [lineElement, rangeIndex - index];
      }
      index += lineElement.textLength + 1;
    }
    throw new Error("failed to find line");
  }
  setReadonly(isReadonly) {
    this.rootElement.contentEditable = isReadonly ? "false" : "true";
    this._isReadonly = isReadonly;
  }
  get isReadonly() {
    return this._isReadonly;
  }
  get isActive() {
    return this._isActive();
  }
  /**
   * the vRange is synced to the native selection asynchronically
   */
  focusEnd() {
    this.rangeService.setVRange({
      index: this.yText.length,
      length: 0
    });
  }
  deleteText(vRange) {
    this._transact(() => {
      this.yText.delete(vRange.index, vRange.length);
    });
  }
  insertText(vRange, text2, attributes = {}) {
    if (this._attributeService.marks) {
      attributes = { ...attributes, ...this._attributeService.marks };
    }
    const normalizedAttributes = this._attributeService.normalizeAttributes(attributes);
    if (!text2 || !text2.length) {
      throw new Error("text must not be empty");
    }
    this._transact(() => {
      this.yText.delete(vRange.index, vRange.length);
      this.yText.insert(vRange.index, text2, normalizedAttributes);
    });
  }
  insertLineBreak(vRange) {
    this._transact(() => {
      this.yText.delete(vRange.index, vRange.length);
      this.yText.insert(vRange.index, "\n");
    });
  }
  formatText(vRange, attributes, options = {}) {
    const { match: match2 = () => true, mode = "merge" } = options;
    const deltas = this._deltaService.getDeltasByVRange(vRange);
    deltas.filter(([delta, deltaVRange]) => match2(delta, deltaVRange)).forEach(([delta, deltaVRange]) => {
      const targetVRange = this._rangeService.mergeRanges(vRange, deltaVRange);
      if (mode === "replace") {
        this.resetText(targetVRange);
      }
      this._transact(() => {
        this.yText.format(targetVRange.index, targetVRange.length, attributes);
      });
    });
  }
  resetText(vRange) {
    const coverDeltas = [];
    for (let i = vRange.index; i <= vRange.index + vRange.length; i++) {
      const delta = this.getDeltaByRangeIndex(i);
      if (delta) {
        coverDeltas.push(delta);
      }
    }
    const unset = Object.fromEntries(coverDeltas.flatMap((delta) => delta.attributes ? Object.keys(delta.attributes).map((key) => [key, null]) : []));
    this._transact(() => {
      this.yText.format(vRange.index, vRange.length, {
        ...unset
      });
    });
  }
  setText(text2, attributes = {}) {
    this._transact(() => {
      this.yText.delete(0, this.yText.length);
      this.yText.insert(0, text2, attributes);
    });
  }
  _transact(fn) {
    const doc2 = this.yText.doc;
    if (!doc2) {
      throw new Error("yText is not attached to a doc");
    }
    doc2.transact(fn, doc2.clientID);
  }
};
VEditor.nativePointToTextPoint = nativePointToTextPoint;
VEditor.textPointToDomPoint = textPointToDomPoint;
VEditor.getTextNodesFromElement = getTextNodesFromElement;

// node_modules/@blocksuite/blocks/dist/__internal__/utils/selection.js
var notStrictCharacterReg = /[^\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/u;
var notStrictCharacterAndSpaceReg = /[^\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}\s]/u;
function setStartRange(editableContainer) {
  const newRange = document.createRange();
  let firstNode = editableContainer.firstChild;
  while (firstNode == null ? void 0 : firstNode.firstChild) {
    firstNode = firstNode.firstChild;
  }
  if (firstNode) {
    newRange.setStart(firstNode, 0);
    newRange.setEnd(firstNode, 0);
  }
  return newRange;
}
function setEndRange(editableContainer) {
  var _a10, _b6;
  const newRange = document.createRange();
  let lastNode = editableContainer.lastChild;
  while (lastNode == null ? void 0 : lastNode.lastChild) {
    lastNode = lastNode.lastChild;
  }
  if (lastNode) {
    newRange.setStart(lastNode, ((_a10 = lastNode.textContent) == null ? void 0 : _a10.length) || 0);
    newRange.setEnd(lastNode, ((_b6 = lastNode.textContent) == null ? void 0 : _b6.length) || 0);
  }
  return newRange;
}
async function setNewTop(y, editableContainer, zoom = 1) {
  const scrollContainer = editableContainer.closest(".affine-default-viewport");
  const { top, bottom } = Rect.fromDOM(editableContainer);
  const { clientHeight } = document.documentElement;
  const lineHeight = (Number(window.getComputedStyle(editableContainer).lineHeight.replace(/\D+$/, "")) || 16) * zoom;
  const compare = bottom < y;
  switch (compare) {
    case true: {
      let finalBottom = bottom;
      if (bottom < SCROLL_THRESHOLD && scrollContainer) {
        scrollContainer.scrollTop = scrollContainer.scrollTop - SCROLL_THRESHOLD + bottom;
        requestAnimationFrame(() => {
          finalBottom = editableContainer.getBoundingClientRect().bottom;
        });
      }
      return finalBottom - lineHeight / 2;
    }
    case false: {
      let finalTop = top;
      if (scrollContainer && top > clientHeight - SCROLL_THRESHOLD) {
        scrollContainer.scrollTop = scrollContainer.scrollTop + (top + SCROLL_THRESHOLD - clientHeight);
        requestAnimationFrame(() => {
          finalTop = editableContainer.getBoundingClientRect().top;
        });
      }
      return finalTop + lineHeight / 2;
    }
  }
}
function focusTitle(page, index = Infinity, len = 0) {
  const pageComponent = getDefaultPage(page);
  if (!pageComponent) {
    throw new Error("Can't find page component!");
  }
  if (!pageComponent.titleVEditor) {
    throw new Error("Can't find title vEditor!");
  }
  if (index > pageComponent.titleVEditor.yText.length) {
    index = pageComponent.titleVEditor.yText.length;
  }
  pageComponent.titleVEditor.setVRange({ index, length: len });
}
async function focusRichText(editableContainer, position = "end", zoom = 1) {
  var _a10;
  const { left, right } = Rect.fromDOM(editableContainer);
  (_a10 = editableContainer.querySelector("v-line")) == null ? void 0 : _a10.scrollIntoView({ block: "nearest" });
  let range = null;
  switch (position) {
    case "start":
      range = setStartRange(editableContainer);
      break;
    case "end":
      range = setEndRange(editableContainer);
      break;
    default: {
      const { x: x2, y } = position;
      let newLeft = x2;
      const newTop = await setNewTop(y, editableContainer, zoom);
      if (x2 <= left) {
        newLeft = left + 1;
      }
      if (x2 >= right) {
        newLeft = right - 1;
      }
      range = caretRangeFromPoint(newLeft, newTop);
      break;
    }
  }
  resetNativeSelection(range);
}
function focusBlockByModel(model, position = "end", zoom = 1) {
  var _a10;
  if (matchFlavours(model, ["affine:frame", "affine:page"])) {
    throw new Error("Can't focus frame or page!");
  }
  const pageBlock = getPageBlock(model);
  assertExists(pageBlock);
  const isPageMode2 = pageBlock.tagName === "AFFINE-DEFAULT-PAGE";
  if (isPageMode2 && matchFlavours(model, [
    "affine:embed",
    "affine:divider",
    "affine:code",
    "affine:database",
    "affine:bookmark"
  ])) {
    pageBlock.selection.state.clearSelection();
    const rect = (_a10 = getBlockElementByModel(model)) == null ? void 0 : _a10.getBoundingClientRect();
    rect && pageBlock.slots.selectedRectsUpdated.emit([rect]);
    const element3 = getBlockElementByModel(model);
    assertExists(element3);
    pageBlock.selection.state.selectedBlocks.push(element3);
    if (matchFlavours(model, ["affine:database"])) {
      const elements = model.children.map((child) => getBlockElementByModel(child)).filter((element4) => element4 !== null);
      pageBlock.selection.state.selectedBlocks.push(...elements);
    }
    pageBlock.selection.state.type = "block";
    resetNativeSelection(null);
    document.activeElement.blur();
    return;
  }
  const element2 = getBlockElementByModel(model);
  const editableContainer = element2 == null ? void 0 : element2.querySelector("[contenteditable]");
  if (editableContainer) {
    if (isPageMode2) {
      pageBlock.selection.state.clearSelection();
      pageBlock.selection.setFocusedBlock(element2);
    }
    focusRichText(editableContainer, position, zoom);
  }
}
function focusPreviousBlock(model, position = "start", zoom = 1) {
  const pageBlock = getPageBlock(model);
  assertExists(pageBlock);
  let nextPosition = position;
  if (pageBlock.tagName === "AFFINE-DEFAULT-PAGE") {
    if (nextPosition) {
      pageBlock.lastSelectionPosition = nextPosition;
    } else if (pageBlock.lastSelectionPosition) {
      nextPosition = pageBlock.lastSelectionPosition;
    }
  }
  const preNodeModel = getPreviousBlock(model);
  if (preNodeModel && nextPosition) {
    focusBlockByModel(preNodeModel, nextPosition, zoom);
  }
}
function focusNextBlock(model, position = "start", zoom = 1) {
  const pageBlock = getPageBlock(model);
  assertExists(pageBlock);
  let nextPosition = position;
  if (pageBlock.tagName === "AFFINE-DEFAULT-PAGE") {
    if (nextPosition) {
      pageBlock.lastSelectionPosition = nextPosition;
    } else if (pageBlock.lastSelectionPosition) {
      nextPosition = pageBlock.lastSelectionPosition;
    }
  }
  const nextNodeModel = getNextBlock(model);
  if (nextNodeModel) {
    focusBlockByModel(nextNodeModel, nextPosition, zoom);
  }
}
function resetNativeSelection(range) {
  const selection = window.getSelection();
  assertExists(selection);
  selection.removeAllRanges();
  range && selection.addRange(range);
}
function clearSelection(page) {
  var _a10;
  if (!page.root)
    return;
  (_a10 = getPageBlock(page.root)) == null ? void 0 : _a10.selection.clear();
}
function hasNativeSelection() {
  const selection = window.getSelection();
  if (!selection)
    return false;
  return !!selection.rangeCount;
}
function isCollapsedNativeSelection() {
  const selection = window.getSelection();
  if (!selection)
    return false;
  return selection.isCollapsed;
}
function isRangeNativeSelection() {
  const selection = window.getSelection();
  if (!selection)
    return false;
  return !selection.isCollapsed;
}
function isMultiBlockRange(range = getCurrentNativeRange()) {
  return getModelsByRange(range).length > 1;
}
function isMultiLineRange(range = getCurrentNativeRange()) {
  const { height } = range.getBoundingClientRect();
  const oneLineRange = document.createRange();
  oneLineRange.setStart(range.startContainer, range.startOffset);
  const { height: oneLineHeight } = oneLineRange.getBoundingClientRect();
  return height > oneLineHeight;
}
function getCurrentNativeRange(selection = window.getSelection()) {
  if (!selection) {
    throw new Error("Failed to get current range, selection is null");
  }
  if (selection.rangeCount === 0) {
    throw new Error("Failed to get current range, rangeCount is 0");
  }
  if (selection.rangeCount > 1) {
    console.warn("getCurrentRange may be wrong, rangeCount > 1");
  }
  return selection.getRangeAt(0);
}
function handleInFrameDragMove(startContainer, startOffset, endContainer, endOffset, currentRange, isBackward) {
  if (isBackward) {
    currentRange.setEnd(endContainer, endOffset);
  } else {
    currentRange.setStart(startContainer, startOffset);
  }
  resetNativeSelection(currentRange);
}
function handleNativeRangeDragMove(startRange, e) {
  const isEdgelessMode = !!document.querySelector("affine-edgeless-page");
  const { clientX: x2, clientY: y, target } = e.raw;
  let currentRange = caretRangeFromPoint(x2, y);
  if (!currentRange)
    return;
  assertExists(startRange);
  const { startContainer, startOffset, endContainer, endOffset } = startRange;
  const _startContainer = startContainer.nodeType === Node.TEXT_NODE ? startContainer.parentElement : startContainer;
  const startFrame = _startContainer.closest("affine-frame");
  if (!startFrame)
    return;
  let currentFrame = null;
  let shouldUpdateCurrentRange = false;
  if (isEdgelessMode) {
    currentFrame = startFrame;
    shouldUpdateCurrentRange = true;
  } else {
    const el = document.elementFromPoint(x2, y);
    if (el == null ? void 0 : el.classList.contains("virgo-editor")) {
      return;
    }
    currentFrame = el == null ? void 0 : el.closest("affine-frame");
    const currentEditor = el == null ? void 0 : el.closest(".virgo-editor");
    shouldUpdateCurrentRange = !currentFrame || !currentEditor;
    currentFrame ?? (currentFrame = getClosestFrame(y));
  }
  if (!currentFrame)
    return;
  if (shouldUpdateCurrentRange) {
    let closestEditor = null;
    if (target && "closest" in target) {
      closestEditor = target.closest(".virgo-editor");
    }
    if (!closestEditor) {
      closestEditor = getClosestEditor(y, currentFrame);
    }
    if (!closestEditor)
      return;
    const newPoint = normalizePointIntoContainer({ x: x2, y }, closestEditor);
    currentRange = caretRangeFromPoint(newPoint.x, newPoint.y);
    if (!currentRange)
      return;
    if (currentRange.endContainer.nodeType !== Node.TEXT_NODE)
      return;
    if (!currentFrame.contains(currentRange.endContainer))
      return;
  }
  const isBackward = currentRange.comparePoint(endContainer, endOffset) === 1;
  handleInFrameDragMove(startContainer, startOffset, endContainer, endOffset, currentRange, isBackward);
}
function normalizePointIntoContainer(point, container) {
  const { top, left, right, bottom } = container.getBoundingClientRect();
  const newPoint = { ...point };
  const { x: x2, y } = point;
  if (y < top) {
    newPoint.y = top + 4;
    newPoint.x = left + 4;
  } else if (y > bottom) {
    newPoint.y = bottom - 4;
    newPoint.x = right - 4;
  } else {
    if (x2 < left) {
      newPoint.x = left;
    } else if (x2 > right) {
      newPoint.x = right;
    }
  }
  return newPoint;
}
function isBlankArea(e) {
  const { cursor } = window.getComputedStyle(e.raw.target);
  return cursor !== "text";
}
function retargetClick(page, e, container) {
  const targetElement = getElementFromEventTarget(e.raw.target);
  const block = targetElement == null ? void 0 : targetElement.closest(`[${BLOCK_ID_ATTR}]`);
  const parentModel = (block == null ? void 0 : block.model) || (block == null ? void 0 : block.pageModel);
  if (!parentModel)
    return;
  const shouldRetarget = matchFlavours(parentModel, [
    "affine:frame",
    "affine:page"
  ]);
  if (!shouldRetarget)
    return;
  const { clientX, clientY } = e.raw;
  const horizontalElement = getClosestEditor(clientY, container);
  if (horizontalElement == null ? void 0 : horizontalElement.closest("affine-database"))
    return;
  if (!horizontalElement)
    return;
  const model = getModelByElement(horizontalElement);
  const rect = horizontalElement.getBoundingClientRect();
  if (matchFlavours(model, nonTextBlock) && clientY > rect.bottom) {
    const parent = page.getParent(model);
    assertExists(parent);
    const id2 = page.addBlock("affine:paragraph", {}, parent.id);
    asyncFocusRichText(page, id2);
    return;
  }
  if (clientX < rect.left) {
    const range = setStartRange(horizontalElement);
    resetNativeSelection(range);
  } else {
    const range = setEndRange(horizontalElement);
    resetNativeSelection(range);
  }
}
function handleNativeRangeClick(page, e, container) {
  if (e.button)
    return;
  handleNativeRangeAtPoint(e.raw.clientX, e.raw.clientY);
  retargetClick(page, e, container);
}
function handleNativeRangeAtPoint(x2, y) {
  const range = caretRangeFromPoint(x2, y);
  const startContainer = range == null ? void 0 : range.startContainer;
  if (startContainer instanceof Node) {
    resetNativeSelection(range);
  }
}
function handleNativeRangeDblClick() {
  var _a10;
  const selection = window.getSelection();
  if (selection && selection.isCollapsed && selection.anchorNode) {
    const editableContainer = (_a10 = selection.anchorNode.parentElement) == null ? void 0 : _a10.closest("[contenteditable]");
    if (editableContainer) {
      return expandRangeByCharacter(selection, editableContainer);
    }
    return null;
  }
  return null;
}
function expandRangeByCharacter(selection, editableContainer) {
  const leafNodes = leftFirstSearchLeafNodes(editableContainer);
  if (!leafNodes.length) {
    return null;
  }
  const [newRange, currentChar, currentNodeIndex] = getNewRangeForDblClick(leafNodes, selection);
  const extendRange = trySelectBySegmenter(selection, newRange, currentChar, leafNodes, currentNodeIndex);
  if (extendRange) {
    resetNativeSelection(extendRange);
  }
  return extendRange;
}
function getNewStartAndEndForDblClick(currentNodeIndex, leafNodes, selection, checkReg) {
  var _a10, _b6, _c4;
  let newStartNode = leafNodes[0];
  let newStartOffset = 0;
  let newEndNode = leafNodes[leafNodes.length - 1];
  let newEndOffset = ((_a10 = newEndNode.textContent) == null ? void 0 : _a10.length) || 0;
  for (let i = currentNodeIndex; i >= 0; i--) {
    const node = leafNodes[i];
    if (node instanceof Text) {
      const text2 = (_b6 = node.textContent) == null ? void 0 : _b6.slice(0, i === currentNodeIndex ? selection.anchorOffset : void 0);
      if (text2) {
        const reverseText = Array.from(text2).reverse().join("");
        const index = reverseText.search(checkReg);
        if (index !== -1) {
          newStartNode = node;
          newStartOffset = reverseText.length - index;
          break;
        }
      }
    }
  }
  for (let j = currentNodeIndex; j < leafNodes.length; j++) {
    const node = leafNodes[j];
    if (node instanceof Text) {
      const text2 = (_c4 = node.textContent) == null ? void 0 : _c4.slice(j === currentNodeIndex ? selection.anchorOffset : void 0);
      if (text2) {
        const index = text2.search(checkReg);
        if (index !== -1) {
          newEndNode = node;
          newEndOffset = j === currentNodeIndex ? selection.anchorOffset + index : index;
          break;
        }
      }
    }
  }
  return [newStartNode, newStartOffset, newEndNode, newEndOffset];
}
function getNewRangeForDblClick(leafNodes, selection) {
  var _a10, _b6;
  let startNode = leafNodes[0];
  let startOffset = 0;
  let endNode = leafNodes[leafNodes.length - 1];
  let endOffset = ((_a10 = endNode.textContent) == null ? void 0 : _a10.length) || 0;
  const currentTextNode = selection.anchorNode instanceof Element ? selection.anchorNode.firstChild : selection.anchorNode;
  const currentChar = ((_b6 = currentTextNode == null ? void 0 : currentTextNode.textContent) == null ? void 0 : _b6[selection.anchorOffset]) || "";
  const currentNodeIndex = leafNodes.findIndex((node) => node === currentTextNode);
  if (currentChar && notStrictCharacterAndSpaceReg.test(currentChar) && currentTextNode) {
    startNode = currentTextNode;
    endNode = currentTextNode;
    startOffset = selection.anchorOffset;
    endOffset = selection.anchorOffset + 1;
  } else {
    let checkReg = notStrictCharacterReg;
    if (/\s/.test(currentChar)) {
      checkReg = /\S/;
    }
    if (/\w/.test(currentChar)) {
      checkReg = /\W/;
    }
    const [newStartNode, newStartOffset, newEndNode, newEndOffset] = getNewStartAndEndForDblClick(currentNodeIndex, leafNodes, selection, checkReg);
    startNode = newStartNode;
    startOffset = newStartOffset;
    endNode = newEndNode;
    endOffset = newEndOffset;
  }
  const newRange = document.createRange();
  newRange.setStart(startNode, startOffset);
  newRange.setEnd(endNode, endOffset);
  return [newRange, currentChar, currentNodeIndex];
}
function trySelectBySegmenter(selection, newRange, currentChar, leafNodes, currentNodeIndex) {
  var _a10, _b6;
  if (Intl.Segmenter && !notStrictCharacterAndSpaceReg.test(currentChar) && !/\w/.test(currentChar)) {
    const [currentCharIndex, wordText] = getCurrentCharIndex(newRange, leafNodes, selection, currentChar);
    if (currentCharIndex === -1 || currentNodeIndex === -1)
      return null;
    let leftLength = currentCharIndex;
    let rightLength = wordText.length - currentCharIndex;
    for (let i = currentNodeIndex; i >= 0; i--) {
      const leafNode = leafNodes[i];
      const allTextLength = i === currentNodeIndex ? selection.anchorOffset : ((_a10 = leafNode.textContent) == null ? void 0 : _a10.length) || 0;
      if (leftLength <= allTextLength) {
        newRange.setStart(leafNode, allTextLength - leftLength);
        break;
      } else {
        leftLength = leftLength - allTextLength;
      }
    }
    for (let i = currentNodeIndex; i < leafNodes.length; i++) {
      const leafNode = leafNodes[i];
      const textLength = ((_b6 = leafNode.textContent) == null ? void 0 : _b6.length) || 0;
      const allTextLength = i === currentNodeIndex ? textLength - selection.anchorOffset : textLength;
      if (rightLength <= allTextLength) {
        newRange.setEnd(leafNode, textLength - allTextLength + rightLength);
        break;
      } else {
        rightLength = rightLength - allTextLength;
      }
    }
  }
  return newRange;
}
function getCurrentCharIndex(newRange, leafNodes, selection, currentChar) {
  var _a10;
  const rangeString = newRange.toString();
  const segmenter = new Intl.Segmenter([], { granularity: "word" });
  const wordsIterator = segmenter.segment(rangeString)[Symbol.iterator]();
  const words = Array.from(wordsIterator);
  if (words.length === 0) {
    return [-1, ""];
  }
  let absoluteOffset = 0;
  let started = false;
  for (let i = 0; i < leafNodes.length; i++) {
    const leafNode = leafNodes[i];
    if (started || leafNode === newRange.startContainer) {
      started = true;
      if (leafNode !== selection.anchorNode) {
        absoluteOffset = absoluteOffset + (((_a10 = leafNode.textContent) == null ? void 0 : _a10.length) || 0);
      } else {
        absoluteOffset = absoluteOffset + selection.anchorOffset - newRange.startOffset;
        break;
      }
    }
  }
  let wordText = words[words.length - 1].segment;
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    if (absoluteOffset === word.index) {
      wordText = word.segment;
      break;
    }
    if (absoluteOffset < word.index) {
      wordText = words[i - 1].segment;
      break;
    }
  }
  const currentCharIndex = wordText.indexOf(currentChar);
  return [currentCharIndex, wordText];
}
function leftFirstSearchLeafNodes(node, leafNodes = []) {
  if (node.nodeType === Node.TEXT_NODE) {
    leafNodes.push(node);
  } else {
    const children = node.childNodes;
    for (let i = 0; i < children.length; i++) {
      leftFirstSearchLeafNodes(children[i], leafNodes);
    }
  }
  return leafNodes;
}
function getLastTextNode(node) {
  return leftFirstSearchLeafNodes(node).pop();
}
function getFirstTextNode(node) {
  return leftFirstSearchLeafNodes(node)[0];
}
function getSplicedTitle(title) {
  const text2 = [...title.value];
  assertExists(title.selectionStart);
  assertExists(title.selectionEnd);
  text2.splice(title.selectionStart, title.selectionEnd - title.selectionStart);
  return text2.join("");
}
function isEmbed(e) {
  if (e.raw.target.classList.contains("resize")) {
    return true;
  }
  return false;
}
function isDatabase(e) {
  const target = e.raw.target;
  if (!(target instanceof HTMLElement)) {
    return false;
  }
  if (
    // target.className.startsWith('affine-database') ||
    // // prevent select column from triggering block selection
    // target.tagName.startsWith('AFFINE-DATABASE')
    target.closest("affine-database-table")
  ) {
    return true;
  }
  return false;
}
function getHorizontalClosestElement(clientY, selector, container = document.body) {
  const elements = Array.from(container.querySelectorAll(selector)).sort((a2, b2) => (
    // getBoundingClientRect here actually run so fast because of the browser cache
    a2.getBoundingClientRect().top > b2.getBoundingClientRect().top ? 1 : -1
  ));
  const len = elements.length;
  if (len === 0)
    return null;
  if (len === 1)
    return elements[0];
  if (clientY < elements[0].getBoundingClientRect().top)
    return elements[0];
  if (clientY > elements[len - 1].getBoundingClientRect().bottom)
    return elements[len - 1];
  let left = 0;
  let right = len - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const minElement = elements[mid];
    if (clientY <= minElement.getBoundingClientRect().bottom && (mid === 0 || clientY > elements[mid - 1].getBoundingClientRect().bottom)) {
      return elements[mid];
    }
    if (minElement.getBoundingClientRect().top > clientY) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return null;
}
function getClosestEditor(clientY, container = document.body) {
  return getHorizontalClosestElement(clientY, ".virgo-editor", container);
}
function getClosestFrame(clientY) {
  return getHorizontalClosestElement(clientY, "affine-frame");
}
function handleNativeRangeTripleClick(e) {
  var _a10, _b6;
  const { raw: { clientX, clientY } } = e;
  const editor = (_a10 = document.elementFromPoint(clientX, clientY)) == null ? void 0 : _a10.closest(".virgo-editor");
  if (!editor)
    return null;
  const textNodes = getTextNodesFromElement(editor);
  const first = textNodes[0];
  const last2 = textNodes[textNodes.length - 1];
  const range = new Range();
  range.setStart(first, 0);
  range.setEnd(last2, Number((_b6 = last2.textContent) == null ? void 0 : _b6.length));
  resetNativeSelection(range);
  return range;
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/query.js
var ATTR_SELECTOR = `[${BLOCK_ID_ATTR}]`;
var MAX_SPACE = 32;
var STEPS = MAX_SPACE / 2 / 2;
function getNextBlock(model, map2 = {}) {
  if (model.id in map2) {
    throw new Error("Can't get next block! There's a loop in the block tree!");
  }
  map2[model.id] = true;
  const page = model.page;
  if (model.children.length) {
    return model.children[0];
  }
  let currentBlock = model;
  while (currentBlock) {
    const nextSibling = page.getNextSibling(currentBlock);
    if (nextSibling) {
      if (matchFlavours(nextSibling, ["affine:frame"])) {
        return getNextBlock(nextSibling);
      }
      return nextSibling;
    }
    currentBlock = page.getParent(currentBlock);
  }
  return null;
}
function getPreviousBlock(model, map2 = {}) {
  if (model.id in map2) {
    throw new Error("Can't get previous block! There's a loop in the block tree!");
  }
  map2[model.id] = true;
  const page = model.page;
  const parentBlock = page.getParent(model);
  if (!parentBlock) {
    return null;
  }
  const previousBlock = page.getPreviousSibling(model);
  if (!previousBlock) {
    if (matchFlavours(parentBlock, [
      "affine:frame",
      "affine:page",
      "affine:database"
    ])) {
      return getPreviousBlock(parentBlock);
    }
    return parentBlock;
  }
  if (previousBlock.children.length) {
    let lastChild = previousBlock.children[previousBlock.children.length - 1];
    while (lastChild.children.length) {
      lastChild = lastChild.children[lastChild.children.length - 1];
    }
    return lastChild;
  }
  return previousBlock;
}
function getPageBlock(model) {
  assertExists(model.page.root);
  return document.querySelector(`[${BLOCK_ID_ATTR}="${model.page.root.id}"]`);
}
function getDefaultPage(page) {
  const editor = getEditorContainer(page);
  if (editor.mode !== "page")
    return null;
  const pageComponent = editor.querySelector("affine-default-page");
  return pageComponent;
}
function getEdgelessPage(page) {
  const editor = getEditorContainer(page);
  if (editor.mode !== "edgeless")
    return null;
  const pageComponent = editor.querySelector("affine-edgeless-page");
  return pageComponent;
}
function getEditorContainer(page) {
  assertExists(page.root, "Failed to check page mode! Page root is not exists!");
  const pageBlock = getBlockElementById(page.root.id);
  const editorContainer = pageBlock == null ? void 0 : pageBlock.closest("editor-container");
  assertExists(editorContainer);
  return editorContainer;
}
function getEditorContainerByElement(ele) {
  const editorContainer = ele.closest("editor-container");
  assertExists(editorContainer);
  return editorContainer;
}
function isPageMode(page) {
  const editor = getEditorContainer(page);
  if (!("mode" in editor)) {
    throw new Error("Failed to check page mode! Editor mode is not exists!");
  }
  return editor.mode === "page";
}
function getViewportElement(page) {
  const isPage = isPageMode(page);
  if (!isPage)
    return null;
  assertExists(page.root);
  const defaultPageBlock = document.querySelector(`[${BLOCK_ID_ATTR}="${page.root.id}"]`);
  if (!defaultPageBlock || defaultPageBlock.closest("affine-default-page") !== defaultPageBlock) {
    throw new Error("Failed to get viewport element!");
  }
  return defaultPageBlock.viewportElement;
}
function getBlockElementByModel(model) {
  assertExists(model.page.root);
  const editor = activeEditorManager.getActiveEditor();
  const page = (editor ?? document).querySelector(`[${BLOCK_ID_ATTR}="${model.page.root.id}"]`);
  if (!page)
    return null;
  if (model.id === model.page.root.id) {
    return page;
  }
  return page.querySelector(`[${BLOCK_ID_ATTR}="${model.id}"]`);
}
function asyncGetBlockElementByModel(model) {
  assertExists(model.page.root);
  const editor = activeEditorManager.getActiveEditor();
  const page = (editor ?? document).querySelector(`[${BLOCK_ID_ATTR}="${model.page.root.id}"]`);
  if (!page)
    return Promise.resolve(null);
  if (model.id === model.page.root.id) {
    return Promise.resolve(page);
  }
  let resolved = false;
  return new Promise((resolve2, reject2) => {
    const onSuccess = (element2) => {
      resolved = true;
      observer.disconnect();
      resolve2(element2);
    };
    const onFail = () => {
      observer.disconnect();
      reject2(new Error(`Cannot find block element by model: ${model.flavour} id: ${model.id}`));
    };
    const observer = new MutationObserver(() => {
      const blockElement = page.querySelector(`[${BLOCK_ID_ATTR}="${model.id}"]`);
      if (blockElement) {
        onSuccess(blockElement);
      }
    });
    observer.observe(page, {
      childList: true,
      subtree: true
    });
    requestAnimationFrame(() => {
      if (!resolved) {
        const blockElement = getBlockElementByModel(model);
        if (blockElement) {
          onSuccess(blockElement);
        } else {
          onFail();
        }
      }
    });
  });
}
function getStartModelBySelection(range = getCurrentNativeRange()) {
  const startContainer = range.startContainer instanceof Text ? range.startContainer.parentElement : range.startContainer;
  const startComponent = startContainer.closest(`[${BLOCK_ID_ATTR}]`);
  if (!startComponent) {
    return null;
  }
  const startModel = startComponent.model;
  if (matchFlavours(startModel, ["affine:frame", "affine:page"])) {
    return null;
  }
  return startModel;
}
function getRichTextByModel(model) {
  const blockElement = getBlockElementByModel(model);
  const richText = blockElement == null ? void 0 : blockElement.querySelector("rich-text");
  if (!richText)
    return null;
  return richText;
}
async function asyncGetRichTextByModel(model) {
  const blockElement = await asyncGetBlockElementByModel(model);
  const richText = blockElement == null ? void 0 : blockElement.querySelector("rich-text");
  if (!richText)
    return null;
  return richText;
}
function getVirgoByModel(model) {
  if (matchFlavours(model, ["affine:database"])) {
    return null;
  }
  const richText = getRichTextByModel(model);
  if (!richText)
    return null;
  return richText.vEditor;
}
async function asyncGetVirgoByModel(model) {
  if (matchFlavours(model, ["affine:database"])) {
    throw new Error("Cannot get virgo by database model!");
  }
  const richText = await asyncGetRichTextByModel(model);
  if (!richText)
    return null;
  return richText.vEditor;
}
function getModelsByRange(range) {
  var _a10;
  if (range.startContainer.nodeType === Node.COMMENT_NODE || range.endContainer.nodeType === Node.COMMENT_NODE || range.commonAncestorContainer.nodeType === Node.COMMENT_NODE) {
    return [];
  }
  let commonAncestor = range.commonAncestorContainer;
  if (commonAncestor.nodeType === Node.TEXT_NODE) {
    const model = getStartModelBySelection(range);
    if (!model)
      return [];
    return [model];
  }
  if (commonAncestor.attributes && !commonAncestor.attributes.getNamedItem(BLOCK_ID_ATTR)) {
    const parentElement = (_a10 = commonAncestor.closest(ATTR_SELECTOR)) == null ? void 0 : _a10.parentElement;
    if (parentElement != null) {
      commonAncestor = parentElement;
    }
  }
  const intersectedModels = [];
  const blockElements = commonAncestor.querySelectorAll(ATTR_SELECTOR);
  if (!blockElements.length)
    return [];
  if (blockElements.length === 1) {
    const model = getStartModelBySelection(range);
    if (!model)
      return [];
    return [model];
  }
  Array.from(blockElements).filter((element2) => "model" in element2).forEach((element2) => {
    const block = element2;
    if (!block.model)
      return;
    const mainElement = matchFlavours(block.model, ["affine:page"]) ? element2 == null ? void 0 : element2.querySelector(".affine-default-page-block-title-container") : (element2 == null ? void 0 : element2.querySelector("rich-text")) || (element2 == null ? void 0 : element2.querySelector("img"));
    if (mainElement && range.intersectsNode(mainElement) && !matchFlavours(block.model, ["affine:frame", "affine:page"])) {
      intersectedModels.push(block.model);
    }
  });
  return intersectedModels;
}
function getModelByElement(element2) {
  const closestBlock = element2.closest(ATTR_SELECTOR);
  assertExists(closestBlock, "Cannot find block element by element");
  return getModelByBlockElement(closestBlock);
}
function isInsideRichText(element2) {
  if (element2 instanceof Event) {
    throw new Error('Did you mean "event.target"?');
  }
  if (!element2 || !(element2 instanceof Element)) {
    return false;
  }
  const richText = element2.closest("rich-text");
  return !!richText;
}
function isInsidePageTitle(element2) {
  const editor = activeEditorManager.getActiveEditor();
  const titleElement = (editor ?? document).querySelector('[data-block-is-title="true"]');
  if (!titleElement)
    return false;
  return titleElement.contains(element2);
}
function isInsideEdgelessTextEditor(element2) {
  const editor = activeEditorManager.getActiveEditor();
  const textElement = (editor ?? document).querySelector("surface-text-editor");
  if (!textElement)
    return false;
  return textElement.contains(element2);
}
function isDatabaseInput(element2) {
  return element2 instanceof HTMLElement && element2.getAttribute("data-virgo-root") === "true" && !!element2.closest("affine-database");
}
function isInsideDatabaseTitle(element2) {
  const titleElement = document.querySelector('[data-block-is-database-title="true"]');
  if (!titleElement)
    return false;
  return titleElement.contains(element2);
}
function isCaptionElement(node) {
  if (!(node instanceof Element)) {
    return false;
  }
  return node.classList.contains("affine-embed-wrapper-caption");
}
function getElementFromEventTarget(target) {
  if (!target)
    return null;
  if (target instanceof Element)
    return target;
  if (target instanceof Node)
    target.parentElement;
  return null;
}
function contains(parent, node) {
  return parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function isContainedIn(elements, node) {
  return elements.some((parent) => contains(parent, node));
}
function hasBlockId(element2) {
  return element2.hasAttribute(BLOCK_ID_ATTR);
}
function isDefaultPage({ tagName }) {
  return tagName === "AFFINE-DEFAULT-PAGE";
}
function isEdgelessPage({ tagName }) {
  return tagName === "AFFINE-EDGELESS-PAGE";
}
function isPageOrFrameOrSurface(element2) {
  return isDefaultPage(element2) || isEdgelessPage(element2) || isFrame(element2) || isSurface(element2);
}
function isBlock(element2) {
  return !isPageOrFrameOrSurface(element2);
}
function isImage({ tagName, firstElementChild }) {
  return tagName === "AFFINE-EMBED" && (firstElementChild == null ? void 0 : firstElementChild.tagName) === "AFFINE-IMAGE";
}
function isFrame({ tagName }) {
  return tagName === "AFFINE-FRAME";
}
function isSurface({ tagName }) {
  return tagName === "AFFINE-SURFACE";
}
function isEmbed2({ tagName }) {
  return tagName === "AFFINE-EMBED";
}
function isDatabase2({ tagName }) {
  return tagName === "AFFINE-DATABASE-TABLE" || tagName === "AFFINE-DATABASE";
}
function isEdgelessBlockChild({ classList }) {
  return classList.contains("affine-edgeless-block-child");
}
function getClosestBlockElementByPoint(point, state2 = null, scale = 1) {
  var _a10, _b6;
  const { y } = point;
  let container;
  let element2 = null;
  let bounds = null;
  let childBounds = null;
  let diff = 0;
  let n = 1;
  if (state2) {
    const { snapToEdge = { x: true, y: false } } = state2;
    container = state2.container;
    const rect = state2.rect || (container == null ? void 0 : container.getBoundingClientRect());
    if (rect) {
      if (snapToEdge.x) {
        point.x = Math.min(Math.max(point.x, rect.left) + BLOCK_CHILDREN_CONTAINER_PADDING_LEFT * scale - 1, rect.right - BLOCK_CHILDREN_CONTAINER_PADDING_LEFT * scale - 1);
      }
      if (snapToEdge.y) {
        if (scale !== 1) {
          console.warn("scale is not supported yet");
        }
        point.y = clamp(point.y, rect.top + 1, rect.bottom - 1);
      }
    }
  }
  element2 = findBlockElement(document.elementsFromPoint(point.x, point.y), container);
  if (element2) {
    if (isDatabase2(element2)) {
      bounds = element2.getBoundingClientRect();
      const rows = getDatabaseBlockRowsElement(element2);
      assertExists(rows);
      childBounds = rows.getBoundingClientRect();
      if (childBounds.height) {
        if (point.y < childBounds.top || point.y > childBounds.bottom) {
          return element2;
        }
        childBounds = null;
      } else {
        return element2;
      }
    } else {
      bounds = getRectByBlockElement(element2);
      childBounds = (_b6 = (_a10 = element2.querySelector(".affine-block-children-container")) == null ? void 0 : _a10.firstElementChild) == null ? void 0 : _b6.getBoundingClientRect();
      if (childBounds && childBounds.height) {
        if (bounds.x < point.x && point.x <= childBounds.x) {
          return element2;
        }
        childBounds = null;
      } else {
        return element2;
      }
    }
    bounds = null;
    element2 = null;
  }
  do {
    point.y = y - n * 2;
    if (n < 0)
      n--;
    n *= -1;
    element2 = findBlockElement(document.elementsFromPoint(point.x, point.y), container);
    if (element2) {
      bounds = getRectByBlockElement(element2);
      diff = bounds.bottom - point.y;
      if (diff >= 0 && diff <= STEPS * 2) {
        return element2;
      }
      diff = point.y - bounds.top;
      if (diff >= 0 && diff <= STEPS * 2) {
        return element2;
      }
      bounds = null;
      element2 = null;
    }
  } while (n <= STEPS);
  return element2;
}
function getClosestBlockElementByElement(element2) {
  if (!element2)
    return null;
  if (hasBlockId(element2) && isBlock(element2)) {
    return element2;
  }
  element2 = element2.closest(ATTR_SELECTOR);
  if (element2 && isBlock(element2)) {
    return element2;
  }
  return null;
}
function getModelByBlockElement(element2) {
  const containerBlock = element2;
  if ("hostModel" in containerBlock) {
    const loader = containerBlock;
    assertExists(loader.hostModel);
    return loader.hostModel;
  }
  assertExists(containerBlock.model);
  return containerBlock.model;
}
function getBlockElementsByElement(element2 = document) {
  return Array.from(element2.querySelectorAll(ATTR_SELECTOR)).filter(isBlock);
}
function getBlockElementById(id2, parent = activeEditorManager.getActiveEditor() ?? document) {
  return parent.querySelector(`[${BLOCK_ID_ATTR}="${id2}"]`);
}
function getClosestFrameBlockElementById(id2, parent = document) {
  const element2 = getBlockElementById(id2, parent);
  if (!element2)
    return null;
  if (isFrame(element2))
    return element2;
  return element2.closest("affine-frame");
}
function getRectByBlockElement(element2) {
  if (isDatabase2(element2))
    return element2.getBoundingClientRect();
  return (element2.firstElementChild ?? element2).getBoundingClientRect();
}
function getSelectedStateRectByBlockElement(element2) {
  if (isImage(element2)) {
    const wrapper = element2.querySelector(".affine-image-wrapper");
    const resizable = element2.querySelector(".resizable-img");
    assertExists(wrapper);
    assertExists(resizable);
    const w = Rect.fromDOM(wrapper);
    const r = Rect.fromDOM(resizable);
    const d3 = w.intersect(r);
    return d3.toDOMRect();
  }
  return getRectByBlockElement(element2);
}
function getBlockElementsExcludeSubtrees(elements) {
  if (elements.length <= 1)
    return elements;
  let parent = elements[0];
  return elements.filter((node, index) => {
    if (index === 0)
      return true;
    if (contains(parent, node)) {
      return false;
    } else {
      parent = node;
      return true;
    }
  });
}
function getBlockElementsIncludeSubtrees(elements) {
  return elements.reduce((elements2, element2) => {
    if (isDatabase2(element2)) {
      elements2.push(element2);
    } else {
      elements2.push(element2, ...getBlockElementsByElement(element2));
    }
    return elements2;
  }, []);
}
function findBlockElement(elements, parent) {
  const len = elements.length;
  let element2 = null;
  let i = 0;
  while (i < len) {
    element2 = elements[i];
    i++;
    if (parent && !contains(parent, element2))
      continue;
    if (hasBlockId(element2) && isBlock(element2))
      return element2;
    if (isEmbed2(element2)) {
      if (i < len && hasBlockId(elements[i]) && isBlock(elements[i])) {
        return elements[i];
      }
      return getClosestBlockElementByElement(element2);
    }
  }
  return null;
}
function queryCurrentMode() {
  const mode = getComputedStyle(document.documentElement).getPropertyValue("--affine-theme-mode");
  if (mode.trim() === "dark") {
    return "dark";
  } else {
    return "light";
  }
}
function getHoveringFrame(point) {
  return document.elementsFromPoint(point.x, point.y).find(isEdgelessBlockChild) || null;
}
function getDatabaseBlockTableElement(element2) {
  return element2.querySelector(".affine-database-block-table");
}
function getDatabaseBlockColumnHeaderElement(element2) {
  return element2.querySelector(".affine-database-column-header");
}
function getDatabaseBlockRowsElement(element2) {
  return element2.querySelector(".affine-database-block-rows");
}
var DropFlags;
(function(DropFlags2) {
  DropFlags2[DropFlags2["Normal"] = 0] = "Normal";
  DropFlags2[DropFlags2["Database"] = 1] = "Database";
  DropFlags2[DropFlags2["EmptyDatabase"] = 2] = "EmptyDatabase";
})(DropFlags || (DropFlags = {}));
function getDropRectByPoint(point, model, element2) {
  const result = {
    rect: getRectByBlockElement(element2),
    flag: DropFlags.Normal
  };
  const isDatabase3 = matchFlavours(model, ["affine:database"]);
  if (isDatabase3) {
    const table = getDatabaseBlockTableElement(element2);
    assertExists(table);
    let bounds = table.getBoundingClientRect();
    if (model.isEmpty()) {
      result.flag = DropFlags.EmptyDatabase;
      if (point.y < bounds.top)
        return result;
      const header = getDatabaseBlockColumnHeaderElement(element2);
      assertExists(header);
      bounds = header.getBoundingClientRect();
      result.rect = new DOMRect(result.rect.left, bounds.bottom, result.rect.width, 1);
    } else {
      result.flag = DropFlags.Database;
      const rows = getDatabaseBlockRowsElement(element2);
      assertExists(rows);
      const rowsBounds = rows.getBoundingClientRect();
      if (point.y < rowsBounds.top || point.y > rowsBounds.bottom)
        return result;
      const elements = document.elementsFromPoint(point.x, point.y);
      const len = elements.length;
      let e;
      let i = 0;
      for (; i < len; i++) {
        e = elements[i];
        if (e.classList.contains("affine-database-block-row-cell-content")) {
          result.rect = getCellRect(e, bounds);
          return result;
        }
        if (e.classList.contains("affine-database-block-row")) {
          e = e.querySelector(ATTR_SELECTOR);
          assertExists(e);
          result.rect = getCellRect(e, bounds);
          return result;
        }
      }
    }
  } else {
    const parent = element2.parentElement;
    if (parent == null ? void 0 : parent.classList.contains("affine-database-block-row-cell-content")) {
      result.flag = DropFlags.Database;
      result.rect = getCellRect(parent);
      return result;
    }
  }
  return result;
}
function getCellRect(element2, bounds) {
  if (!bounds) {
    const table = element2.closest(".affine-database-block-table");
    assertExists(table);
    bounds = table.getBoundingClientRect();
  }
  const col = element2.parentElement;
  assertExists(col);
  const row = col.parentElement;
  assertExists(row);
  const colRect = col.getBoundingClientRect();
  const rowRect = row.getBoundingClientRect();
  return new DOMRect(bounds.left, rowRect.top, colRect.right - bounds.left, colRect.height);
}
function isElement(target) {
  return target && target instanceof Element;
}
function isSelectedBlocks(target) {
  return target.tagName === "AFFINE-SELECTED-BLOCKS";
}
function isDragHandle(target) {
  return target.tagName === "AFFINE-DRAG-HANDLE";
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/common-operations.js
async function asyncSetVRange(model, vRange) {
  var _a10;
  const richText = await asyncGetRichTextByModel(model);
  (_a10 = richText == null ? void 0 : richText.vEditor) == null ? void 0 : _a10.setVRange(vRange);
  return new Promise((resolve2) => {
    var _a11;
    (_a11 = richText == null ? void 0 : richText.vEditor) == null ? void 0 : _a11.slots.rangeUpdated.once(() => {
      resolve2();
    });
  });
}
function asyncFocusRichText(page, id2, vRange = { index: 0, length: 0 }) {
  const model = page.getBlockById(id2);
  assertExists(model);
  if (matchFlavours(model, ["affine:divider"]))
    return;
  return asyncSetVRange(model, vRange);
}
function isCollapsedAtBlockStart(vEditor) {
  const vRange = vEditor.getVRange();
  return (vRange == null ? void 0 : vRange.index) === 0 && (vRange == null ? void 0 : vRange.length) === 0;
}
function isInSamePath(page, children, father) {
  if (children === father) {
    return true;
  }
  let parent;
  for (; ; ) {
    parent = page.getParent(children);
    if (parent === null) {
      return false;
    } else if (parent.id === father.id) {
      return true;
    }
    children = parent;
  }
}
function convertToList(page, model, listType, prefix2, otherProperties) {
  var _a10, _b6, _c4, _d3, _e2;
  if (matchFlavours(model, ["affine:list"]) && model["type"] === listType) {
    return false;
  }
  if (matchFlavours(model, ["affine:paragraph"])) {
    const parent = page.getParent(model);
    if (!parent)
      return false;
    const index = parent.children.indexOf(model);
    (_a10 = model.text) == null ? void 0 : _a10.insert(" ", prefix2.length);
    page.captureSync();
    (_b6 = model.text) == null ? void 0 : _b6.delete(0, prefix2.length + 1);
    const blockProps = {
      type: listType,
      text: (_c4 = model.text) == null ? void 0 : _c4.clone(),
      children: model.children,
      ...otherProperties
    };
    page.deleteBlock(model);
    const id2 = page.addBlock("affine:list", blockProps, parent, index);
    asyncFocusRichText(page, id2);
  } else if (matchFlavours(model, ["affine:list"]) && model["type"] !== listType) {
    (_d3 = model.text) == null ? void 0 : _d3.insert(" ", prefix2.length);
    page.captureSync();
    (_e2 = model.text) == null ? void 0 : _e2.delete(0, prefix2.length + 1);
    page.updateBlock(model, { type: listType });
    asyncFocusRichText(page, model.id);
  }
  return true;
}
function convertToParagraph(page, model, type, prefix2) {
  var _a10, _b6, _c4, _d3, _e2;
  if (matchFlavours(model, ["affine:paragraph"]) && model["type"] === type) {
    return false;
  }
  if (!matchFlavours(model, ["affine:paragraph"])) {
    const parent = page.getParent(model);
    if (!parent)
      return false;
    const index = parent.children.indexOf(model);
    (_a10 = model.text) == null ? void 0 : _a10.insert(" ", prefix2.length);
    page.captureSync();
    (_b6 = model.text) == null ? void 0 : _b6.delete(0, prefix2.length + 1);
    const blockProps = {
      type,
      text: (_c4 = model.text) == null ? void 0 : _c4.clone(),
      children: model.children
    };
    page.deleteBlock(model);
    const id2 = page.addBlock("affine:paragraph", blockProps, parent, index);
    asyncFocusRichText(page, id2);
  } else if (matchFlavours(model, ["affine:paragraph"]) && model["type"] !== type) {
    (_d3 = model.text) == null ? void 0 : _d3.insert(" ", prefix2.length);
    page.captureSync();
    (_e2 = model.text) == null ? void 0 : _e2.delete(0, prefix2.length + 1);
    const vEditor = getVirgoByModel(model);
    if (vEditor) {
      vEditor.setVRange({
        index: 0,
        length: 0
      });
    }
    page.updateBlock(model, { type });
  }
  return true;
}
function convertToDivider(page, model, prefix2) {
  var _a10, _b6;
  if (matchFlavours(model, ["affine:divider"]) || model.type === "quote") {
    return false;
  }
  if (!matchFlavours(model, ["affine:divider"])) {
    const parent = page.getParent(model);
    if (!parent)
      return false;
    const index = parent.children.indexOf(model);
    (_a10 = model.text) == null ? void 0 : _a10.insert(" ", prefix2.length);
    page.captureSync();
    (_b6 = model.text) == null ? void 0 : _b6.delete(0, prefix2.length + 1);
    const blockProps = {
      children: model.children
    };
    page.addBlock("affine:divider", blockProps, parent, index);
    const nextBlock = parent.children[index + 1];
    if (nextBlock) {
      asyncFocusRichText(page, nextBlock.id);
    } else {
      const nextId = page.addBlock("affine:paragraph", {}, parent);
      asyncFocusRichText(page, nextId);
    }
  }
  return true;
}
function createBookmarkBlock(parentModel, index) {
  const { page } = parentModel;
  const id2 = page.addBlock("affine:bookmark", { url: "" }, parentModel.id, index);
  requestAnimationFrame(() => {
    const model = page.getBlockById(id2);
    const element2 = getBlockElementByModel(model);
    element2.slots.openInitialModal.emit();
  });
  return id2;
}

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/rich-text-operations.js
function handleBlockEndEnter(page, model) {
  var _a10;
  const parent = page.getParent(model);
  const nextSibling = page.getNextSibling(model);
  if (!parent) {
    return;
  }
  const getProps = () => {
    const shouldInheritFlavour = matchFlavours(model, ["affine:list"]);
    if (shouldInheritFlavour) {
      return [model.flavour, { type: model.type }];
    }
    return ["affine:paragraph", { type: "text" }];
  };
  const [flavour, blockProps] = getProps();
  if (utils_exports.isInsideBlockByFlavour(page, model, "affine:database")) {
    page.captureSync();
    const index2 = parent.children.findIndex((child) => child.id === model.id);
    let newParent = parent;
    let newBlockIndex = index2 + 1;
    const childrenLength = parent.children.length;
    if (index2 === childrenLength - 1 && ((_a10 = model.text) == null ? void 0 : _a10.yText.length) === 0) {
      if (childrenLength !== 1) {
        page.deleteBlock(model);
      }
      const nextModel = page.getNextSibling(newParent);
      if (nextModel && matchFlavours(nextModel, ["affine:paragraph"])) {
        asyncFocusRichText(page, nextModel.id, {
          index: nextModel.text.yText.length,
          length: 0
        });
        return;
      }
      const prevParent = page.getParent(parent);
      if (!prevParent)
        return;
      const prevIndex = prevParent.children.findIndex((child) => child.id === parent.id);
      newParent = prevParent;
      newBlockIndex = prevIndex + 1;
    }
    const id3 = page.addBlock(flavour, blockProps, newParent, newBlockIndex);
    asyncFocusRichText(page, id3);
    return;
  }
  const index = parent.children.indexOf(model);
  if (index === -1) {
    return;
  }
  page.captureSync();
  const id2 = !model.children.length ? page.addBlock(flavour, blockProps, parent, index + 1) : (
    // If the block has children, insert a new block as the first child
    page.addBlock(flavour, blockProps, model, 0)
  );
  if (matchFlavours(model, ["affine:list"]) && model.type === "numbered") {
    let next = nextSibling;
    while (next && matchFlavours(next, ["affine:list"]) && model.type === "numbered") {
      page.updateBlock(next, {});
      next = page.getNextSibling(next);
    }
  }
  asyncFocusRichText(page, id2);
}
function handleSoftEnter(page, model, index, length4) {
  if (!model.text) {
    console.error("Failed to handle soft enter! No text found!", model);
    return;
  }
  page.captureSync();
  model.text.replace(index, length4, "\n");
}
function handleBlockSplit(page, model, splitIndex, splitLength) {
  if (!(model.text instanceof Text2))
    return;
  if (model.text.yText.length < splitIndex + splitLength)
    return;
  const parent = page.getParent(model);
  if (!parent)
    return;
  page.captureSync();
  const right = model.text.split(splitIndex, splitLength);
  let newParent = parent;
  let newBlockIndex = newParent.children.indexOf(model) + 1;
  if (matchFlavours(model, ["affine:list"]) && model.children.length > 0) {
    newParent = model;
    newBlockIndex = 0;
  }
  const children = [...model.children];
  page.updateBlock(model, { children: [] });
  const id2 = page.addBlock(model.flavour, {
    text: right,
    type: model.type,
    children
  }, newParent, newBlockIndex);
  return asyncFocusRichText(page, id2);
}
function handleIndent(page, model, offset = 0) {
  const previousSibling = page.getPreviousSibling(model);
  const nextSibling = page.getNextSibling(model);
  if (!previousSibling || !supportsChildren(previousSibling)) {
    return;
  }
  const parent = page.getParent(model);
  if (!parent)
    return;
  page.captureSync();
  const children = model.children;
  page.updateBlock(model, {
    children: []
  });
  page.updateBlock(parent, {
    children: parent.children.filter((child) => child.id !== model.id)
  });
  page.updateBlock(previousSibling, {
    children: [...previousSibling.children, model, ...children]
  });
  if (matchFlavours(model, ["affine:list"]) && model.type === "numbered") {
    let next = nextSibling;
    while (next && matchFlavours(next, ["affine:list"]) && model.type === "numbered") {
      page.updateBlock(next, {});
      next = page.getNextSibling(next);
    }
  }
  assertExists(model);
  asyncSetVRange(model, { index: offset, length: 0 });
}
function handleMultiBlockIndent(page, models) {
  if (!models.length)
    return;
  const previousSibling = page.getPreviousSibling(models[0]);
  const nextSibling = page.getNextSibling(models.at(-1));
  if (!previousSibling || !supportsChildren(previousSibling)) {
    return;
  }
  if (!models.every((model, idx, array) => {
    const previousModel = array.at(idx - 1);
    if (!previousModel) {
      return false;
    }
    const p1 = page.getParent(model);
    const p2 = page.getParent(previousModel);
    return p1 && p2 && p1.id === p2.id;
  })) {
    return;
  }
  page.captureSync();
  const parent = page.getParent(models[0]);
  assertExists(parent);
  models.forEach((model) => {
    const children = model.children;
    page.updateBlock(model, {
      children: []
    });
    page.updateBlock(parent, {
      children: parent.children.filter((child) => child.id !== model.id)
    });
    page.updateBlock(previousSibling, {
      children: [...previousSibling.children, model, ...children]
    });
    if (matchFlavours(model, ["affine:list"]) && model.type === "numbered") {
      let next = nextSibling;
      while (next && matchFlavours(next, ["affine:list"]) && model.type === "numbered") {
        page.updateBlock(next, {});
        next = page.getNextSibling(next);
      }
    }
    assertExists(model);
    asyncSetVRange(model, { index: 0, length: 0 });
  });
}
function handleUnindent(page, model, offset = 0, capture = true) {
  const parent = page.getParent(model);
  if (!parent || matchFlavours(parent, ["affine:frame"])) {
    return;
  }
  const grandParent = page.getParent(parent);
  if (!grandParent)
    return;
  if (capture) {
    page.captureSync();
  }
  const previousSiblings = page.getPreviousSiblings(model);
  const nextSiblings = page.getNextSiblings(model);
  page.updateBlock(parent, {
    children: previousSiblings
  });
  const index = grandParent.children.indexOf(parent);
  page.updateBlock(grandParent, {
    children: [
      ...grandParent.children.slice(0, index + 1),
      model,
      ...grandParent.children.slice(index + 1)
    ]
  });
  page.updateBlock(model, {
    children: [...model.children, ...nextSiblings]
  });
  const nextSibling = page.getNextSibling(model);
  if (matchFlavours(model, ["affine:list"]) && model.type === "numbered") {
    let next = nextSibling;
    while (next && matchFlavours(next, ["affine:list"]) && model.type === "numbered") {
      page.updateBlock(next, {});
      next = page.getNextSibling(next);
    }
  }
  assertExists(model);
  asyncSetVRange(model, { index: offset, length: 0 });
}
function handleCodeBlockBackspace(page, model) {
  if (!matchFlavours(model, ["affine:code"]))
    return false;
  focusBlockByModel(model);
  return true;
}
function handleDatabaseBlockBackspace(page, model) {
  if (!utils_exports.isInsideBlockByFlavour(page, model, "affine:database"))
    return false;
  return true;
}
function handleListBlockBackspace(page, model) {
  var _a10;
  if (!matchFlavours(model, ["affine:list"]))
    return false;
  const parent = page.getParent(model);
  if (!parent)
    return false;
  const index = parent.children.indexOf(model);
  const blockProps = {
    type: "text",
    text: (_a10 = model.text) == null ? void 0 : _a10.clone(),
    children: model.children
  };
  page.captureSync();
  page.deleteBlock(model);
  const id2 = page.addBlock("affine:paragraph", blockProps, parent, index);
  asyncFocusRichText(page, id2);
  return true;
}
function handleParagraphDeleteActions(page, model) {
  function handleParagraphOrListSibling(page2, model2, previousSibling2, parent2) {
    var _a10, _b6, _c4;
    if (!previousSibling2 || !matchFlavours(previousSibling2, ["affine:paragraph", "affine:list"]))
      return false;
    page2.captureSync();
    const preTextLength = ((_a10 = previousSibling2.text) == null ? void 0 : _a10.length) || 0;
    ((_b6 = model2.text) == null ? void 0 : _b6.length) && ((_c4 = previousSibling2.text) == null ? void 0 : _c4.join(model2.text));
    page2.deleteBlock(model2, {
      bringChildrenTo: parent2
    });
    const vEditor = getVirgoByModel(previousSibling2);
    vEditor == null ? void 0 : vEditor.setVRange({
      index: preTextLength,
      length: 0
    });
    return true;
  }
  function handleEmbedDividerCodeSibling(page2, model2, previousSibling2) {
    var _a10;
    if (!previousSibling2 || !matchFlavours(previousSibling2, [
      "affine:embed",
      "affine:divider",
      "affine:code"
    ]))
      return false;
    focusBlockByModel(previousSibling2);
    if (!((_a10 = model2.text) == null ? void 0 : _a10.length)) {
      page2.captureSync();
      page2.deleteBlock(model2);
    }
    return true;
  }
  function handleNoPreviousSibling(page2, model2, previousSibling2) {
    if (previousSibling2)
      return false;
    const text2 = model2.text;
    const titleElement = document.querySelector(".affine-default-page-block-title");
    const pageModel = getModelByElement(titleElement);
    const title = pageModel.title;
    page2.captureSync();
    let textLength = 0;
    if (text2) {
      textLength = text2.length;
      title.join(text2);
    }
    page2.deleteBlock(model2);
    focusTitle(page2, title.length - textLength);
    return true;
  }
  const parent = page.getParent(model);
  if (!parent)
    return false;
  const previousSibling = getPreviousBlock(model);
  if (matchFlavours(parent, ["affine:database"])) {
    if (previousSibling) {
      page.deleteBlock(model);
      focusBlockByModel(previousSibling);
      return true;
    } else {
      return handleNoPreviousSibling(page, model, previousSibling);
    }
  } else if (matchFlavours(parent, ["affine:frame"])) {
    return handleParagraphOrListSibling(page, model, previousSibling, parent) || handleEmbedDividerCodeSibling(page, model, previousSibling) || handleNoPreviousSibling(page, model, previousSibling);
  }
  return false;
}
function handleParagraphBlockBackspace(page, model) {
  if (!matchFlavours(model, ["affine:paragraph"]))
    return false;
  if (model.type !== "text") {
    page.captureSync();
    page.updateBlock(model, { type: "text" });
    return true;
  }
  const isHandled = handleParagraphDeleteActions(page, model);
  if (isHandled)
    return true;
  handleUnindent(page, model);
  return true;
}
function handleUnknownBlockBackspace(model) {
  throw new Error("Failed to handle backspace! Unknown block flavours! flavour:" + model.flavour);
}
function handleLineStartBackspace(page, model) {
  if (handleCodeBlockBackspace(page, model) || handleListBlockBackspace(page, model) || handleParagraphBlockBackspace(page, model)) {
    handleDatabaseBlockBackspace(page, model);
    return;
  }
  handleUnknownBlockBackspace(model);
}
function handleKeyUp(event, editableContainer) {
  const range = getCurrentNativeRange();
  if (!range.collapsed) {
    range.collapse(true);
  }
  const isFirstLine = checkFirstLine(range, editableContainer);
  if (isFirstLine) {
    return PREVENT_DEFAULT;
  }
  event.stopPropagation();
  return ALLOW_DEFAULT;
}
function handleKeyDown(block, event, editableContainer) {
  const range = getCurrentNativeRange();
  if (!range.collapsed) {
    range.collapse();
  }
  const isLastLine = checkLastLine(range, editableContainer);
  if (isLastLine) {
    return getNextBlock(block) ? PREVENT_DEFAULT : ALLOW_DEFAULT;
  }
  event.stopPropagation();
  return ALLOW_DEFAULT;
}

export {
  IS_IOS,
  IS_MAC,
  SHORT_KEY,
  CSSResult,
  css,
  html,
  svg,
  noChange,
  nothing,
  render,
  LitElement,
  DatabaseSearchIcon,
  DatabaseDuplicate,
  DatabaseInsertLeft,
  DatabaseInsertRight,
  DatabaseMoveLeft,
  DatabaseMoveRight,
  DatabaseMultiSelect,
  DatabaseNumber,
  DatabaseSelect,
  DatabaseProgress,
  DatabaseSearchClose,
  DatabaseDone,
  DatabaseAddColumn,
  DatabaseDragIcon,
  SelectIcon,
  ShapeIcon,
  ImageIcon,
  ImageIcon20,
  EmbedIcon,
  BookmarkIcon,
  ConnectorIcon,
  PenIcon,
  HandIcon,
  SquareIcon,
  EllipseIcon,
  DiamondIcon,
  TriangleIcon,
  RoundedRectangleIcon,
  MinusIcon,
  PlusIcon,
  ViewBarIcon,
  TransparentIcon,
  MoreHorizontalIcon,
  LineStyleIcon,
  ConnectorXIcon,
  ConnectorLIcon,
  DashLineIcon,
  BanIcon,
  NoteIcon,
  ImportIcon,
  AlighLeftIcon,
  AlignCenterIcon,
  AlignRightIcon,
  CloseIcon,
  ExportToMarkdownIcon,
  ExportToHTMLIcon,
  NotionIcon,
  NewIcon,
  HelpIcon,
  TextIcon,
  TextIconLarge,
  NumberedListIconLarge,
  DatabaseTableViewIcon,
  DatabaseKanbanViewIcon,
  TodoIcon,
  BoldIcon,
  ItalicIcon,
  UnderlineIcon,
  StrikethroughIcon,
  InlineCodeIcon,
  LinkIcon,
  FontLinkIcon,
  CopyIcon,
  DuplicateIcon,
  DeleteIcon,
  TodayIcon,
  TomorrowIcon,
  YesterdayIcon,
  NowIcon,
  CrossIcon,
  BlockHubIcon20,
  BlockHubIcon,
  BlockHubRoundedRectangleIcon,
  SearchIcon,
  ConfirmIcon,
  EditIcon,
  UnlinkIcon,
  LinkToCardIcon,
  CaptionIcon,
  DownloadIcon,
  WrapIcon,
  CancelWrapIcon,
  ArrowDownIcon,
  FontPageIcon,
  FontLinkedPageIcon,
  PageIcon,
  LinkedPageIcon,
  NewPageIcon,
  DualLinkIcon,
  DualLinkIcon16,
  paragraphConfig,
  BLOCKHUB_TEXT_ITEMS,
  BLOCKHUB_LIST_ITEMS,
  BLOCKHUB_FILE_ITEMS,
  BLOCK_ID_ATTR,
  BLOCK_SERVICE_LOADING_ATTR,
  PREVENT_DEFAULT,
  ALLOW_DEFAULT,
  HOTKEYS,
  SCROLL_THRESHOLD,
  EDITOR_WIDTH,
  BLOCK_CHILDREN_CONTAINER_PADDING_LEFT,
  PAGE_BLOCK_PADDING_BOTTOM,
  PAGE_BLOCK_CHILD_PADDING,
  DRAG_HANDLE_OFFSET_LEFT,
  EDGELESS_BLOCK_CHILD_PADDING,
  FRAME_BACKGROUND_COLORS,
  customElement,
  property,
  state,
  query,
  queryAll,
  DisposableGroup,
  Slot,
  isFirefox,
  caretRangeFromPoint,
  assertExists,
  assertNotExists,
  assertFlavours,
  matchFlavours,
  assertEquals,
  isEqual,
  sleep,
  PartType,
  directive,
  Directive,
  setCommittedValue,
  repeat2 as repeat,
  nanoid,
  nanoid2,
  z,
  Doc,
  UndoManager,
  YMap,
  YText,
  Text2 as Text,
  defineBlockSchema,
  BaseBlockModel,
  utils_exports,
  Page,
  Workspace,
  activeEditorManager,
  BrushSize,
  AbstractSelectionManager,
  supportsChildren,
  isEmpty2 as isEmpty,
  almostEqual,
  createEvent,
  noop,
  throttle,
  debounce,
  clamp,
  countBy,
  maxBy,
  isControlledKeyboardEvent,
  isPrintableKeyEvent,
  atLeastNMatches,
  groupBy,
  isFuzzyMatch,
  Point,
  Rect,
  ZERO_WIDTH_SPACE,
  ZERO_WIDTH_NON_JOINER,
  styleMap,
  VText,
  baseTextAttributes,
  VEditor,
  asyncSetVRange,
  asyncFocusRichText,
  isCollapsedAtBlockStart,
  isInSamePath,
  convertToList,
  convertToParagraph,
  convertToDivider,
  createBookmarkBlock,
  focusTitle,
  focusBlockByModel,
  focusPreviousBlock,
  focusNextBlock,
  resetNativeSelection,
  clearSelection,
  hasNativeSelection,
  isMultiBlockRange,
  isMultiLineRange,
  getCurrentNativeRange,
  handleNativeRangeDragMove,
  isBlankArea,
  handleNativeRangeClick,
  handleNativeRangeAtPoint,
  handleNativeRangeDblClick,
  isEmbed,
  handleNativeRangeTripleClick,
  selection_exports,
  getPreviousBlock,
  getPageBlock,
  getDefaultPage,
  getEdgelessPage,
  getEditorContainer,
  getEditorContainerByElement,
  isPageMode,
  getViewportElement,
  getBlockElementByModel,
  asyncGetBlockElementByModel,
  getRichTextByModel,
  asyncGetRichTextByModel,
  getVirgoByModel,
  asyncGetVirgoByModel,
  getModelsByRange,
  getModelByElement,
  isInsideRichText,
  isInsidePageTitle,
  isInsideEdgelessTextEditor,
  isDatabaseInput,
  isInsideDatabaseTitle,
  isCaptionElement,
  contains,
  isContainedIn,
  isImage,
  getClosestBlockElementByPoint,
  getClosestBlockElementByElement,
  getModelByBlockElement,
  getBlockElementsByElement,
  getBlockElementById,
  getClosestFrameBlockElementById,
  getRectByBlockElement,
  getSelectedStateRectByBlockElement,
  getBlockElementsExcludeSubtrees,
  getBlockElementsIncludeSubtrees,
  queryCurrentMode,
  getHoveringFrame,
  DropFlags,
  getDropRectByPoint,
  isElement,
  isSelectedBlocks,
  isDragHandle,
  isAtLineEdge,
  handleBlockEndEnter,
  handleSoftEnter,
  handleBlockSplit,
  handleIndent,
  handleMultiBlockIndent,
  handleUnindent,
  handleLineStartBackspace,
  handleKeyUp,
  handleKeyDown
};
/*! Bundled license information:

simple-peer/simplepeer.min.js:
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <https://feross.org>
  * @license  MIT
  *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@lit/reactive-element/development/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/development/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-OZBHL7FS.js.map
