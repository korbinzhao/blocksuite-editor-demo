import {
  BlockHub,
  BookmarkBlockSchema,
  CodeBlockSchema,
  DividerBlockSchema,
  EmbedBlockSchema,
  FrameBlockSchema,
  ListBlockSchema,
  PageBlockSchema,
  ParagraphBlockSchema,
  ShadowlessElement,
  SurfaceBlockSchema,
  ThemeObserver,
  WithDisposable,
  edgelessPreset,
  getAllowSelectedBlocks,
  getCurrentBlockRange,
  getServiceOrRegister,
  pagePreset,
  tryUpdateFrameSize,
  uploadImageFromLocal
} from "./chunk-ZGY32QOB.js";
import {
  Directive,
  LitElement,
  PAGE_BLOCK_PADDING_BOTTOM,
  Rect,
  Slot,
  Workspace,
  activeEditorManager,
  assertExists,
  asyncFocusRichText,
  createBookmarkBlock,
  customElement,
  directive,
  getClosestFrameBlockElementById,
  getEdgelessPage,
  getHoveringFrame,
  getPageBlock,
  html,
  isFirefox,
  nothing,
  property,
  query,
  setCommittedValue
} from "./chunk-OZBHL7FS.js";
import "./chunk-AX6B7HUW.js";

// node_modules/lit-html/development/directives/keyed.js
var Keyed = class extends Directive {
  constructor() {
    super(...arguments);
    this.key = nothing;
  }
  render(k, v) {
    this.key = k;
    return v;
  }
  update(part, [k, v]) {
    if (k !== this.key) {
      setCommittedValue(part);
      this.key = k;
    }
    return v;
  }
};
var keyed = directive(Keyed);

// node_modules/@blocksuite/editor/dist/utils/editor.js
var checkEditorElementActive = () => {
  var _a;
  return ((_a = document.activeElement) == null ? void 0 : _a.closest("editor-container")) != null;
};
var createBlockHub = (editor, page) => {
  const blockHub = new BlockHub({
    mouseRoot: editor,
    enableDatabase: !!page.awarenessStore.getFlag("enable_database"),
    onClickCard: async (data) => {
      var _a, _b, _c, _d;
      const models = [];
      const isDatabase = data.flavour === "affine:database";
      if (isDatabase && !page.awarenessStore.getFlag("enable_database")) {
        console.warn("database block is not enabled");
        return;
      }
      if (data.flavour === "affine:embed" && data.type === "image") {
        models.push(...await uploadImageFromLocal(page));
      } else {
        models.push(data);
      }
      const last = (_a = page.root) == null ? void 0 : _a.lastItem();
      const range = getCurrentBlockRange(page);
      if (range) {
        const lastModel = range.models[range.models.length - 1];
        if (data.flavour === "affine:bookmark") {
          const parent = page.getParent(lastModel);
          assertExists(parent);
          const index = parent.children.indexOf(lastModel);
          createBookmarkBlock(parent, index + 1);
          return;
        }
        const arr = page.addSiblingBlocks(lastModel, models, "after");
        const lastId = arr[arr.length - 1];
        asyncFocusRichText(page, lastId);
      } else if (last) {
        if (data.flavour === "affine:bookmark") {
          createBookmarkBlock((_b = page.root) == null ? void 0 : _b.lastItem());
          return;
        }
        let lastId = (_d = (_c = page.root) == null ? void 0 : _c.lastItem()) == null ? void 0 : _d.id;
        models.forEach((model) => {
          var _a2;
          lastId = page.addBlock(model.flavour ?? "affine:paragraph", model, (_a2 = page.root) == null ? void 0 : _a2.lastItem());
        });
        lastId && asyncFocusRichText(page, lastId);
      }
    },
    onDrop: async (e, point, end, type) => {
      const dataTransfer = e.dataTransfer;
      assertExists(dataTransfer);
      const data = dataTransfer.getData("affine/block-hub");
      const models = [];
      const props = JSON.parse(data);
      const isDatabase = props.flavour === "affine:database";
      if (isDatabase && !page.awarenessStore.getFlag("enable_database")) {
        console.warn("database block is not enabled");
        return;
      }
      if (props.flavour === "affine:embed" && props.type === "image") {
        models.push(...await uploadImageFromLocal(page));
      } else {
        models.push(props);
      }
      let parentId;
      let focusId;
      if (end && type !== "none") {
        const { model } = end;
        page.captureSync();
        if (type === "database") {
          const ids = page.addBlocks(models, model);
          focusId = ids[0];
          parentId = model.id;
        } else if (props.flavour === "affine:bookmark") {
          const parent = page.getParent(model);
          assertExists(parent);
          const index = parent.children.indexOf(model);
          focusId = createBookmarkBlock(parent, index + 1);
          parentId = parent.id;
        } else {
          const parent = page.getParent(model);
          assertExists(parent);
          const ids = page.addSiblingBlocks(model, models, type);
          focusId = ids[0];
          parentId = parent.id;
        }
        if (isDatabase) {
          const service = await getServiceOrRegister(props.flavour);
          service.initDatabaseBlock(page, model, focusId);
        }
      }
      if (editor.mode === "page") {
        if (focusId) {
          asyncFocusRichText(page, focusId);
          tryUpdateFrameSize(page, 1);
        }
        return;
      }
      const pageBlock = getEdgelessPage(page);
      assertExists(pageBlock);
      let frameId;
      if (focusId && parentId) {
        const targetFrameBlock = getClosestFrameBlockElementById(parentId, pageBlock);
        assertExists(targetFrameBlock);
        frameId = targetFrameBlock.model.id;
      } else {
        const result = pageBlock.addNewFrame(models, point);
        frameId = result.frameId;
        focusId = result.ids[0];
      }
      pageBlock.setSelection(frameId, true, focusId, point);
    },
    onDragStart: () => {
      if (editor.mode === "page") {
        const defaultPageBlock = editor.querySelector("affine-default-page");
        assertExists(defaultPageBlock);
        defaultPageBlock.selection.clear();
      }
    },
    getAllowedBlocks: () => {
      if (editor.mode === "page") {
        const defaultPageBlock = editor.querySelector("affine-default-page");
        assertExists(defaultPageBlock);
        return getAllowSelectedBlocks(defaultPageBlock.model);
      } else {
        const edgelessPageBlock = editor.querySelector("affine-edgeless-page");
        assertExists(edgelessPageBlock);
        return getAllowSelectedBlocks(edgelessPageBlock.model);
      }
    },
    getHoveringFrameState: (point) => {
      const state = {
        scale: 1
      };
      if (editor.mode === "page") {
        const defaultPageBlock = editor.querySelector("affine-default-page");
        assertExists(defaultPageBlock);
        const rect = Rect.fromDOMRect(defaultPageBlock.pageBlockContainer.getBoundingClientRect());
        rect.height -= PAGE_BLOCK_PADDING_BOTTOM;
        state.rect = rect;
      } else {
        const edgelessPageBlock = editor.querySelector("affine-edgeless-page");
        assertExists(edgelessPageBlock);
        state.scale = edgelessPageBlock.surface.viewport.zoom;
        const container = getHoveringFrame(point);
        if (container) {
          state.rect = Rect.fromDOM(container);
          state.container = container;
        }
      }
      return state;
    },
    page
  });
  return blockHub;
};

// node_modules/@blocksuite/editor/dist/components/editor-container.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function forwardSlot(from, to) {
  Object.entries(from).forEach(([key, slot]) => {
    const target = to[key];
    if (target) {
      slot.pipe(target);
    }
  });
}
var EditorContainer = class EditorContainer2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this.mode = "page";
    this.autofocus = false;
    this.themeObserver = new ThemeObserver();
    this.slots = {
      pageLinkClicked: new Slot(),
      pageModeSwitched: new Slot()
    };
  }
  get model() {
    return this.page.root;
  }
  connectedCallback() {
    super.connectedCallback();
    activeEditorManager.setIfNoActive(this);
    const keydown = (e) => {
      var _a;
      if (e.altKey && e.metaKey && e.code === "KeyC") {
        e.preventDefault();
      }
      if (e.code !== "Escape") {
        return;
      }
      const pageModel = this.model;
      if (!pageModel)
        return;
      if (this.mode === "page") {
        (_a = getPageBlock(pageModel)) == null ? void 0 : _a.selection.clear();
      }
      const selection = getSelection();
      if (!selection || selection.isCollapsed || !checkEditorElementActive()) {
        return;
      }
      selection.removeAllRanges();
    };
    if (isFirefox) {
      this._disposables.addFromEvent(document.body, "keydown", keydown);
    } else {
      this._disposables.addFromEvent(window, "keydown", keydown);
    }
    if (!this.page) {
      throw new Error("Missing page for EditorContainer!");
    }
    this._disposables.add(this.page.slots.rootAdded.on(() => {
      this.requestUpdate("page");
    }));
    this._disposables.add(this.page.slots.blockUpdated.on(async ({ type, id }) => {
      const block = this.page.getBlockById(id);
      if (!block)
        return;
      if (type === "update") {
        const service = await getServiceOrRegister(block.flavour);
        service.updateEffect(block);
      }
    }));
    this.themeObserver.observer(document.documentElement);
    this._disposables.add(this.themeObserver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    activeEditorManager.clearActive();
    this.page.awarenessStore.setLocalRange(this.page, null);
  }
  firstUpdated() {
    getServiceOrRegister("affine:code");
    if (this.mode === "page") {
      setTimeout(() => {
        const defaultPage = this.querySelector("affine-default-page");
        if (this.autofocus) {
          defaultPage == null ? void 0 : defaultPage.titleVEditor.focusEnd();
        }
      });
    }
  }
  updated(changedProperties) {
    if (changedProperties.has("mode")) {
      this.slots.pageModeSwitched.emit(this.mode);
    }
    if (!changedProperties.has("page") && !changedProperties.has("mode")) {
      return;
    }
    requestAnimationFrame(() => {
      if (this._defaultPageBlock) {
        forwardSlot(this._defaultPageBlock.slots, this.slots);
      }
      if (this._edgelessPageBlock) {
        forwardSlot(this._edgelessPageBlock.slots, this.slots);
      }
    });
  }
  async createBlockHub() {
    await this.updateComplete;
    if (!this.page.root) {
      await new Promise((res) => this.page.slots.rootAdded.once(res));
    }
    return createBlockHub(this, this.page);
  }
  render() {
    if (!this.model)
      return null;
    const rootContainer = keyed(this.model.id, html`<block-suite-root
        .page=${this.page}
        .componentMap=${this.mode === "page" ? pagePreset : edgelessPreset}
      ></block-suite-root>`);
    const remoteSelectionContainer = html`
      <remote-selection .page=${this.page}></remote-selection>
    `;
    return html`
      <style>
        editor-container * {
          box-sizing: border-box;
        }
        editor-container,
        .affine-editor-container {
          display: block;
          height: 100%;
          position: relative;
          overflow: hidden;
          font-family: var(--affine-font-family);
          background: var(--affine-background-primary-color);
        }
        @media print {
          editor-container,
          .affine-editor-container {
            height: auto;
          }
        }
      </style>
      ${rootContainer} ${remoteSelectionContainer}
    `;
  }
};
__decorate([
  property()
], EditorContainer.prototype, "page", void 0);
__decorate([
  property()
], EditorContainer.prototype, "mode", void 0);
__decorate([
  property()
], EditorContainer.prototype, "autofocus", void 0);
__decorate([
  query("affine-default-page")
], EditorContainer.prototype, "_defaultPageBlock", void 0);
__decorate([
  query("affine-edgeless-page")
], EditorContainer.prototype, "_edgelessPageBlock", void 0);
EditorContainer = __decorate([
  customElement("editor-container")
], EditorContainer);

// node_modules/@blocksuite/blocks/dist/models.js
var AffineSchemas = [
  CodeBlockSchema,
  ParagraphBlockSchema,
  PageBlockSchema,
  ListBlockSchema,
  FrameBlockSchema,
  DividerBlockSchema,
  EmbedBlockSchema,
  SurfaceBlockSchema,
  BookmarkBlockSchema
  // DatabaseBlockSchema,
];

// node_modules/@blocksuite/editor/dist/components/simple-affine-editor.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SimpleAffineEditor = class SimpleAffineEditor2 extends LitElement {
  constructor() {
    super();
    this.workspace = new Workspace({ id: "test" }).register(AffineSchemas);
    this.page = this.workspace.createPage({ id: "page0" });
    const pageBlockId = this.page.addBlock("affine:page");
    const frameId = this.page.addBlock("affine:frame", {}, pageBlockId);
    this.page.addBlock("affine:paragraph", {}, frameId);
  }
  connectedCallback() {
    const editor = new EditorContainer();
    editor.page = this.page;
    this.appendChild(editor);
  }
  disconnectedCallback() {
    this.removeChild(this.children[0]);
  }
};
SimpleAffineEditor = __decorate2([
  customElement("simple-affine-editor")
], SimpleAffineEditor);

// node_modules/@blocksuite/editor/dist/index.js
var env = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : (
  // @ts-ignore
  typeof global !== "undefined" ? (
    // @ts-ignore
    global
  ) : {}
);
var importIdentifier = "__ $BLOCKSUITE_EDITOR$ __";
if (env[importIdentifier] === true) {
  console.error("@blocksuite/editor was already imported. This breaks constructor checks and will lead to issues!");
}
if (typeof window === "undefined") {
  throw new Error("Seems like you are importing @blocksuite/editor in SSR mode. Which is not supported for now.");
}
env[importIdentifier] = true;
export {
  EditorContainer,
  SimpleAffineEditor,
  checkEditorElementActive,
  createBlockHub
};
/*! Bundled license information:

lit-html/development/directives/keyed.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@blocksuite_editor.js.map
