import {
  ALLOW_DEFAULT,
  AbstractSelectionManager,
  AlighLeftIcon,
  AlignCenterIcon,
  AlignRightIcon,
  ArrowDownIcon,
  BLOCKHUB_FILE_ITEMS,
  BLOCKHUB_LIST_ITEMS,
  BLOCKHUB_TEXT_ITEMS,
  BLOCK_CHILDREN_CONTAINER_PADDING_LEFT,
  BLOCK_ID_ATTR,
  BLOCK_SERVICE_LOADING_ATTR,
  BanIcon,
  BaseBlockModel,
  BlockHubIcon,
  BlockHubIcon20,
  BlockHubRoundedRectangleIcon,
  BoldIcon,
  BookmarkIcon,
  BrushSize,
  CSSResult,
  CancelWrapIcon,
  CaptionIcon,
  CloseIcon,
  ConfirmIcon,
  ConnectorIcon,
  ConnectorLIcon,
  ConnectorXIcon,
  CopyIcon,
  CrossIcon,
  DRAG_HANDLE_OFFSET_LEFT,
  DashLineIcon,
  DatabaseAddColumn,
  DatabaseDone,
  DatabaseDragIcon,
  DatabaseDuplicate,
  DatabaseInsertLeft,
  DatabaseInsertRight,
  DatabaseKanbanViewIcon,
  DatabaseMoveLeft,
  DatabaseMoveRight,
  DatabaseMultiSelect,
  DatabaseNumber,
  DatabaseProgress,
  DatabaseSearchClose,
  DatabaseSearchIcon,
  DatabaseSelect,
  DatabaseTableViewIcon,
  DeleteIcon,
  DiamondIcon,
  Directive,
  DisposableGroup,
  Doc,
  DownloadIcon,
  DropFlags,
  DualLinkIcon,
  DualLinkIcon16,
  DuplicateIcon,
  EDGELESS_BLOCK_CHILD_PADDING,
  EDITOR_WIDTH,
  EditIcon,
  EllipseIcon,
  EmbedIcon,
  ExportToHTMLIcon,
  ExportToMarkdownIcon,
  FRAME_BACKGROUND_COLORS,
  FontLinkIcon,
  FontLinkedPageIcon,
  FontPageIcon,
  HOTKEYS,
  HandIcon,
  HelpIcon,
  IS_IOS,
  IS_MAC,
  ImageIcon,
  ImageIcon20,
  ImportIcon,
  InlineCodeIcon,
  ItalicIcon,
  LineStyleIcon,
  LinkIcon,
  LinkToCardIcon,
  LinkedPageIcon,
  LitElement,
  MinusIcon,
  MoreHorizontalIcon,
  NewIcon,
  NewPageIcon,
  NoteIcon,
  NotionIcon,
  NowIcon,
  NumberedListIconLarge,
  PAGE_BLOCK_CHILD_PADDING,
  PAGE_BLOCK_PADDING_BOTTOM,
  PREVENT_DEFAULT,
  Page,
  PageIcon,
  PartType,
  PenIcon,
  PlusIcon,
  Point,
  Rect,
  RoundedRectangleIcon,
  SCROLL_THRESHOLD,
  SHORT_KEY,
  SearchIcon,
  SelectIcon,
  ShapeIcon,
  Slot,
  SquareIcon,
  StrikethroughIcon,
  Text as Text2,
  TextIcon,
  TextIconLarge,
  TodayIcon,
  TodoIcon,
  TomorrowIcon,
  TransparentIcon,
  TriangleIcon,
  UnderlineIcon,
  UndoManager,
  UnlinkIcon,
  VEditor,
  VText,
  ViewBarIcon,
  WrapIcon,
  YMap,
  YText,
  YesterdayIcon,
  ZERO_WIDTH_NON_JOINER,
  ZERO_WIDTH_SPACE,
  activeEditorManager,
  almostEqual,
  assertEquals,
  assertExists,
  assertFlavours,
  assertNotExists,
  asyncFocusRichText,
  asyncGetBlockElementByModel,
  asyncGetRichTextByModel,
  asyncGetVirgoByModel,
  asyncSetVRange,
  atLeastNMatches,
  baseTextAttributes,
  caretRangeFromPoint,
  clamp,
  clearSelection,
  contains,
  convertToDivider,
  convertToList,
  convertToParagraph,
  countBy,
  createBookmarkBlock,
  createEvent,
  css,
  customElement,
  debounce,
  defineBlockSchema,
  directive,
  focusBlockByModel,
  focusNextBlock,
  focusPreviousBlock,
  focusTitle,
  getBlockElementById,
  getBlockElementByModel,
  getBlockElementsByElement,
  getBlockElementsExcludeSubtrees,
  getBlockElementsIncludeSubtrees,
  getClosestBlockElementByElement,
  getClosestBlockElementByPoint,
  getClosestFrameBlockElementById,
  getCurrentNativeRange,
  getDefaultPage,
  getDropRectByPoint,
  getEditorContainer,
  getEditorContainerByElement,
  getHoveringFrame,
  getModelByBlockElement,
  getModelByElement,
  getModelsByRange,
  getPageBlock,
  getPreviousBlock,
  getRectByBlockElement,
  getRichTextByModel,
  getSelectedStateRectByBlockElement,
  getViewportElement,
  getVirgoByModel,
  groupBy,
  handleBlockEndEnter,
  handleBlockSplit,
  handleIndent,
  handleKeyDown,
  handleKeyUp,
  handleLineStartBackspace,
  handleMultiBlockIndent,
  handleNativeRangeAtPoint,
  handleNativeRangeClick,
  handleNativeRangeDblClick,
  handleNativeRangeDragMove,
  handleNativeRangeTripleClick,
  handleSoftEnter,
  handleUnindent,
  hasNativeSelection,
  html,
  isAtLineEdge,
  isBlankArea,
  isCaptionElement,
  isCollapsedAtBlockStart,
  isContainedIn,
  isControlledKeyboardEvent,
  isDatabaseInput,
  isDragHandle,
  isElement,
  isEmbed,
  isEmpty,
  isEqual,
  isFirefox,
  isFuzzyMatch,
  isImage,
  isInSamePath,
  isInsideDatabaseTitle,
  isInsideEdgelessTextEditor,
  isInsidePageTitle,
  isInsideRichText,
  isMultiBlockRange,
  isMultiLineRange,
  isPageMode,
  isPrintableKeyEvent,
  isSelectedBlocks,
  matchFlavours,
  maxBy,
  nanoid,
  nanoid2,
  noChange,
  noop,
  nothing,
  paragraphConfig,
  property,
  query,
  queryAll,
  queryCurrentMode,
  render,
  repeat,
  resetNativeSelection,
  selection_exports,
  sleep,
  state,
  styleMap,
  supportsChildren,
  svg,
  throttle,
  utils_exports,
  z
} from "./chunk-OZBHL7FS.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-AX6B7HUW.js";

// node_modules/vscode-oniguruma/release/main.js
var require_main = __commonJS({
  "node_modules/vscode-oniguruma/release/main.js"(exports, module) {
    !function(t, n) {
      "object" == typeof exports && "object" == typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define([], n) : "object" == typeof exports ? exports.onig = n() : t.onig = n();
    }(exports, () => {
      return t = { 770: function(t2, n2, e) {
        "use strict";
        var r = this && this.__importDefault || function(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        };
        Object.defineProperty(n2, "__esModule", { value: true }), n2.setDefaultDebugCall = n2.createOnigScanner = n2.createOnigString = n2.loadWASM = n2.OnigScanner = n2.OnigString = void 0;
        const i = r(e(418));
        let o = null, a = false;
        class f {
          static _utf8ByteLength(t3) {
            let n3 = 0;
            for (let e2 = 0, r2 = t3.length; e2 < r2; e2++) {
              const i2 = t3.charCodeAt(e2);
              let o2 = i2, a2 = false;
              if (i2 >= 55296 && i2 <= 56319 && e2 + 1 < r2) {
                const n4 = t3.charCodeAt(e2 + 1);
                n4 >= 56320 && n4 <= 57343 && (o2 = 65536 + (i2 - 55296 << 10) | n4 - 56320, a2 = true);
              }
              n3 += o2 <= 127 ? 1 : o2 <= 2047 ? 2 : o2 <= 65535 ? 3 : 4, a2 && e2++;
            }
            return n3;
          }
          constructor(t3) {
            const n3 = t3.length, e2 = f._utf8ByteLength(t3), r2 = e2 !== n3, i2 = r2 ? new Uint32Array(n3 + 1) : null;
            r2 && (i2[n3] = e2);
            const o2 = r2 ? new Uint32Array(e2 + 1) : null;
            r2 && (o2[e2] = n3);
            const a2 = new Uint8Array(e2);
            let s2 = 0;
            for (let e3 = 0; e3 < n3; e3++) {
              const f2 = t3.charCodeAt(e3);
              let u2 = f2, c2 = false;
              if (f2 >= 55296 && f2 <= 56319 && e3 + 1 < n3) {
                const n4 = t3.charCodeAt(e3 + 1);
                n4 >= 56320 && n4 <= 57343 && (u2 = 65536 + (f2 - 55296 << 10) | n4 - 56320, c2 = true);
              }
              r2 && (i2[e3] = s2, c2 && (i2[e3 + 1] = s2), u2 <= 127 ? o2[s2 + 0] = e3 : u2 <= 2047 ? (o2[s2 + 0] = e3, o2[s2 + 1] = e3) : u2 <= 65535 ? (o2[s2 + 0] = e3, o2[s2 + 1] = e3, o2[s2 + 2] = e3) : (o2[s2 + 0] = e3, o2[s2 + 1] = e3, o2[s2 + 2] = e3, o2[s2 + 3] = e3)), u2 <= 127 ? a2[s2++] = u2 : u2 <= 2047 ? (a2[s2++] = 192 | (1984 & u2) >>> 6, a2[s2++] = 128 | (63 & u2) >>> 0) : u2 <= 65535 ? (a2[s2++] = 224 | (61440 & u2) >>> 12, a2[s2++] = 128 | (4032 & u2) >>> 6, a2[s2++] = 128 | (63 & u2) >>> 0) : (a2[s2++] = 240 | (1835008 & u2) >>> 18, a2[s2++] = 128 | (258048 & u2) >>> 12, a2[s2++] = 128 | (4032 & u2) >>> 6, a2[s2++] = 128 | (63 & u2) >>> 0), c2 && e3++;
            }
            this.utf16Length = n3, this.utf8Length = e2, this.utf16Value = t3, this.utf8Value = a2, this.utf16OffsetToUtf8 = i2, this.utf8OffsetToUtf16 = o2;
          }
          createString(t3) {
            const n3 = t3._omalloc(this.utf8Length);
            return t3.HEAPU8.set(this.utf8Value, n3), n3;
          }
        }
        class s {
          constructor(t3) {
            if (this.id = ++s.LAST_ID, !o)
              throw new Error("Must invoke loadWASM first.");
            this._onigBinding = o, this.content = t3;
            const n3 = new f(t3);
            this.utf16Length = n3.utf16Length, this.utf8Length = n3.utf8Length, this.utf16OffsetToUtf8 = n3.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n3.utf8OffsetToUtf16, this.utf8Length < 1e4 && !s._sharedPtrInUse ? (s._sharedPtr || (s._sharedPtr = o._omalloc(1e4)), s._sharedPtrInUse = true, o.HEAPU8.set(n3.utf8Value, s._sharedPtr), this.ptr = s._sharedPtr) : this.ptr = n3.createString(o);
          }
          convertUtf8OffsetToUtf16(t3) {
            return this.utf8OffsetToUtf16 ? t3 < 0 ? 0 : t3 > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t3] : t3;
          }
          convertUtf16OffsetToUtf8(t3) {
            return this.utf16OffsetToUtf8 ? t3 < 0 ? 0 : t3 > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t3] : t3;
          }
          dispose() {
            this.ptr === s._sharedPtr ? s._sharedPtrInUse = false : this._onigBinding._ofree(this.ptr);
          }
        }
        n2.OnigString = s, s.LAST_ID = 0, s._sharedPtr = 0, s._sharedPtrInUse = false;
        class u {
          constructor(t3) {
            if (!o)
              throw new Error("Must invoke loadWASM first.");
            const n3 = [], e2 = [];
            for (let r3 = 0, i3 = t3.length; r3 < i3; r3++) {
              const i4 = new f(t3[r3]);
              n3[r3] = i4.createString(o), e2[r3] = i4.utf8Length;
            }
            const r2 = o._omalloc(4 * t3.length);
            o.HEAPU32.set(n3, r2 / 4);
            const i2 = o._omalloc(4 * t3.length);
            o.HEAPU32.set(e2, i2 / 4);
            const a2 = o._createOnigScanner(r2, i2, t3.length);
            for (let e3 = 0, r3 = t3.length; e3 < r3; e3++)
              o._ofree(n3[e3]);
            o._ofree(i2), o._ofree(r2), 0 === a2 && function(t4) {
              throw new Error(t4.UTF8ToString(t4._getLastOnigError()));
            }(o), this._onigBinding = o, this._ptr = a2;
          }
          dispose() {
            this._onigBinding._freeOnigScanner(this._ptr);
          }
          findNextMatchSync(t3, n3, e2) {
            let r2 = a, i2 = 0;
            if ("number" == typeof e2 ? (8 & e2 && (r2 = true), i2 = e2) : "boolean" == typeof e2 && (r2 = e2), "string" == typeof t3) {
              t3 = new s(t3);
              const e3 = this._findNextMatchSync(t3, n3, r2, i2);
              return t3.dispose(), e3;
            }
            return this._findNextMatchSync(t3, n3, r2, i2);
          }
          _findNextMatchSync(t3, n3, e2, r2) {
            const i2 = this._onigBinding;
            let o2;
            if (o2 = e2 ? i2._findNextOnigScannerMatchDbg(this._ptr, t3.id, t3.ptr, t3.utf8Length, t3.convertUtf16OffsetToUtf8(n3), r2) : i2._findNextOnigScannerMatch(this._ptr, t3.id, t3.ptr, t3.utf8Length, t3.convertUtf16OffsetToUtf8(n3), r2), 0 === o2)
              return null;
            const a2 = i2.HEAPU32;
            let f2 = o2 / 4;
            const s2 = a2[f2++], u2 = a2[f2++];
            let c2 = [];
            for (let n4 = 0; n4 < u2; n4++) {
              const e3 = t3.convertUtf8OffsetToUtf16(a2[f2++]), r3 = t3.convertUtf8OffsetToUtf16(a2[f2++]);
              c2[n4] = { start: e3, end: r3, length: r3 - e3 };
            }
            return { index: s2, captureIndices: c2 };
          }
        }
        n2.OnigScanner = u;
        let c = false, l = null;
        n2.loadWASM = function(t3) {
          if (c)
            return l;
          let n3, e2, r2, a2;
          if (c = true, function(t4) {
            return "function" == typeof t4.instantiator;
          }(t3))
            n3 = t3.instantiator, e2 = t3.print;
          else {
            let r3;
            !function(t4) {
              return void 0 !== t4.data;
            }(t3) ? r3 = t3 : (r3 = t3.data, e2 = t3.print), n3 = function(t4) {
              return "undefined" != typeof Response && t4 instanceof Response;
            }(r3) ? "function" == typeof WebAssembly.instantiateStreaming ? function(t4) {
              return (n4) => WebAssembly.instantiateStreaming(t4, n4);
            }(r3) : function(t4) {
              return async (n4) => {
                const e3 = await t4.arrayBuffer();
                return WebAssembly.instantiate(e3, n4);
              };
            }(r3) : function(t4) {
              return (n4) => WebAssembly.instantiate(t4, n4);
            }(r3);
          }
          return l = new Promise((t4, n4) => {
            r2 = t4, a2 = n4;
          }), function(t4, n4, e3, r3) {
            (0, i.default)({ print: n4, instantiateWasm: (n5, e4) => {
              if ("undefined" == typeof performance) {
                const t5 = () => Date.now();
                n5.env.emscripten_get_now = t5, n5.wasi_snapshot_preview1.emscripten_get_now = t5;
              }
              return t4(n5).then((t5) => e4(t5.instance), r3), {};
            } }).then((t5) => {
              o = t5, e3();
            });
          }(n3, e2, r2, a2), l;
        }, n2.createOnigString = function(t3) {
          return new s(t3);
        }, n2.createOnigScanner = function(t3) {
          return new u(t3);
        }, n2.setDefaultDebugCall = function(t3) {
          a = t3;
        };
      }, 418: (t2) => {
        var n2 = ("undefined" != typeof document && document.currentScript && document.currentScript.src, function(t3) {
          var n3, e, r = void 0 !== (t3 = t3 || {}) ? t3 : {};
          r.ready = new Promise(function(t4, r2) {
            n3 = t4, e = r2;
          });
          var i, o = Object.assign({}, r), a = [], f = false, s = false, u = true, c = "";
          function l(t4) {
            return r.locateFile ? r.locateFile(t4, c) : c + t4;
          }
          u && (i = function(t4) {
            let n4;
            return "function" == typeof readbuffer ? new Uint8Array(readbuffer(t4)) : (n4 = read(t4, "binary"), m("object" == typeof n4), n4);
          }, "undefined" != typeof scriptArgs ? a = scriptArgs : void 0 !== arguments && (a = arguments), "undefined" != typeof onig_print && ("undefined" == typeof console && (console = {}), console.log = onig_print, console.warn = console.error = "undefined" != typeof printErr ? printErr : onig_print));
          var h, p, d = r.print || console.log.bind(console), g = r.printErr || console.warn.bind(console);
          Object.assign(r, o), o = null, r.arguments && (a = r.arguments), r.thisProgram && r.thisProgram, r.quit && r.quit, r.wasmBinary && (h = r.wasmBinary), r.noExitRuntime, "object" != typeof WebAssembly && k("no native wasm support detected");
          var _ = false;
          function m(t4, n4) {
            t4 || k(n4);
          }
          var y, w, S, v = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
          function A(t4, n4, e2) {
            for (var r2 = n4 + e2, i2 = n4; t4[i2] && !(i2 >= r2); )
              ++i2;
            if (i2 - n4 > 16 && t4.buffer && v)
              return v.decode(t4.subarray(n4, i2));
            for (var o2 = ""; n4 < i2; ) {
              var a2 = t4[n4++];
              if (128 & a2) {
                var f2 = 63 & t4[n4++];
                if (192 != (224 & a2)) {
                  var s2 = 63 & t4[n4++];
                  if ((a2 = 224 == (240 & a2) ? (15 & a2) << 12 | f2 << 6 | s2 : (7 & a2) << 18 | f2 << 12 | s2 << 6 | 63 & t4[n4++]) < 65536)
                    o2 += String.fromCharCode(a2);
                  else {
                    var u2 = a2 - 65536;
                    o2 += String.fromCharCode(55296 | u2 >> 10, 56320 | 1023 & u2);
                  }
                } else
                  o2 += String.fromCharCode((31 & a2) << 6 | f2);
              } else
                o2 += String.fromCharCode(a2);
            }
            return o2;
          }
          function b(t4, n4) {
            return t4 ? A(w, t4, n4) : "";
          }
          function O(t4) {
            y = t4, r.HEAP8 = new Int8Array(t4), r.HEAP16 = new Int16Array(t4), r.HEAP32 = new Int32Array(t4), r.HEAPU8 = w = new Uint8Array(t4), r.HEAPU16 = new Uint16Array(t4), r.HEAPU32 = S = new Uint32Array(t4), r.HEAPF32 = new Float32Array(t4), r.HEAPF64 = new Float64Array(t4);
          }
          r.INITIAL_MEMORY;
          var U = [], P = [], R = [];
          function x() {
            if (r.preRun)
              for ("function" == typeof r.preRun && (r.preRun = [r.preRun]); r.preRun.length; )
                M(r.preRun.shift());
            G(U);
          }
          function T() {
            G(P);
          }
          function E() {
            if (r.postRun)
              for ("function" == typeof r.postRun && (r.postRun = [r.postRun]); r.postRun.length; )
                I(r.postRun.shift());
            G(R);
          }
          function M(t4) {
            U.unshift(t4);
          }
          function L(t4) {
            P.unshift(t4);
          }
          function I(t4) {
            R.unshift(t4);
          }
          var W = 0, D = null, C = null;
          function N(t4) {
            W++, r.monitorRunDependencies && r.monitorRunDependencies(W);
          }
          function j(t4) {
            if (W--, r.monitorRunDependencies && r.monitorRunDependencies(W), 0 == W && (null !== D && (clearInterval(D), D = null), C)) {
              var n4 = C;
              C = null, n4();
            }
          }
          function k(t4) {
            r.onAbort && r.onAbort(t4), g(t4 = "Aborted(" + t4 + ")"), _ = true, t4 += ". Build with -sASSERTIONS for more info.";
            var n4 = new WebAssembly.RuntimeError(t4);
            throw e(n4), n4;
          }
          var B, H, F = "data:application/octet-stream;base64,";
          function V(t4) {
            return t4.startsWith(F);
          }
          function z2(t4) {
            try {
              if (t4 == B && h)
                return new Uint8Array(h);
              if (i)
                return i(t4);
              throw "both async and sync fetching of the wasm failed";
            } catch (t5) {
              k(t5);
            }
          }
          function q() {
            return h || !f && !s || "function" != typeof fetch ? Promise.resolve().then(function() {
              return z2(B);
            }) : fetch(B, { credentials: "same-origin" }).then(function(t4) {
              if (!t4.ok)
                throw "failed to load wasm binary file at '" + B + "'";
              return t4.arrayBuffer();
            }).catch(function() {
              return z2(B);
            });
          }
          function Y() {
            var t4 = { env: nt, wasi_snapshot_preview1: nt };
            function n4(t5, n5) {
              var e2 = t5.exports;
              r.asm = e2, O((p = r.asm.memory).buffer), r.asm.__indirect_function_table, L(r.asm.__wasm_call_ctors), j();
            }
            function i2(t5) {
              n4(t5.instance);
            }
            function o2(n5) {
              return q().then(function(n6) {
                return WebAssembly.instantiate(n6, t4);
              }).then(function(t5) {
                return t5;
              }).then(n5, function(t5) {
                g("failed to asynchronously prepare wasm: " + t5), k(t5);
              });
            }
            if (N(), r.instantiateWasm)
              try {
                return r.instantiateWasm(t4, n4);
              } catch (t5) {
                g("Module.instantiateWasm callback failed with error: " + t5), e(t5);
              }
            return (h || "function" != typeof WebAssembly.instantiateStreaming || V(B) || "function" != typeof fetch ? o2(i2) : fetch(B, { credentials: "same-origin" }).then(function(n5) {
              return WebAssembly.instantiateStreaming(n5, t4).then(i2, function(t5) {
                return g("wasm streaming compile failed: " + t5), g("falling back to ArrayBuffer instantiation"), o2(i2);
              });
            })).catch(e), {};
          }
          function G(t4) {
            for (; t4.length > 0; )
              t4.shift()(r);
          }
          function J(t4, n4, e2) {
            w.copyWithin(t4, n4, n4 + e2);
          }
          function K(t4) {
            try {
              return p.grow(t4 - y.byteLength + 65535 >>> 16), O(p.buffer), 1;
            } catch (t5) {
            }
          }
          function Q(t4) {
            var n4, e2 = w.length, r2 = 2147483648;
            if ((t4 >>>= 0) > r2)
              return false;
            for (var i2 = 1; i2 <= 4; i2 *= 2) {
              var o2 = e2 * (1 + 0.2 / i2);
              if (o2 = Math.min(o2, t4 + 100663296), K(Math.min(r2, (n4 = Math.max(t4, o2)) + (65536 - n4 % 65536) % 65536)))
                return true;
            }
            return false;
          }
          V(B = "onig.wasm") || (B = l(B)), H = "undefined" != typeof dateNow ? dateNow : () => performance.now();
          var X = [null, [], []];
          function Z(t4, n4) {
            var e2 = X[t4];
            0 === n4 || 10 === n4 ? ((1 === t4 ? d : g)(A(e2, 0)), e2.length = 0) : e2.push(n4);
          }
          function $(t4, n4, e2, r2) {
            for (var i2 = 0, o2 = 0; o2 < e2; o2++) {
              var a2 = S[n4 >> 2], f2 = S[n4 + 4 >> 2];
              n4 += 8;
              for (var s2 = 0; s2 < f2; s2++)
                Z(t4, w[a2 + s2]);
              i2 += f2;
            }
            return S[r2 >> 2] = i2, 0;
          }
          var tt, nt = { emscripten_get_now: H, emscripten_memcpy_big: J, emscripten_resize_heap: Q, fd_write: $ };
          function et(t4) {
            function e2() {
              tt || (tt = true, r.calledRun = true, _ || (T(), n3(r), r.onRuntimeInitialized && r.onRuntimeInitialized(), E()));
            }
            t4 = t4 || a, W > 0 || (x(), W > 0 || (r.setStatus ? (r.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                r.setStatus("");
              }, 1), e2();
            }, 1)) : e2()));
          }
          if (Y(), r.___wasm_call_ctors = function() {
            return (r.___wasm_call_ctors = r.asm.__wasm_call_ctors).apply(null, arguments);
          }, r.___errno_location = function() {
            return (r.___errno_location = r.asm.__errno_location).apply(null, arguments);
          }, r._omalloc = function() {
            return (r._omalloc = r.asm.omalloc).apply(null, arguments);
          }, r._ofree = function() {
            return (r._ofree = r.asm.ofree).apply(null, arguments);
          }, r._getLastOnigError = function() {
            return (r._getLastOnigError = r.asm.getLastOnigError).apply(null, arguments);
          }, r._createOnigScanner = function() {
            return (r._createOnigScanner = r.asm.createOnigScanner).apply(null, arguments);
          }, r._freeOnigScanner = function() {
            return (r._freeOnigScanner = r.asm.freeOnigScanner).apply(null, arguments);
          }, r._findNextOnigScannerMatch = function() {
            return (r._findNextOnigScannerMatch = r.asm.findNextOnigScannerMatch).apply(null, arguments);
          }, r._findNextOnigScannerMatchDbg = function() {
            return (r._findNextOnigScannerMatchDbg = r.asm.findNextOnigScannerMatchDbg).apply(null, arguments);
          }, r.stackSave = function() {
            return (r.stackSave = r.asm.stackSave).apply(null, arguments);
          }, r.stackRestore = function() {
            return (r.stackRestore = r.asm.stackRestore).apply(null, arguments);
          }, r.stackAlloc = function() {
            return (r.stackAlloc = r.asm.stackAlloc).apply(null, arguments);
          }, r.dynCall_jiji = function() {
            return (r.dynCall_jiji = r.asm.dynCall_jiji).apply(null, arguments);
          }, r.UTF8ToString = b, C = function t4() {
            tt || et(), tt || (C = t4);
          }, r.preInit)
            for ("function" == typeof r.preInit && (r.preInit = [r.preInit]); r.preInit.length > 0; )
              r.preInit.pop()();
          return et(), t3.ready;
        });
        t2.exports = n2;
      } }, n = {}, function e(r) {
        var i = n[r];
        if (void 0 !== i)
          return i.exports;
        var o = n[r] = { exports: {} };
        return t[r].call(o.exports, o, o.exports, e), o.exports;
      }(770);
      var t, n;
    });
  }
});

// node_modules/vscode-textmate/release/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-textmate/release/main.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.vscodetextmate = t() : e.vscodetextmate = t();
    }(exports, function() {
      return (() => {
        "use strict";
        var e = { 350: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.UseOnigurumaFindOptions = t2.DebugFlags = void 0, t2.DebugFlags = { InDebugMode: "undefined" != typeof process && !!process.env.VSCODE_TEXTMATE_DEBUG }, t2.UseOnigurumaFindOptions = false;
        }, 36: (e2, t2) => {
          var n;
          Object.defineProperty(t2, "__esModule", { value: true }), t2.toOptionalTokenType = t2.EncodedTokenAttributes = void 0, (n = t2.EncodedTokenAttributes || (t2.EncodedTokenAttributes = {})).toBinaryStr = function(e3) {
            let t3 = e3.toString(2);
            for (; t3.length < 32; )
              t3 = "0" + t3;
            return t3;
          }, n.print = function(e3) {
            const t3 = n.getLanguageId(e3), s = n.getTokenType(e3), r = n.getFontStyle(e3), i = n.getForeground(e3), o = n.getBackground(e3);
            console.log({ languageId: t3, tokenType: s, fontStyle: r, foreground: i, background: o });
          }, n.getLanguageId = function(e3) {
            return (255 & e3) >>> 0;
          }, n.getTokenType = function(e3) {
            return (768 & e3) >>> 8;
          }, n.containsBalancedBrackets = function(e3) {
            return 0 != (1024 & e3);
          }, n.getFontStyle = function(e3) {
            return (30720 & e3) >>> 11;
          }, n.getForeground = function(e3) {
            return (16744448 & e3) >>> 15;
          }, n.getBackground = function(e3) {
            return (4278190080 & e3) >>> 24;
          }, n.set = function(e3, t3, s, r, i, o, c) {
            let a = n.getLanguageId(e3), l = n.getTokenType(e3), u = n.containsBalancedBrackets(e3) ? 1 : 0, h = n.getFontStyle(e3), p = n.getForeground(e3), d = n.getBackground(e3);
            return 0 !== t3 && (a = t3), 8 !== s && (l = s), null !== r && (u = r ? 1 : 0), -1 !== i && (h = i), 0 !== o && (p = o), 0 !== c && (d = c), (a << 0 | l << 8 | u << 10 | h << 11 | p << 15 | d << 24) >>> 0;
          }, t2.toOptionalTokenType = function(e3) {
            return e3;
          };
        }, 996: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.BasicScopeAttributesProvider = t2.BasicScopeAttributes = void 0;
          const s = n(878);
          class r {
            constructor(e3, t3) {
              this.languageId = e3, this.tokenType = t3;
            }
          }
          t2.BasicScopeAttributes = r;
          class i {
            constructor(e3, t3) {
              this._getBasicScopeAttributes = new s.CachedFn((e4) => {
                const t4 = this._scopeToLanguage(e4), n2 = this._toStandardTokenType(e4);
                return new r(t4, n2);
              }), this._defaultAttributes = new r(e3, 8), this._embeddedLanguagesMatcher = new o(Object.entries(t3 || {}));
            }
            getDefaultAttributes() {
              return this._defaultAttributes;
            }
            getBasicScopeAttributes(e3) {
              return null === e3 ? i._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e3);
            }
            _scopeToLanguage(e3) {
              return this._embeddedLanguagesMatcher.match(e3) || 0;
            }
            _toStandardTokenType(e3) {
              const t3 = e3.match(i.STANDARD_TOKEN_TYPE_REGEXP);
              if (!t3)
                return 8;
              switch (t3[1]) {
                case "comment":
                  return 1;
                case "string":
                  return 2;
                case "regex":
                  return 3;
                case "meta.embedded":
                  return 0;
              }
              throw new Error("Unexpected match for standard token type!");
            }
          }
          t2.BasicScopeAttributesProvider = i, i._NULL_SCOPE_METADATA = new r(0, 0), i.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
          class o {
            constructor(e3) {
              if (0 === e3.length)
                this.values = null, this.scopesRegExp = null;
              else {
                this.values = new Map(e3);
                const t3 = e3.map(([e4, t4]) => s.escapeRegExpCharacters(e4));
                t3.sort(), t3.reverse(), this.scopesRegExp = new RegExp(`^((${t3.join(")|(")}))($|\\.)`, "");
              }
            }
            match(e3) {
              if (!this.scopesRegExp)
                return;
              const t3 = e3.match(this.scopesRegExp);
              return t3 ? this.values.get(t3[1]) : void 0;
            }
          }
        }, 947: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.LineTokens = t2.BalancedBracketSelectors = t2.StateStack = t2.AttributedScopeStack = t2.Grammar = t2.createGrammar = void 0;
          const s = n(350), r = n(36), i = n(736), o = n(44), c = n(792), a = n(583), l = n(878), u = n(996), h = n(47);
          function p(e3, t3, n2, s2, r2) {
            const o2 = i.createMatchers(t3, d), a2 = c.RuleFactory.getCompiledRuleId(n2, s2, r2.repository);
            for (const n3 of o2)
              e3.push({ debugSelector: t3, matcher: n3.matcher, ruleId: a2, grammar: r2, priority: n3.priority });
          }
          function d(e3, t3) {
            if (t3.length < e3.length)
              return false;
            let n2 = 0;
            return e3.every((e4) => {
              for (let s2 = n2; s2 < t3.length; s2++)
                if (f(t3[s2], e4))
                  return n2 = s2 + 1, true;
              return false;
            });
          }
          function f(e3, t3) {
            if (!e3)
              return false;
            if (e3 === t3)
              return true;
            const n2 = t3.length;
            return e3.length > n2 && e3.substr(0, n2) === t3 && "." === e3[n2];
          }
          t2.createGrammar = function(e3, t3, n2, s2, r2, i2, o2, c2) {
            return new g(e3, t3, n2, s2, r2, i2, o2, c2);
          };
          class g {
            constructor(e3, t3, n2, s2, r2, o2, c2, a2) {
              if (this._rootScopeName = e3, this.balancedBracketSelectors = o2, this._onigLib = a2, this._basicScopeAttributesProvider = new u.BasicScopeAttributesProvider(n2, s2), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = c2, this._grammar = m(t3, null), this._injections = null, this._tokenTypeMatchers = [], r2)
                for (const e4 of Object.keys(r2)) {
                  const t4 = i.createMatchers(e4, d);
                  for (const n3 of t4)
                    this._tokenTypeMatchers.push({ matcher: n3.matcher, type: r2[e4] });
                }
            }
            get themeProvider() {
              return this._grammarRepository;
            }
            dispose() {
              for (const e3 of this._ruleId2desc)
                e3 && e3.dispose();
            }
            createOnigScanner(e3) {
              return this._onigLib.createOnigScanner(e3);
            }
            createOnigString(e3) {
              return this._onigLib.createOnigString(e3);
            }
            getMetadataForScope(e3) {
              return this._basicScopeAttributesProvider.getBasicScopeAttributes(e3);
            }
            _collectInjections() {
              const e3 = [], t3 = this._rootScopeName, n2 = ((e4) => e4 === this._rootScopeName ? this._grammar : this.getExternalGrammar(e4))(t3);
              if (n2) {
                const s2 = n2.injections;
                if (s2)
                  for (let t4 in s2)
                    p(e3, t4, s2[t4], this, n2);
                const r2 = this._grammarRepository.injections(t3);
                r2 && r2.forEach((t4) => {
                  const n3 = this.getExternalGrammar(t4);
                  if (n3) {
                    const t5 = n3.injectionSelector;
                    t5 && p(e3, t5, n3, this, n3);
                  }
                });
              }
              return e3.sort((e4, t4) => e4.priority - t4.priority), e3;
            }
            getInjections() {
              if (null === this._injections && (this._injections = this._collectInjections(), s.DebugFlags.InDebugMode && this._injections.length > 0)) {
                console.log(`Grammar ${this._rootScopeName} contains the following injections:`);
                for (const e3 of this._injections)
                  console.log(`  - ${e3.debugSelector}`);
              }
              return this._injections;
            }
            registerRule(e3) {
              const t3 = ++this._lastRuleId, n2 = e3(c.ruleIdFromNumber(t3));
              return this._ruleId2desc[t3] = n2, n2;
            }
            getRule(e3) {
              return this._ruleId2desc[c.ruleIdToNumber(e3)];
            }
            getExternalGrammar(e3, t3) {
              if (this._includedGrammars[e3])
                return this._includedGrammars[e3];
              if (this._grammarRepository) {
                const n2 = this._grammarRepository.lookup(e3);
                if (n2)
                  return this._includedGrammars[e3] = m(n2, t3 && t3.$base), this._includedGrammars[e3];
              }
            }
            tokenizeLine(e3, t3, n2 = 0) {
              const s2 = this._tokenize(e3, t3, false, n2);
              return { tokens: s2.lineTokens.getResult(s2.ruleStack, s2.lineLength), ruleStack: s2.ruleStack, stoppedEarly: s2.stoppedEarly };
            }
            tokenizeLine2(e3, t3, n2 = 0) {
              const s2 = this._tokenize(e3, t3, true, n2);
              return { tokens: s2.lineTokens.getBinaryResult(s2.ruleStack, s2.lineLength), ruleStack: s2.ruleStack, stoppedEarly: s2.stoppedEarly };
            }
            _tokenize(e3, t3, n2, s2) {
              let i2;
              if (-1 === this._rootId && (this._rootId = c.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)), t3 && t3 !== b.NULL)
                i2 = false, t3.reset();
              else {
                i2 = true;
                const e4 = this._basicScopeAttributesProvider.getDefaultAttributes(), n3 = this.themeProvider.getDefaults(), s3 = r.EncodedTokenAttributes.set(0, e4.languageId, e4.tokenType, null, n3.fontStyle, n3.foregroundId, n3.backgroundId), o2 = this.getRule(this._rootId).getName(null, null);
                let c2;
                c2 = o2 ? _.createRootAndLookUpScopeName(o2, s3, this) : _.createRoot("unknown", s3), t3 = new b(null, this._rootId, -1, -1, false, null, c2, c2);
              }
              e3 += "\n";
              const a2 = this.createOnigString(e3), l2 = a2.content.length, u2 = new y(n2, e3, this._tokenTypeMatchers, this.balancedBracketSelectors), p2 = h._tokenizeString(this, a2, i2, 0, t3, u2, true, s2);
              return o.disposeOnigString(a2), { lineLength: l2, lineTokens: u2, ruleStack: p2.stack, stoppedEarly: p2.stoppedEarly };
            }
          }
          function m(e3, t3) {
            return (e3 = l.clone(e3)).repository = e3.repository || {}, e3.repository.$self = { $vscodeTextmateLocation: e3.$vscodeTextmateLocation, patterns: e3.patterns, name: e3.scopeName }, e3.repository.$base = t3 || e3.repository.$self, e3;
          }
          t2.Grammar = g;
          class _ {
            constructor(e3, t3, n2) {
              this.parent = e3, this.scopePath = t3, this.tokenAttributes = n2;
            }
            static createRoot(e3, t3) {
              return new _(null, new a.ScopeStack(null, e3), t3);
            }
            static createRootAndLookUpScopeName(e3, t3, n2) {
              const s2 = n2.getMetadataForScope(e3), r2 = new a.ScopeStack(null, e3), i2 = n2.themeProvider.themeMatch(r2), o2 = _.mergeAttributes(t3, s2, i2);
              return new _(null, r2, o2);
            }
            get scopeName() {
              return this.scopePath.scopeName;
            }
            equals(e3) {
              return _._equals(this, e3);
            }
            static _equals(e3, t3) {
              for (; ; ) {
                if (e3 === t3)
                  return true;
                if (!e3 && !t3)
                  return true;
                if (!e3 || !t3)
                  return false;
                if (e3.scopeName !== t3.scopeName || e3.tokenAttributes !== t3.tokenAttributes)
                  return false;
                e3 = e3.parent, t3 = t3.parent;
              }
            }
            static mergeAttributes(e3, t3, n2) {
              let s2 = -1, i2 = 0, o2 = 0;
              return null !== n2 && (s2 = n2.fontStyle, i2 = n2.foregroundId, o2 = n2.backgroundId), r.EncodedTokenAttributes.set(e3, t3.languageId, t3.tokenType, null, s2, i2, o2);
            }
            pushAttributed(e3, t3) {
              if (null === e3)
                return this;
              if (-1 === e3.indexOf(" "))
                return _._pushAttributed(this, e3, t3);
              const n2 = e3.split(/ /g);
              let s2 = this;
              for (const e4 of n2)
                s2 = _._pushAttributed(s2, e4, t3);
              return s2;
            }
            static _pushAttributed(e3, t3, n2) {
              const s2 = n2.getMetadataForScope(t3), r2 = e3.scopePath.push(t3), i2 = n2.themeProvider.themeMatch(r2), o2 = _.mergeAttributes(e3.tokenAttributes, s2, i2);
              return new _(e3, r2, o2);
            }
            getScopeNames() {
              return this.scopePath.getSegments();
            }
          }
          t2.AttributedScopeStack = _;
          class b {
            constructor(e3, t3, n2, s2, r2, i2, o2, c2) {
              this.parent = e3, this.ruleId = t3, this.beginRuleCapturedEOL = r2, this.endRule = i2, this.nameScopesList = o2, this.contentNameScopesList = c2, this._stackElementBrand = void 0, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = n2, this._anchorPos = s2;
            }
            equals(e3) {
              return null !== e3 && b._equals(this, e3);
            }
            static _equals(e3, t3) {
              return e3 === t3 || !!this._structuralEquals(e3, t3) && e3.contentNameScopesList.equals(t3.contentNameScopesList);
            }
            static _structuralEquals(e3, t3) {
              for (; ; ) {
                if (e3 === t3)
                  return true;
                if (!e3 && !t3)
                  return true;
                if (!e3 || !t3)
                  return false;
                if (e3.depth !== t3.depth || e3.ruleId !== t3.ruleId || e3.endRule !== t3.endRule)
                  return false;
                e3 = e3.parent, t3 = t3.parent;
              }
            }
            clone() {
              return this;
            }
            static _reset(e3) {
              for (; e3; )
                e3._enterPos = -1, e3._anchorPos = -1, e3 = e3.parent;
            }
            reset() {
              b._reset(this);
            }
            pop() {
              return this.parent;
            }
            safePop() {
              return this.parent ? this.parent : this;
            }
            push(e3, t3, n2, s2, r2, i2, o2) {
              return new b(this, e3, t3, n2, s2, r2, i2, o2);
            }
            getEnterPos() {
              return this._enterPos;
            }
            getAnchorPos() {
              return this._anchorPos;
            }
            getRule(e3) {
              return e3.getRule(this.ruleId);
            }
            toString() {
              const e3 = [];
              return this._writeString(e3, 0), "[" + e3.join(",") + "]";
            }
            _writeString(e3, t3) {
              return this.parent && (t3 = this.parent._writeString(e3, t3)), e3[t3++] = `(${this.ruleId}, TODO-${this.nameScopesList}, TODO-${this.contentNameScopesList})`, t3;
            }
            withContentNameScopesList(e3) {
              return this.contentNameScopesList === e3 ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e3);
            }
            withEndRule(e3) {
              return this.endRule === e3 ? this : new b(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, e3, this.nameScopesList, this.contentNameScopesList);
            }
            hasSameRuleAs(e3) {
              let t3 = this;
              for (; t3 && t3._enterPos === e3._enterPos; ) {
                if (t3.ruleId === e3.ruleId)
                  return true;
                t3 = t3.parent;
              }
              return false;
            }
          }
          t2.StateStack = b, b.NULL = new b(null, 0, 0, 0, false, null, null, null), t2.BalancedBracketSelectors = class {
            constructor(e3, t3) {
              this.allowAny = false, this.balancedBracketScopes = e3.flatMap((e4) => "*" === e4 ? (this.allowAny = true, []) : i.createMatchers(e4, d).map((e5) => e5.matcher)), this.unbalancedBracketScopes = t3.flatMap((e4) => i.createMatchers(e4, d).map((e5) => e5.matcher));
            }
            get matchesAlways() {
              return this.allowAny && 0 === this.unbalancedBracketScopes.length;
            }
            get matchesNever() {
              return 0 === this.balancedBracketScopes.length && !this.allowAny;
            }
            match(e3) {
              for (const t3 of this.unbalancedBracketScopes)
                if (t3(e3))
                  return false;
              for (const t3 of this.balancedBracketScopes)
                if (t3(e3))
                  return true;
              return this.allowAny;
            }
          };
          class y {
            constructor(e3, t3, n2, r2) {
              this.balancedBracketSelectors = r2, this._emitBinaryTokens = e3, this._tokenTypeOverrides = n2, s.DebugFlags.InDebugMode ? this._lineText = t3 : this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
            }
            produce(e3, t3) {
              this.produceFromScopes(e3.contentNameScopesList, t3);
            }
            produceFromScopes(e3, t3) {
              var _a3;
              if (this._lastTokenEndIndex >= t3)
                return;
              if (this._emitBinaryTokens) {
                let n3 = e3.tokenAttributes, i2 = false;
                if (((_a3 = this.balancedBracketSelectors) == null ? void 0 : _a3.matchesAlways) && (i2 = true), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
                  const t4 = e3.getScopeNames();
                  for (const e4 of this._tokenTypeOverrides)
                    e4.matcher(t4) && (n3 = r.EncodedTokenAttributes.set(n3, 0, r.toOptionalTokenType(e4.type), null, -1, 0, 0));
                  this.balancedBracketSelectors && (i2 = this.balancedBracketSelectors.match(t4));
                }
                if (i2 && (n3 = r.EncodedTokenAttributes.set(n3, 0, 8, i2, -1, 0, 0)), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n3)
                  return void (this._lastTokenEndIndex = t3);
                if (s.DebugFlags.InDebugMode) {
                  const n4 = e3.getScopeNames();
                  console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, t3).replace(/\n$/, "\\n") + "|");
                  for (let e4 = 0; e4 < n4.length; e4++)
                    console.log("      * " + n4[e4]);
                }
                return this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n3), void (this._lastTokenEndIndex = t3);
              }
              const n2 = e3.getScopeNames();
              if (s.DebugFlags.InDebugMode) {
                console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, t3).replace(/\n$/, "\\n") + "|");
                for (let e4 = 0; e4 < n2.length; e4++)
                  console.log("      * " + n2[e4]);
              }
              this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: t3, scopes: n2 }), this._lastTokenEndIndex = t3;
            }
            getResult(e3, t3) {
              return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t3 - 1 && this._tokens.pop(), 0 === this._tokens.length && (this._lastTokenEndIndex = -1, this.produce(e3, t3), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
            }
            getBinaryResult(e3, t3) {
              this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t3 - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), 0 === this._binaryTokens.length && (this._lastTokenEndIndex = -1, this.produce(e3, t3), this._binaryTokens[this._binaryTokens.length - 2] = 0);
              const n2 = new Uint32Array(this._binaryTokens.length);
              for (let e4 = 0, t4 = this._binaryTokens.length; e4 < t4; e4++)
                n2[e4] = this._binaryTokens[e4];
              return n2;
            }
          }
          t2.LineTokens = y;
        }, 965: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.parseInclude = t2.TopLevelRepositoryReference = t2.TopLevelReference = t2.RelativeReference = t2.SelfReference = t2.BaseReference = t2.ScopeDependencyProcessor = t2.ExternalReferenceCollector = t2.TopLevelRepositoryRuleReference = t2.TopLevelRuleReference = void 0;
          const s = n(878);
          class r {
            constructor(e3) {
              this.scopeName = e3;
            }
            toKey() {
              return this.scopeName;
            }
          }
          t2.TopLevelRuleReference = r;
          class i {
            constructor(e3, t3) {
              this.scopeName = e3, this.ruleName = t3;
            }
            toKey() {
              return `${this.scopeName}#${this.ruleName}`;
            }
          }
          t2.TopLevelRepositoryRuleReference = i;
          class o {
            constructor() {
              this._references = [], this._seenReferenceKeys = /* @__PURE__ */ new Set(), this.visitedRule = /* @__PURE__ */ new Set();
            }
            get references() {
              return this._references;
            }
            add(e3) {
              const t3 = e3.toKey();
              this._seenReferenceKeys.has(t3) || (this._seenReferenceKeys.add(t3), this._references.push(e3));
            }
          }
          function c(e3, t3, n2, s2) {
            const i2 = n2.lookup(e3.scopeName);
            if (!i2) {
              if (e3.scopeName === t3)
                throw new Error(`No grammar provided for <${t3}>`);
              return;
            }
            const o2 = n2.lookup(t3);
            e3 instanceof r ? l({ baseGrammar: o2, selfGrammar: i2 }, s2) : a(e3.ruleName, { baseGrammar: o2, selfGrammar: i2, repository: i2.repository }, s2);
            const c2 = n2.injections(e3.scopeName);
            if (c2)
              for (const e4 of c2)
                s2.add(new r(e4));
          }
          function a(e3, t3, n2) {
            t3.repository && t3.repository[e3] && u([t3.repository[e3]], t3, n2);
          }
          function l(e3, t3) {
            e3.selfGrammar.patterns && Array.isArray(e3.selfGrammar.patterns) && u(e3.selfGrammar.patterns, { ...e3, repository: e3.selfGrammar.repository }, t3), e3.selfGrammar.injections && u(Object.values(e3.selfGrammar.injections), { ...e3, repository: e3.selfGrammar.repository }, t3);
          }
          function u(e3, t3, n2) {
            for (const o2 of e3) {
              if (n2.visitedRule.has(o2))
                continue;
              n2.visitedRule.add(o2);
              const e4 = o2.repository ? s.mergeObjects({}, t3.repository, o2.repository) : t3.repository;
              Array.isArray(o2.patterns) && u(o2.patterns, { ...t3, repository: e4 }, n2);
              const c2 = o2.include;
              if (!c2)
                continue;
              const h2 = m(c2);
              switch (h2.kind) {
                case 0:
                  l({ ...t3, selfGrammar: t3.baseGrammar }, n2);
                  break;
                case 1:
                  l(t3, n2);
                  break;
                case 2:
                  a(h2.ruleName, { ...t3, repository: e4 }, n2);
                  break;
                case 3:
                case 4:
                  const s2 = h2.scopeName === t3.selfGrammar.scopeName ? t3.selfGrammar : h2.scopeName === t3.baseGrammar.scopeName ? t3.baseGrammar : void 0;
                  if (s2) {
                    const r2 = { baseGrammar: t3.baseGrammar, selfGrammar: s2, repository: e4 };
                    4 === h2.kind ? a(h2.ruleName, r2, n2) : l(r2, n2);
                  } else
                    4 === h2.kind ? n2.add(new i(h2.scopeName, h2.ruleName)) : n2.add(new r(h2.scopeName));
              }
            }
          }
          t2.ExternalReferenceCollector = o, t2.ScopeDependencyProcessor = class {
            constructor(e3, t3) {
              this.repo = e3, this.initialScopeName = t3, this.seenFullScopeRequests = /* @__PURE__ */ new Set(), this.seenPartialScopeRequests = /* @__PURE__ */ new Set(), this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new r(this.initialScopeName)];
            }
            processQueue() {
              const e3 = this.Q;
              this.Q = [];
              const t3 = new o();
              for (const n2 of e3)
                c(n2, this.initialScopeName, this.repo, t3);
              for (const e4 of t3.references)
                if (e4 instanceof r) {
                  if (this.seenFullScopeRequests.has(e4.scopeName))
                    continue;
                  this.seenFullScopeRequests.add(e4.scopeName), this.Q.push(e4);
                } else {
                  if (this.seenFullScopeRequests.has(e4.scopeName))
                    continue;
                  if (this.seenPartialScopeRequests.has(e4.toKey()))
                    continue;
                  this.seenPartialScopeRequests.add(e4.toKey()), this.Q.push(e4);
                }
            }
          };
          class h {
            constructor() {
              this.kind = 0;
            }
          }
          t2.BaseReference = h;
          class p {
            constructor() {
              this.kind = 1;
            }
          }
          t2.SelfReference = p;
          class d {
            constructor(e3) {
              this.ruleName = e3, this.kind = 2;
            }
          }
          t2.RelativeReference = d;
          class f {
            constructor(e3) {
              this.scopeName = e3, this.kind = 3;
            }
          }
          t2.TopLevelReference = f;
          class g {
            constructor(e3, t3) {
              this.scopeName = e3, this.ruleName = t3, this.kind = 4;
            }
          }
          function m(e3) {
            if ("$base" === e3)
              return new h();
            if ("$self" === e3)
              return new p();
            const t3 = e3.indexOf("#");
            if (-1 === t3)
              return new f(e3);
            if (0 === t3)
              return new d(e3.substring(1));
            {
              const n2 = e3.substring(0, t3), s2 = e3.substring(t3 + 1);
              return new g(n2, s2);
            }
          }
          t2.TopLevelRepositoryReference = g, t2.parseInclude = m;
        }, 391: function(e2, t2, n) {
          var s = this && this.__createBinding || (Object.create ? function(e3, t3, n2, s2) {
            void 0 === s2 && (s2 = n2), Object.defineProperty(e3, s2, { enumerable: true, get: function() {
              return t3[n2];
            } });
          } : function(e3, t3, n2, s2) {
            void 0 === s2 && (s2 = n2), e3[s2] = t3[n2];
          }), r = this && this.__exportStar || function(e3, t3) {
            for (var n2 in e3)
              "default" === n2 || Object.prototype.hasOwnProperty.call(t3, n2) || s(t3, e3, n2);
          };
          Object.defineProperty(t2, "__esModule", { value: true }), r(n(947), t2);
        }, 47: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.LocalStackElement = t2._tokenizeString = void 0;
          const s = n(350), r = n(44), i = n(792), o = n(878);
          class c {
            constructor(e3, t3) {
              this.stack = e3, this.stoppedEarly = t3;
            }
          }
          function a(e3, t3, n2, r2, a2, h2, d2, f) {
            const g = t3.content.length;
            let m = false, _ = -1;
            if (d2) {
              const o2 = function(e4, t4, n3, r3, o3, c2) {
                let a3 = o3.beginRuleCapturedEOL ? 0 : -1;
                const l2 = [];
                for (let t5 = o3; t5; t5 = t5.pop()) {
                  const n4 = t5.getRule(e4);
                  n4 instanceof i.BeginWhileRule && l2.push({ rule: n4, stack: t5 });
                }
                for (let h3 = l2.pop(); h3; h3 = l2.pop()) {
                  const { ruleScanner: l3, findOptions: d3 } = u(h3.rule, e4, h3.stack.endRule, n3, r3 === a3), f2 = l3.findNextMatchSync(t4, r3, d3);
                  if (s.DebugFlags.InDebugMode && (console.log("  scanning for while rule"), console.log(l3.toString())), !f2) {
                    s.DebugFlags.InDebugMode && console.log("  popping " + h3.rule.debugName + " - " + h3.rule.debugWhileRegExp), o3 = h3.stack.pop();
                    break;
                  }
                  if (f2.ruleId !== i.whileRuleId) {
                    o3 = h3.stack.pop();
                    break;
                  }
                  f2.captureIndices && f2.captureIndices.length && (c2.produce(h3.stack, f2.captureIndices[0].start), p(e4, t4, n3, h3.stack, c2, h3.rule.whileCaptures, f2.captureIndices), c2.produce(h3.stack, f2.captureIndices[0].end), a3 = f2.captureIndices[0].end, f2.captureIndices[0].end > r3 && (r3 = f2.captureIndices[0].end, n3 = false));
                }
                return { stack: o3, linePos: r3, anchorPosition: a3, isFirstLine: n3 };
              }(e3, t3, n2, r2, a2, h2);
              a2 = o2.stack, r2 = o2.linePos, n2 = o2.isFirstLine, _ = o2.anchorPosition;
            }
            const b = Date.now();
            for (; !m; ) {
              if (0 !== f && Date.now() - b > f)
                return new c(a2, true);
              y();
            }
            return new c(a2, false);
            function y() {
              s.DebugFlags.InDebugMode && (console.log(""), console.log(`@@scanNext ${r2}: |${t3.content.substr(r2).replace(/\n$/, "\\n")}|`));
              const c2 = function(e4, t4, n3, r3, i2, c3) {
                const a3 = function(e5, t5, n4, r4, i3, c4) {
                  const a4 = i3.getRule(e5), { ruleScanner: u4, findOptions: h4 } = l(a4, e5, i3.endRule, n4, r4 === c4);
                  let p3 = 0;
                  s.DebugFlags.InDebugMode && (p3 = o.performanceNow());
                  const d5 = u4.findNextMatchSync(t5, r4, h4);
                  if (s.DebugFlags.InDebugMode) {
                    const e6 = o.performanceNow() - p3;
                    e6 > 5 && console.warn(`Rule ${a4.debugName} (${a4.id}) matching took ${e6} against '${t5}'`), console.log(`  scanning for (linePos: ${r4}, anchorPosition: ${c4})`), console.log(u4.toString()), d5 && console.log(`matched rule id: ${d5.ruleId} from ${d5.captureIndices[0].start} to ${d5.captureIndices[0].end}`);
                  }
                  return d5 ? { captureIndices: d5.captureIndices, matchedRuleId: d5.ruleId } : null;
                }(e4, t4, n3, r3, i2, c3), u3 = e4.getInjections();
                if (0 === u3.length)
                  return a3;
                const h3 = function(e5, t5, n4, r4, i3, o2, c4) {
                  let a4, u4 = Number.MAX_VALUE, h4 = null, p3 = 0;
                  const d5 = o2.contentNameScopesList.getScopeNames();
                  for (let o3 = 0, f3 = e5.length; o3 < f3; o3++) {
                    const f4 = e5[o3];
                    if (!f4.matcher(d5))
                      continue;
                    const g2 = t5.getRule(f4.ruleId), { ruleScanner: m2, findOptions: _2 } = l(g2, t5, null, r4, i3 === c4), b2 = m2.findNextMatchSync(n4, i3, _2);
                    if (!b2)
                      continue;
                    s.DebugFlags.InDebugMode && (console.log(`  matched injection: ${f4.debugSelector}`), console.log(m2.toString()));
                    const y2 = b2.captureIndices[0].start;
                    if (!(y2 >= u4) && (u4 = y2, h4 = b2.captureIndices, a4 = b2.ruleId, p3 = f4.priority, u4 === i3))
                      break;
                  }
                  return h4 ? { priorityMatch: -1 === p3, captureIndices: h4, matchedRuleId: a4 } : null;
                }(u3, e4, t4, n3, r3, i2, c3);
                if (!h3)
                  return a3;
                if (!a3)
                  return h3;
                const p2 = a3.captureIndices[0].start, d4 = h3.captureIndices[0].start;
                return d4 < p2 || h3.priorityMatch && d4 === p2 ? h3 : a3;
              }(e3, t3, n2, r2, a2, _);
              if (!c2)
                return s.DebugFlags.InDebugMode && console.log("  no more matches."), h2.produce(a2, g), void (m = true);
              const u2 = c2.captureIndices, d3 = c2.matchedRuleId, f2 = !!(u2 && u2.length > 0) && u2[0].end > r2;
              if (d3 === i.endRuleId) {
                const i2 = a2.getRule(e3);
                s.DebugFlags.InDebugMode && console.log("  popping " + i2.debugName + " - " + i2.debugEndRegExp), h2.produce(a2, u2[0].start), a2 = a2.withContentNameScopesList(a2.nameScopesList), p(e3, t3, n2, a2, h2, i2.endCaptures, u2), h2.produce(a2, u2[0].end);
                const o2 = a2;
                if (a2 = a2.parent, _ = o2.getAnchorPos(), !f2 && o2.getEnterPos() === r2)
                  return s.DebugFlags.InDebugMode && console.error("[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing"), a2 = o2, h2.produce(a2, g), void (m = true);
              } else {
                const o2 = e3.getRule(d3);
                h2.produce(a2, u2[0].start);
                const c3 = a2, l2 = o2.getName(t3.content, u2), b2 = a2.contentNameScopesList.pushAttributed(l2, e3);
                if (a2 = a2.push(d3, r2, _, u2[0].end === g, null, b2, b2), o2 instanceof i.BeginEndRule) {
                  const r3 = o2;
                  s.DebugFlags.InDebugMode && console.log("  pushing " + r3.debugName + " - " + r3.debugBeginRegExp), p(e3, t3, n2, a2, h2, r3.beginCaptures, u2), h2.produce(a2, u2[0].end), _ = u2[0].end;
                  const i2 = r3.getContentName(t3.content, u2), l3 = b2.pushAttributed(i2, e3);
                  if (a2 = a2.withContentNameScopesList(l3), r3.endHasBackReferences && (a2 = a2.withEndRule(r3.getEndWithResolvedBackReferences(t3.content, u2))), !f2 && c3.hasSameRuleAs(a2))
                    return s.DebugFlags.InDebugMode && console.error("[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), a2 = a2.pop(), h2.produce(a2, g), void (m = true);
                } else if (o2 instanceof i.BeginWhileRule) {
                  const r3 = o2;
                  s.DebugFlags.InDebugMode && console.log("  pushing " + r3.debugName), p(e3, t3, n2, a2, h2, r3.beginCaptures, u2), h2.produce(a2, u2[0].end), _ = u2[0].end;
                  const i2 = r3.getContentName(t3.content, u2), l3 = b2.pushAttributed(i2, e3);
                  if (a2 = a2.withContentNameScopesList(l3), r3.whileHasBackReferences && (a2 = a2.withEndRule(r3.getWhileWithResolvedBackReferences(t3.content, u2))), !f2 && c3.hasSameRuleAs(a2))
                    return s.DebugFlags.InDebugMode && console.error("[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), a2 = a2.pop(), h2.produce(a2, g), void (m = true);
                } else {
                  const r3 = o2;
                  if (s.DebugFlags.InDebugMode && console.log("  matched " + r3.debugName + " - " + r3.debugMatchRegExp), p(e3, t3, n2, a2, h2, r3.captures, u2), h2.produce(a2, u2[0].end), a2 = a2.pop(), !f2)
                    return s.DebugFlags.InDebugMode && console.error("[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping"), a2 = a2.safePop(), h2.produce(a2, g), void (m = true);
                }
              }
              u2[0].end > r2 && (r2 = u2[0].end, n2 = false);
            }
          }
          function l(e3, t3, n2, r2, i2) {
            return s.UseOnigurumaFindOptions ? { ruleScanner: e3.compile(t3, n2), findOptions: h(r2, i2) } : { ruleScanner: e3.compileAG(t3, n2, r2, i2), findOptions: 0 };
          }
          function u(e3, t3, n2, r2, i2) {
            return s.UseOnigurumaFindOptions ? { ruleScanner: e3.compileWhile(t3, n2), findOptions: h(r2, i2) } : { ruleScanner: e3.compileWhileAG(t3, n2, r2, i2), findOptions: 0 };
          }
          function h(e3, t3) {
            let n2 = 0;
            return e3 || (n2 |= 1), t3 || (n2 |= 4), n2;
          }
          function p(e3, t3, n2, s2, i2, o2, c2) {
            if (0 === o2.length)
              return;
            const l2 = t3.content, u2 = Math.min(o2.length, c2.length), h2 = [], p2 = c2[0].end;
            for (let t4 = 0; t4 < u2; t4++) {
              const u3 = o2[t4];
              if (null === u3)
                continue;
              const f = c2[t4];
              if (0 === f.length)
                continue;
              if (f.start > p2)
                break;
              for (; h2.length > 0 && h2[h2.length - 1].endPos <= f.start; )
                i2.produceFromScopes(h2[h2.length - 1].scopes, h2[h2.length - 1].endPos), h2.pop();
              if (h2.length > 0 ? i2.produceFromScopes(h2[h2.length - 1].scopes, f.start) : i2.produce(s2, f.start), u3.retokenizeCapturedWithRuleId) {
                const t5 = u3.getName(l2, c2), o3 = s2.contentNameScopesList.pushAttributed(t5, e3), h3 = u3.getContentName(l2, c2), p3 = o3.pushAttributed(h3, e3), d2 = s2.push(u3.retokenizeCapturedWithRuleId, f.start, -1, false, null, o3, p3), g2 = e3.createOnigString(l2.substring(0, f.end));
                a(e3, g2, n2 && 0 === f.start, f.start, d2, i2, false, 0), r.disposeOnigString(g2);
                continue;
              }
              const g = u3.getName(l2, c2);
              if (null !== g) {
                const t5 = (h2.length > 0 ? h2[h2.length - 1].scopes : s2.contentNameScopesList).pushAttributed(g, e3);
                h2.push(new d(t5, f.end));
              }
            }
            for (; h2.length > 0; )
              i2.produceFromScopes(h2[h2.length - 1].scopes, h2[h2.length - 1].endPos), h2.pop();
          }
          t2._tokenizeString = a;
          class d {
            constructor(e3, t3) {
              this.scopes = e3, this.endPos = t3;
            }
          }
          t2.LocalStackElement = d;
        }, 974: (e2, t2) => {
          function n(e3, t3) {
            throw new Error("Near offset " + e3.pos + ": " + t3 + " ~~~" + e3.source.substr(e3.pos, 50) + "~~~");
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.parseJSON = void 0, t2.parseJSON = function(e3, t3, o) {
            let c = new s(e3), a = new r(), l = 0, u = null, h = [], p = [];
            function d() {
              h.push(l), p.push(u);
            }
            function f() {
              l = h.pop(), u = p.pop();
            }
            function g(e4) {
              n(c, e4);
            }
            for (; i(c, a); ) {
              if (0 === l) {
                if (null !== u && g("too many constructs in root"), 3 === a.type) {
                  u = {}, o && (u.$vscodeTextmateLocation = a.toLocation(t3)), d(), l = 1;
                  continue;
                }
                if (2 === a.type) {
                  u = [], d(), l = 4;
                  continue;
                }
                g("unexpected token in root");
              }
              if (2 === l) {
                if (5 === a.type) {
                  f();
                  continue;
                }
                if (7 === a.type) {
                  l = 3;
                  continue;
                }
                g("expected , or }");
              }
              if (1 === l || 3 === l) {
                if (1 === l && 5 === a.type) {
                  f();
                  continue;
                }
                if (1 === a.type) {
                  let e4 = a.value;
                  if (i(c, a) && 6 === a.type || g("expected colon"), i(c, a) || g("expected value"), l = 2, 1 === a.type) {
                    u[e4] = a.value;
                    continue;
                  }
                  if (8 === a.type) {
                    u[e4] = null;
                    continue;
                  }
                  if (9 === a.type) {
                    u[e4] = true;
                    continue;
                  }
                  if (10 === a.type) {
                    u[e4] = false;
                    continue;
                  }
                  if (11 === a.type) {
                    u[e4] = parseFloat(a.value);
                    continue;
                  }
                  if (2 === a.type) {
                    let t4 = [];
                    u[e4] = t4, d(), l = 4, u = t4;
                    continue;
                  }
                  if (3 === a.type) {
                    let n2 = {};
                    o && (n2.$vscodeTextmateLocation = a.toLocation(t3)), u[e4] = n2, d(), l = 1, u = n2;
                    continue;
                  }
                }
                g("unexpected token in dict");
              }
              if (5 === l) {
                if (4 === a.type) {
                  f();
                  continue;
                }
                if (7 === a.type) {
                  l = 6;
                  continue;
                }
                g("expected , or ]");
              }
              if (4 === l || 6 === l) {
                if (4 === l && 4 === a.type) {
                  f();
                  continue;
                }
                if (l = 5, 1 === a.type) {
                  u.push(a.value);
                  continue;
                }
                if (8 === a.type) {
                  u.push(null);
                  continue;
                }
                if (9 === a.type) {
                  u.push(true);
                  continue;
                }
                if (10 === a.type) {
                  u.push(false);
                  continue;
                }
                if (11 === a.type) {
                  u.push(parseFloat(a.value));
                  continue;
                }
                if (2 === a.type) {
                  let e4 = [];
                  u.push(e4), d(), l = 4, u = e4;
                  continue;
                }
                if (3 === a.type) {
                  let e4 = {};
                  o && (e4.$vscodeTextmateLocation = a.toLocation(t3)), u.push(e4), d(), l = 1, u = e4;
                  continue;
                }
                g("unexpected token in array");
              }
              g("unknown state");
            }
            return 0 !== p.length && g("unclosed constructs"), u;
          };
          class s {
            constructor(e3) {
              this.source = e3, this.pos = 0, this.len = e3.length, this.line = 1, this.char = 0;
            }
          }
          class r {
            constructor() {
              this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1;
            }
            toLocation(e3) {
              return { filename: e3, line: this.line, char: this.char };
            }
          }
          function i(e3, t3) {
            t3.value = null, t3.type = 0, t3.offset = -1, t3.len = -1, t3.line = -1, t3.char = -1;
            let s2, r2 = e3.source, i2 = e3.pos, o = e3.len, c = e3.line, a = e3.char;
            for (; ; ) {
              if (i2 >= o)
                return false;
              if (s2 = r2.charCodeAt(i2), 32 !== s2 && 9 !== s2 && 13 !== s2) {
                if (10 !== s2)
                  break;
                i2++, c++, a = 0;
              } else
                i2++, a++;
            }
            if (t3.offset = i2, t3.line = c, t3.char = a, 34 === s2) {
              for (t3.type = 1, i2++, a++; ; ) {
                if (i2 >= o)
                  return false;
                if (s2 = r2.charCodeAt(i2), i2++, a++, 92 !== s2) {
                  if (34 === s2)
                    break;
                } else
                  i2++, a++;
              }
              t3.value = r2.substring(t3.offset + 1, i2 - 1).replace(/\\u([0-9A-Fa-f]{4})/g, (e4, t4) => String.fromCodePoint(parseInt(t4, 16))).replace(/\\(.)/g, (t4, s3) => {
                switch (s3) {
                  case '"':
                    return '"';
                  case "\\":
                    return "\\";
                  case "/":
                    return "/";
                  case "b":
                    return "\b";
                  case "f":
                    return "\f";
                  case "n":
                    return "\n";
                  case "r":
                    return "\r";
                  case "t":
                    return "	";
                  default:
                    n(e3, "invalid escape sequence");
                }
                throw new Error("unreachable");
              });
            } else if (91 === s2)
              t3.type = 2, i2++, a++;
            else if (123 === s2)
              t3.type = 3, i2++, a++;
            else if (93 === s2)
              t3.type = 4, i2++, a++;
            else if (125 === s2)
              t3.type = 5, i2++, a++;
            else if (58 === s2)
              t3.type = 6, i2++, a++;
            else if (44 === s2)
              t3.type = 7, i2++, a++;
            else if (110 === s2) {
              if (t3.type = 8, i2++, a++, s2 = r2.charCodeAt(i2), 117 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 108 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 108 !== s2)
                return false;
              i2++, a++;
            } else if (116 === s2) {
              if (t3.type = 9, i2++, a++, s2 = r2.charCodeAt(i2), 114 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 117 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 101 !== s2)
                return false;
              i2++, a++;
            } else if (102 === s2) {
              if (t3.type = 10, i2++, a++, s2 = r2.charCodeAt(i2), 97 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 108 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 115 !== s2)
                return false;
              if (i2++, a++, s2 = r2.charCodeAt(i2), 101 !== s2)
                return false;
              i2++, a++;
            } else
              for (t3.type = 11; ; ) {
                if (i2 >= o)
                  return false;
                if (s2 = r2.charCodeAt(i2), !(46 === s2 || s2 >= 48 && s2 <= 57 || 101 === s2 || 69 === s2 || 45 === s2 || 43 === s2))
                  break;
                i2++, a++;
              }
            return t3.len = i2 - t3.offset, null === t3.value && (t3.value = r2.substr(t3.offset, t3.len)), e3.pos = i2, e3.line = c, e3.char = a, true;
          }
        }, 787: function(e2, t2, n) {
          var s = this && this.__createBinding || (Object.create ? function(e3, t3, n2, s2) {
            void 0 === s2 && (s2 = n2), Object.defineProperty(e3, s2, { enumerable: true, get: function() {
              return t3[n2];
            } });
          } : function(e3, t3, n2, s2) {
            void 0 === s2 && (s2 = n2), e3[s2] = t3[n2];
          }), r = this && this.__exportStar || function(e3, t3) {
            for (var n2 in e3)
              "default" === n2 || Object.prototype.hasOwnProperty.call(t3, n2) || s(t3, e3, n2);
          };
          Object.defineProperty(t2, "__esModule", { value: true }), t2.parseRawGrammar = t2.INITIAL = t2.Registry = void 0;
          const i = n(391), o = n(50), c = n(652), a = n(583), l = n(965);
          r(n(44), t2), t2.Registry = class {
            constructor(e3) {
              this._options = e3, this._syncRegistry = new c.SyncRegistry(a.Theme.createFromRawTheme(e3.theme, e3.colorMap), e3.onigLib), this._ensureGrammarCache = /* @__PURE__ */ new Map();
            }
            dispose() {
              this._syncRegistry.dispose();
            }
            setTheme(e3, t3) {
              this._syncRegistry.setTheme(a.Theme.createFromRawTheme(e3, t3));
            }
            getColorMap() {
              return this._syncRegistry.getColorMap();
            }
            loadGrammarWithEmbeddedLanguages(e3, t3, n2) {
              return this.loadGrammarWithConfiguration(e3, t3, { embeddedLanguages: n2 });
            }
            loadGrammarWithConfiguration(e3, t3, n2) {
              return this._loadGrammar(e3, t3, n2.embeddedLanguages, n2.tokenTypes, new i.BalancedBracketSelectors(n2.balancedBracketSelectors || [], n2.unbalancedBracketSelectors || []));
            }
            loadGrammar(e3) {
              return this._loadGrammar(e3, 0, null, null, null);
            }
            async _loadGrammar(e3, t3, n2, s2, r2) {
              const i2 = new l.ScopeDependencyProcessor(this._syncRegistry, e3);
              for (; i2.Q.length > 0; )
                await Promise.all(i2.Q.map((e4) => this._loadSingleGrammar(e4.scopeName))), i2.processQueue();
              return this._grammarForScopeName(e3, t3, n2, s2, r2);
            }
            async _loadSingleGrammar(e3) {
              return this._ensureGrammarCache.has(e3) || this._ensureGrammarCache.set(e3, this._doLoadSingleGrammar(e3)), this._ensureGrammarCache.get(e3);
            }
            async _doLoadSingleGrammar(e3) {
              const t3 = await this._options.loadGrammar(e3);
              if (t3) {
                const n2 = "function" == typeof this._options.getInjections ? this._options.getInjections(e3) : void 0;
                this._syncRegistry.addGrammar(t3, n2);
              }
            }
            async addGrammar(e3, t3 = [], n2 = 0, s2 = null) {
              return this._syncRegistry.addGrammar(e3, t3), await this._grammarForScopeName(e3.scopeName, n2, s2);
            }
            _grammarForScopeName(e3, t3 = 0, n2 = null, s2 = null, r2 = null) {
              return this._syncRegistry.grammarForScopeName(e3, t3, n2, s2, r2);
            }
          }, t2.INITIAL = i.StateStack.NULL, t2.parseRawGrammar = o.parseRawGrammar;
        }, 736: (e2, t2) => {
          function n(e3) {
            return !!e3 && !!e3.match(/[\w\.:]+/);
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.createMatchers = void 0, t2.createMatchers = function(e3, t3) {
            const s = [], r = function(e4) {
              let t4 = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n2 = t4.exec(e4);
              return { next: () => {
                if (!n2)
                  return null;
                const s2 = n2[0];
                return n2 = t4.exec(e4), s2;
              } };
            }(e3);
            let i = r.next();
            for (; null !== i; ) {
              let e4 = 0;
              if (2 === i.length && ":" === i.charAt(1)) {
                switch (i.charAt(0)) {
                  case "R":
                    e4 = 1;
                    break;
                  case "L":
                    e4 = -1;
                    break;
                  default:
                    console.log(`Unknown priority ${i} in scope selector`);
                }
                i = r.next();
              }
              let t4 = c();
              if (s.push({ matcher: t4, priority: e4 }), "," !== i)
                break;
              i = r.next();
            }
            return s;
            function o() {
              if ("-" === i) {
                i = r.next();
                const e4 = o();
                return (t4) => !!e4 && !e4(t4);
              }
              if ("(" === i) {
                i = r.next();
                const e4 = function() {
                  const e5 = [];
                  let t4 = c();
                  for (; t4 && (e5.push(t4), "|" === i || "," === i); ) {
                    do {
                      i = r.next();
                    } while ("|" === i || "," === i);
                    t4 = c();
                  }
                  return (t5) => e5.some((e6) => e6(t5));
                }();
                return ")" === i && (i = r.next()), e4;
              }
              if (n(i)) {
                const e4 = [];
                do {
                  e4.push(i), i = r.next();
                } while (n(i));
                return (n2) => t3(e4, n2);
              }
              return null;
            }
            function c() {
              const e4 = [];
              let t4 = o();
              for (; t4; )
                e4.push(t4), t4 = o();
              return (t5) => e4.every((e5) => e5(t5));
            }
          };
        }, 44: (e2, t2) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.disposeOnigString = void 0, t2.disposeOnigString = function(e3) {
            "function" == typeof e3.dispose && e3.dispose();
          };
        }, 50: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.parseRawGrammar = void 0;
          const s = n(69), r = n(350), i = n(974);
          t2.parseRawGrammar = function(e3, t3 = null) {
            return null !== t3 && /\.json$/.test(t3) ? (n2 = e3, o = t3, r.DebugFlags.InDebugMode ? i.parseJSON(n2, o, true) : JSON.parse(n2)) : function(e4, t4) {
              return r.DebugFlags.InDebugMode ? s.parseWithLocation(e4, t4, "$vscodeTextmateLocation") : s.parsePLIST(e4);
            }(e3, t3);
            var n2, o;
          };
        }, 69: (e2, t2) => {
          function n(e3, t3, n2) {
            const s = e3.length;
            let r = 0, i = 1, o = 0;
            function c(t4) {
              if (null === n2)
                r += t4;
              else
                for (; t4 > 0; )
                  10 === e3.charCodeAt(r) ? (r++, i++, o = 0) : (r++, o++), t4--;
            }
            function a(e4) {
              null === n2 ? r = e4 : c(e4 - r);
            }
            function l() {
              for (; r < s; ) {
                let t4 = e3.charCodeAt(r);
                if (32 !== t4 && 9 !== t4 && 13 !== t4 && 10 !== t4)
                  break;
                c(1);
              }
            }
            function u(t4) {
              return e3.substr(r, t4.length) === t4 && (c(t4.length), true);
            }
            function h(t4) {
              let n3 = e3.indexOf(t4, r);
              a(-1 !== n3 ? n3 + t4.length : s);
            }
            function p(t4) {
              let n3 = e3.indexOf(t4, r);
              if (-1 !== n3) {
                let s2 = e3.substring(r, n3);
                return a(n3 + t4.length), s2;
              }
              {
                let t5 = e3.substr(r);
                return a(s), t5;
              }
            }
            s > 0 && 65279 === e3.charCodeAt(0) && (r = 1);
            let d = 0, f = null, g = [], m = [], _ = null;
            function b(e4, t4) {
              g.push(d), m.push(f), d = e4, f = t4;
            }
            function y() {
              if (0 === g.length)
                return S("illegal state stack");
              d = g.pop(), f = m.pop();
            }
            function S(t4) {
              throw new Error("Near offset " + r + ": " + t4 + " ~~~" + e3.substr(r, 50) + "~~~");
            }
            const k = function() {
              if (null === _)
                return S("missing <key>");
              let e4 = {};
              null !== n2 && (e4[n2] = { filename: t3, line: i, char: o }), f[_] = e4, _ = null, b(1, e4);
            }, C = function() {
              if (null === _)
                return S("missing <key>");
              let e4 = [];
              f[_] = e4, _ = null, b(2, e4);
            }, R = function() {
              let e4 = {};
              null !== n2 && (e4[n2] = { filename: t3, line: i, char: o }), f.push(e4), b(1, e4);
            }, A = function() {
              let e4 = [];
              f.push(e4), b(2, e4);
            };
            function w() {
              if (1 !== d)
                return S("unexpected </dict>");
              y();
            }
            function P() {
              return 1 === d || 2 !== d ? S("unexpected </array>") : void y();
            }
            function I(e4) {
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function v(e4) {
              if (isNaN(e4))
                return S("cannot parse float");
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function N(e4) {
              if (isNaN(e4))
                return S("cannot parse integer");
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function T(e4) {
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function x(e4) {
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function G(e4) {
              if (1 === d) {
                if (null === _)
                  return S("missing <key>");
                f[_] = e4, _ = null;
              } else
                2 === d ? f.push(e4) : f = e4;
            }
            function E() {
              let e4 = p(">"), t4 = false;
              return 47 === e4.charCodeAt(e4.length - 1) && (t4 = true, e4 = e4.substring(0, e4.length - 1)), { name: e4.trim(), isClosed: t4 };
            }
            function L(e4) {
              if (e4.isClosed)
                return "";
              let t4 = p("</");
              return h(">"), t4.replace(/&#([0-9]+);/g, function(e5, t5) {
                return String.fromCodePoint(parseInt(t5, 10));
              }).replace(/&#x([0-9a-f]+);/g, function(e5, t5) {
                return String.fromCodePoint(parseInt(t5, 16));
              }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(e5) {
                switch (e5) {
                  case "&amp;":
                    return "&";
                  case "&lt;":
                    return "<";
                  case "&gt;":
                    return ">";
                  case "&quot;":
                    return '"';
                  case "&apos;":
                    return "'";
                }
                return e5;
              });
            }
            for (; r < s && (l(), !(r >= s)); ) {
              const a2 = e3.charCodeAt(r);
              if (c(1), 60 !== a2)
                return S("expected <");
              if (r >= s)
                return S("unexpected end of input");
              const p2 = e3.charCodeAt(r);
              if (63 === p2) {
                c(1), h("?>");
                continue;
              }
              if (33 === p2) {
                if (c(1), u("--")) {
                  h("-->");
                  continue;
                }
                h(">");
                continue;
              }
              if (47 === p2) {
                if (c(1), l(), u("plist")) {
                  h(">");
                  continue;
                }
                if (u("dict")) {
                  h(">"), w();
                  continue;
                }
                if (u("array")) {
                  h(">"), P();
                  continue;
                }
                return S("unexpected closed tag");
              }
              let g2 = E();
              switch (g2.name) {
                case "dict":
                  1 === d ? k() : 2 === d ? R() : (f = {}, null !== n2 && (f[n2] = { filename: t3, line: i, char: o }), b(1, f)), g2.isClosed && w();
                  continue;
                case "array":
                  1 === d ? C() : 2 === d ? A() : (f = [], b(2, f)), g2.isClosed && P();
                  continue;
                case "key":
                  M = L(g2), 1 !== d ? S("unexpected <key>") : null !== _ ? S("too many <key>") : _ = M;
                  continue;
                case "string":
                  I(L(g2));
                  continue;
                case "real":
                  v(parseFloat(L(g2)));
                  continue;
                case "integer":
                  N(parseInt(L(g2), 10));
                  continue;
                case "date":
                  T(new Date(L(g2)));
                  continue;
                case "data":
                  x(L(g2));
                  continue;
                case "true":
                  L(g2), G(true);
                  continue;
                case "false":
                  L(g2), G(false);
                  continue;
              }
              if (!/^plist/.test(g2.name))
                return S("unexpected opened tag " + g2.name);
            }
            var M;
            return f;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.parsePLIST = t2.parseWithLocation = void 0, t2.parseWithLocation = function(e3, t3, s) {
            return n(e3, t3, s);
          }, t2.parsePLIST = function(e3) {
            return n(e3, null, null);
          };
        }, 652: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.SyncRegistry = void 0;
          const s = n(391);
          t2.SyncRegistry = class {
            constructor(e3, t3) {
              this._onigLibPromise = t3, this._grammars = /* @__PURE__ */ new Map(), this._rawGrammars = /* @__PURE__ */ new Map(), this._injectionGrammars = /* @__PURE__ */ new Map(), this._theme = e3;
            }
            dispose() {
              for (const e3 of this._grammars.values())
                e3.dispose();
            }
            setTheme(e3) {
              this._theme = e3;
            }
            getColorMap() {
              return this._theme.getColorMap();
            }
            addGrammar(e3, t3) {
              this._rawGrammars.set(e3.scopeName, e3), t3 && this._injectionGrammars.set(e3.scopeName, t3);
            }
            lookup(e3) {
              return this._rawGrammars.get(e3);
            }
            injections(e3) {
              return this._injectionGrammars.get(e3);
            }
            getDefaults() {
              return this._theme.getDefaults();
            }
            themeMatch(e3) {
              return this._theme.match(e3);
            }
            async grammarForScopeName(e3, t3, n2, r, i) {
              if (!this._grammars.has(e3)) {
                let o = this._rawGrammars.get(e3);
                if (!o)
                  return null;
                this._grammars.set(e3, s.createGrammar(e3, o, t3, n2, r, i, this, await this._onigLibPromise));
              }
              return this._grammars.get(e3);
            }
          };
        }, 792: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.CompiledRule = t2.RegExpSourceList = t2.RegExpSource = t2.RuleFactory = t2.BeginWhileRule = t2.BeginEndRule = t2.IncludeOnlyRule = t2.MatchRule = t2.CaptureRule = t2.Rule = t2.ruleIdToNumber = t2.ruleIdFromNumber = t2.whileRuleId = t2.endRuleId = void 0;
          const s = n(878), r = n(965), i = /\\(\d+)/, o = /\\(\d+)/g;
          Symbol("RuleId"), t2.endRuleId = -1, t2.whileRuleId = -2, t2.ruleIdFromNumber = function(e3) {
            return e3;
          }, t2.ruleIdToNumber = function(e3) {
            return e3;
          };
          class c {
            constructor(e3, t3, n2, r2) {
              this.$location = e3, this.id = t3, this._name = n2 || null, this._nameIsCapturing = s.RegexSource.hasCaptures(this._name), this._contentName = r2 || null, this._contentNameIsCapturing = s.RegexSource.hasCaptures(this._contentName);
            }
            get debugName() {
              const e3 = this.$location ? `${s.basename(this.$location.filename)}:${this.$location.line}` : "unknown";
              return `${this.constructor.name}#${this.id} @ ${e3}`;
            }
            getName(e3, t3) {
              return this._nameIsCapturing && null !== this._name && null !== e3 && null !== t3 ? s.RegexSource.replaceCaptures(this._name, e3, t3) : this._name;
            }
            getContentName(e3, t3) {
              return this._contentNameIsCapturing && null !== this._contentName ? s.RegexSource.replaceCaptures(this._contentName, e3, t3) : this._contentName;
            }
          }
          t2.Rule = c;
          class a extends c {
            constructor(e3, t3, n2, s2, r2) {
              super(e3, t3, n2, s2), this.retokenizeCapturedWithRuleId = r2;
            }
            dispose() {
            }
            collectPatterns(e3, t3) {
              throw new Error("Not supported!");
            }
            compile(e3, t3) {
              throw new Error("Not supported!");
            }
            compileAG(e3, t3, n2, s2) {
              throw new Error("Not supported!");
            }
          }
          t2.CaptureRule = a;
          class l extends c {
            constructor(e3, t3, n2, s2, r2) {
              super(e3, t3, n2, null), this._match = new f(s2, this.id), this.captures = r2, this._cachedCompiledPatterns = null;
            }
            dispose() {
              this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
            }
            get debugMatchRegExp() {
              return `${this._match.source}`;
            }
            collectPatterns(e3, t3) {
              t3.push(this._match);
            }
            compile(e3, t3) {
              return this._getCachedCompiledPatterns(e3).compile(e3);
            }
            compileAG(e3, t3, n2, s2) {
              return this._getCachedCompiledPatterns(e3).compileAG(e3, n2, s2);
            }
            _getCachedCompiledPatterns(e3) {
              return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new g(), this.collectPatterns(e3, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
            }
          }
          t2.MatchRule = l;
          class u extends c {
            constructor(e3, t3, n2, s2, r2) {
              super(e3, t3, n2, s2), this.patterns = r2.patterns, this.hasMissingPatterns = r2.hasMissingPatterns, this._cachedCompiledPatterns = null;
            }
            dispose() {
              this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
            }
            collectPatterns(e3, t3) {
              for (const n2 of this.patterns)
                e3.getRule(n2).collectPatterns(e3, t3);
            }
            compile(e3, t3) {
              return this._getCachedCompiledPatterns(e3).compile(e3);
            }
            compileAG(e3, t3, n2, s2) {
              return this._getCachedCompiledPatterns(e3).compileAG(e3, n2, s2);
            }
            _getCachedCompiledPatterns(e3) {
              return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new g(), this.collectPatterns(e3, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
            }
          }
          t2.IncludeOnlyRule = u;
          class h extends c {
            constructor(e3, t3, n2, s2, r2, i2, o2, c2, a2, l2) {
              super(e3, t3, n2, s2), this._begin = new f(r2, this.id), this.beginCaptures = i2, this._end = new f(o2 || "￿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = c2, this.applyEndPatternLast = a2 || false, this.patterns = l2.patterns, this.hasMissingPatterns = l2.hasMissingPatterns, this._cachedCompiledPatterns = null;
            }
            dispose() {
              this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
            }
            get debugBeginRegExp() {
              return `${this._begin.source}`;
            }
            get debugEndRegExp() {
              return `${this._end.source}`;
            }
            getEndWithResolvedBackReferences(e3, t3) {
              return this._end.resolveBackReferences(e3, t3);
            }
            collectPatterns(e3, t3) {
              t3.push(this._begin);
            }
            compile(e3, t3) {
              return this._getCachedCompiledPatterns(e3, t3).compile(e3);
            }
            compileAG(e3, t3, n2, s2) {
              return this._getCachedCompiledPatterns(e3, t3).compileAG(e3, n2, s2);
            }
            _getCachedCompiledPatterns(e3, t3) {
              if (!this._cachedCompiledPatterns) {
                this._cachedCompiledPatterns = new g();
                for (const t4 of this.patterns)
                  e3.getRule(t4).collectPatterns(e3, this._cachedCompiledPatterns);
                this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
              }
              return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t3) : this._cachedCompiledPatterns.setSource(0, t3)), this._cachedCompiledPatterns;
            }
          }
          t2.BeginEndRule = h;
          class p extends c {
            constructor(e3, n2, s2, r2, i2, o2, c2, a2, l2) {
              super(e3, n2, s2, r2), this._begin = new f(i2, this.id), this.beginCaptures = o2, this.whileCaptures = a2, this._while = new f(c2, t2.whileRuleId), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l2.patterns, this.hasMissingPatterns = l2.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
            }
            dispose() {
              this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
            }
            get debugBeginRegExp() {
              return `${this._begin.source}`;
            }
            get debugWhileRegExp() {
              return `${this._while.source}`;
            }
            getWhileWithResolvedBackReferences(e3, t3) {
              return this._while.resolveBackReferences(e3, t3);
            }
            collectPatterns(e3, t3) {
              t3.push(this._begin);
            }
            compile(e3, t3) {
              return this._getCachedCompiledPatterns(e3).compile(e3);
            }
            compileAG(e3, t3, n2, s2) {
              return this._getCachedCompiledPatterns(e3).compileAG(e3, n2, s2);
            }
            _getCachedCompiledPatterns(e3) {
              if (!this._cachedCompiledPatterns) {
                this._cachedCompiledPatterns = new g();
                for (const t3 of this.patterns)
                  e3.getRule(t3).collectPatterns(e3, this._cachedCompiledPatterns);
              }
              return this._cachedCompiledPatterns;
            }
            compileWhile(e3, t3) {
              return this._getCachedCompiledWhilePatterns(e3, t3).compile(e3);
            }
            compileWhileAG(e3, t3, n2, s2) {
              return this._getCachedCompiledWhilePatterns(e3, t3).compileAG(e3, n2, s2);
            }
            _getCachedCompiledWhilePatterns(e3, t3) {
              return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new g(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t3 || "￿"), this._cachedCompiledWhilePatterns;
            }
          }
          t2.BeginWhileRule = p;
          class d {
            static createCaptureRule(e3, t3, n2, s2, r2) {
              return e3.registerRule((e4) => new a(t3, e4, n2, s2, r2));
            }
            static getCompiledRuleId(e3, t3, n2) {
              return e3.id || t3.registerRule((r2) => {
                if (e3.id = r2, e3.match)
                  return new l(e3.$vscodeTextmateLocation, e3.id, e3.name, e3.match, d._compileCaptures(e3.captures, t3, n2));
                if (void 0 === e3.begin) {
                  e3.repository && (n2 = s.mergeObjects({}, n2, e3.repository));
                  let r3 = e3.patterns;
                  return void 0 === r3 && e3.include && (r3 = [{ include: e3.include }]), new u(e3.$vscodeTextmateLocation, e3.id, e3.name, e3.contentName, d._compilePatterns(r3, t3, n2));
                }
                return e3.while ? new p(e3.$vscodeTextmateLocation, e3.id, e3.name, e3.contentName, e3.begin, d._compileCaptures(e3.beginCaptures || e3.captures, t3, n2), e3.while, d._compileCaptures(e3.whileCaptures || e3.captures, t3, n2), d._compilePatterns(e3.patterns, t3, n2)) : new h(e3.$vscodeTextmateLocation, e3.id, e3.name, e3.contentName, e3.begin, d._compileCaptures(e3.beginCaptures || e3.captures, t3, n2), e3.end, d._compileCaptures(e3.endCaptures || e3.captures, t3, n2), e3.applyEndPatternLast, d._compilePatterns(e3.patterns, t3, n2));
              }), e3.id;
            }
            static _compileCaptures(e3, t3, n2) {
              let s2 = [];
              if (e3) {
                let r2 = 0;
                for (const t4 in e3) {
                  if ("$vscodeTextmateLocation" === t4)
                    continue;
                  const e4 = parseInt(t4, 10);
                  e4 > r2 && (r2 = e4);
                }
                for (let e4 = 0; e4 <= r2; e4++)
                  s2[e4] = null;
                for (const r3 in e3) {
                  if ("$vscodeTextmateLocation" === r3)
                    continue;
                  const i2 = parseInt(r3, 10);
                  let o2 = 0;
                  e3[r3].patterns && (o2 = d.getCompiledRuleId(e3[r3], t3, n2)), s2[i2] = d.createCaptureRule(t3, e3[r3].$vscodeTextmateLocation, e3[r3].name, e3[r3].contentName, o2);
                }
              }
              return s2;
            }
            static _compilePatterns(e3, t3, n2) {
              let s2 = [];
              if (e3)
                for (let i2 = 0, o2 = e3.length; i2 < o2; i2++) {
                  const o3 = e3[i2];
                  let c2 = -1;
                  if (o3.include) {
                    const e4 = r.parseInclude(o3.include);
                    switch (e4.kind) {
                      case 0:
                      case 1:
                        c2 = d.getCompiledRuleId(n2[o3.include], t3, n2);
                        break;
                      case 2:
                        let s3 = n2[e4.ruleName];
                        s3 && (c2 = d.getCompiledRuleId(s3, t3, n2));
                        break;
                      case 3:
                      case 4:
                        const r2 = e4.scopeName, i3 = 4 === e4.kind ? e4.ruleName : null, a2 = t3.getExternalGrammar(r2, n2);
                        if (a2)
                          if (i3) {
                            let e5 = a2.repository[i3];
                            e5 && (c2 = d.getCompiledRuleId(e5, t3, a2.repository));
                          } else
                            c2 = d.getCompiledRuleId(a2.repository.$self, t3, a2.repository);
                    }
                  } else
                    c2 = d.getCompiledRuleId(o3, t3, n2);
                  if (-1 !== c2) {
                    const e4 = t3.getRule(c2);
                    let n3 = false;
                    if ((e4 instanceof u || e4 instanceof h || e4 instanceof p) && e4.hasMissingPatterns && 0 === e4.patterns.length && (n3 = true), n3)
                      continue;
                    s2.push(c2);
                  }
                }
              return { patterns: s2, hasMissingPatterns: (e3 ? e3.length : 0) !== s2.length };
            }
          }
          t2.RuleFactory = d;
          class f {
            constructor(e3, t3) {
              if (e3) {
                const t4 = e3.length;
                let n2 = 0, s2 = [], r2 = false;
                for (let i2 = 0; i2 < t4; i2++)
                  if ("\\" === e3.charAt(i2) && i2 + 1 < t4) {
                    const t5 = e3.charAt(i2 + 1);
                    "z" === t5 ? (s2.push(e3.substring(n2, i2)), s2.push("$(?!\\n)(?<!\\n)"), n2 = i2 + 2) : "A" !== t5 && "G" !== t5 || (r2 = true), i2++;
                  }
                this.hasAnchor = r2, 0 === n2 ? this.source = e3 : (s2.push(e3.substring(n2, t4)), this.source = s2.join(""));
              } else
                this.hasAnchor = false, this.source = e3;
              this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = t3, this.hasBackReferences = i.test(this.source);
            }
            clone() {
              return new f(this.source, this.ruleId);
            }
            setSource(e3) {
              this.source !== e3 && (this.source = e3, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
            }
            resolveBackReferences(e3, t3) {
              let n2 = t3.map((t4) => e3.substring(t4.start, t4.end));
              return o.lastIndex = 0, this.source.replace(o, (e4, t4) => s.escapeRegExpCharacters(n2[parseInt(t4, 10)] || ""));
            }
            _buildAnchorCache() {
              let e3, t3, n2, s2, r2 = [], i2 = [], o2 = [], c2 = [];
              for (e3 = 0, t3 = this.source.length; e3 < t3; e3++)
                n2 = this.source.charAt(e3), r2[e3] = n2, i2[e3] = n2, o2[e3] = n2, c2[e3] = n2, "\\" === n2 && e3 + 1 < t3 && (s2 = this.source.charAt(e3 + 1), "A" === s2 ? (r2[e3 + 1] = "￿", i2[e3 + 1] = "￿", o2[e3 + 1] = "A", c2[e3 + 1] = "A") : "G" === s2 ? (r2[e3 + 1] = "￿", i2[e3 + 1] = "G", o2[e3 + 1] = "￿", c2[e3 + 1] = "G") : (r2[e3 + 1] = s2, i2[e3 + 1] = s2, o2[e3 + 1] = s2, c2[e3 + 1] = s2), e3++);
              return { A0_G0: r2.join(""), A0_G1: i2.join(""), A1_G0: o2.join(""), A1_G1: c2.join("") };
            }
            resolveAnchors(e3, t3) {
              return this.hasAnchor && this._anchorCache ? e3 ? t3 ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : t3 ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source;
            }
          }
          t2.RegExpSource = f;
          class g {
            constructor() {
              this._items = [], this._hasAnchors = false, this._cached = null, this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null };
            }
            dispose() {
              this._disposeCaches();
            }
            _disposeCaches() {
              this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
            }
            push(e3) {
              this._items.push(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
            }
            unshift(e3) {
              this._items.unshift(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
            }
            length() {
              return this._items.length;
            }
            setSource(e3, t3) {
              this._items[e3].source !== t3 && (this._disposeCaches(), this._items[e3].setSource(t3));
            }
            compile(e3) {
              if (!this._cached) {
                let t3 = this._items.map((e4) => e4.source);
                this._cached = new m(e3, t3, this._items.map((e4) => e4.ruleId));
              }
              return this._cached;
            }
            compileAG(e3, t3, n2) {
              return this._hasAnchors ? t3 ? n2 ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A1_G0) : n2 ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A0_G0) : this.compile(e3);
            }
            _resolveAnchors(e3, t3, n2) {
              let s2 = this._items.map((e4) => e4.resolveAnchors(t3, n2));
              return new m(e3, s2, this._items.map((e4) => e4.ruleId));
            }
          }
          t2.RegExpSourceList = g;
          class m {
            constructor(e3, t3, n2) {
              this.regExps = t3, this.rules = n2, this.scanner = e3.createOnigScanner(t3);
            }
            dispose() {
              "function" == typeof this.scanner.dispose && this.scanner.dispose();
            }
            toString() {
              const e3 = [];
              for (let t3 = 0, n2 = this.rules.length; t3 < n2; t3++)
                e3.push("   - " + this.rules[t3] + ": " + this.regExps[t3]);
              return e3.join("\n");
            }
            findNextMatchSync(e3, t3, n2) {
              const s2 = this.scanner.findNextMatchSync(e3, t3, n2);
              return s2 ? { ruleId: this.rules[s2.index], captureIndices: s2.captureIndices } : null;
            }
          }
          t2.CompiledRule = m;
        }, 583: (e2, t2, n) => {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeTrieElement = t2.ThemeTrieElementRule = t2.ColorMap = t2.fontStyleToString = t2.ParsedThemeRule = t2.parseTheme = t2.StyleAttributes = t2.ScopeStack = t2.Theme = void 0;
          const s = n(878);
          class r {
            constructor(e3, t3, n2) {
              this._colorMap = e3, this._defaults = t3, this._root = n2, this._cachedMatchRoot = new s.CachedFn((e4) => this._root.match(e4));
            }
            static createFromRawTheme(e3, t3) {
              return this.createFromParsedTheme(a(e3), t3);
            }
            static createFromParsedTheme(e3, t3) {
              return function(e4, t4) {
                e4.sort((e5, t5) => {
                  let n3 = s.strcmp(e5.scope, t5.scope);
                  return 0 !== n3 ? n3 : (n3 = s.strArrCmp(e5.parentScopes, t5.parentScopes), 0 !== n3 ? n3 : e5.index - t5.index);
                });
                let n2 = 0, i2 = "#000000", o2 = "#ffffff";
                for (; e4.length >= 1 && "" === e4[0].scope; ) {
                  let t5 = e4.shift();
                  -1 !== t5.fontStyle && (n2 = t5.fontStyle), null !== t5.foreground && (i2 = t5.foreground), null !== t5.background && (o2 = t5.background);
                }
                let a2 = new u(t4), l2 = new c(n2, a2.getId(i2), a2.getId(o2)), d = new p(new h(0, null, -1, 0, 0), []);
                for (let t5 = 0, n3 = e4.length; t5 < n3; t5++) {
                  let n4 = e4[t5];
                  d.insert(0, n4.scope, n4.parentScopes, n4.fontStyle, a2.getId(n4.foreground), a2.getId(n4.background));
                }
                return new r(a2, l2, d);
              }(e3, t3);
            }
            getColorMap() {
              return this._colorMap.getColorMap();
            }
            getDefaults() {
              return this._defaults;
            }
            match(e3) {
              if (null === e3)
                return this._defaults;
              const t3 = e3.scopeName, n2 = this._cachedMatchRoot.get(t3).find((t4) => function(e4, t5) {
                if (null === t5)
                  return true;
                let n3 = 0, s2 = t5[n3];
                for (; e4; ) {
                  if (o(e4.scopeName, s2)) {
                    if (n3++, n3 === t5.length)
                      return true;
                    s2 = t5[n3];
                  }
                  e4 = e4.parent;
                }
                return false;
              }(e3.parent, t4.parentScopes));
              return n2 ? new c(n2.fontStyle, n2.foreground, n2.background) : null;
            }
          }
          t2.Theme = r;
          class i {
            constructor(e3, t3) {
              this.parent = e3, this.scopeName = t3;
            }
            static from(...e3) {
              let t3 = null;
              for (let n2 = 0; n2 < e3.length; n2++)
                t3 = new i(t3, e3[n2]);
              return t3;
            }
            push(e3) {
              return new i(this, e3);
            }
            getSegments() {
              let e3 = this;
              const t3 = [];
              for (; e3; )
                t3.push(e3.scopeName), e3 = e3.parent;
              return t3.reverse(), t3;
            }
            toString() {
              return this.getSegments().join(" ");
            }
          }
          function o(e3, t3) {
            return t3 === e3 || e3.startsWith(t3) && "." === e3[t3.length];
          }
          t2.ScopeStack = i;
          class c {
            constructor(e3, t3, n2) {
              this.fontStyle = e3, this.foregroundId = t3, this.backgroundId = n2;
            }
          }
          function a(e3) {
            if (!e3)
              return [];
            if (!e3.settings || !Array.isArray(e3.settings))
              return [];
            let t3 = e3.settings, n2 = [], r2 = 0;
            for (let e4 = 0, i2 = t3.length; e4 < i2; e4++) {
              let i3, o2 = t3[e4];
              if (!o2.settings)
                continue;
              if ("string" == typeof o2.scope) {
                let e5 = o2.scope;
                e5 = e5.replace(/^[,]+/, ""), e5 = e5.replace(/[,]+$/, ""), i3 = e5.split(",");
              } else
                i3 = Array.isArray(o2.scope) ? o2.scope : [""];
              let c2 = -1;
              if ("string" == typeof o2.settings.fontStyle) {
                c2 = 0;
                let e5 = o2.settings.fontStyle.split(" ");
                for (let t4 = 0, n3 = e5.length; t4 < n3; t4++)
                  switch (e5[t4]) {
                    case "italic":
                      c2 |= 1;
                      break;
                    case "bold":
                      c2 |= 2;
                      break;
                    case "underline":
                      c2 |= 4;
                      break;
                    case "strikethrough":
                      c2 |= 8;
                  }
              }
              let a2 = null;
              "string" == typeof o2.settings.foreground && s.isValidHexColor(o2.settings.foreground) && (a2 = o2.settings.foreground);
              let u2 = null;
              "string" == typeof o2.settings.background && s.isValidHexColor(o2.settings.background) && (u2 = o2.settings.background);
              for (let t4 = 0, s2 = i3.length; t4 < s2; t4++) {
                let s3 = i3[t4].trim().split(" "), o3 = s3[s3.length - 1], h2 = null;
                s3.length > 1 && (h2 = s3.slice(0, s3.length - 1), h2.reverse()), n2[r2++] = new l(o3, h2, e4, c2, a2, u2);
              }
            }
            return n2;
          }
          t2.StyleAttributes = c, t2.parseTheme = a;
          class l {
            constructor(e3, t3, n2, s2, r2, i2) {
              this.scope = e3, this.parentScopes = t3, this.index = n2, this.fontStyle = s2, this.foreground = r2, this.background = i2;
            }
          }
          t2.ParsedThemeRule = l, t2.fontStyleToString = function(e3) {
            if (-1 === e3)
              return "not set";
            let t3 = "";
            return 1 & e3 && (t3 += "italic "), 2 & e3 && (t3 += "bold "), 4 & e3 && (t3 += "underline "), 8 & e3 && (t3 += "strikethrough "), "" === t3 && (t3 = "none"), t3.trim();
          };
          class u {
            constructor(e3) {
              if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e3)) {
                this._isFrozen = true;
                for (let t3 = 0, n2 = e3.length; t3 < n2; t3++)
                  this._color2id[e3[t3]] = t3, this._id2color[t3] = e3[t3];
              } else
                this._isFrozen = false;
            }
            getId(e3) {
              if (null === e3)
                return 0;
              e3 = e3.toUpperCase();
              let t3 = this._color2id[e3];
              if (t3)
                return t3;
              if (this._isFrozen)
                throw new Error(`Missing color in color map - ${e3}`);
              return t3 = ++this._lastColorId, this._color2id[e3] = t3, this._id2color[t3] = e3, t3;
            }
            getColorMap() {
              return this._id2color.slice(0);
            }
          }
          t2.ColorMap = u;
          class h {
            constructor(e3, t3, n2, s2, r2) {
              this.scopeDepth = e3, this.parentScopes = t3, this.fontStyle = n2, this.foreground = s2, this.background = r2;
            }
            clone() {
              return new h(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
            }
            static cloneArr(e3) {
              let t3 = [];
              for (let n2 = 0, s2 = e3.length; n2 < s2; n2++)
                t3[n2] = e3[n2].clone();
              return t3;
            }
            acceptOverwrite(e3, t3, n2, s2) {
              this.scopeDepth > e3 ? console.log("how did this happen?") : this.scopeDepth = e3, -1 !== t3 && (this.fontStyle = t3), 0 !== n2 && (this.foreground = n2), 0 !== s2 && (this.background = s2);
            }
          }
          t2.ThemeTrieElementRule = h;
          class p {
            constructor(e3, t3 = [], n2 = {}) {
              this._mainRule = e3, this._children = n2, this._rulesWithParentScopes = t3;
            }
            static _sortBySpecificity(e3) {
              return 1 === e3.length || e3.sort(this._cmpBySpecificity), e3;
            }
            static _cmpBySpecificity(e3, t3) {
              if (e3.scopeDepth === t3.scopeDepth) {
                const n2 = e3.parentScopes, s2 = t3.parentScopes;
                let r2 = null === n2 ? 0 : n2.length, i2 = null === s2 ? 0 : s2.length;
                if (r2 === i2)
                  for (let e4 = 0; e4 < r2; e4++) {
                    const t4 = n2[e4].length, r3 = s2[e4].length;
                    if (t4 !== r3)
                      return r3 - t4;
                  }
                return i2 - r2;
              }
              return t3.scopeDepth - e3.scopeDepth;
            }
            match(e3) {
              if ("" === e3)
                return p._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
              let t3, n2, s2 = e3.indexOf(".");
              return -1 === s2 ? (t3 = e3, n2 = "") : (t3 = e3.substring(0, s2), n2 = e3.substring(s2 + 1)), this._children.hasOwnProperty(t3) ? this._children[t3].match(n2) : p._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
            }
            insert(e3, t3, n2, s2, r2, i2) {
              if ("" === t3)
                return void this._doInsertHere(e3, n2, s2, r2, i2);
              let o2, c2, a2, l2 = t3.indexOf(".");
              -1 === l2 ? (o2 = t3, c2 = "") : (o2 = t3.substring(0, l2), c2 = t3.substring(l2 + 1)), this._children.hasOwnProperty(o2) ? a2 = this._children[o2] : (a2 = new p(this._mainRule.clone(), h.cloneArr(this._rulesWithParentScopes)), this._children[o2] = a2), a2.insert(e3 + 1, c2, n2, s2, r2, i2);
            }
            _doInsertHere(e3, t3, n2, r2, i2) {
              if (null !== t3) {
                for (let o2 = 0, c2 = this._rulesWithParentScopes.length; o2 < c2; o2++) {
                  let c3 = this._rulesWithParentScopes[o2];
                  if (0 === s.strArrCmp(c3.parentScopes, t3))
                    return void c3.acceptOverwrite(e3, n2, r2, i2);
                }
                -1 === n2 && (n2 = this._mainRule.fontStyle), 0 === r2 && (r2 = this._mainRule.foreground), 0 === i2 && (i2 = this._mainRule.background), this._rulesWithParentScopes.push(new h(e3, t3, n2, r2, i2));
              } else
                this._mainRule.acceptOverwrite(e3, n2, r2, i2);
            }
          }
          t2.ThemeTrieElement = p;
        }, 878: (e2, t2) => {
          function n(e3) {
            return Array.isArray(e3) ? function(e4) {
              let t3 = [];
              for (let s2 = 0, r2 = e4.length; s2 < r2; s2++)
                t3[s2] = n(e4[s2]);
              return t3;
            }(e3) : "object" == typeof e3 ? function(e4) {
              let t3 = {};
              for (let s2 in e4)
                t3[s2] = n(e4[s2]);
              return t3;
            }(e3) : e3;
          }
          Object.defineProperty(t2, "__esModule", { value: true }), t2.performanceNow = t2.CachedFn = t2.escapeRegExpCharacters = t2.isValidHexColor = t2.strArrCmp = t2.strcmp = t2.RegexSource = t2.basename = t2.mergeObjects = t2.clone = void 0, t2.clone = function(e3) {
            return n(e3);
          }, t2.mergeObjects = function(e3, ...t3) {
            return t3.forEach((t4) => {
              for (let n2 in t4)
                e3[n2] = t4[n2];
            }), e3;
          }, t2.basename = function e3(t3) {
            const n2 = ~t3.lastIndexOf("/") || ~t3.lastIndexOf("\\");
            return 0 === n2 ? t3 : ~n2 == t3.length - 1 ? e3(t3.substring(0, t3.length - 1)) : t3.substr(1 + ~n2);
          };
          let s = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
          function r(e3, t3) {
            return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
          }
          t2.RegexSource = class {
            static hasCaptures(e3) {
              return null !== e3 && (s.lastIndex = 0, s.test(e3));
            }
            static replaceCaptures(e3, t3, n2) {
              return e3.replace(s, (e4, s2, r2, i) => {
                let o = n2[parseInt(s2 || r2, 10)];
                if (!o)
                  return e4;
                {
                  let e5 = t3.substring(o.start, o.end);
                  for (; "." === e5[0]; )
                    e5 = e5.substring(1);
                  switch (i) {
                    case "downcase":
                      return e5.toLowerCase();
                    case "upcase":
                      return e5.toUpperCase();
                    default:
                      return e5;
                  }
                }
              });
            }
          }, t2.strcmp = r, t2.strArrCmp = function(e3, t3) {
            if (null === e3 && null === t3)
              return 0;
            if (!e3)
              return -1;
            if (!t3)
              return 1;
            let n2 = e3.length, s2 = t3.length;
            if (n2 === s2) {
              for (let s3 = 0; s3 < n2; s3++) {
                let n3 = r(e3[s3], t3[s3]);
                if (0 !== n3)
                  return n3;
              }
              return 0;
            }
            return n2 - s2;
          }, t2.isValidHexColor = function(e3) {
            return !!(/^#[0-9a-f]{6}$/i.test(e3) || /^#[0-9a-f]{8}$/i.test(e3) || /^#[0-9a-f]{3}$/i.test(e3) || /^#[0-9a-f]{4}$/i.test(e3));
          }, t2.escapeRegExpCharacters = function(e3) {
            return e3.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
          }, t2.CachedFn = class {
            constructor(e3) {
              this.fn = e3, this.cache = /* @__PURE__ */ new Map();
            }
            get(e3) {
              if (this.cache.has(e3))
                return this.cache.get(e3);
              const t3 = this.fn(e3);
              return this.cache.set(e3, t3), t3;
            }
          }, t2.performanceNow = "undefined" == typeof performance ? function() {
            return Date.now();
          } : function() {
            return performance.now();
          };
        } }, t = {};
        return function n(s) {
          var r = t[s];
          if (void 0 !== r)
            return r.exports;
          var i = t[s] = { exports: {} };
          return e[s].call(i.exports, i, i.exports, n), i.exports;
        }(787);
      })();
    });
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof __require && __require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z2 = 0, C = 0;
          w && (z2 |= 16), "UNIX" === i2 ? (C = 798, z2 |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z2 |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z2 = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z2 && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z2) {
              if (j(e2), e2.lookahead < z2 && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z2) {
              if (j(e2), e2.lookahead < z2 && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z2, C;
          r2 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z2[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z2[n++] << p, p += 8, d += z2[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z2[n++] << p, (p += 8) < y && (d += z2[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z2, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z2 = _ + 2; l2 < z2; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z2 = _ + 3; l2 < z2; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z2 = _ + 7; l2 < z2; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z2 = r2.extra; l2 < z2; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z2 = r2.extra; l2 < z2; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z2 = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z2 = 1; b <= 15; b++)
            if (z2 <<= 1, (z2 -= O[b]) < 0)
              return -1;
          if (0 < z2 && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z2 = 1 << (x = b - S); x + S < w && !((z2 -= O[x + S]) <= 0); )
                x++, z2 <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l + 2));
        n(z2);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z2[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z2[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z2, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z2, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z2, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z2), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/@blocksuite/blocks/dist/components/button.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IconButton = class IconButton2 extends LitElement {
  constructor() {
    super();
    this.size = null;
    this.width = "28px";
    this.height = "28px";
    this.text = null;
    this.disabled = false;
    this.addEventListener("keypress", (event) => {
      if (this.disabled) {
        return;
      }
      if (event.key === "Enter") {
        this.click();
      }
    });
    this.addEventListener("click", (event) => {
      if (this.disabled === "") {
        event.preventDefault();
        event.stopPropagation();
      }
    }, { capture: true });
  }
  connectedCallback() {
    super.connectedCallback();
    this.tabIndex = 0;
    if (this.size && (this.width || this.height)) {
      throw new Error("Cannot set both size and width/height on an icon-button");
    }
    let width = this.width;
    let height = this.height;
    if (this.size) {
      width = this.size;
      height = this.size;
    }
    this.style.setProperty("--button-width", typeof width === "string" ? width : `${width}px`);
    this.style.setProperty("--button-height", typeof height === "string" ? height : `${height}px`);
  }
  render() {
    return html`<slot></slot>${this.text ? html`<span>${this.text}</span>` : ""}<slot name="optional"></slot> `;
  }
};
IconButton.styles = css`
    :host {
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
      border: none;
      width: var(--button-width);
      height: var(--button-height);
      border-radius: 5px;
      background: transparent;
      cursor: pointer;
      user-select: none;
      font-family: var(--affine-font-family);
      fill: var(--affine-icon-color);
      color: var(--affine-popover-color);
      pointer-events: auto;
    }

    :host > span {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host(:hover) {
      background: var(--affine-hover-color);
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }

    :host(:active) {
      background: transparent;
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }

    :host([disabled]),
    :host(:disabled) {
      background: transparent;
      color: var(--affine-text-disable-color);
      fill: var(--affine-text-disable-color);
      cursor: not-allowed;
    }

    /* You can add a 'hover' attribute to the button to show the hover style */
    :host([hover]) {
      background: var(--affine-hover-color);
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }

    /* You can add a 'active' attribute to the button to revert the active style */
    :host([active]) {
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }

    :host(:active[active]) {
      background: transparent;
      fill: var(--affine-icon-color);
    }
  `;
__decorate([
  property()
], IconButton.prototype, "size", void 0);
__decorate([
  property()
], IconButton.prototype, "width", void 0);
__decorate([
  property()
], IconButton.prototype, "height", void 0);
__decorate([
  property()
], IconButton.prototype, "text", void 0);
__decorate([
  property()
], IconButton.prototype, "disabled", void 0);
IconButton = __decorate([
  customElement("icon-button")
], IconButton);

// node_modules/@blocksuite/lit/dist/width-disposable.js
function WithDisposable(SuperClass) {
  class DerivedClass extends SuperClass {
    constructor() {
      super(...arguments);
      this._disposables = new DisposableGroup();
    }
    connectedCallback() {
      super.connectedCallback();
      if (this._disposables.disposed) {
        this._disposables = new DisposableGroup();
      }
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._disposables.dispose();
    }
  }
  return DerivedClass;
}

// node_modules/@blocksuite/lit/dist/element/shadowless-element.js
var ShadowlessElement = class extends LitElement {
  static finalizeStyles(styles15) {
    let elementStyles = super.finalizeStyles(styles15);
    const styleRoot = document.head;
    if (this.disableShadowRoot) {
      elementStyles.forEach((s) => {
        if (s instanceof CSSResult) {
          const style = document.createElement("style");
          style.textContent = s.cssText;
          styleRoot.appendChild(style);
        } else {
          console.error("unreachable");
        }
      });
      elementStyles = [];
    }
    return elementStyles;
  }
  createRenderRoot() {
    return this.constructor.disableShadowRoot ? this : super.createRenderRoot();
  }
};
ShadowlessElement.disableShadowRoot = true;

// node_modules/@blocksuite/lit/dist/element/block-element.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BlockElement = class extends WithDisposable(ShadowlessElement) {
};
__decorate2([
  property()
], BlockElement.prototype, "root", void 0);
__decorate2([
  property()
], BlockElement.prototype, "model", void 0);
__decorate2([
  property()
], BlockElement.prototype, "content", void 0);
__decorate2([
  property()
], BlockElement.prototype, "page", void 0);

// node_modules/lit-html/development/static.js
var brand = Symbol.for("");
var unwrapStaticValue = (value) => {
  if ((value === null || value === void 0 ? void 0 : value.r) !== brand) {
    return void 0;
  }
  return value === null || value === void 0 ? void 0 : value["_$litStatic$"];
};
var unsafeStatic = (value) => ({
  ["_$litStatic$"]: value,
  r: brand
});
var textFromStatic = (value) => {
  if (value["_$litStatic$"] !== void 0) {
    return value["_$litStatic$"];
  } else {
    throw new Error(`Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
var literal = (strings, ...values) => ({
  ["_$litStatic$"]: values.reduce((acc, v, idx) => acc + textFromStatic(v) + strings[idx + 1], strings[0]),
  r: brand
});
var stringsCache = /* @__PURE__ */ new Map();
var withStatic = (coreTag) => (strings, ...values) => {
  const l = values.length;
  let staticValue;
  let dynamicValue;
  const staticStrings = [];
  const dynamicValues = [];
  let i = 0;
  let hasStatics = false;
  let s;
  while (i < l) {
    s = strings[i];
    while (i < l && (dynamicValue = values[i], staticValue = unwrapStaticValue(dynamicValue)) !== void 0) {
      s += staticValue + strings[++i];
      hasStatics = true;
    }
    if (i !== l) {
      dynamicValues.push(dynamicValue);
    }
    staticStrings.push(s);
    i++;
  }
  if (i === l) {
    staticStrings.push(strings[l]);
  }
  if (hasStatics) {
    const key = staticStrings.join("$$lit$$");
    strings = stringsCache.get(key);
    if (strings === void 0) {
      staticStrings.raw = staticStrings;
      stringsCache.set(key, strings = staticStrings);
    }
    values = dynamicValues;
  }
  return coreTag(strings, ...values);
};
var html2 = withStatic(html);
var svg2 = withStatic(svg);

// node_modules/@blocksuite/lit/dist/event/base.js
var UIEventState = class {
  constructor(event) {
    this.event = event;
    this.type = "defaultState";
  }
};
var UIEventStateContext = class _UIEventStateContext {
  constructor() {
    this._map = {};
    this.add = (state2) => {
      const name = state2.type;
      if (this._map[name]) {
        console.warn("UIEventStateContext: state name duplicated", name);
      }
      this._map[name] = state2;
    };
    this.has = (type) => {
      return !!this._map[type];
    };
    this.get = (type) => {
      const state2 = this._map[type];
      assertExists(state2, `UIEventStateContext: state ${type} not found`);
      return state2;
    };
  }
  static from(...states) {
    const context = new _UIEventStateContext();
    states.forEach((state2) => {
      context.add(state2);
    });
    return context;
  }
};

// node_modules/@blocksuite/lit/dist/event/state.js
var PointerEventState = class extends UIEventState {
  get x() {
    return this.point.x;
  }
  get y() {
    return this.point.y;
  }
  constructor({ event, rect, startX, startY, last }) {
    super(event);
    this.type = "pointerState";
    const offsetX = event.clientX - rect.left;
    const offsetY = event.clientY - rect.top;
    this.raw = event;
    this.point = { x: offsetX, y: offsetY };
    this.containerOffset = { x: rect.left, y: rect.top };
    this.start = { x: startX, y: startY };
    this.delta = last ? { x: offsetX - last.point.x, y: offsetY - last.point.y } : { x: 0, y: 0 };
    this.keys = {
      shift: event.shiftKey,
      cmd: event.metaKey || event.ctrlKey,
      alt: event.altKey
    };
    this.button = (last == null ? void 0 : last.button) || event.button;
    this.dragging = !!last;
  }
};
var KeyboardEventState = class extends UIEventState {
  constructor({ event }) {
    super(event);
    this.type = "keyboardState";
    this.raw = event;
  }
};

// node_modules/@blocksuite/lit/dist/event/keyboard.js
var KeyboardControl = class {
  constructor(_dispatcher) {
    this._dispatcher = _dispatcher;
    this._down = (event) => {
      const keyboardEventState = new KeyboardEventState({
        event
      });
      this._dispatcher.run("keyDown", UIEventStateContext.from(keyboardEventState));
    };
    this._up = (event) => {
      const keyboardEventState = new KeyboardEventState({
        event
      });
      this._dispatcher.run("keyUp", UIEventStateContext.from(keyboardEventState));
    };
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(document, "keydown", this._down);
    this._dispatcher.disposables.addFromEvent(document, "keyup", this._up);
  }
};

// node_modules/@blocksuite/lit/dist/event/utils.js
function isFarEnough(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.pow(dx, 2) + Math.pow(dy, 2) > 4;
}
var toLowerCase = (str) => str.toLowerCase();

// node_modules/@blocksuite/lit/dist/event/pointer.js
var PointerControl = class {
  constructor(_dispatcher) {
    this._dispatcher = _dispatcher;
    this._lastPointerDownEvent = null;
    this._startDragState = null;
    this._lastDragState = null;
    this._pointerDownCount = 0;
    this._dragging = false;
    this._startX = -Infinity;
    this._startY = -Infinity;
    this._reset = () => {
      this._startX = -Infinity;
      this._startY = -Infinity;
      this._lastDragState = null;
      this._dragging = false;
    };
    this._down = (event) => {
      if (this._lastPointerDownEvent && event.timeStamp - this._lastPointerDownEvent.timeStamp < 500 && !isFarEnough(event, this._lastPointerDownEvent)) {
        this._pointerDownCount++;
      } else {
        this._pointerDownCount = 1;
      }
      const pointerEventState = new PointerEventState({
        event,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: null
      });
      this._startX = pointerEventState.point.x;
      this._startY = pointerEventState.point.y;
      this._startDragState = pointerEventState;
      this._lastDragState = pointerEventState;
      this._lastPointerDownEvent = event;
      this._dispatcher.run("pointerDown", UIEventStateContext.from(pointerEventState));
      this._dispatcher.disposables.addFromEvent(document, "pointermove", this._move);
      this._dispatcher.disposables.addFromEvent(document, "pointerup", this._up);
    };
    this._up = (event) => {
      const pointerEventState = new PointerEventState({
        event,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: this._lastDragState
      });
      const context = UIEventStateContext.from(pointerEventState);
      const run = () => {
        if (this._dragging) {
          this._dispatcher.run("dragEnd", context);
          return;
        }
        this._dispatcher.run("click", context);
        if (this._pointerDownCount === 2) {
          this._dispatcher.run("doubleClick", context);
        }
        if (this._pointerDownCount === 3) {
          this._dispatcher.run("tripleClick", context);
        }
      };
      run();
      this._dispatcher.run("pointerUp", context);
      this._reset();
      document.removeEventListener("pointermove", this._move);
      document.removeEventListener("pointerup", this._up);
    };
    this._move = (event) => {
      const last = this._lastDragState;
      const state2 = new PointerEventState({
        event,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last
      });
      this._lastDragState = state2;
      assertExists(this._startDragState);
      if (!this._dragging && isFarEnough(this._startDragState.raw, state2.raw)) {
        this._dragging = true;
        this._dispatcher.run("dragStart", UIEventStateContext.from(this._startDragState));
      }
      if (this._dragging) {
        this._dispatcher.run("dragMove", UIEventStateContext.from(state2));
      }
    };
    this._moveOn = (event) => {
      const state2 = new PointerEventState({
        event,
        rect: this._rect,
        startX: this._startX,
        startY: this._startY,
        last: this._lastDragState
      });
      this._dispatcher.run("pointerMove", UIEventStateContext.from(state2));
    };
    this._out = (event) => {
      const state2 = new PointerEventState({
        event,
        rect: this._rect,
        startX: -Infinity,
        startY: -Infinity,
        last: null
      });
      this._dispatcher.run("pointerOut", UIEventStateContext.from(state2));
    };
  }
  listen() {
    this._dispatcher.disposables.addFromEvent(this._dispatcher.root, "pointerdown", this._down);
    this._dispatcher.disposables.addFromEvent(this._dispatcher.root, "pointermove", this._moveOn);
    this._dispatcher.disposables.addFromEvent(this._dispatcher.root, "pointerout", this._out);
  }
  get _rect() {
    return this._dispatcher.root.getBoundingClientRect();
  }
};

// node_modules/@blocksuite/lit/dist/event/dispatcher.js
var bypassEventNames = [
  "beforeInput",
  "compositionStart",
  "compositionUpdate",
  "compositionEnd",
  "paste",
  "copy",
  "blur",
  "focus",
  "drop",
  "contextMenu",
  "wheel"
];
var globalEventNames = ["selectionChange", "virgo-vrange-updated"];
var eventNames = [
  "click",
  "doubleClick",
  "tripleClick",
  "pointerDown",
  "pointerMove",
  "pointerUp",
  "pointerOut",
  "dragStart",
  "dragMove",
  "dragEnd",
  "keyDown",
  "keyUp",
  ...bypassEventNames,
  ...globalEventNames
];
var UIEventDispatcher = class {
  constructor(root2) {
    this.root = root2;
    this.disposables = new DisposableGroup();
    this._handlersMap = Object.fromEntries(eventNames.map((name) => [name, []]));
    this._pointerControl = new PointerControl(this);
    this._keyboardControl = new KeyboardControl(this);
  }
  mount() {
    if (this.disposables.disposed) {
      this.disposables = new DisposableGroup();
    }
    this._bindEvents();
  }
  unmount() {
    this.disposables.dispose();
  }
  run(name, context) {
    const handlers = this._handlersMap[name];
    if (!handlers)
      return;
    for (const handler of handlers) {
      const result = handler(context);
      if (result) {
        return;
      }
    }
  }
  add(name, handler) {
    this._handlersMap[name].unshift(handler);
    return () => {
      if (this._handlersMap[name].includes(handler)) {
        this._handlersMap[name] = this._handlersMap[name].filter((f) => f !== handler);
      }
    };
  }
  _bindEvents() {
    bypassEventNames.forEach((eventName) => {
      this.disposables.addFromEvent(this.root, toLowerCase(eventName), (e) => {
        this.run(eventName, UIEventStateContext.from(new UIEventState(e)));
      });
    });
    globalEventNames.forEach((eventName) => {
      this.disposables.addFromEvent(document, toLowerCase(eventName), (e) => {
        this.run(eventName, UIEventStateContext.from(new UIEventState(e)));
      });
    });
    this._pointerControl.listen();
    this._keyboardControl.listen();
  }
};

// node_modules/@blocksuite/lit/dist/element/lit-root.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BlockSuiteRoot = class BlockSuiteRoot2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.blockIdAttr = "data-block-id";
    this.modelSubscribed = /* @__PURE__ */ new Set();
    this.uiEventDispatcher = new UIEventDispatcher(this);
    this.renderModel = (model) => {
      const { flavour, children } = model;
      const schema = this.page.schema.flavourSchemaMap.get(flavour);
      if (!schema) {
        console.warn(`Cannot find schema for ${flavour}.`);
        return html2`${nothing}`;
      }
      const tag = this.componentMap.get(schema);
      if (!tag) {
        console.warn(`Cannot find tag for ${flavour}.`);
        return html2`${nothing}`;
      }
      this._onLoadModel(model);
      return html2`<${tag}
      ${unsafeStatic(this.blockIdAttr)}=${model.id}
      .root=${this}
      .page=${this.page}
      .model=${model}
      .content=${html2`${repeat(children, (child) => child.id, (child) => this.renderModel(child))}`}
    ></${tag}>`;
    };
    this._onLoadModel = (model) => {
      const { id } = model;
      if (!this.modelSubscribed.has(id)) {
        model.propsUpdated.on(() => {
          this.requestUpdate();
        });
        model.childrenUpdated.on(() => {
          this.requestUpdate();
        });
        this.modelSubscribed.add(id);
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.uiEventDispatcher.mount();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.uiEventDispatcher.unmount();
  }
  render() {
    const { root: root2 } = this.page;
    if (!root2) {
      return null;
    }
    return this.renderModel(root2);
  }
};
__decorate3([
  property()
], BlockSuiteRoot.prototype, "componentMap", void 0);
__decorate3([
  property()
], BlockSuiteRoot.prototype, "page", void 0);
__decorate3([
  property()
], BlockSuiteRoot.prototype, "blockIdAttr", void 0);
BlockSuiteRoot = __decorate3([
  customElement("block-suite-root")
], BlockSuiteRoot);

// node_modules/@blocksuite/blocks/dist/components/tooltip/tooltip.js
var tooltipStyle = css`
  tool-tip {
    font-family: var(--affine-font-family);
    position: absolute;

    inline-size: max-content;
    text-align: center;
    font-size: var(--affine-font-sm);
    padding: 4px 12px;
    color: var(--affine-white);
    background: var(--affine-tooltip);
    opacity: 0;
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
    user-select: none;

    /* Default is top-start */
    left: 0;
    top: 0;
    border-radius: 10px 10px 10px 0;
    transform: translate(0, calc(-100% - 8px));
  }

  tool-tip:is([tip-position='top']) {
    left: 50%;
    border-radius: 10px;
    transform: translate(-50%, calc(-100% - 8px));
  }
  tool-tip:is([tip-position='right']) {
    left: unset;
    right: 0;
    transform: translateX(calc(100% + 8px));
    border-radius: 0 10px 10px 10px;
  }
  tool-tip:is([tip-position='left']) {
    left: 0;
    top: 50%;
    transform: translate(calc(-100% - 8px), -50%);
    border-radius: 10px 10px 0 10px;
  }
  tool-tip:is([tip-position='bottom']) {
    top: unset;
    left: 50%;
    bottom: 0;
    transform: translate(-50%, calc(100% + 8px));
    border-radius: 10px;
  }

  /* work for tip-position='top' */
  tool-tip:is([arrow]):is([tip-position='top']) {
    transform: translate(-50%, calc(-100% - 16px));
  }
  tool-tip:is([arrow]):is([tip-position='top'])::before {
    position: absolute;
    content: '';
    left: 50%;
    bottom: 0;
    transform: translate(-50%, 100%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 6px solid var(--affine-tooltip);
  }

  /* work for tip-position='right' */
  tool-tip:is([arrow]):is([tip-position='right']) {
    transform: translateX(calc(100% + 16px));
  }
  tool-tip:is([arrow]):is([tip-position='right'])::before {
    position: absolute;
    content: '';
    left: 0;
    bottom: 50%;
    transform: translate(-100%, 50%);
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-right: 6px solid var(--affine-tooltip);
  }

  /* work for tip-position='left' */
  tool-tip:is([arrow]):is([tip-position='left']) {
    transform: translate(calc(-100% - 16px), -50%);
  }
  tool-tip:is([arrow]):is([tip-position='left'])::before {
    position: absolute;
    content: '';
    right: 0;
    bottom: 50%;
    transform: translate(100%, 50%);
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    border-left: 6px solid var(--affine-tooltip);
  }

  /* work for tip-position='bottom' */
  tool-tip:is([arrow]):is([tip-position='bottom']) {
    transform: translate(-50%, calc(100% + 16px));
  }
  tool-tip:is([arrow]):is([tip-position='bottom'])::before {
    position: absolute;
    content: '';
    left: 50%;
    top: 0;
    transform: translate(-50%, -100%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-bottom: 6px solid var(--affine-tooltip);
  }

  .has-tool-tip {
    position: relative;
  }
  .has-tool-tip:is(:hover, :focus-visible, :active) > tool-tip {
    opacity: 1;
    transition-delay: 200ms;
  }
`;

// node_modules/@blocksuite/blocks/dist/bookmark-block/images/icons.js
var DefaultIcon = html`
  <svg
    width="16"
    height="16"
    viewBox="0 0 16 16"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3334_77372)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M2.71294 6.47927C2.9781 6.34125 3.27709 6.21883 3.59925 6.11144C4.18904 5.91485 4.88593 5.759 5.65385 5.65385C5.759 4.88593 5.91485 4.18904 6.11144 3.59925C6.21883 3.27709 6.34125 2.9781 6.47927 2.71294C4.66435 3.23402 3.23402 4.66435 2.71294 6.47927ZM8 1.5C4.41015 1.5 1.5 4.41015 1.5 8C1.5 11.5899 4.41015 14.5 8 14.5C11.5899 14.5 14.5 11.5899 14.5 8C14.5 4.41015 11.5899 1.5 8 1.5ZM8 2.5C7.94272 2.5 7.80858 2.53437 7.61422 2.781C7.42429 3.02199 7.23139 3.4017 7.06013 3.91547C6.90527 4.38004 6.77549 4.9317 6.67997 5.5472C7.10671 5.5162 7.5484 5.5 8 5.5C8.4516 5.5 8.89329 5.5162 9.32003 5.5472C9.22451 4.9317 9.09473 4.38004 8.93987 3.91547C8.76861 3.4017 8.57571 3.02199 8.38579 2.781C8.19142 2.53437 8.05728 2.5 8 2.5ZM10.3461 5.65385C10.241 4.88593 10.0852 4.18904 9.88856 3.59925C9.78117 3.27709 9.65875 2.9781 9.52073 2.71294C11.3357 3.23402 12.766 4.66435 13.2871 6.47927C13.0219 6.34125 12.7229 6.21883 12.4008 6.11144C11.811 5.91485 11.1141 5.759 10.3461 5.65385ZM9.44027 6.55973C8.98158 6.52087 8.49906 6.5 8 6.5C7.50094 6.5 7.01842 6.52087 6.55973 6.55973C6.52087 7.01842 6.5 7.50094 6.5 8C6.5 8.49906 6.52087 8.98158 6.55973 9.44027C7.01842 9.47913 7.50094 9.5 8 9.5C8.49906 9.5 8.98158 9.47913 9.44027 9.44027C9.47913 8.98158 9.5 8.49906 9.5 8C9.5 7.50094 9.47913 7.01842 9.44027 6.55973ZM10.4528 9.32002C10.4838 8.89329 10.5 8.4516 10.5 8C10.5 7.5484 10.4838 7.10671 10.4528 6.67998C11.0683 6.7755 11.62 6.90527 12.0845 7.06013C12.5983 7.23139 12.978 7.42429 13.219 7.61422C13.4656 7.80858 13.5 7.94272 13.5 8C13.5 8.05728 13.4656 8.19142 13.219 8.38579C12.978 8.57571 12.5983 8.76861 12.0845 8.93987C11.62 9.09473 11.0683 9.2245 10.4528 9.32002ZM9.32003 10.4528C8.89329 10.4838 8.4516 10.5 8 10.5C7.5484 10.5 7.10671 10.4838 6.67998 10.4528C6.7755 11.0683 6.90527 11.62 7.06013 12.0845C7.23139 12.5983 7.42429 12.978 7.61422 13.219C7.80858 13.4656 7.94272 13.5 8 13.5C8.05728 13.5 8.19142 13.4656 8.38579 13.219C8.57571 12.978 8.76861 12.5983 8.93987 12.0845C9.09473 11.62 9.22451 11.0683 9.32003 10.4528ZM9.52073 13.2871C9.65875 13.0219 9.78117 12.7229 9.88856 12.4008C10.0852 11.811 10.241 11.1141 10.3461 10.3461C11.1141 10.241 11.811 10.0852 12.4008 9.88856C12.7229 9.78117 13.0219 9.65875 13.2871 9.52073C12.766 11.3357 11.3357 12.766 9.52073 13.2871ZM6.47927 13.2871C4.66435 12.766 3.23402 11.3357 2.71294 9.52073C2.9781 9.65875 3.27709 9.78117 3.59925 9.88856C4.18904 10.0852 4.88593 10.241 5.65385 10.3461C5.759 11.1141 5.91485 11.811 6.11144 12.4008C6.21883 12.7229 6.34125 13.0219 6.47927 13.2871ZM5.5472 9.32003C4.9317 9.22451 4.38004 9.09473 3.91547 8.93987C3.4017 8.76861 3.02199 8.57571 2.781 8.38579C2.53437 8.19142 2.5 8.05728 2.5 8C2.5 7.94272 2.53437 7.80858 2.781 7.61422C3.02199 7.42429 3.4017 7.23139 3.91547 7.06013C4.38004 6.90527 4.9317 6.7755 5.5472 6.67998C5.5162 7.10671 5.5 7.5484 5.5 8C5.5 8.4516 5.5162 8.89329 5.5472 9.32003Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3334_77372">
        <rect width="16" height="16" fill="white" />
      </clipPath>
    </defs>
  </svg>
`;
var EdgelessIcon = html`
  <svg
    width="16"
    height="16"
    viewBox="0 0 16 16"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3334_76304)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.33341 3.16667C3.68908 3.16667 3.16675 3.68901 3.16675 4.33334C3.16675 4.97767 3.68908 5.5 4.33341 5.5C4.97775 5.5 5.50008 4.97767 5.50008 4.33334C5.50008 3.68901 4.97775 3.16667 4.33341 3.16667ZM2.16675 4.33334C2.16675 3.13672 3.1368 2.16667 4.33341 2.16667C5.53003 2.16667 6.50008 3.13672 6.50008 4.33334C6.50008 5.52995 5.53003 6.5 4.33341 6.5C3.1368 6.5 2.16675 5.52995 2.16675 4.33334Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.33341 10.5C3.68908 10.5 3.16675 11.0223 3.16675 11.6667C3.16675 12.311 3.68908 12.8333 4.33341 12.8333C4.97775 12.8333 5.50008 12.311 5.50008 11.6667C5.50008 11.0223 4.97775 10.5 4.33341 10.5ZM2.16675 11.6667C2.16675 10.4701 3.1368 9.5 4.33341 9.5C5.53003 9.5 6.50008 10.4701 6.50008 11.6667C6.50008 12.8633 5.53003 13.8333 4.33341 13.8333C3.1368 13.8333 2.16675 12.8633 2.16675 11.6667Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M6.83341 4.33334C6.83341 4.0572 7.05727 3.83334 7.33341 3.83334H8.00008C8.54726 3.83334 9.08907 3.94111 9.59459 4.15051C10.1001 4.3599 10.5594 4.66682 10.9464 5.05373C11.3333 5.44064 11.6402 5.89997 11.8496 6.40549C12.059 6.91101 12.1667 7.45283 12.1667 8V8.66667C12.1667 8.94281 11.9429 9.16667 11.6667 9.16667C11.3906 9.16667 11.1667 8.94281 11.1667 8.66667V8C11.1667 7.58415 11.0848 7.17237 10.9257 6.78817C10.7666 6.40398 10.5333 6.05489 10.2393 5.76083C9.9452 5.46678 9.59611 5.23353 9.21191 5.07439C8.82772 4.91525 8.41593 4.83334 8.00008 4.83334H7.33341C7.05727 4.83334 6.83341 4.60948 6.83341 4.33334Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M9.50008 10.6667C9.50008 10.0223 10.0224 9.5 10.6667 9.5H12.6667C13.3111 9.5 13.8334 10.0223 13.8334 10.6667V12.6667C13.8334 13.311 13.3111 13.8333 12.6667 13.8333H10.6667C10.0224 13.8333 9.50008 13.311 9.50008 12.6667V10.6667ZM10.6667 10.5C10.5747 10.5 10.5001 10.5746 10.5001 10.6667V12.6667C10.5001 12.7587 10.5747 12.8333 10.6667 12.8333H12.6667C12.7588 12.8333 12.8334 12.7587 12.8334 12.6667V10.6667C12.8334 10.5746 12.7588 10.5 12.6667 10.5H10.6667Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.33341 6.83334C4.60956 6.83334 4.83341 7.0572 4.83341 7.33334L4.83341 8.66667C4.83341 8.94281 4.60956 9.16667 4.33341 9.16667C4.05727 9.16667 3.83341 8.94281 3.83341 8.66667L3.83341 7.33334C3.83341 7.0572 4.05727 6.83334 4.33341 6.83334Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3334_76304">
        <rect width="16" height="16" fill="white" />
      </clipPath>
    </defs>
  </svg>
`;
var PageIcon2 = html`<svg
  width="16"
  height="16"
  viewBox="0 0 16 16"
  xmlns="http://www.w3.org/2000/svg"
>
  <g clip-path="url(#clip0_3334_79048)">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      fill="currentColor"
      d="M2.16675 3.99999C2.16675 2.98747 2.98756 2.16666 4.00008 2.16666H9.33342C9.60956 2.16666 9.83342 2.39051 9.83342 2.66666C9.83342 2.9428 9.60956 3.16666 9.33342 3.16666H4.00008C3.53984 3.16666 3.16675 3.53975 3.16675 3.99999V13.3333C3.16675 13.6095 2.94289 13.8333 2.66675 13.8333C2.39061 13.8333 2.16675 13.6095 2.16675 13.3333V3.99999Z"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      fill="currentColor"
      d="M13.8334 12C13.8334 13.0125 13.0126 13.8333 12.0001 13.8333H6.66675C6.39061 13.8333 6.16675 13.6095 6.16675 13.3333C6.16675 13.0572 6.39061 12.8333 6.66675 12.8333L12.0001 12.8333C12.4603 12.8333 12.8334 12.4602 12.8334 12L12.8334 2.66666C12.8334 2.39051 13.0573 2.16666 13.3334 2.16666C13.6096 2.16666 13.8334 2.39051 13.8334 2.66666L13.8334 12Z"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      fill="currentColor"
      d="M5.50008 5.99999C5.50008 5.35566 6.02242 4.83332 6.66675 4.83332H9.33342C9.97775 4.83332 10.5001 5.35566 10.5001 5.99999V7.33332C10.5001 7.97765 9.97775 8.49999 9.33342 8.49999H6.66675C6.02242 8.49999 5.50008 7.97765 5.50008 7.33332V5.99999ZM6.66675 5.83332C6.5747 5.83332 6.50008 5.90794 6.50008 5.99999V7.33332C6.50008 7.42537 6.5747 7.49999 6.66675 7.49999H9.33342C9.42546 7.49999 9.50008 7.42537 9.50008 7.33332V5.99999C9.50008 5.90794 9.42546 5.83332 9.33342 5.83332H6.66675Z"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      fill="currentColor"
      d="M5.50008 10.6667C5.50008 10.3905 5.72394 10.1667 6.00008 10.1667H10.0001C10.2762 10.1667 10.5001 10.3905 10.5001 10.6667C10.5001 10.9428 10.2762 11.1667 10.0001 11.1667H6.00008C5.72394 11.1667 5.50008 10.9428 5.50008 10.6667Z"
    />
  </g>
  <defs>
    <clipPath id="clip0_3334_79048">
      <rect width="16" height="16" fill="white" />
    </clipPath>
  </defs>
</svg>`;
var RefreshIcon = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77646)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.70834 12C4.70834 7.97292 7.97293 4.70833 12 4.70833C13.8671 4.70833 15.5717 5.41092 16.8613 6.56516L16.8633 6.56695L18.0417 7.63079V5.33333C18.0417 4.98815 18.3215 4.70833 18.6667 4.70833C19.0119 4.70833 19.2917 4.98815 19.2917 5.33333V9.03704C19.2917 9.38221 19.0119 9.66204 18.6667 9.66204H14.963C14.6178 9.66204 14.338 9.38221 14.338 9.03704C14.338 8.69186 14.6178 8.41204 14.963 8.41204H17.0417L16.0276 7.49658C16.0273 7.49628 16.027 7.49599 16.0266 7.49569C14.9575 6.53917 13.5473 5.95833 12 5.95833C8.66329 5.95833 5.95834 8.66328 5.95834 12C5.95834 15.3367 8.66329 18.0417 12 18.0417C14.8745 18.0417 17.2815 16.0336 17.892 13.3432C17.9684 13.0066 18.3032 12.7956 18.6398 12.872C18.9764 12.9484 19.1874 13.2832 19.111 13.6198C18.3741 16.8671 15.471 19.2917 12 19.2917C7.97293 19.2917 4.70834 16.0271 4.70834 12Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77646">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var DeleteIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77647)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M11.3166 3.87493C11.3513 3.87497 11.3864 3.875 11.422 3.875H12.578C12.6136 3.875 12.6487 3.87497 12.6834 3.87493C13.2704 3.87439 13.7306 3.87396 14.1375 4.03401C14.4945 4.17443 14.8106 4.40223 15.0567 4.69654C15.3372 5.032 15.4824 5.46866 15.6674 6.02568C15.6784 6.05861 15.6895 6.09197 15.7007 6.12575L15.7838 6.375H18.6667C19.0119 6.375 19.2917 6.65482 19.2917 7C19.2917 7.34518 19.0119 7.625 18.6667 7.625H17.625V15.5268C17.625 16.2041 17.625 16.7505 17.5889 17.1929C17.5517 17.6484 17.473 18.0485 17.2844 18.4187C16.9848 19.0067 16.5067 19.4848 15.9187 19.7844C15.5485 19.973 15.1484 20.0516 14.6929 20.0889C14.2505 20.125 13.7041 20.125 13.0268 20.125H10.9732C10.2959 20.125 9.74954 20.125 9.30712 20.0889C8.85159 20.0516 8.45147 19.973 8.08129 19.7844C7.49328 19.4848 7.01522 19.0067 6.71561 18.4187C6.527 18.0485 6.44836 17.6484 6.41115 17.1929C6.375 16.7505 6.375 16.2041 6.37501 15.5268L6.37501 7.625H5.33334C4.98817 7.625 4.70834 7.34518 4.70834 7C4.70834 6.65482 4.98817 6.375 5.33334 6.375H8.2162L8.29929 6.12575C8.31055 6.09197 8.32163 6.05861 8.33257 6.02568C8.51767 5.46866 8.66277 5.032 8.9433 4.69654C9.18942 4.40224 9.50548 4.17443 9.86251 4.03401C10.2695 3.87396 10.7296 3.87439 11.3166 3.87493ZM8.65226 7.625C8.66195 7.62522 8.67162 7.62522 8.68127 7.625H15.3188C15.3284 7.62522 15.3381 7.62522 15.3478 7.625H16.375V15.5C16.375 16.2104 16.3745 16.7056 16.343 17.0911C16.3121 17.4693 16.2545 17.6866 16.1706 17.8512C15.9909 18.204 15.704 18.4909 15.3512 18.6706C15.1866 18.7545 14.9693 18.8121 14.5911 18.843C14.2056 18.8745 13.7104 18.875 13 18.875H11C10.2896 18.875 9.79444 18.8745 9.40891 18.843C9.03068 18.8121 8.81338 18.7545 8.64878 18.6706C8.29597 18.4909 8.00914 18.204 7.82937 17.8512C7.74551 17.6866 7.6879 17.4693 7.657 17.0911C7.6255 16.7056 7.62501 16.2104 7.62501 15.5V7.625H8.65226ZM14.466 6.375H9.53401C9.73142 5.78788 9.8018 5.61848 9.9022 5.49843C10.0141 5.36465 10.1577 5.2611 10.32 5.19728C10.4771 5.1355 10.6776 5.125 11.422 5.125H12.578C13.3225 5.125 13.5229 5.1355 13.68 5.19728C13.8423 5.2611 13.986 5.36465 14.0978 5.49843C14.1982 5.61848 14.2686 5.78788 14.466 6.375ZM10.3333 9.70833C10.6785 9.70833 10.9583 9.98815 10.9583 10.3333V16.1667C10.9583 16.5118 10.6785 16.7917 10.3333 16.7917C9.98817 16.7917 9.70834 16.5118 9.70834 16.1667V10.3333C9.70834 9.98815 9.98817 9.70833 10.3333 9.70833ZM13.6667 9.70833C14.0119 9.70833 14.2917 9.98815 14.2917 10.3333V16.1667C14.2917 16.5118 14.0119 16.7917 13.6667 16.7917C13.3215 16.7917 13.0417 16.5118 13.0417 16.1667V10.3333C13.0417 9.98815 13.3215 9.70833 13.6667 9.70833Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77647">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var EditIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77641)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M15.245 6.43527L14.543 7.16176L16.8382 9.45697L17.5647 8.755C18.2018 8.11415 18.2006 7.07817 17.5612 6.43876C16.9218 5.79935 15.8859 5.79819 15.245 6.43527ZM15.9392 10.3257L13.6743 8.06082L7.13833 14.8251L6.2655 17.7345L9.17493 16.8617L15.9392 10.3257ZM14.3576 5.55488C15.4863 4.42615 17.3164 4.42615 18.4451 5.55488C19.5738 6.68361 19.5738 8.51364 18.4451 9.64238L18.4375 9.64996L9.93429 17.8661C9.86252 17.9355 9.77518 17.9866 9.67959 18.0153L5.51292 19.2653C5.29269 19.3314 5.05397 19.2712 4.89139 19.1086C4.7288 18.946 4.66862 18.7073 4.73469 18.4871L5.98469 14.3204C6.01337 14.2248 6.06452 14.1375 6.13387 14.0657L14.3576 5.55488Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77641">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var LinkIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77679)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M12.7019 5.83896C14.2094 4.33145 16.6535 4.33145 18.161 5.83896C19.6685 7.34646 19.6685 9.79061 18.161 11.2981L16.4453 13.0138C16.2012 13.2579 15.8055 13.2579 15.5614 13.0138C15.3173 12.7698 15.3173 12.374 15.5614 12.13L17.2771 10.4142C18.2965 9.39488 18.2965 7.74219 17.2771 6.72284C16.2578 5.70349 14.6051 5.70349 13.5857 6.72284L11.2981 9.01048C10.2788 10.0298 10.2788 11.6825 11.2981 12.7019C11.4581 12.8619 11.633 12.9963 11.818 13.1055C12.1152 13.281 12.2138 13.6643 12.0383 13.9615C11.8628 14.2587 11.4795 14.3573 11.1823 14.1818C10.9076 14.0196 10.6492 13.8207 10.4142 13.5858C8.90671 12.0782 8.90671 9.6341 10.4142 8.1266L12.7019 5.83896ZM11.9617 10.0385C12.1372 9.74129 12.5204 9.64265 12.8177 9.81819C13.0924 9.98043 13.3508 10.1793 13.5857 10.4142C15.0932 11.9217 15.0932 14.3659 13.5857 15.8734L11.2981 18.161C9.7906 19.6685 7.34645 19.6685 5.83894 18.161C4.33144 16.6535 4.33144 14.2094 5.83894 12.7019L7.55467 10.9861C7.79875 10.7421 8.19448 10.7421 8.43855 10.9861C8.68263 11.2302 8.68263 11.6259 8.43855 11.87L6.72283 13.5858C5.70348 14.6051 5.70348 16.2578 6.72283 17.2771C7.74218 18.2965 9.39487 18.2965 10.4142 17.2771L12.7019 14.9895C13.7212 13.9702 13.7212 12.3175 12.7019 11.2981C12.5418 11.1381 12.367 11.0037 12.182 10.8945C11.8848 10.719 11.7861 10.3357 11.9617 10.0385Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77679">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var CopyIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77644)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M11.308 4.70833H16.0254C16.4705 4.70832 16.842 4.70832 17.1456 4.73312C17.4621 4.75898 17.7594 4.81491 18.0404 4.95811C18.4716 5.17782 18.8222 5.5284 19.0419 5.9596C19.1851 6.24066 19.241 6.53787 19.2669 6.85444C19.2917 7.15797 19.2917 7.5295 19.2917 7.97462V12.692C19.2917 13.1372 19.2917 13.5087 19.2669 13.8122C19.241 14.1288 19.1851 14.426 19.0419 14.7071C18.8222 15.1383 18.4716 15.4888 18.0404 15.7086C17.7594 15.8518 17.4621 15.9077 17.1456 15.9336C16.842 15.9584 16.4705 15.9583 16.0254 15.9583H15.9583V16.0254C15.9584 16.4705 15.9584 16.842 15.9336 17.1456C15.9077 17.4621 15.8518 17.7593 15.7086 18.0404C15.4889 18.4716 15.1383 18.8222 14.7071 19.0419C14.426 19.1851 14.1288 19.241 13.8122 19.2669C13.5087 19.2917 13.1372 19.2917 12.6921 19.2917H7.97463C7.52951 19.2917 7.15798 19.2917 6.85445 19.2669C6.53788 19.241 6.24067 19.1851 5.95962 19.0419C5.52841 18.8222 5.17783 18.4716 4.95812 18.0404C4.81492 17.7593 4.75899 17.4621 4.73313 17.1456C4.70833 16.842 4.70833 16.4705 4.70834 16.0254V11.308C4.70833 10.8628 4.70833 10.4913 4.73313 10.1878C4.75899 9.8712 4.81492 9.57399 4.95812 9.29294C5.17783 8.86173 5.52841 8.51115 5.95962 8.29144C6.24067 8.14824 6.53788 8.09231 6.85445 8.06645C7.15798 8.04165 7.52952 8.04166 7.97465 8.04167L8.04168 8.04167L8.04168 7.97464C8.04167 7.52951 8.04166 7.15797 8.06646 6.85444C8.09233 6.53787 8.14825 6.24066 8.29145 5.9596C8.51116 5.5284 8.86174 5.17782 9.29295 4.95811C9.574 4.81491 9.87122 4.75898 10.1878 4.73312C10.4913 4.70832 10.8629 4.70832 11.308 4.70833ZM8.04168 9.29167H8.00001C7.52299 9.29167 7.20281 9.29215 6.95624 9.3123C6.71697 9.33185 6.60257 9.36675 6.5271 9.4052C6.3311 9.50507 6.17175 9.66442 6.07188 9.86043C6.03343 9.93589 5.99852 10.0503 5.97898 10.2896C5.95883 10.5361 5.95834 10.8563 5.95834 11.3333V16C5.95834 16.477 5.95883 16.7972 5.97898 17.0438C5.99852 17.283 6.03343 17.3974 6.07188 17.4729C6.17175 17.6689 6.3311 17.8283 6.5271 17.9281C6.60257 17.9666 6.71697 18.0015 6.95624 18.021C7.20281 18.0412 7.52299 18.0417 8.00001 18.0417H12.6667C13.1437 18.0417 13.4639 18.0412 13.7104 18.021C13.9497 18.0015 14.0641 17.9666 14.1396 17.9281C14.3356 17.8283 14.4949 17.6689 14.5948 17.4729C14.6333 17.3974 14.6682 17.283 14.6877 17.0438C14.7079 16.7972 14.7083 16.477 14.7083 16V15.9583H11.308C10.8628 15.9583 10.4913 15.9584 10.1878 15.9336C9.87122 15.9077 9.574 15.8518 9.29295 15.7086C8.86174 15.4888 8.51116 15.1383 8.29145 14.7071C8.14825 14.426 8.09233 14.1288 8.06646 13.8122C8.04166 13.5087 8.04167 13.1372 8.04168 12.692L8.04168 9.29167ZM11.3333 14.7083C10.8563 14.7083 10.5361 14.7078 10.2896 14.6877C10.0503 14.6682 9.93591 14.6333 9.86044 14.5948C9.66444 14.4949 9.50508 14.3356 9.40521 14.1396C9.36676 14.0641 9.33186 13.9497 9.31231 13.7104C9.29216 13.4639 9.29168 13.1437 9.29168 12.6667V8C9.29168 7.52298 9.29216 7.2028 9.31231 6.95623C9.33186 6.71696 9.36676 6.60256 9.40521 6.52709C9.50508 6.33109 9.66444 6.17174 9.86044 6.07187C9.93591 6.03342 10.0503 5.99851 10.2896 5.97896C10.5361 5.95882 10.8563 5.95833 11.3333 5.95833H16C16.477 5.95833 16.7972 5.95882 17.0438 5.97896C17.2831 5.99851 17.3975 6.03342 17.4729 6.07187C17.6689 6.17174 17.8283 6.33109 17.9281 6.52709C17.9666 6.60256 18.0015 6.71696 18.021 6.95623C18.0412 7.2028 18.0417 7.52298 18.0417 8V12.6667C18.0417 13.1437 18.0412 13.4639 18.021 13.7104C18.0015 13.9497 17.9666 14.0641 17.9281 14.1396C17.8283 14.3356 17.6689 14.4949 17.4729 14.5948C17.3975 14.6333 17.2831 14.6682 17.0438 14.6877C16.7972 14.7078 16.477 14.7083 16 14.7083H11.3333Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77644">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var CaptionIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77683)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.70831 6.16666C4.70831 5.36125 5.36123 4.70833 6.16665 4.70833H9.49998C10.3054 4.70833 10.9583 5.36125 10.9583 6.16666V9.49999C10.9583 10.3054 10.3054 10.9583 9.49998 10.9583H6.16665C5.36123 10.9583 4.70831 10.3054 4.70831 9.49999V6.16666ZM6.16665 5.95833C6.05159 5.95833 5.95831 6.0516 5.95831 6.16666V9.49999C5.95831 9.61505 6.05159 9.70833 6.16665 9.70833H9.49998C9.61504 9.70833 9.70831 9.61505 9.70831 9.49999V6.16666C9.70831 6.0516 9.61504 5.95833 9.49998 5.95833H6.16665Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.70831 18.6667C4.70831 18.3215 4.98814 18.0417 5.33331 18.0417L15.3333 18.0417C15.6785 18.0417 15.9583 18.3215 15.9583 18.6667C15.9583 19.0118 15.6785 19.2917 15.3333 19.2917L5.33331 19.2917C4.98813 19.2917 4.70831 19.0118 4.70831 18.6667Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M4.70831 14.5C4.70831 14.1548 4.98814 13.875 5.33331 13.875L18.6666 13.875C19.0118 13.875 19.2916 14.1548 19.2916 14.5C19.2916 14.8452 19.0118 15.125 18.6666 15.125L5.33331 15.125C4.98813 15.125 4.70831 14.8452 4.70831 14.5Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77683">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var DuplicateIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_77645)">
      <path
        d="M11.375 9.5C11.375 9.84518 11.6548 10.125 12 10.125H12.9911L8.22474 14.8914C7.98066 15.1355 7.98066 15.5312 8.22474 15.7753C8.46881 16.0194 8.86454 16.0194 9.10862 15.7753L13.875 11.0089V12C13.875 12.3452 14.1548 12.625 14.5 12.625C14.8452 12.625 15.125 12.3452 15.125 12V9.58333C15.125 9.56886 15.1246 9.5545 15.1237 9.54024C15.1348 9.36716 15.0742 9.19034 14.942 9.05806C14.8097 8.92578 14.6328 8.86519 14.4598 8.87629C14.4455 8.87543 14.4311 8.875 14.4167 8.875H12C11.6548 8.875 11.375 9.15482 11.375 9.5Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M16.0254 4.70833H11.308C10.8629 4.70832 10.4913 4.70832 10.1878 4.73312C9.87122 4.75898 9.574 4.81491 9.29295 4.95811C8.86174 5.17782 8.51116 5.5284 8.29145 5.9596C8.14825 6.24066 8.09233 6.53787 8.06646 6.85444C8.04166 7.15797 8.04167 7.5295 8.04168 7.97463L8.04168 8.04167L7.97465 8.04167C7.52953 8.04166 7.15798 8.04165 6.85445 8.06645C6.53788 8.09231 6.24067 8.14824 5.95962 8.29144C5.52841 8.51115 5.17783 8.86173 4.95812 9.29294C4.81492 9.57399 4.75899 9.8712 4.73313 10.1878C4.70833 10.4913 4.70834 10.8628 4.70834 11.308V16.0254C4.70834 16.4705 4.70833 16.842 4.73313 17.1456C4.75899 17.4621 4.81492 17.7593 4.95812 18.0404C5.17783 18.4716 5.52841 18.8222 5.95962 19.0419C6.24067 19.1851 6.53788 19.241 6.85445 19.2669C7.15798 19.2917 7.52951 19.2917 7.97463 19.2917H12.6921C13.1372 19.2917 13.5087 19.2917 13.8122 19.2669C14.1288 19.241 14.426 19.1851 14.7071 19.0419C15.1383 18.8222 15.4889 18.4716 15.7086 18.0404C15.8518 17.7593 15.9077 17.4621 15.9336 17.1456C15.9584 16.842 15.9584 16.4705 15.9583 16.0254V15.9583H16.0254C16.4705 15.9583 16.8421 15.9583 17.1456 15.9335C17.4621 15.9077 17.7594 15.8518 18.0404 15.7086C18.4716 15.4888 18.8222 15.1383 19.0419 14.7071C19.1851 14.426 19.241 14.1288 19.2669 13.8122C19.2917 13.5087 19.2917 13.1372 19.2917 12.692V7.97462C19.2917 7.5295 19.2917 7.15797 19.2669 6.85444C19.241 6.53787 19.1851 6.24066 19.0419 5.9596C18.8222 5.5284 18.4716 5.17782 18.0404 4.95811C17.7594 4.81491 17.4621 4.75898 17.1456 4.73312C16.842 4.70832 16.4705 4.70832 16.0254 4.70833ZM8.04168 11.1667V9.29167H8.00001C7.52299 9.29167 7.20281 9.29215 6.95624 9.3123C6.71697 9.33185 6.60257 9.36675 6.5271 9.4052C6.3311 9.50507 6.17175 9.66442 6.07188 9.86043C6.03343 9.93589 5.99852 10.0503 5.97898 10.2896C5.95883 10.5361 5.95834 10.8563 5.95834 11.3333V16C5.95834 16.477 5.95883 16.7972 5.97898 17.0438C5.99852 17.283 6.03343 17.3974 6.07188 17.4729C6.17175 17.6689 6.3311 17.8283 6.5271 17.9281C6.60257 17.9666 6.71697 18.0015 6.95624 18.021C7.20281 18.0412 7.52299 18.0417 8.00001 18.0417H12.6667C13.1437 18.0417 13.4639 18.0412 13.7104 18.021C13.9497 18.0015 14.0641 17.9666 14.1396 17.9281C14.3356 17.8283 14.4949 17.6689 14.5948 17.4729C14.6333 17.3974 14.6682 17.283 14.6877 17.0438C14.7079 16.7972 14.7083 16.477 14.7083 16V15.9583H12.8333C12.4882 15.9583 12.2083 15.6785 12.2083 15.3333C12.2083 14.9882 12.4882 14.7083 12.8333 14.7083H16C16.477 14.7083 16.7972 14.7078 17.0438 14.6877C17.283 14.6682 17.3974 14.6333 17.4729 14.5948C17.6689 14.4949 17.8283 14.3356 17.9281 14.1396C17.9666 14.0641 18.0015 13.9497 18.021 13.7104C18.0412 13.4639 18.0417 13.1437 18.0417 12.6667V8C18.0417 7.52298 18.0412 7.2028 18.021 6.95623C18.0015 6.71696 17.9666 6.60256 17.9281 6.52709C17.8283 6.33109 17.6689 6.17174 17.4729 6.07187C17.3974 6.03342 17.283 5.99851 17.0438 5.97896C16.7972 5.95882 16.477 5.95833 16 5.95833H11.3333C10.8563 5.95833 10.5361 5.95882 10.2896 5.97896C10.0503 5.99851 9.9359 6.03342 9.86044 6.07187C9.66444 6.17174 9.50508 6.33109 9.40521 6.52709C9.36676 6.60256 9.33186 6.71696 9.31231 6.95623C9.29216 7.2028 9.29168 7.52298 9.29168 8V11.1667C9.29168 11.5118 9.01186 11.7917 8.66668 11.7917C8.3215 11.7917 8.04168 11.5118 8.04168 11.1667Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_77645">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var CloseIcon2 = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3409_76820)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M6.34314 6.34314C6.63604 6.05025 7.11091 6.05025 7.4038 6.34314L12 10.9393L16.5962 6.34314C16.8891 6.05025 17.364 6.05025 17.6569 6.34314C17.9497 6.63604 17.9497 7.11091 17.6569 7.4038L13.0607 12L17.6569 16.5962C17.9497 16.8891 17.9497 17.364 17.6569 17.6569C17.364 17.9497 16.8891 17.9497 16.5962 17.6569L12 13.0607L7.4038 17.6569C7.11091 17.9497 6.63604 17.9497 6.34314 17.6569C6.05025 17.364 6.05025 16.8891 6.34314 16.5962L10.9393 12L6.34314 7.4038C6.05025 7.11091 6.05025 6.63604 6.34314 6.34314Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3409_76820">
        <rect width="24" height="24" fill="white" />
      </clipPath>
    </defs>
  </svg>
`;
var MoreIcon = html`
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_3407_76065)">
      <path
        d="M12 6.99999C11.5398 6.99999 11.1667 6.6269 11.1667 6.16666C11.1667 5.70642 11.5398 5.33333 12 5.33333C12.4602 5.33333 12.8333 5.70642 12.8333 6.16666C12.8333 6.6269 12.4602 6.99999 12 6.99999Z"
        fill="currentColor"
      />
      <path
        d="M12 12.8333C11.5398 12.8333 11.1667 12.4602 11.1667 12C11.1667 11.5398 11.5398 11.1667 12 11.1667C12.4602 11.1667 12.8333 11.5398 12.8333 12C12.8333 12.4602 12.4602 12.8333 12 12.8333Z"
        fill="currentColor"
      />
      <path
        d="M12 18.6667C11.5398 18.6667 11.1667 18.2936 11.1667 17.8333C11.1667 17.3731 11.5398 17 12 17C12.4602 17 12.8333 17.3731 12.8333 17.8333C12.8333 18.2936 12.4602 18.6667 12 18.6667Z"
        fill="currentColor"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M12 5.75001C11.7699 5.75001 11.5833 5.93655 11.5833 6.16667C11.5833 6.39679 11.7699 6.58334 12 6.58334C12.2301 6.58334 12.4167 6.39679 12.4167 6.16667C12.4167 5.93655 12.2301 5.75001 12 5.75001ZM10.75 6.16667C10.75 5.47632 11.3096 4.91667 12 4.91667C12.6904 4.91667 13.25 5.47632 13.25 6.16667C13.25 6.85703 12.6904 7.41667 12 7.41667C11.3096 7.41667 10.75 6.85703 10.75 6.16667ZM12 11.5833C11.7699 11.5833 11.5833 11.7699 11.5833 12C11.5833 12.2301 11.7699 12.4167 12 12.4167C12.2301 12.4167 12.4167 12.2301 12.4167 12C12.4167 11.7699 12.2301 11.5833 12 11.5833ZM10.75 12C10.75 11.3096 11.3096 10.75 12 10.75C12.6904 10.75 13.25 11.3096 13.25 12C13.25 12.6904 12.6904 13.25 12 13.25C11.3096 13.25 10.75 12.6904 10.75 12ZM12 17.4167C11.7699 17.4167 11.5833 17.6032 11.5833 17.8333C11.5833 18.0635 11.7699 18.25 12 18.25C12.2301 18.25 12.4167 18.0635 12.4167 17.8333C12.4167 17.6032 12.2301 17.4167 12 17.4167ZM10.75 17.8333C10.75 17.143 11.3096 16.5833 12 16.5833C12.6904 16.5833 13.25 17.143 13.25 17.8333C13.25 18.5237 12.6904 19.0833 12 19.0833C11.3096 19.0833 10.75 18.5237 10.75 17.8333Z"
        fill="currentColor"
      />
    </g>
    <defs>
      <clipPath id="clip0_3407_76065">
        <rect width="20" height="20" fill="white" transform="translate(2 2)" />
      </clipPath>
    </defs>
  </svg>
`;
var LoadingBanner = html`
  <svg
    width="140"
    height="96"
    viewBox="0 0 140 96"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_4257_88403)">
      <g opacity="0.4">
        <g clip-path="url(#clip1_4257_88403)">
          <g clip-path="url(#clip2_4257_88403)">
            <g opacity="0.8" filter="url(#filter0_f_4257_88403)">
              <ellipse
                cx="45.5713"
                cy="61.2938"
                rx="45.5713"
                ry="61.2938"
                transform="matrix(-0.275152 -0.961401 0.994111 -0.108365 23.6692 80.3025)"
                fill="#C0BFC1"
              />
            </g>
            <g opacity="0.8" filter="url(#filter1_f_4257_88403)">
              <ellipse
                cx="49.6555"
                cy="50.1114"
                rx="49.6555"
                ry="50.1114"
                transform="matrix(-0.517539 -0.855659 0.945307 -0.326182 10.3975 87.9766)"
                fill="#C0BFC1"
              />
            </g>
            <g opacity="0.8" filter="url(#filter2_f_4257_88403)">
              <path
                d="M141.154 3.03247C167.539 22.8936 134.54 99.5878 124.212 92.7915C117.912 88.6456 113.733 60.4772 94.173 45.9086C81.6691 36.5955 56.6586 38.5939 41.1056 37.1878C1.22291 33.5821 114.548 -16.9943 141.154 3.03247Z"
                fill="#C0BFC1"
              />
            </g>
            <path
              d="M78.5971 45.1263C77.9794 49.5216 81.121 53.5957 85.6131 54.2271C90.1053 54.8584 94.2481 51.808 94.8658 47.4128C95.4835 43.0175 92.342 38.9434 87.8498 38.312C83.3577 37.6807 79.2149 40.7311 78.5971 45.1263Z"
              fill="url(#paint0_linear_4257_88403)"
            />
            <path
              d="M120.378 78.3637L119.989 81.1303C119.731 82.9654 119.562 84.15 119.36 85.0413C119.166 85.8959 118.999 86.1992 118.895 86.3451C118.499 86.9002 117.932 87.3171 117.277 87.5363C117.105 87.5938 116.76 87.6677 115.867 87.6141C114.934 87.5582 113.723 87.3905 111.847 87.1268L80.6109 82.7369C78.735 82.4733 77.524 82.3006 76.6125 82.0973C75.7385 81.9024 75.4276 81.7365 75.278 81.6337C74.7087 81.2424 74.2794 80.6856 74.0516 80.0428C73.9917 79.8739 73.9142 79.5361 73.9635 78.6612C74.0149 77.7488 74.1789 76.5635 74.4369 74.7283L75.6584 66.0369C75.8058 65.9369 75.9505 65.8411 76.0924 65.7498C77.1899 65.0437 78.3629 64.4423 79.7464 64.1873C81.8083 63.8072 83.9443 64.0829 85.8427 64.9742C87.1166 65.5723 88.0991 66.452 88.9822 67.4137C89.5619 68.0451 90.1807 68.8058 90.8604 69.6691L94.5285 66.9912C95.9295 65.9684 97.1371 65.0867 98.1922 64.4415C99.3051 63.761 100.491 63.1868 101.879 62.9626C103.947 62.6286 106.075 62.9506 107.951 63.8817C109.21 64.5065 110.172 65.4058 111.033 66.385C111.033 66.385 117.277 74.3919 120.378 78.3637Z"
              fill="url(#paint1_linear_4257_88403)"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M18.0193 52.2289C18.1346 51.4086 18.8931 50.837 19.7134 50.9523L67.2463 57.6326C68.0667 57.7479 68.6382 58.5064 68.5229 59.3268C68.4076 60.1471 67.6491 60.7187 66.8288 60.6034L19.2959 53.9231C18.4755 53.8078 17.904 53.0493 18.0193 52.2289Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M21.5681 26.9771C21.7218 25.8833 22.7332 25.1212 23.827 25.2749L47.5934 28.6151C48.6872 28.7688 49.4493 29.7801 49.2956 30.874C49.1419 31.9678 48.1305 32.7299 47.0367 32.5762L23.2703 29.236C22.1765 29.0823 21.4144 28.0709 21.5681 26.9771Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M19.55 41.336C19.6653 40.5156 20.4238 39.9441 21.2442 40.0593L68.7771 46.7397C69.5974 46.8549 70.169 47.6135 70.0537 48.4338C69.9384 49.2542 69.1799 49.8258 68.3595 49.7105L20.8267 43.0301C20.0063 42.9149 19.4347 42.1564 19.55 41.336Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M16.4883 63.1219C16.6036 62.3015 17.3621 61.7299 18.1824 61.8452L65.7153 68.5255C66.5357 68.6408 67.1072 69.3993 66.9919 70.2197C66.8766 71.0401 66.1181 71.6116 65.2978 71.4963L17.7649 64.816C16.9445 64.7007 16.373 63.9422 16.4883 63.1219Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M15.2358 72.0343C15.3511 71.2139 16.1096 70.6424 16.93 70.7576L64.4628 77.438C65.2832 77.5533 65.8548 78.3118 65.7395 79.1321C65.6242 79.9525 64.8657 80.5241 64.0453 80.4088L16.5125 73.7285C15.6921 73.6132 15.1205 72.8547 15.2358 72.0343Z"
              fill="white"
              fill-opacity="0.4"
            />
          </g>
        </g>
      </g>
    </g>
    <defs>
      <filter
        id="filter0_f_4257_88403"
        x="-14.1589"
        y="-38.4709"
        width="172.444"
        height="136.638"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4257_88403"
        />
      </filter>
      <filter
        id="filter1_f_4257_88403"
        x="-45.8333"
        y="-40.3932"
        width="155.805"
        height="139.072"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4257_88403"
        />
      </filter>
      <filter
        id="filter2_f_4257_88403"
        x="8.68726"
        y="-25.6425"
        width="166.468"
        height="142.859"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4257_88403"
        />
      </filter>
      <linearGradient
        id="paint0_linear_4257_88403"
        x1="102.492"
        y1="40.3698"
        x2="96.2289"
        y2="84.9319"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0.578125" stop-color="white" />
        <stop offset="1" stop-color="white" stop-opacity="0" />
      </linearGradient>
      <linearGradient
        id="paint1_linear_4257_88403"
        x1="102.492"
        y1="40.3698"
        x2="96.2289"
        y2="84.9319"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0.578125" stop-color="white" />
        <stop offset="1" stop-color="white" stop-opacity="0" />
      </linearGradient>
      <clipPath id="clip0_4257_88403">
        <rect width="140" height="96" fill="white" />
      </clipPath>
      <clipPath id="clip1_4257_88403">
        <rect
          x="11.7563"
          y="3.38196"
          width="130"
          height="88"
          rx="4"
          transform="rotate(8 11.7563 3.38196)"
          fill="white"
        />
      </clipPath>
      <clipPath id="clip2_4257_88403">
        <rect
          width="130"
          height="88"
          fill="white"
          transform="translate(11.7563 3.38196) rotate(8)"
        />
      </clipPath>
    </defs>
  </svg>
`;
var DarkLoadingBanner = html`
  <svg
    width="140"
    height="96"
    viewBox="0 0 140 96"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <g clip-path="url(#clip0_4391_90250)">
      <g opacity="0.4">
        <g clip-path="url(#clip1_4391_90250)">
          <g clip-path="url(#clip2_4391_90250)">
            <g opacity="0.8" filter="url(#filter0_f_4391_90250)">
              <ellipse
                cx="45.5713"
                cy="61.2938"
                rx="45.5713"
                ry="61.2938"
                transform="matrix(-0.275152 -0.961401 0.994111 -0.108365 23.6692 80.3025)"
                fill="#3E3E3F"
              />
            </g>
            <g opacity="0.8" filter="url(#filter1_f_4391_90250)">
              <ellipse
                cx="49.6555"
                cy="50.1114"
                rx="49.6555"
                ry="50.1114"
                transform="matrix(-0.517539 -0.855659 0.945307 -0.326182 10.3975 87.9766)"
                fill="#3E3E3F"
              />
            </g>
            <g opacity="0.8" filter="url(#filter2_f_4391_90250)">
              <path
                d="M141.154 3.03247C167.539 22.8936 134.54 99.5878 124.212 92.7915C117.912 88.6456 113.733 60.4772 94.173 45.9086C81.6691 36.5955 56.6586 38.5939 41.1056 37.1878C1.22291 33.5821 114.548 -16.9943 141.154 3.03247Z"
                fill="#3E3E3F"
              />
            </g>
            <path
              d="M78.5971 45.1263C77.9794 49.5216 81.121 53.5957 85.6131 54.2271C90.1053 54.8584 94.2481 51.808 94.8658 47.4128C95.4835 43.0175 92.342 38.9434 87.8498 38.312C83.3577 37.6807 79.2149 40.7311 78.5971 45.1263Z"
              fill="url(#paint0_linear_4391_90250)"
            />
            <path
              d="M120.378 78.3637L119.989 81.1303C119.731 82.9654 119.562 84.15 119.36 85.0413C119.166 85.8959 118.999 86.1992 118.895 86.3451C118.499 86.9002 117.932 87.3171 117.277 87.5363C117.105 87.5938 116.76 87.6677 115.867 87.6141C114.934 87.5582 113.723 87.3905 111.847 87.1268L80.6109 82.7369C78.735 82.4733 77.524 82.3006 76.6125 82.0973C75.7385 81.9024 75.4276 81.7365 75.278 81.6337C74.7087 81.2424 74.2794 80.6856 74.0516 80.0428C73.9917 79.8739 73.9142 79.5361 73.9635 78.6612C74.0149 77.7488 74.1789 76.5635 74.4369 74.7283L75.6584 66.0369C75.8058 65.9369 75.9505 65.8411 76.0924 65.7498C77.1899 65.0437 78.3629 64.4423 79.7464 64.1873C81.8083 63.8072 83.9443 64.0829 85.8427 64.9742C87.1166 65.5723 88.0991 66.452 88.9822 67.4137C89.5619 68.0451 90.1807 68.8058 90.8604 69.6691L94.5285 66.9912C95.9295 65.9684 97.1371 65.0867 98.1922 64.4415C99.3051 63.761 100.491 63.1868 101.879 62.9626C103.947 62.6286 106.075 62.9506 107.951 63.8817C109.21 64.5065 110.172 65.4058 111.033 66.385C111.033 66.385 117.277 74.3919 120.378 78.3637Z"
              fill="url(#paint1_linear_4391_90250)"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M18.0193 52.2289C18.1346 51.4086 18.8931 50.837 19.7134 50.9523L67.2463 57.6326C68.0667 57.7479 68.6382 58.5064 68.5229 59.3268C68.4076 60.1471 67.6491 60.7187 66.8288 60.6034L19.2959 53.9231C18.4755 53.8078 17.904 53.0493 18.0193 52.2289Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M21.5681 26.9771C21.7218 25.8833 22.7332 25.1212 23.827 25.2749L47.5934 28.6151C48.6872 28.7688 49.4493 29.7801 49.2956 30.874C49.1419 31.9678 48.1305 32.7299 47.0367 32.5762L23.2703 29.236C22.1765 29.0823 21.4144 28.0709 21.5681 26.9771Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M19.55 41.336C19.6653 40.5156 20.4238 39.9441 21.2442 40.0593L68.7771 46.7397C69.5974 46.8549 70.169 47.6135 70.0537 48.4338C69.9384 49.2542 69.1799 49.8258 68.3595 49.7105L20.8267 43.0301C20.0063 42.9149 19.4347 42.1564 19.55 41.336Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M16.4883 63.1219C16.6036 62.3015 17.3621 61.7299 18.1824 61.8452L65.7153 68.5255C66.5357 68.6408 67.1072 69.3993 66.9919 70.2197C66.8766 71.0401 66.1181 71.6116 65.2978 71.4963L17.7649 64.816C16.9445 64.7007 16.373 63.9422 16.4883 63.1219Z"
              fill="white"
              fill-opacity="0.8"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M15.2358 72.0344C15.3511 71.214 16.1096 70.6424 16.93 70.7577L64.4628 77.438C65.2832 77.5533 65.8548 78.3118 65.7395 79.1322C65.6242 79.9525 64.8657 80.5241 64.0453 80.4088L16.5125 73.7285C15.6921 73.6132 15.1205 72.8547 15.2358 72.0344Z"
              fill="white"
              fill-opacity="0.4"
            />
          </g>
        </g>
      </g>
    </g>
    <defs>
      <filter
        id="filter0_f_4391_90250"
        x="-14.1589"
        y="-38.4709"
        width="172.444"
        height="136.638"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4391_90250"
        />
      </filter>
      <filter
        id="filter1_f_4391_90250"
        x="-45.8333"
        y="-40.3932"
        width="155.805"
        height="139.072"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4391_90250"
        />
      </filter>
      <filter
        id="filter2_f_4391_90250"
        x="8.68726"
        y="-25.6425"
        width="166.468"
        height="142.859"
        filterUnits="userSpaceOnUse"
        color-interpolation-filters="sRGB"
      >
        <feFlood flood-opacity="0" result="BackgroundImageFix" />
        <feBlend
          mode="normal"
          in="SourceGraphic"
          in2="BackgroundImageFix"
          result="shape"
        />
        <feGaussianBlur
          stdDeviation="12"
          result="effect1_foregroundBlur_4391_90250"
        />
      </filter>
      <linearGradient
        id="paint0_linear_4391_90250"
        x1="102.492"
        y1="40.3698"
        x2="96.2289"
        y2="84.9319"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0.578125" stop-color="white" />
        <stop offset="1" stop-color="white" stop-opacity="0" />
      </linearGradient>
      <linearGradient
        id="paint1_linear_4391_90250"
        x1="102.492"
        y1="40.3698"
        x2="96.2289"
        y2="84.9319"
        gradientUnits="userSpaceOnUse"
      >
        <stop offset="0.578125" stop-color="white" />
        <stop offset="1" stop-color="white" stop-opacity="0" />
      </linearGradient>
      <clipPath id="clip0_4391_90250">
        <rect width="140" height="96" fill="white" />
      </clipPath>
      <clipPath id="clip1_4391_90250">
        <rect
          x="11.7563"
          y="3.38196"
          width="130"
          height="88"
          rx="4"
          transform="rotate(8 11.7563 3.38196)"
          fill="white"
        />
      </clipPath>
      <clipPath id="clip2_4391_90250">
        <rect
          width="130"
          height="88"
          fill="white"
          transform="translate(11.7563 3.38196) rotate(8)"
        />
      </clipPath>
    </defs>
  </svg>
`;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read2 = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read2, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement2(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name) {
    var style = state2.styles[name] || {};
    var attributes = state2.attributes[name] || {};
    var element = state2.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name) {
      var element = state2.elements[name];
      var attributes = state2.attributes[name] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property2) {
        style2[property2] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement2(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains2(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox2 = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min3, value, max2) {
  return max(min3, min(value, max2));
}
function withinMaxClamp(min3, value, max2) {
  var v = within(min3, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name = _ref.name, options2 = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len3 = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len3] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len3];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len3] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len3] / 2 + centerToReference;
  var offset2 = within(min3, center, max2);
  var axisProp = axis;
  state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains2(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr2 = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr2) / dpr2 || 0,
    y: round(y * dpr2) / dpr2 || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html3 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html3.clientWidth;
  var height = html3.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html3 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html3.scrollWidth, html3.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html3.scrollHeight, html3.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html3).direction === "rtl") {
    x += max(html3.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement2(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len3 = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len3] / 2 - element[len3] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len3] / 2 - element[len3] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement2(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options2 = _ref.options, name = _ref.name;
  if (state2.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len3 = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len3] > popperRect[len3]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x;
    state2.modifiersData.popperOffsets.y += y;
  }
  state2.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state2 = _ref.state, name = _ref.name;
  state2.modifiersData[name] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state2 = _ref.state, options2 = _ref.options, name = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len3 = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min3 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len3] / 2 : 0;
    var minLen = variation === start ? referenceRect[len3] : popperRect[len3];
    var maxLen = variation === start ? -popperRect[len3] : -referenceRect[len3];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len3], arrowRect[len3]);
    var minOffset = isBasePlacement ? referenceRect[len3] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len3] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min3, tetherMin) : min3, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset2 = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset2 + overflow[_mainSide];
    var _max = _offset2 - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset2 - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset2 + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset2, _tetherMax) : within(tether ? _tetherMin : _min, _offset2, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset2;
  }
  state2.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions2(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions, state2.options, options3);
        state2.scrollParents = {
          reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state2.orderedModifiers.length; index++) {
          if (state2.reset === true) {
            state2.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state3) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state: state2,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@blocksuite/blocks/dist/components/toast.js
var ToastContainer = null;
var htmlToElement = (html3) => {
  const template = document.createElement("template");
  if (typeof html3 === "string") {
    html3 = html3.trim();
    template.innerHTML = html3;
  } else {
    const { strings, values } = html3;
    const v = [...values, ""];
    const htmlString = strings.reduce((acc, cur, i) => acc + cur + v[i], "");
    template.innerHTML = htmlString;
  }
  return template.content.firstChild;
};
var createToastContainer = () => {
  const styles15 = css`
    position: fixed;
    z-index: 9999;
    top: 16px;
    left: 16px;
    right: 16px;
    bottom: 78px;
    pointer-events: none;
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
  `;
  const template = html`<div style="${styles15}"></div>`;
  const element = htmlToElement(template);
  document.body.appendChild(element);
  return element;
};
var toast = (message, duration = 2500) => {
  if (!ToastContainer) {
    ToastContainer = createToastContainer();
  }
  const styles15 = css`
    max-width: 480px;
    text-align: center;
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-sm);
    padding: 6px 12px;
    margin: 10px 0 0 0;
    color: var(--affine-white);
    background: var(--affine-tooltip);
    box-shadow: var(--affine-float-button-shadow);
    border-radius: 10px;
    transition: all 230ms cubic-bezier(0.21, 1.02, 0.73, 1);
    opacity: 0;
  `;
  const template = html`<div style="${styles15}"></div>`;
  const element = htmlToElement(template);
  element.textContent = message;
  ToastContainer.appendChild(element);
  const fadeIn = [
    {
      opacity: 0
    },
    { opacity: 1 }
  ];
  const options2 = {
    duration: 230,
    easing: "cubic-bezier(0.21, 1.02, 0.73, 1)",
    fill: "forwards"
  };
  element.animate(fadeIn, options2);
  setTimeout(async () => {
    const fadeOut = fadeIn.reverse();
    const animation = element.animate(fadeOut, options2);
    await animation.finished;
    element.style.maxHeight = "0";
    element.style.margin = "0";
    element.style.padding = "0";
    element.addEventListener("transitionend", () => {
      element.remove();
    }, {
      once: true
    });
  }, duration);
  return element;
};

// node_modules/@blocksuite/phasor/dist/consts.js
var ZOOM_MAX = 6;
var ZOOM_MIN = 0.1;
var ZOOM_STEP = 0.25;
var GRID_SIZE = 3e3;
var StrokeStyle;
(function(StrokeStyle2) {
  StrokeStyle2["Solid"] = "solid";
  StrokeStyle2["Dashed"] = "dash";
  StrokeStyle2["None"] = "none";
})(StrokeStyle || (StrokeStyle = {}));

// node_modules/@blocksuite/phasor/dist/elements/connector/types.js
var ConnectorMode;
(function(ConnectorMode2) {
  ConnectorMode2[ConnectorMode2["Straight"] = 0] = "Straight";
  ConnectorMode2[ConnectorMode2["Orthogonal"] = 1] = "Orthogonal";
})(ConnectorMode || (ConnectorMode = {}));

// node_modules/@blocksuite/phasor/dist/perfect-freehand/getStrokeRadius.js
function getStrokeRadius(size, thinning, pressure, easing = (t) => t) {
  return size * easing(0.5 - thinning * (0.5 - pressure));
}

// node_modules/@blocksuite/phasor/dist/perfect-freehand/vec.js
function neg(A) {
  return [-A[0], -A[1]];
}
function add(A, B) {
  return [A[0] + B[0], A[1] + B[1]];
}
function sub(A, B) {
  return [A[0] - B[0], A[1] - B[1]];
}
function mul(A, n) {
  return [A[0] * n, A[1] * n];
}
function div(A, n) {
  return [A[0] / n, A[1] / n];
}
function per(A) {
  return [A[1], -A[0]];
}
function dpr(A, B) {
  return A[0] * B[0] + A[1] * B[1];
}
function isEqual2(A, B) {
  return A[0] === B[0] && A[1] === B[1];
}
function len(A) {
  return Math.hypot(A[0], A[1]);
}
function len2(A) {
  return A[0] * A[0] + A[1] * A[1];
}
function dist2(A, B) {
  return len2(sub(A, B));
}
function uni(A) {
  return div(A, len(A));
}
function dist(A, B) {
  return Math.hypot(A[1] - B[1], A[0] - B[0]);
}
function rotAround(A, C, r) {
  const s = Math.sin(r);
  const c = Math.cos(r);
  const px2 = A[0] - C[0];
  const py = A[1] - C[1];
  const nx = px2 * c - py * s;
  const ny = px2 * s + py * c;
  return [nx + C[0], ny + C[1]];
}
function lrp(A, B, t) {
  return add(A, mul(sub(B, A), t));
}
function prj(A, B, c) {
  return add(A, mul(B, c));
}

// node_modules/@blocksuite/phasor/dist/perfect-freehand/getStrokeOutlinePoints.js
var { min: min2, PI } = Math;
var RATE_OF_PRESSURE_CHANGE = 0.275;
var FIXED_PI = PI + 1e-4;
function getStrokeOutlinePoints(points2, options2 = {}) {
  const { size = 16, smoothing = 0.5, thinning = 0.5, simulatePressure = true, easing = (t) => t, start: start2 = {}, end: end2 = {}, last: isComplete = false } = options2;
  const { cap: capStart = true, easing: taperStartEase = (t) => t * (2 - t) } = start2;
  const { cap: capEnd = true, easing: taperEndEase = (t) => --t * t * t + 1 } = end2;
  if (points2.length === 0 || size <= 0) {
    return [];
  }
  const totalLength = points2[points2.length - 1].runningLength;
  const taperStart = start2.taper === false ? 0 : start2.taper === true ? Math.max(size, totalLength) : start2.taper;
  const taperEnd = end2.taper === false ? 0 : end2.taper === true ? Math.max(size, totalLength) : end2.taper;
  const minDistance = Math.pow(size * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevPressure = points2.slice(0, 10).reduce((acc, curr) => {
    let pressure = curr.pressure;
    if (simulatePressure) {
      const sp = min2(1, curr.distance / size);
      const rp = min2(1, 1 - sp);
      pressure = min2(1, acc + (rp - acc) * (sp * RATE_OF_PRESSURE_CHANGE));
    }
    return (acc + pressure) / 2;
  }, points2[0].pressure);
  let radius = getStrokeRadius(size, thinning, points2[points2.length - 1].pressure, easing);
  let firstRadius = void 0;
  let prevVector = points2[0].vector;
  let pl = points2[0].point;
  let pr = pl;
  let tl = pl;
  let tr = pr;
  let isPrevPointSharpCorner = false;
  for (let i = 0; i < points2.length; i++) {
    let { pressure } = points2[i];
    const { point, vector, distance: distance2, runningLength } = points2[i];
    if (i < points2.length - 1 && totalLength - runningLength < 3) {
      continue;
    }
    if (thinning) {
      if (simulatePressure) {
        const sp = min2(1, distance2 / size);
        const rp = min2(1, 1 - sp);
        pressure = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      }
      radius = getStrokeRadius(size, thinning, pressure, easing);
    } else {
      radius = size / 2;
    }
    if (firstRadius === void 0) {
      firstRadius = radius;
    }
    const ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
    const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
    radius = Math.max(0.01, radius * Math.min(ts, te));
    const nextVector = (i < points2.length - 1 ? points2[i + 1] : points2[i]).vector;
    const nextDpr = i < points2.length - 1 ? dpr(vector, nextVector) : 1;
    const prevDpr = dpr(vector, prevVector);
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      const offset3 = mul(per(prevVector), radius);
      for (let step = 1 / 13, t = 0; t <= 1; t += step) {
        tl = rotAround(sub(point, offset3), point, FIXED_PI * t);
        leftPts.push(tl);
        tr = rotAround(add(point, offset3), point, FIXED_PI * -t);
        rightPts.push(tr);
      }
      pl = tl;
      pr = tr;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (i === points2.length - 1) {
      const offset3 = mul(per(vector), radius);
      leftPts.push(sub(point, offset3));
      rightPts.push(add(point, offset3));
      continue;
    }
    const offset2 = mul(per(lrp(nextVector, vector, nextDpr)), radius);
    tl = sub(point, offset2);
    if (i <= 1 || dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr = add(point, offset2);
    if (i <= 1 || dist2(pr, tr) > minDistance) {
      rightPts.push(tr);
      pr = tr;
    }
    prevPressure = pressure;
    prevVector = vector;
  }
  const firstPoint = points2[0].point.slice(0, 2);
  const lastPoint = points2.length > 1 ? points2[points2.length - 1].point.slice(0, 2) : add(points2[0].point, [1, 1]);
  const startCap = [];
  const endCap = [];
  if (points2.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start3 = prj(firstPoint, uni(per(sub(firstPoint, lastPoint))), -(firstRadius || radius));
      const dotPts = [];
      for (let step = 1 / 13, t = step; t <= 1; t += step) {
        dotPts.push(rotAround(start3, firstPoint, FIXED_PI * 2 * t));
      }
      return dotPts;
    }
  } else {
    if (taperStart || taperEnd && points2.length === 1) {
    } else if (capStart) {
      for (let step = 1 / 13, t = step; t <= 1; t += step) {
        const pt = rotAround(rightPts[0], firstPoint, FIXED_PI * t);
        startCap.push(pt);
      }
    } else {
      const cornersVector = sub(leftPts[0], rightPts[0]);
      const offsetA = mul(cornersVector, 0.5);
      const offsetB = mul(cornersVector, 0.51);
      startCap.push(sub(firstPoint, offsetA), sub(firstPoint, offsetB), add(firstPoint, offsetB), add(firstPoint, offsetA));
    }
    const direction = per(neg(points2[points2.length - 1].vector));
    if (taperEnd || taperStart && points2.length === 1) {
      endCap.push(lastPoint);
    } else if (capEnd) {
      const start3 = prj(lastPoint, direction, radius);
      for (let step = 1 / 29, t = step; t < 1; t += step) {
        endCap.push(rotAround(start3, lastPoint, FIXED_PI * 3 * t));
      }
    } else {
      endCap.push(add(lastPoint, mul(direction, radius)), add(lastPoint, mul(direction, radius * 0.99)), sub(lastPoint, mul(direction, radius * 0.99)), sub(lastPoint, mul(direction, radius)));
    }
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}

// node_modules/@blocksuite/phasor/dist/perfect-freehand/getStrokePoints.js
function getStrokePoints(points2, options2 = {}) {
  var _a3;
  const { streamline = 0.5, size = 16, last: isComplete = false } = options2;
  if (points2.length === 0)
    return [];
  const t = 0.15 + (1 - streamline) * 0.85;
  let pts = Array.isArray(points2[0]) ? points2 : points2.map(({ x, y, pressure = 0.5 }) => [x, y, pressure]);
  if (pts.length === 2) {
    const last = pts[1];
    pts = pts.slice(0, -1);
    for (let i = 1; i < 5; i++) {
      pts.push(lrp(pts[0], last, i / 4));
    }
  }
  if (pts.length === 1) {
    pts = [...pts, [...add(pts[0], [1, 1]), ...pts[0].slice(2)]];
  }
  const strokePoints = [
    {
      point: [pts[0][0], pts[0][1]],
      pressure: pts[0][2] >= 0 ? pts[0][2] : 0.25,
      vector: [1, 1],
      distance: 0,
      runningLength: 0
    }
  ];
  let hasReachedMinimumLength = false;
  let runningLength = 0;
  let prev = strokePoints[0];
  const max2 = pts.length - 1;
  for (let i = 1; i < pts.length; i++) {
    const point = isComplete && i === max2 ? (
      // If we're at the last point, and `options.last` is true,
      // then add the actual input point.
      pts[i].slice(0, 2)
    ) : (
      // Otherwise, using the t calculated from the streamline
      // option, interpolate a new point between the previous
      // point the current point.
      lrp(prev.point, pts[i], t)
    );
    if (isEqual2(prev.point, point))
      continue;
    const distance2 = dist(point, prev.point);
    runningLength += distance2;
    if (i < max2 && !hasReachedMinimumLength) {
      if (runningLength < size)
        continue;
      hasReachedMinimumLength = true;
    }
    prev = {
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: pts[i][2] >= 0 ? pts[i][2] : 0.5,
      // The vector from the current point to the previous point
      vector: uni(sub(prev.point, point)),
      // The distance between the current point and the previous point
      distance: distance2,
      // The total distance so far
      runningLength
    };
    strokePoints.push(prev);
  }
  strokePoints[0].vector = ((_a3 = strokePoints[1]) == null ? void 0 : _a3.vector) || [0, 0];
  return strokePoints;
}

// node_modules/@blocksuite/phasor/dist/perfect-freehand/getStroke.js
function getStroke(points2, options2 = {}) {
  return getStrokeOutlinePoints(getStrokePoints(points2, options2), options2);
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/block-range.js
function getCurrentBlockRange(page) {
  var _a3;
  const pageBlock = getDefaultPage(page);
  if (pageBlock) {
    const selectedBlocks = pageBlock.selection.state.selectedBlocks;
    const selectedEmbeds = pageBlock.selection.state.selectedEmbeds;
    const models = [...selectedBlocks, ...selectedEmbeds].map((element) => getModelByElement(element)).filter(Boolean);
    if (models.length) {
      return {
        type: "Block",
        startOffset: 0,
        endOffset: ((_a3 = models[models.length - 1].text) == null ? void 0 : _a3.length) ?? 0,
        models
      };
    }
  }
  if (hasNativeSelection()) {
    const range = getCurrentNativeRange();
    const blockRange = nativeRangeToBlockRange(range);
    if (!blockRange) {
      return null;
    }
    return { ...blockRange, nativeRange: range };
  }
  return null;
}
function blockRangeToNativeRange(blockRange) {
  if (blockRange.type === "Title") {
    const page = blockRange.models[0].page;
    const pageElement = getDefaultPage(page);
    if (!pageElement) {
      return null;
    }
    const titleVEditor = pageElement.titleVEditor;
    const [startNode2, startOffset2] = titleVEditor.getTextPoint(blockRange.startOffset);
    const [endNode2, endOffset2] = titleVEditor.getTextPoint(blockRange.endOffset);
    const range2 = new Range();
    range2.setStart(startNode2, startOffset2);
    range2.setEnd(endNode2, endOffset2);
    return range2;
  }
  const models = blockRange.models.filter((model) => model.text);
  if (!models.length) {
    return null;
  }
  const [startNode, startOffset] = getTextNodeByModel(models[0], blockRange.startOffset);
  const [endNode, endOffset] = getTextNodeByModel(models[models.length - 1], blockRange.endOffset);
  const range = new Range();
  range.setStart(startNode, startOffset);
  range.setEnd(endNode, endOffset);
  return range;
}
function nativeRangeToBlockRange(range) {
  const models = getModelsByRange(range);
  if (!models.length) {
    return null;
  }
  const startVRange = getVRangeByNode(range.startContainer);
  const endVRange = getVRangeByNode(range.endContainer);
  if (!startVRange || !endVRange) {
    return null;
  }
  const startOffset = startVRange.index;
  const endOffset = endVRange.index + endVRange.length;
  return {
    type: "Native",
    startOffset,
    endOffset,
    models
  };
}
function updateBlockRange(blockRange, oldModel, newModel) {
  blockRange.models = blockRange.models.map((model) => model === oldModel ? newModel : model);
  return blockRange;
}
function restoreSelection(blockRange) {
  if (!blockRange.models.length) {
    throw new Error("Can't restore selection, blockRange.models is empty");
  }
  const page = blockRange.models[0].page;
  const defaultPageBlock = getDefaultPage(page);
  if (blockRange.type === "Native") {
    const range = blockRangeToNativeRange(blockRange);
    resetNativeSelection(range);
    if (defaultPageBlock) {
      defaultPageBlock.selection.state.clearBlockSelection();
      defaultPageBlock.selection.state.type = "native";
    }
    return;
  }
  if (blockRange.type === "Block") {
    if (defaultPageBlock) {
      defaultPageBlock.selection.state.type = "block";
      defaultPageBlock.selection.refreshSelectedBlocksRectsByModels(blockRange.models);
    }
    resetNativeSelection(null);
    document.activeElement.blur();
    return;
  }
  if (defaultPageBlock && blockRange.type === "Title") {
    focusTitle(page, blockRange.startOffset, blockRange.endOffset - blockRange.startOffset);
    return;
  }
  throw new Error("Invalid block range type: " + blockRange.type);
}
function getExtendBlockRange(page) {
  const basicBlockRange = getCurrentBlockRange(page);
  if (basicBlockRange)
    return basicBlockRange;
  if (!hasNativeSelection()) {
    return null;
  }
  const range = getCurrentNativeRange();
  const isTitleRange = isInsidePageTitle(range.startContainer) && isInsidePageTitle(range.endContainer);
  if (isTitleRange) {
    const pageModel = page.root;
    assertExists(pageModel);
    return {
      type: "Title",
      startOffset: range.startOffset,
      endOffset: range.endOffset,
      models: [pageModel]
    };
  }
  return null;
}
function getVRangeByNode(node) {
  if (!node.parentElement)
    return null;
  const virgoElement = node.parentElement.closest('[data-virgo-root="true"]') || (node instanceof HTMLElement ? node.querySelector('[data-virgo-root="true"]') : null);
  const vEditor = virgoElement == null ? void 0 : virgoElement.virgoEditor;
  if (!vEditor)
    return null;
  return vEditor.getVRange();
}
function getTextNodeByModel(model, offset2 = 0) {
  const text = model.text;
  if (!text) {
    throw new Error("Failed to get block's text!");
  }
  if (offset2 > text.length) {
    offset2 = text.length;
  }
  const vEditor = getVirgoByModel(model);
  assertExists(vEditor);
  const [leaf, leafOffset] = vEditor.getTextPoint(offset2);
  return [leaf, leafOffset];
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/drag-and-drop.js
function calcDropTarget(point, model, element, draggingElements, scale, flavour = null) {
  var _a3, _b;
  const schema = model.page.getSchemaByFlavour("affine:database");
  assertExists(schema);
  const children = schema.model.children ?? [];
  let shouldAppendToDatabase = true;
  if (children.length) {
    if (draggingElements.length) {
      shouldAppendToDatabase = draggingElements.map(getModelByBlockElement).every((m) => children.includes(m.flavour));
    } else if (flavour) {
      shouldAppendToDatabase = children.includes(flavour);
    }
  }
  if (!shouldAppendToDatabase && !matchFlavours(model, ["affine:database"])) {
    const databaseBlockElement = element.closest("affine-database");
    if (databaseBlockElement) {
      element = databaseBlockElement;
      model = getModelByBlockElement(element);
    }
  }
  let type = "none";
  const height = 3 * scale;
  const { rect: domRect, flag } = getDropRectByPoint(point, model, element);
  if (flag === DropFlags.EmptyDatabase) {
    const rect = Rect.fromDOMRect(domRect);
    rect.top -= height / 2;
    rect.height = height;
    type = "database";
    return {
      type,
      rect,
      modelState: {
        model,
        rect: domRect,
        element
      }
    };
  } else if (flag === DropFlags.Database) {
    const distanceToTop2 = Math.abs(domRect.top - point.y);
    const distanceToBottom2 = Math.abs(domRect.bottom - point.y);
    const before2 = distanceToTop2 < distanceToBottom2;
    type = before2 ? "before" : "after";
    return {
      type,
      rect: Rect.fromLWTH(domRect.left, domRect.width, (before2 ? domRect.top - 1 : domRect.bottom) - height / 2, height),
      modelState: {
        model,
        rect: domRect,
        element
      }
    };
  }
  const distanceToTop = Math.abs(domRect.top - point.y);
  const distanceToBottom = Math.abs(domRect.bottom - point.y);
  const before = distanceToTop < distanceToBottom;
  type = before ? "before" : "after";
  let offsetY = 4;
  if (type === "before") {
    let prev;
    let prevRect;
    prev = element.previousElementSibling;
    if (prev) {
      if (prev === draggingElements[draggingElements.length - 1]) {
        type = "none";
      } else {
        prevRect = getRectByBlockElement(prev);
      }
    } else {
      prev = (_a3 = element.parentElement) == null ? void 0 : _a3.previousElementSibling;
      if (prev) {
        prevRect = prev.getBoundingClientRect();
      }
    }
    if (prevRect) {
      offsetY = (domRect.top - prevRect.bottom) / 2;
    }
  } else {
    let next2;
    let nextRect;
    next2 = element.nextElementSibling;
    if (next2) {
      if (next2 === draggingElements[0]) {
        type = "none";
        next2 = null;
      }
    } else {
      next2 = (_b = getClosestBlockElementByElement(element.parentElement)) == null ? void 0 : _b.nextElementSibling;
    }
    if (next2) {
      nextRect = getRectByBlockElement(next2);
      offsetY = (nextRect.top - domRect.bottom) / 2;
    }
  }
  if (type === "none")
    return null;
  let top2 = domRect.top;
  if (type === "before") {
    top2 -= offsetY;
  } else {
    top2 += domRect.height + offsetY;
  }
  return {
    type,
    rect: Rect.fromLWTH(domRect.left, domRect.width, top2 - height / 2, height),
    modelState: {
      model,
      rect: domRect,
      element
    }
  };
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/event.js
function isPinchEvent(e) {
  if (IS_IOS || IS_MAC) {
    return e.ctrlKey || e.metaKey;
  }
  return e.ctrlKey;
}
function createDragEvent(type, event) {
  const options2 = {
    dataTransfer: new DataTransfer()
  };
  if (event) {
    const { clientX, clientY, screenX, screenY } = event;
    Object.assign(options2, {
      clientX,
      clientY,
      screenX,
      screenY
    });
  }
  return new DragEvent(type, options2);
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/filesys.js
var createImageInputElement = () => {
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.multiple = true;
  fileInput.accept = "image/*";
  fileInput.style.position = "fixed";
  fileInput.style.left = "0";
  fileInput.style.top = "0";
  fileInput.style.opacity = "0.001";
  return fileInput;
};
var uploadImageFromLocal = async (page, getSize) => {
  const baseProps = { flavour: "affine:embed", type: "image" };
  const fileInput = createImageInputElement();
  document.body.appendChild(fileInput);
  let resolvePromise;
  const pending = new Promise((resolve) => {
    resolvePromise = resolve;
  });
  const onChange = async () => {
    if (!fileInput.files)
      return;
    const storage = await page.blobs;
    assertExists(storage);
    const files = fileInput.files;
    if (files.length === 1) {
      const file = files[0];
      if (getSize) {
        getSize(await readImageSize(file));
      }
      const id = await storage.set(file);
      resolvePromise([{ ...baseProps, sourceId: id }]);
    } else {
      const res = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const id = await storage.set(file);
        res.push({ ...baseProps, sourceId: id });
      }
      resolvePromise(res);
    }
    fileInput.removeEventListener("change", onChange);
    fileInput.remove();
  };
  fileInput.addEventListener("change", onChange);
  fileInput.click();
  return await pending;
};
function readImageSize(file) {
  return new Promise((resolve) => {
    let width = 0;
    let height = 0;
    let reader = new FileReader();
    reader.addEventListener("load", (_) => {
      const img = new Image();
      img.onload = () => {
        width = img.width;
        height = img.height;
        reader = null;
        resolve({ width, height });
      };
      img.src = reader == null ? void 0 : reader.result;
    });
    reader.addEventListener("error", (_) => {
      reader = null;
      resolve({ width, height });
    });
    reader.readAsDataURL(file);
  });
}

// node_modules/hotkeys-js/dist/hotkeys.esm.js
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i = 0; i < mods.length; i++) {
    mods[i] = modifier[mods[i].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys = key.split(",");
  var index = keys.lastIndexOf("");
  for (; index >= 0; ) {
    keys[index - 1] += ",";
    keys.splice(index, 1);
    index = keys.lastIndexOf("");
  }
  return keys;
}
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var k;
var _downKeys = [];
var winListendFocus = false;
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
};
var getKey = function getKey2(x) {
  return Object.keys(_keyMap).find(function(k) {
    return _keyMap[k] === x;
  });
};
var getModifier = function getModifier2(x) {
  return Object.keys(_modifier).find(function(k) {
    return _modifier[k] === x;
  });
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map(function(c) {
    return getKey(c) || getModifier(c) || String.fromCharCode(c);
  });
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope)
          handlers.splice(i, 1);
        else
          i++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = false;
    }
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len3 = unbindKeys.length;
    var lastKey = unbindKeys[len3 - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len3 > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
    });
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key && _handlers[key][_i].scope === scope) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  var capture = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (option.capture !== void 0)
      capture = option.capture;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i < keys.length; i++) {
    key = keys[i].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys[i],
      method,
      key: keys[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e) {
      dispatch(e, element);
    }, capture);
    if (!winListendFocus) {
      winListendFocus = true;
      addEvent(window, "focus", function() {
        _downKeys = [];
      }, capture);
    }
    addEvent(element, "keyup", function(e) {
      dispatch(e, element);
      clearModifier(e);
    }, capture);
  }
}
function trigger(shortcut) {
  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach(function(key) {
    var dataList = _handlers[key].filter(function(item) {
      return item.scope === scope && item.shortcut === shortcut;
    });
    dataList.forEach(function(data) {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
var _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
var a;
if (typeof window !== "undefined") {
  _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var _hotkeys;

// node_modules/@blocksuite/blocks/dist/__internal__/utils/hotkey.js
hotkeys.filter = (event) => {
  if (shouldFilterHotkey(event))
    return false;
  return true;
};
function isUndoRedo(event) {
  if ((event.ctrlKey || event.metaKey) && !event.altKey && event.key === "z") {
    return true;
  }
  return false;
}
function shouldFilterHotkey(event) {
  const target = event.target;
  if (!target) {
    return true;
  }
  if (!isInsideRichText(event.target)) {
    if (isCaptionElement(event.target) && event.key === "Enter") {
      return false;
    }
    if (isInsidePageTitle(event.target) && isUndoRedo(event)) {
      return false;
    }
    if ((isInsideDatabaseTitle(event.target) || isDatabaseInput(event.target)) && isUndoRedo(event)) {
      return false;
    }
    if (isInsideEdgelessTextEditor(event.target) && isUndoRedo(event)) {
      return false;
    }
    if (event.target === document.body) {
      return false;
    }
    return true;
  }
  return false;
}
var HOTKEY_SCOPE_TYPE = {
  AFFINE_PAGE: "affine:page",
  AFFINE_EDGELESS: "affine:edgeless"
};
var HOTKEY_DISABLED_SCOPE = "hotkey_disabled";
var HotkeyManager = class {
  constructor() {
    this._scope = HOTKEY_DISABLED_SCOPE;
    this._disabled = false;
    this.counter = 0;
    this._hotkeys = hotkeys;
  }
  get disabled() {
    return this._disabled;
  }
  newScope(type) {
    return `${type}-${this.counter++}`;
  }
  setScope(scope) {
    this._scope = scope;
    this._hotkeys.setScope(scope);
  }
  deleteScope(scope) {
    this._hotkeys.deleteScope(scope);
  }
  addListener(hotkey2, listener, options2 = {}) {
    this._hotkeys(hotkey2, { ...options2, scope: this._scope }, listener);
  }
  removeListener(hotkey2) {
    this._hotkeys.unbind((Array.isArray(hotkey2) ? hotkey2 : [hotkey2]).join(","), this._scope);
  }
  disableHotkey() {
    this._disabled = true;
    this._hotkeys.setScope(HOTKEY_DISABLED_SCOPE);
  }
  enableHotkey() {
    this._disabled = false;
    this._hotkeys.setScope(this._scope);
  }
  /**
   * Create a context to shielding against global hotkey.
   *
   * The param `fn` will be executed immediately.
   * @example
   * ```ts
   * const ret = await hotkey.withDisableHotkey(async () => {
   *   const result = await createLink(space);
   *   return result;
   * });
   * ```
   */
  async withDisabledHotkey(fn2) {
    this.disableHotkey();
    try {
      return await fn2();
    } finally {
      this.enableHotkey();
    }
  }
  /**
   * Similar to {@link withDisableHotkey}, but return a function instead of execute immediately.
   * @example
   * ```ts
   * const createLinkWithoutHotkey = withDisabledHotkeyFn((space) => createLink(space));
   * await createLinkWithoutHotkey(space);
   * ```
   */
  withDisabledHotkeyFn(fn2) {
    return (...args) => this.withDisabledHotkey(() => fn2(...args));
  }
  withScope(scope, fn2) {
    const pre = this._scope;
    try {
      this._scope = scope;
      fn2();
    } finally {
      this._scope = pre;
    }
  }
};
var hotkey = new HotkeyManager();

// node_modules/@blocksuite/blocks/dist/__internal__/utils/reordering.js
function getIndexesWith(a, b) {
  return a.map((e) => b.findIndex((element) => element === e));
}
function generateRanges(indexes) {
  let curr;
  let i = 1;
  let start2 = indexes[0];
  let end2 = indexes[0];
  const ranges = [{ start: start2, end: end2 }];
  const len3 = indexes.length;
  for (; i < len3; i++) {
    curr = indexes[i];
    if (curr - end2 === 1) {
      ranges[ranges.length - 1].end = end2 = curr;
    } else {
      start2 = end2 = curr;
      ranges.push({ start: start2, end: end2 });
    }
  }
  return ranges;
}
function bringForward(ranges, elements) {
  let i = ranges.length;
  while (i) {
    i--;
    const { start: start2, end: end2 } = ranges[i];
    const temp = elements.splice(start2, end2 + 1 - start2);
    elements.splice(start2 + 1, 0, ...temp);
  }
}
function sendBackward(ranges, elements) {
  let i = 0;
  const len3 = ranges.length;
  for (; i < len3; i++) {
    const { start: start2, end: end2 } = ranges[i];
    if (start2 === 0)
      continue;
    const temp = elements.splice(start2, end2 + 1 - start2);
    elements.splice(start2 - 1, 0, ...temp);
  }
}
function reorderTo(elements, compare2, getIndexes, genKeys, setIndexes) {
  if (!elements.length) {
    return;
  }
  elements.sort(compare2);
  const { start: start2, end: end2 } = getIndexes(elements);
  const keys = genKeys(start2, end2, elements.length);
  setIndexes(keys, elements);
}
function reorder(elements, compare2, pick, getIndexes, order2, genKeys, setIndexes) {
  if (!elements.length) {
    return;
  }
  elements.sort(compare2);
  const pickedElements = pick().sort(compare2);
  const { start: start2, end: end2 } = getIndexes(pickedElements);
  const indexes = getIndexesWith(elements, pickedElements);
  const ranges = generateRanges(indexes);
  order2(ranges, pickedElements);
  const keys = genKeys(start2, end2, pickedElements.length);
  setIndexes(keys, pickedElements);
}

// node_modules/@blocksuite/blocks/dist/page-block/default/backlink-popover.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles = css`
  :host {
    position: relative;
  }

  .btn {
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    border: none;
    padding: 1px 4px;
    border-radius: 5px;
    gap: 4px;
    background: transparent;
    cursor: pointer;

    user-select: none;
    font-family: var(--affine-font-family);
    fill: var(--affine-text-secondary-color);
    color: var(--affine-text-secondary-color);
    pointer-events: auto;
  }

  .btn > span {
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .btn:hover {
    background: var(--affine-hover-color);
  }

  .btn:active {
    background: var(--affine-hover-color);
  }

  .backlink-popover {
    position: absolute;
    left: 0;
    bottom: -8px;

    display: flex;
    flex-direction: column;
    padding: 8px 4px;
    background: var(--affine-white);
    box-shadow: var(--affine-menu-shadow);
    border-radius: 12px;
    transform: translateY(100%);
    z-index: 1;
  }

  .backlink-popover .group-title {
    color: var(--affine-text-secondary-color);
    margin: 8px 12px;
  }

  .backlink-popover icon-button {
    padding: 8px;
    justify-content: flex-start;
    gap: 8px;
  }

  ::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }
  ::-webkit-scrollbar-thumb {
    border-radius: 2px;
    background-color: #b1b1b1;
  }
`;
var BacklinkButton = class BacklinkButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._backlinks = [];
    this._showPopover = false;
    this._onClickAway = (e) => {
      if (e.target === this)
        return;
      if (!this._showPopover)
        return;
      this._showPopover = false;
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.tabIndex = 0;
    const page = this.page;
    assertExists(page);
    const backlinkIndexer = page.workspace.indexer.backlink;
    this._backlinks = backlinkIndexer.getBacklink(page.id);
    backlinkIndexer.slots.indexUpdated.on(() => {
      this._backlinks = backlinkIndexer.getBacklink(page.id);
      if (!this._backlinks.length) {
        this._showPopover = false;
      }
    });
    this._disposables.addFromEvent(window, "mousedown", this._onClickAway);
  }
  onClick() {
    this._showPopover = !this._showPopover;
  }
  render() {
    const linkedBacklinks = this._backlinks.filter(({ type }) => type === "LinkedPage");
    if (!linkedBacklinks.length) {
      return null;
    }
    return html`<div class="btn" @click=${this.onClick}>
        ${DualLinkIcon16}<span>Backlinks (${linkedBacklinks.length})</span
        >${ArrowDownIcon}
      </div>
      ${this._showPopover ? backlinkPopover(this.host, linkedBacklinks) : null}`;
  }
};
BacklinkButton.styles = styles;
__decorate4([
  property()
], BacklinkButton.prototype, "page", void 0);
__decorate4([
  property()
], BacklinkButton.prototype, "host", void 0);
__decorate4([
  state()
], BacklinkButton.prototype, "_backlinks", void 0);
__decorate4([
  state()
], BacklinkButton.prototype, "_showPopover", void 0);
BacklinkButton = __decorate4([
  customElement("backlink-button")
], BacklinkButton);
var DEFAULT_PAGE_NAME = "Untitled";
function backlinkPopover(host, backlinks) {
  const metas = host.page.workspace.meta.pageMetas;
  return html`<div class="backlink-popover">
    <div class="group-title">Linked to this page</div>
    <div class="group" style="overflow-y: scroll; max-height: 372px;">
      ${backlinks.map(({ pageId, blockId, type }) => {
    const icon = type === "LinkedPage" ? LinkedPageIcon : PageIcon;
    const pageMeta = metas.find((page) => page.id === pageId);
    if (!pageMeta) {
      console.warn("Unexpected page meta not found", pageId);
    }
    const title = (pageMeta == null ? void 0 : pageMeta.title) || DEFAULT_PAGE_NAME;
    return html`<icon-button
          width="248px"
          height="32px"
          text=${title}
          @click=${() => {
      if (pageId === host.page.id) {
        return;
      }
      host.slots.pageLinkClicked.emit({ pageId, blockId });
    }}
        >
          ${icon}
        </icon-button>`;
  })}
    </div>
  </div>`;
}

// node_modules/@blocksuite/blocks/dist/__internal__/utils/virgo.js
function clearMarksOnDiscontinuousInput(vEditor) {
  let vRange = vEditor.getVRange();
  const dispose = vEditor.slots.vRangeUpdated.on(([r, t]) => {
    if (vRange && r && (t === "native" && r.index === vRange.index || t !== "native" && r.index === vRange.index + 1)) {
      vRange = r;
    } else {
      vEditor.resetMarks();
      dispose.dispose();
    }
  });
}
function setupVirgoScroll(page, vEditor) {
  vEditor.shouldLineScrollIntoView = isPageMode(page);
}

// node_modules/@blocksuite/blocks/dist/components/format-quick-bar/button.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FormatBarButton = class FormatBarButton2 extends IconButton {
  constructor() {
    super(...arguments);
    this.width = "32px";
    this.height = "32px";
    this.active = false;
    this._mousedown = (e) => {
      e.stopPropagation();
      e.preventDefault();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("mousedown", this._mousedown);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("mousedown", this._mousedown);
  }
};
FormatBarButton.styles = css`
    ${IconButton.styles}

    :host {
      width: var(--button-width);
      height: var(--button-height);
      fill: var(--affine-icon-color);
      white-space: nowrap;
      user-select: none;
      gap: 8px;
    }
  `;
__decorate5([
  property()
], FormatBarButton.prototype, "width", void 0);
__decorate5([
  property()
], FormatBarButton.prototype, "height", void 0);
__decorate5([
  property()
], FormatBarButton.prototype, "active", void 0);
FormatBarButton = __decorate5([
  customElement("format-bar-button")
], FormatBarButton);

// node_modules/@blocksuite/blocks/dist/page-block/utils/position.js
function repairContextMenuRange(e) {
  const selection = window.getSelection();
  const currentRange = selection && selection.rangeCount && selection.getRangeAt(0);
  const pointRange = caretRangeFromPoint(e.x, e.y);
  if (currentRange && pointRange && currentRange.isPointInRange(pointRange.startContainer, pointRange.startOffset) && currentRange.isPointInRange(pointRange.endContainer, pointRange.endOffset)) {
    requestAnimationFrame(() => {
      resetNativeSelection(currentRange);
    });
  } else {
    e.preventDefault();
  }
}
function getDragDirection(e) {
  const startX = e.start.x;
  const startY = e.start.y;
  const endX = e.point.x;
  const endY = e.point.y;
  const isForwards = endX > startX;
  const range = getCurrentNativeRange();
  const selectedOneLine = !isMultiLineRange(range);
  if (isForwards) {
    if (selectedOneLine || endY >= startY) {
      return "right-bottom";
    } else {
      return "right-top";
    }
  } else {
    if (selectedOneLine || endY <= startY) {
      return "left-top";
    } else {
      return "left-bottom";
    }
  }
}
function getNativeSelectionMouseDragInfo(e) {
  const curRange = getCurrentNativeRange();
  const direction = getDragDirection(e);
  const isSelectedNothing = curRange.collapsed || // If you try to drag from back to front on an empty line,
  // you will get a empty range, but the `range.collapsed` is false,
  // and the range has different startContainer and endContainer.
  // So we need to check the length of the range
  curRange.toString().length === 0;
  const selectedType = isSelectedNothing ? "Caret" : "Text";
  return { selectedType, direction };
}
function calcPositionPointByRange(range, direction) {
  const { startContainer, startOffset, endContainer, endOffset } = range;
  const isStartAnchor = direction.includes("top");
  const [targetNode, offset2] = isStartAnchor ? [startContainer, startOffset] : [endContainer, endOffset];
  const lineRange = new Range();
  if (direction.includes("center")) {
    lineRange.setStart(startContainer, startOffset);
    lineRange.setEnd(endContainer, endOffset);
  } else {
    lineRange.setStart(targetNode, offset2);
    const isTextLikeNode = targetNode.nodeType === Node.TEXT_NODE || targetNode.nodeType === Node.COMMENT_NODE || targetNode.nodeType === Node.CDATA_SECTION_NODE;
    if (!isTextLikeNode) {
      lineRange.setStart(startContainer, startOffset);
      lineRange.setEnd(endContainer, endOffset);
    }
    if (direction.includes("left")) {
      const maybeShiftRange = isAtLineEdge(lineRange);
      if (maybeShiftRange) {
        lineRange.setStart(maybeShiftRange.startContainer, maybeShiftRange.startOffset);
        lineRange.setEnd(maybeShiftRange.endContainer, maybeShiftRange.endOffset);
      }
    }
  }
  const lineRect = lineRange.getBoundingClientRect();
  const isBottom = direction.includes("bottom");
  const positioningPoint = {
    // Use the center of the position rect
    x: lineRect.x + lineRect.width / 2,
    // if the direction is bottom, use the bottom of the position rect
    y: lineRect.y + (isBottom ? lineRect.height : 0)
  };
  return positioningPoint;
}
function calcCurrentSelectionPosition(direction, pageSelectionState) {
  if (!pageSelectionState || !pageSelectionState.selectedBlocks.length) {
    if (!hasNativeSelection()) {
      throw new Error("Failed to get anchor element! There's no block selection or native selection.");
    }
    const range = getCurrentNativeRange();
    const positioningPoint = calcPositionPointByRange(range, direction);
    return positioningPoint;
  }
  const blocks = pageSelectionState.selectedBlocks;
  const firstBlock = blocks[0];
  const lastBlock = blocks[blocks.length - 1];
  const targetBlock = direction.includes("bottom") ? lastBlock : firstBlock;
  const rect = targetBlock.getBoundingClientRect();
  const x = rect.x + rect.width / 2;
  const y = direction.includes("bottom") ? rect.bottom : rect.top;
  return { x, y };
}
function calcSafeCoordinate({ positioningPoint, objRect = { width: 0, height: 0 }, boundaryRect = document.body.getBoundingClientRect(), offsetX = 0, offsetY = 0, edgeGap = 20 }) {
  const safeX = clamp(positioningPoint.x + offsetX, edgeGap, boundaryRect.width - objRect.width - edgeGap);
  const y = positioningPoint.y + offsetY;
  return {
    x: safeX,
    y
  };
}
function compareTopAndBottomSpace(obj, container = document.body, gap = 20) {
  const objRect = obj.getBoundingClientRect();
  const spaceRect = container.getBoundingClientRect();
  const topSpace = objRect.top - spaceRect.top;
  const bottomSpace = spaceRect.bottom - objRect.bottom;
  const topOrBottom = topSpace > bottomSpace ? "top" : "bottom";
  return {
    placement: topOrBottom,
    // the height is the available space.
    height: (topOrBottom === "top" ? topSpace : bottomSpace) - gap
  };
}
function getPopperPosition(popper2, reference2, { gap = 12, offsetY = 5 } = {}) {
  if (!popper2) {
    console.warn("The popper element is not exist. Popper position maybe incorrect");
  }
  const { placement, height } = compareTopAndBottomSpace(reference2, document.body, gap + offsetY);
  const referenceRect = reference2.getBoundingClientRect();
  const positioningPoint = {
    x: referenceRect.x,
    y: referenceRect.y + (placement === "bottom" ? referenceRect.height : 0)
  };
  const boundaryRect = document.body.getBoundingClientRect();
  const popperRect = popper2 == null ? void 0 : popper2.getBoundingClientRect();
  const safeCoordinate = calcSafeCoordinate({
    positioningPoint,
    objRect: popperRect,
    boundaryRect,
    offsetY: placement === "bottom" ? offsetY : -offsetY
  });
  return {
    placement,
    /**
     * The height is the available space height.
     *
     * Note: it's a max height, not the real height,
     * because sometimes the popper's height is smaller than the available space.
     */
    height,
    x: `${safeCoordinate.x}px`,
    y: placement === "bottom" ? `${safeCoordinate.y}px` : (
      // We need to use `calc(-100%)` since the height of popper maybe incorrect
      `calc(${safeCoordinate.y}px - 100%)`
    )
  };
}

// node_modules/@blocksuite/connector/dist/heap.js
var BinaryHeap = class {
  constructor(scoreFunction) {
    this._content = [];
    this._scoreFunction = scoreFunction;
  }
  push(element) {
    this._content.push(element);
    this.sinkDown(this._content.length - 1);
  }
  pop() {
    const { _content } = this;
    const result = _content[0];
    const end2 = _content.pop();
    if (_content.length > 0) {
      _content[0] = end2;
      this.bubbleUp(0);
    }
    return result;
  }
  remove(element) {
    const { _content, _scoreFunction } = this;
    const i = _content.indexOf(element);
    const end2 = _content.pop();
    if (i !== _content.length - 1) {
      _content[i] = end2;
      if (_scoreFunction(end2) < _scoreFunction(element)) {
        this.sinkDown(i);
      } else {
        this.bubbleUp(i);
      }
    }
  }
  size() {
    return this._content.length;
  }
  rescoreElement(element) {
    this.sinkDown(this._content.indexOf(element));
  }
  sinkDown(n) {
    const { _content, _scoreFunction } = this;
    const element = this._content[n];
    while (n > 0) {
      const parentN = (n + 1 >> 1) - 1;
      const parent = _content[parentN];
      if (_scoreFunction(element) < _scoreFunction(parent)) {
        _content[parentN] = element;
        _content[n] = parent;
        n = parentN;
      } else {
        break;
      }
    }
  }
  bubbleUp(n) {
    const { _content, _scoreFunction } = this;
    const length2 = _content.length;
    const element = _content[n];
    const elemScore = _scoreFunction(element);
    while (true) {
      const child2N = n + 1 << 1;
      const child1N = child2N - 1;
      let swap = null;
      let child1Score = null;
      if (child1N < length2) {
        const child1 = _content[child1N];
        child1Score = _scoreFunction(child1);
        if (child1Score < elemScore) {
          swap = child1N;
        }
      }
      if (child2N < length2) {
        const child2 = _content[child2N];
        const child2Score = _scoreFunction(child2);
        if (child2Score < (swap === null ? elemScore : child1Score)) {
          swap = child2N;
        }
      }
      if (swap !== null) {
        _content[n] = _content[swap];
        _content[swap] = element;
        n = swap;
      } else {
        break;
      }
    }
  }
};

// node_modules/@blocksuite/connector/dist/a-star.js
function manhattan(start2, end2) {
  return Math.abs(start2.x - end2.x) + Math.abs(start2.y - end2.y);
}
function pathTo(element) {
  let curr = element;
  const path = [];
  while (curr.parent) {
    path.unshift(curr);
    curr = curr.parent;
  }
  path.unshift(curr);
  return path;
}
function aStarRoute(graph, start2, end2, heuristic = manhattan) {
  const openHeap = new BinaryHeap((element) => element.f);
  start2.h = heuristic(start2, end2);
  openHeap.push(start2);
  while (openHeap.size() > 0) {
    const currentNode = openHeap.pop();
    if (currentNode === end2) {
      return pathTo(currentNode);
    }
    currentNode.closed = true;
    const neighbors = graph.neighbors(currentNode);
    for (let i = 0, il = neighbors.length; i < il; ++i) {
      const neighbor = neighbors[i];
      if (neighbor.closed) {
        continue;
      }
      const gScore = currentNode.g + neighbor.cost(currentNode);
      const beenVisited = neighbor.visited;
      if (!beenVisited || gScore < neighbor.g) {
        neighbor.visited = true;
        neighbor.parent = currentNode;
        neighbor.h = neighbor.h || heuristic(neighbor, end2);
        neighbor.g = gScore;
        neighbor.f = neighbor.g + neighbor.h;
        if (!beenVisited) {
          openHeap.push(neighbor);
        } else {
          openHeap.rescoreElement(neighbor);
        }
      }
    }
  }
  return [];
}

// node_modules/@blocksuite/connector/dist/graph.js
function isDirectionChanged(p, fromNode) {
  if (fromNode.parent) {
    if (fromNode.x === fromNode.parent.x && fromNode.x !== p.x || fromNode.y === fromNode.parent.y && fromNode.y !== p.y) {
      return true;
    }
  }
  return false;
}
var Graph = class _Graph {
  constructor(points2) {
    this.nodes = {};
    this.edges = {};
    this.connections = [];
    this.gridX = [];
    this.gridY = [];
    this._init(points2);
  }
  _init(points2) {
    this._addGraphNodesAndInitGrid(points2);
    this._linkGraphNodes();
  }
  _createGraphNode(p) {
    return {
      x: p.x,
      y: p.y,
      parent: null,
      cost: (fromNode) => {
        const basic = Math.abs(p.x - fromNode.x) + Math.abs(p.y - fromNode.y);
        const directionChanged = isDirectionChanged(p, fromNode);
        return basic + (directionChanged ? 10 : 0);
      },
      f: 0,
      h: 0,
      g: 0
    };
  }
  _addGraphNodesAndInitGrid(points2) {
    const xs = /* @__PURE__ */ new Set();
    const ys = /* @__PURE__ */ new Set();
    points2.forEach((p) => {
      const node = this._createGraphNode(p);
      xs.add(p.x);
      ys.add(p.y);
      const key = _Graph.getKey(p);
      this.nodes[key] = node;
      this.edges[key] = /* @__PURE__ */ new Set();
    });
    this.gridX = [...xs.values()].sort((a, b) => a - b);
    this.gridY = [...ys.values()].sort((a, b) => a - b);
  }
  _linkGraphNodes() {
    const { gridX, gridY } = this;
    for (let i = 0; i < gridX.length; i++) {
      for (let j = 0; j < gridY.length; j++) {
        const key = _Graph.getKey({ x: gridX[i], y: gridY[j] });
        if (!this.nodes[key]) {
          continue;
        }
        if (j > 0) {
          const topKey = _Graph.getKey({ x: gridX[i], y: gridY[j - 1] });
          if (this.nodes[topKey]) {
            this.edges[key].add(topKey);
            this.edges[topKey].add(key);
            this.connections.push([this.nodes[key], this.nodes[topKey]]);
          }
        }
        if (i > 0) {
          const leftKey = _Graph.getKey({ x: gridX[i - 1], y: gridY[j] });
          if (this.nodes[leftKey]) {
            this.edges[key].add(leftKey);
            this.edges[leftKey].add(key);
            this.connections.push([this.nodes[key], this.nodes[leftKey]]);
          }
        }
      }
    }
  }
  neighbors(node) {
    const key = _Graph.getKey(node);
    const n = [];
    this.edges[key].forEach((k) => {
      n.push(this.nodes[k]);
    });
    return n;
  }
  getNode(p) {
    const k = _Graph.getKey(p);
    return this.nodes[k];
  }
  static getKey({ x, y }) {
    return `${x}:${y}`;
  }
  static parseKey(key) {
    const [x, y] = key.split(":").map((n) => Number(n));
    return { x, y };
  }
};

// node_modules/@blocksuite/connector/dist/create-graph/create-nodes.js
function createValidNodesAndGrid(findPointInRect) {
  const nodes = [];
  const cache2 = /* @__PURE__ */ new Set();
  const gridX = /* @__PURE__ */ new Set();
  const gridY = /* @__PURE__ */ new Set();
  const addPoint = (x, y, force = false) => {
    if (!force && findPointInRect(x, y)) {
      return;
    }
    const p = { x, y };
    const key = Graph.getKey(p);
    if (cache2.has(key)) {
      return;
    }
    cache2.add(key);
    gridX.add(x);
    gridY.add(y);
    nodes.push(p);
  };
  const hasPoint = (x, y) => {
    const key = Graph.getKey({ x, y });
    return cache2.has(key);
  };
  return {
    nodes,
    getGrid: () => {
      const sortedGridX = [...gridX.values()].sort((a, b) => a - b);
      const sortedGridY = [...gridY.values()].sort((a, b) => a - b);
      return {
        gridX: sortedGridX,
        gridY: sortedGridY
      };
    },
    addPoint,
    hasPoint
  };
}
function addRulersPoints(rulers, addPoint) {
  const { rows, columns } = rulers;
  for (let i = 0; i < rows.length; i++) {
    const isRowEdge = i === 0 || i === rows.length - 2;
    for (let j = 0; j < columns.length; j++) {
      const isColumnEdge = j === 0 || j === columns.length - 2;
      const currentX = columns[j];
      const currentY = rows[i];
      addPoint(currentX, currentY);
      const nextX = isColumnEdge ? void 0 : columns[j + 1];
      const nextY = isRowEdge ? void 0 : rows[i + 1];
      if (nextX) {
        addPoint((currentX + nextX) / 2, currentY);
      }
      if (nextY) {
        addPoint(currentX, (currentY + nextY) / 2);
      }
      if (nextX && nextY) {
        addPoint((currentX + nextX) / 2, (currentY + nextY) / 2);
      }
    }
  }
}
function forceAddPointsAsNodes(points2, gridX, gridY, addPoint, hasPoint, findPointInRect) {
  points2.forEach((p) => {
    const rect = findPointInRect(p.x, p.y);
    if (rect) {
      const direction = rect.relativeDirection(p.x, p.y);
      switch (direction) {
        case "left": {
          let index = gridX.indexOf(p.x);
          while (index > -1) {
            const columnsValue = gridX[index];
            if (hasPoint(columnsValue, p.y)) {
              break;
            }
            addPoint(columnsValue, p.y, true);
            index--;
          }
          break;
        }
        case "right": {
          let index = gridX.indexOf(p.x);
          while (index < gridX.length) {
            const columnsValue = gridX[index];
            if (hasPoint(columnsValue, p.y)) {
              break;
            }
            addPoint(columnsValue, p.y, true);
            index++;
          }
          break;
        }
        case "top": {
          let index = gridY.indexOf(p.y);
          while (index > -1) {
            const rowsValue = gridY[index];
            if (hasPoint(p.x, rowsValue)) {
              break;
            }
            addPoint(p.x, rowsValue, true);
            index--;
          }
          break;
        }
        case "bottom": {
          let index = gridY.indexOf(p.y);
          while (index < gridY.length) {
            const rowsValue = gridY[index];
            if (hasPoint(p.x, rowsValue)) {
              break;
            }
            addPoint(p.x, rowsValue, true);
            index++;
          }
          break;
        }
      }
    }
  });
}
function createNodes(rulers, rectangles, points2) {
  const findPointInRect = (x, y) => rectangles.find((r) => r.contains(x, y));
  const { nodes, addPoint, hasPoint, getGrid } = createValidNodesAndGrid(findPointInRect);
  addRulersPoints(rulers, addPoint);
  const { gridX, gridY } = getGrid();
  forceAddPointsAsNodes(points2, gridX, gridY, addPoint, hasPoint, findPointInRect);
  return nodes;
}

// node_modules/@blocksuite/connector/dist/create-graph/create-rulers.js
function createRulers(rectangles, points2, margin) {
  const columns = /* @__PURE__ */ new Set();
  const rows = /* @__PURE__ */ new Set();
  rectangles.forEach((rect) => {
    columns.add(rect.minX);
    columns.add(rect.maxX);
    rows.add(rect.minY);
    rows.add(rect.maxY);
  });
  points2.forEach((p) => {
    columns.add(p.x);
    rows.add(p.y);
  });
  const sortedColumns = [...columns.values()].sort((a, b) => a - b);
  const sortedRows = [...rows.values()].sort((a, b) => a - b);
  return {
    columns: [
      sortedColumns[0] - margin[0],
      ...sortedColumns,
      sortedColumns[sortedColumns.length - 1] + margin[0]
    ],
    rows: [
      sortedRows[0] - margin[1],
      ...sortedRows,
      sortedRows[sortedRows.length - 1] + margin[1]
    ]
  };
}

// node_modules/@blocksuite/connector/dist/create-graph/manual-generate-graph.js
function shouldManualGenerateGraph(rectangles, points2) {
  if (!rectangles.length) {
    return true;
  }
  if (rectangles.length !== 1 || points2.length !== 2) {
    return false;
  }
  const p0x = points2[0].x;
  const p0y = points2[0].y;
  const p1x = points2[1].x;
  const p1y = points2[1].y;
  const rect = rectangles[0];
  const { x, y, maxX, maxY } = rect;
  const pointsBothOnLeft = p0x <= x && p1x <= rect.x;
  const pointsBothOnRight = p0x >= maxX && p1x >= maxX;
  const pointsBothOnTop = p0y <= y && p1y <= y;
  const pointsBothOnBottom = p0y >= maxY && p1y >= maxY;
  if (pointsBothOnLeft || pointsBothOnRight || pointsBothOnTop || pointsBothOnBottom) {
    return true;
  }
  return false;
}
function manualGenerateGraph(rectangles, points2) {
  const isVertical = rectangles.length === 1 && (points2[0].y <= rectangles[0].y && points2[1].y <= rectangles[0].y || points2[0].y >= rectangles[0].maxY && points2[1].y >= rectangles[0].maxY);
  const edgeCenters = isVertical ? [
    { x: points2[0].x, y: (points2[0].y + points2[1].y) / 2 },
    { x: points2[1].x, y: (points2[0].y + points2[1].y) / 2 }
  ] : [
    { x: (points2[0].x + points2[1].x) / 2, y: points2[0].y },
    { x: (points2[0].x + points2[1].x) / 2, y: points2[1].y }
  ];
  const nodes = [
    ...points2,
    ...edgeCenters,
    {
      x: (points2[0].x + points2[1].x) / 2,
      y: (points2[0].y + points2[1].y) / 2
    }
  ];
  const graph = new Graph(nodes);
  return {
    rectangles,
    points: points2,
    inflatedRectangles: [],
    rulers: { rows: [], columns: [] },
    nodes,
    graph
  };
}

// node_modules/@blocksuite/connector/dist/create-graph/create-graph.js
function createGraph(rectangles, points2, margin = [10, 10]) {
  if (shouldManualGenerateGraph(rectangles, points2)) {
    return manualGenerateGraph(rectangles, points2);
  }
  const inflatedRects = rectangles.map((r) => r.inflate(margin[0], margin[1]));
  const rulers = createRulers(inflatedRects, points2, margin);
  const nodes = createNodes(rulers, inflatedRects, points2);
  const graph = new Graph(nodes);
  return {
    rectangles,
    points: points2,
    inflatedRectangles: inflatedRects,
    rulers,
    nodes,
    graph
  };
}

// node_modules/@blocksuite/connector/dist/rectangle.js
var Rectangle = class _Rectangle {
  constructor(x, y, w, h) {
    this.id = Math.random().toString(16).slice(2);
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  get minX() {
    return this.x;
  }
  get maxX() {
    return this.x + this.w;
  }
  get minY() {
    return this.y;
  }
  get maxY() {
    return this.y + this.h;
  }
  inflate(horizontal, vertical) {
    return new _Rectangle(this.x - horizontal, this.y - vertical, this.w + horizontal * 2, this.h + vertical * 2);
  }
  contains(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }
  relativeDirection(x, y) {
    const directionValues = {
      left: Math.abs(x - this.x),
      right: Math.abs(x - this.x - this.w),
      top: Math.abs(y - this.y),
      bottom: Math.abs(y - this.y - this.h)
    };
    let min3;
    let d = "top";
    Object.entries(directionValues).forEach(([k, v]) => {
      if (min3 === void 0) {
        min3 = v;
        d = k;
      } else {
        if (v < min3) {
          min3 = v;
          d = k;
        }
      }
    });
    return d;
  }
};

// node_modules/@blocksuite/connector/dist/simplify-path.js
function getSqDist(p1, p2) {
  const dx = p1.x - p2.x, dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
  let x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = p2.x;
      y = p2.y;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p.x - x;
  dy = p.y - y;
  return dx * dx + dy * dy;
}
function simplifyRadialDist(points2, sqTolerance) {
  let prevPoint = points2[0];
  const newPoints = [prevPoint];
  let point;
  for (let i = 1, len3 = points2.length; i < len3; i++) {
    point = points2[i];
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  }
  if (prevPoint !== point)
    newPoints.push(point);
  return newPoints;
}
function simplifyDPStep(points2, first, last, sqTolerance, simplified) {
  let maxSqDist = sqTolerance;
  let index = -1;
  for (let i = first + 1; i < last; i++) {
    const sqDist = getSqSegDist(points2[i], points2[first], points2[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 1)
      simplifyDPStep(points2, first, index, sqTolerance, simplified);
    simplified.push(points2[index]);
    if (last - index > 1)
      simplifyDPStep(points2, index, last, sqTolerance, simplified);
  }
}
function simplifyDouglasPeucker(points2, sqTolerance) {
  const last = points2.length - 1;
  const simplified = [points2[0]];
  simplifyDPStep(points2, 0, last, sqTolerance, simplified);
  simplified.push(points2[last]);
  return simplified;
}
function simplifyPath(points2, tolerance = 0, highestQuality) {
  if (points2.length <= 2)
    return points2;
  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
  points2 = highestQuality ? points2 : simplifyRadialDist(points2, sqTolerance);
  points2 = simplifyDouglasPeucker(points2, sqTolerance);
  return points2;
}

// node_modules/@blocksuite/connector/dist/route.js
function route(rectangles, points2) {
  const { graph } = createGraph(rectangles, points2);
  const start2 = graph.getNode(points2[0]);
  const end2 = graph.getNode(points2[1]);
  const routed = aStarRoute(graph, start2, end2);
  const simplifiedRoute = simplifyPath(routed);
  return simplifiedRoute;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/align-panel.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessAlignPanel = class EdgelessAlignPanel2 extends LitElement {
  constructor() {
    super(...arguments);
    this.value = "left";
  }
  _onSelect(value) {
    this.value = value;
    if (this.onSelect) {
      this.onSelect(value);
    }
  }
  render() {
    return html`
      <div class="align-panel-container">
        <edgeless-tool-icon-button
          .tooltip=${"Left"}
          .active=${this.value === "left"}
          @click=${() => {
      this._onSelect("left");
    }}
        >
          ${AlighLeftIcon}
        </edgeless-tool-icon-button>
        <edgeless-tool-icon-button
          .tooltip=${"Center"}
          .active=${this.value === "center"}
          @click=${() => {
      this._onSelect("center");
    }}
        >
          ${AlignCenterIcon}
        </edgeless-tool-icon-button>
        <edgeless-tool-icon-button
          .tooltip=${"Right"}
          .active=${this.value === "right"}
          @click=${() => {
      this._onSelect("right");
    }}
        >
          ${AlignRightIcon}
        </edgeless-tool-icon-button>
      </div>
    `;
  }
};
EdgelessAlignPanel.styles = css`
    :host {
      display: block;
      z-index: 2;
    }
    .align-panel-container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
      fill: none;
      stroke: currentColor;
    }
  `;
__decorate6([
  property()
], EdgelessAlignPanel.prototype, "value", void 0);
__decorate6([
  property()
], EdgelessAlignPanel.prototype, "onSelect", void 0);
EdgelessAlignPanel = __decorate6([
  customElement("edgeless-align-panel")
], EdgelessAlignPanel);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/color-panel.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColorEvent = class extends Event {
  constructor(type, { detail, composed, bubbles }) {
    super(type, { bubbles, composed });
    this.detail = detail;
  }
};
var DEFAULT_COLORS = [
  "--affine-palette-line-yellow",
  "--affine-palette-line-orange",
  "--affine-palette-line-tangerine",
  "--affine-palette-line-red",
  "--affine-palette-line-magenta",
  "--affine-palette-line-purple",
  "--affine-palette-line-green",
  "--affine-palette-line-blue",
  "--affine-palette-line-navy",
  "--affine-palette-line-black",
  "--affine-palette-line-grey",
  "--affine-palette-line-white"
];
var DEFAULT_SELECTED_COLOR = DEFAULT_COLORS[9];
function isTransparent(color) {
  return color.toLowerCase() === "--affine-palette-transparent";
}
function isSameColorWithBackground(color) {
  return [
    "--affine-palette-line-white",
    "--affine-palette-shape-white"
  ].includes(color.toLowerCase());
}
function TransparentColor(hollowCircle = false) {
  const containerStyle = {
    position: "relative",
    width: "16px",
    height: "16px",
    stroke: "none"
  };
  const maskStyle = {
    position: "absolute",
    width: "10px",
    height: "10px",
    left: "3px",
    top: "3.5px",
    borderRadius: "50%",
    background: "var(--affine-popover-background)"
  };
  const mask = hollowCircle ? html`<div style=${styleMap(maskStyle)}></div>` : nothing;
  return html`<div style=${styleMap(containerStyle)}>
    ${TransparentIcon} ${mask}
  </div>`;
}
function BorderedHollowCircle(color) {
  const strokeWidth = isSameColorWithBackground(color) ? 1 : 0;
  const style = {
    fill: `var(${color})`,
    stroke: "var(--affine-border-color)"
  };
  return html`<svg
    width="16"
    height="16"
    viewBox="0 0 16 16"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M12.3125 8C12.3125 10.3817 10.3817 12.3125 8 12.3125C5.61827 12.3125 3.6875 10.3817 3.6875 8C3.6875 5.61827 5.61827 3.6875 8 3.6875C10.3817 3.6875 12.3125 5.61827 12.3125 8ZM8 15.5C12.1421 15.5 15.5 12.1421 15.5 8C15.5 3.85786 12.1421 0.5 8 0.5C3.85786 0.5 0.5 3.85786 0.5 8C0.5 12.1421 3.85786 15.5 8 15.5Z"
      stroke-width="${strokeWidth}"
      style=${styleMap(style)}
    />
  </svg> `;
}
function AdditionIcon(color, hollowCircle) {
  if (isTransparent(color)) {
    return TransparentColor(hollowCircle);
  }
  if (hollowCircle) {
    return BorderedHollowCircle(color);
  }
  return nothing;
}
function ColorUnit(color, { hollowCircle, letter } = {}) {
  const additionIcon = AdditionIcon(color, !!hollowCircle);
  const colorStyle = !hollowCircle ? { background: `var(${color})` } : {};
  const borderStyle = isSameColorWithBackground(color) && !hollowCircle ? {
    border: "1px solid var(--affine-border-color)"
  } : {};
  const style = {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "16px",
    height: "16px",
    borderRadius: "50%",
    boxSizing: "border-box",
    overflow: "hidden",
    ...borderStyle,
    ...colorStyle
  };
  return html`<div
    class="color-unit"
    style=${styleMap(style)}
    aria-label=${color.toLowerCase()}
    data-letter=${letter ? "A" : ""}
  >
    ${additionIcon}
  </div>`;
}
var EdgelessColorPanel = class EdgelessColorPanel2 extends LitElement {
  constructor() {
    super(...arguments);
    this.options = DEFAULT_COLORS;
    this.showLetterMark = false;
    this.hollowCircle = false;
  }
  _onSelect(value) {
    this.dispatchEvent(new ColorEvent("select", {
      detail: value,
      composed: true,
      bubbles: true
    }));
    this.value = value;
  }
  render() {
    return repeat(this.options, (color) => color, (color) => {
      const unit = ColorUnit(color, {
        hollowCircle: this.hollowCircle,
        letter: this.showLetterMark
      });
      return html`
          <div
            class="color-container"
            ?active=${color === this.value}
            @click=${() => this._onSelect(color)}
          >
            ${unit}
          </div>
        `;
    });
  }
};
EdgelessColorPanel.styles = css`
    :host {
      display: flex;
      width: 204px;
      padding: 8px 12px;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 12px;
      box-sizing: border-box;
      background: var(--affine-popover-background);
    }

    .color-container {
      display: flex;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      box-sizing: border-box;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
    }

    .color-container[active] {
      border: 1px solid var(--affine-primary-color);
    }

    .color-unit::before {
      content: attr(data-letter);
      display: block;
      font-size: 12px;
    }
  `;
__decorate7([
  property()
], EdgelessColorPanel.prototype, "value", void 0);
__decorate7([
  property()
], EdgelessColorPanel.prototype, "options", void 0);
__decorate7([
  property()
], EdgelessColorPanel.prototype, "showLetterMark", void 0);
__decorate7([
  property()
], EdgelessColorPanel.prototype, "hollowCircle", void 0);
EdgelessColorPanel = __decorate7([
  customElement("edgeless-color-panel")
], EdgelessColorPanel);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/utils.js
function getCommonRectStyle(rect, active = false, selected = false) {
  return {
    "--affine-border-width": `${active ? 2 : 1}px`,
    left: rect.x + "px",
    top: rect.y + "px",
    width: rect.width + "px",
    height: rect.height + "px",
    backgroundColor: !active && selected ? "var(--affine-hover-color)" : ""
  };
}
function getSelectedRect(selected, viewport2) {
  if (selected.length === 0) {
    return new DOMRect(0, 0, 0, 0);
  }
  const rects = selected.map((selectable) => {
    const { x, y, width, height } = getSelectionBoxBound(viewport2, getXYWH(selectable));
    return {
      x,
      y,
      w: width,
      h: height
    };
  });
  const commonBound = getCommonBound(rects);
  return new DOMRect(commonBound == null ? void 0 : commonBound.x, commonBound == null ? void 0 : commonBound.y, commonBound == null ? void 0 : commonBound.w, commonBound == null ? void 0 : commonBound.h);
}
function getSelectableBounds(selected) {
  const bounds = /* @__PURE__ */ new Map();
  for (const s of selected) {
    let bound;
    if (isTopLevelBlock(s)) {
      bound = Bound.deserialize(getXYWH(s));
    } else {
      bound = new Bound(s.x, s.y, s.w, s.h);
    }
    bounds.set(s.id, bound);
  }
  return bounds;
}
function listenClickAway(element, onClickAway) {
  const callback = (event) => {
    const inside = event.composedPath().includes(element);
    if (!inside) {
      onClickAway();
    }
  };
  document.addEventListener("click", callback);
  return {
    dispose: () => {
      document.removeEventListener("click", callback);
    }
  };
}
var ATTR_SHOW = "data-show";
function createButtonPopper(reference2, popperElement, stateUpdated = () => {
}) {
  const popper2 = createPopper3(reference2, popperElement, {
    placement: "top",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 12]
        }
      }
    ]
  });
  const show = () => {
    popperElement.setAttribute(ATTR_SHOW, "");
    popper2.setOptions((options2) => ({
      ...options2,
      modifiers: [
        ...options2.modifiers ?? [],
        { name: "eventListeners", enabled: false }
      ]
    }));
    popper2.update();
    stateUpdated({ display: "show" });
  };
  const hide2 = () => {
    popperElement.removeAttribute(ATTR_SHOW);
    popper2.setOptions((options2) => ({
      ...options2,
      modifiers: [
        ...options2.modifiers ?? [],
        { name: "eventListeners", enabled: false }
      ]
    }));
    stateUpdated({ display: "hidden" });
  };
  const toggle = () => {
    if (popperElement.hasAttribute(ATTR_SHOW)) {
      hide2();
    } else {
      show();
    }
  };
  const clickAway = listenClickAway(reference2, () => hide2());
  return {
    popper: popper2,
    show,
    hide: hide2,
    toggle,
    dispose: () => {
      popper2.destroy();
      clickAway.dispose();
    }
  };
}
function getTooltipWithShortcut(tip, shortcut) {
  return html`<span>${tip}</span
    ><span style="margin-left: 10px;">(${shortcut})</span>`;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/change-text-button.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMostCommonColor(texts) {
  const colors = countBy(texts, (text) => text.color);
  const max2 = maxBy(Object.entries(colors), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonAlign(texts) {
  const aligns = countBy(texts, (text) => text.textAlign);
  const max2 = maxBy(Object.entries(aligns), ([k, count]) => count);
  return max2 ? max2[0] : "left";
}
var TEXT_COLORS = [
  "--affine-palette-line-yellow",
  "--affine-palette-line-orange",
  "--affine-palette-line-tangerine",
  "--affine-palette-line-red",
  "--affine-palette-line-magenta",
  "--affine-palette-line-purple",
  "--affine-palette-line-navy",
  "--affine-palette-line-blue",
  "--affine-palette-line-green",
  "--affine-palette-line-white",
  "--affine-palette-line-black",
  "--affine-palette-line-grey"
];
var DEFAULT_TEXT_COLOR = TEXT_COLORS[10];
var EdgelessChangeTextButton = class EdgelessChangeTextButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.texts = [];
    this._popperShow = false;
    this._colorSelectorPopper = null;
    this._textAlignPopper = null;
  }
  _setTextColor(color) {
    this.texts.forEach((text) => {
      this.surface.updateElement(text.id, {
        color
      });
    });
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  _setTextAlign(align) {
    this.texts.forEach((text) => {
      this.surface.updateElement(text.id, {
        textAlign: align
      });
    });
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._colorSelectorPopper = createButtonPopper(this._textColorButton, this._textColorMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._colorSelectorPopper);
    this._textAlignPopper = createButtonPopper(this._textAlignButton, this._textAlignMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._textAlignPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const selectedColor = getMostCommonColor(this.texts) ?? TEXT_COLORS[0];
    const selectedAlign = getMostCommonAlign(this.texts);
    return html`
      <edgeless-tool-icon-button
        class="text-color-button"
        .tooltip=${this._popperShow ? "" : "Text Color"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._colorSelectorPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${ColorUnit(selectedColor)}
      </edgeless-tool-icon-button>
      <div class="color-panel-container text-color">
        <edgeless-color-panel
          .value=${selectedColor}
          .options=${TEXT_COLORS}
          @select=${(event) => {
      this._setTextColor(event.detail);
    }}
        ></edgeless-color-panel>
      </div>

      <menu-divider .vertical=${true}></menu-divider>

      <edgeless-tool-icon-button
        class="text-align-button"
        .tooltip=${this._popperShow ? "" : "Alignment"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._textAlignPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${selectedAlign === "left" ? AlighLeftIcon : selectedAlign === "center" ? AlignCenterIcon : AlignRightIcon}
      </edgeless-tool-icon-button>
      <div class="align-panel-container text-align">
        <edgeless-align-panel
          .value=${selectedAlign}
          .onSelect=${(value) => {
      this._setTextAlign(value);
    }}
        ></edgeless-align-panel>
      </div>
    `;
  }
};
EdgelessChangeTextButton.styles = css`
    :host {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      color: var(--affine-text-primary-color);
      stroke: none;
      fill: currentColor;
    }

    .color-panel-container,
    .align-panel-container {
      display: none;
      padding: 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    .color-panel-container[data-show],
    .align-panel-container[data-show] {
      display: block;
    }
  `;
__decorate8([
  property()
], EdgelessChangeTextButton.prototype, "texts", void 0);
__decorate8([
  property()
], EdgelessChangeTextButton.prototype, "page", void 0);
__decorate8([
  property()
], EdgelessChangeTextButton.prototype, "surface", void 0);
__decorate8([
  property()
], EdgelessChangeTextButton.prototype, "selectionState", void 0);
__decorate8([
  property()
], EdgelessChangeTextButton.prototype, "slots", void 0);
__decorate8([
  state()
], EdgelessChangeTextButton.prototype, "_popperShow", void 0);
__decorate8([
  query(".text-color-button")
], EdgelessChangeTextButton.prototype, "_textColorButton", void 0);
__decorate8([
  query(".color-panel-container.text-color")
], EdgelessChangeTextButton.prototype, "_textColorMenu", void 0);
__decorate8([
  query(".text-align-button")
], EdgelessChangeTextButton.prototype, "_textAlignButton", void 0);
__decorate8([
  query(".align-panel-container.text-align")
], EdgelessChangeTextButton.prototype, "_textAlignMenu", void 0);
EdgelessChangeTextButton = __decorate8([
  customElement("edgeless-change-text-button")
], EdgelessChangeTextButton);

// node_modules/@blocksuite/blocks/dist/__internal__/theme/css-variables.js
var COLOR_VARIABLES = [
  "--affine-brand-color",
  "--affine-primary-color",
  "--affine-secondary-color",
  "--affine-tertiary-color",
  "--affine-hover-color",
  "--affine-icon-color",
  "--affine-icon-secondary",
  "--affine-border-color",
  "--affine-divider-color",
  "--affine-placeholder-color",
  "--affine-quote-color",
  "--affine-link-color",
  "--affine-edgeless-grid-color",
  "--affine-success-color",
  "--affine-warning-color",
  "--affine-error-color",
  "--affine-processing-color",
  "--affine-text-emphasis-color",
  "--affine-text-primary-color",
  "--affine-text-secondary-color",
  "--affine-text-disable-color",
  "--affine-black-10",
  "--affine-black-30",
  "--affine-black-50",
  "--affine-black-60",
  "--affine-black-80",
  "--affine-black-90",
  "--affine-black",
  "--affine-white-10",
  "--affine-white-30",
  "--affine-white-50",
  "--affine-white-60",
  "--affine-white-80",
  "--affine-white-90",
  "--affine-white",
  "--affine-background-code-block",
  "--affine-background-tertiary-color",
  "--affine-background-processing-color",
  "--affine-background-error-color",
  "--affine-background-warning-color",
  "--affine-background-success-color",
  "--affine-background-primary-color",
  "--affine-background-secondary-color",
  "--affine-background-modal-color",
  "--affine-background-overlay-panel-color",
  "--affine-tag-blue",
  "--affine-tag-green",
  "--affine-tag-teal",
  "--affine-tag-white",
  "--affine-tag-purple",
  "--affine-tag-red",
  "--affine-tag-pink",
  "--affine-tag-yellow",
  "--affine-tag-orange",
  "--affine-tag-gray",
  "--affine-palette-line-yellow",
  "--affine-palette-line-orange",
  "--affine-palette-line-tangerine",
  "--affine-palette-line-red",
  "--affine-palette-line-magenta",
  "--affine-palette-line-purple",
  "--affine-palette-line-navy",
  "--affine-palette-line-blue",
  "--affine-palette-line-green",
  "--affine-palette-line-white",
  "--affine-palette-line-black",
  "--affine-palette-line-grey",
  "--affine-palette-shape-yellow",
  "--affine-palette-shape-orange",
  "--affine-palette-shape-tangerine",
  "--affine-palette-shape-red",
  "--affine-palette-shape-magenta",
  "--affine-palette-shape-purple",
  "--affine-palette-shape-navy",
  "--affine-palette-shape-blue",
  "--affine-palette-shape-green",
  "--affine-palette-shape-white",
  "--affine-palette-shape-black",
  "--affine-palette-shape-grey",
  "--affine-tooltip"
];
var SIZE_VARIABLES = [
  "--affine-font-h-1",
  "--affine-font-h-2",
  "--affine-font-h-3",
  "--affine-font-h-4",
  "--affine-font-h-5",
  "--affine-font-h-6",
  "--affine-font-base",
  "--affine-font-sm",
  "--affine-font-xs",
  "--affine-line-height",
  "--affine-z-index-modal",
  "--affine-z-index-popover"
];
var FONT_FAMILY_VARIABLES = [
  "--affine-font-family",
  "--affine-font-number-family",
  "--affine-font-code-family"
];
var VARIABLES = [
  "--affine-editor-width",
  "--affine-theme-mode",
  "--affine-editor-mode",
  /* --affine-palette-transparent: special values added for the sake of logical consistency. */
  "--affine-palette-transparent",
  "--affine-popover-shadow",
  "--affine-menu-shadow",
  "--affine-float-button-shadow",
  "--affine-shadow-1",
  "--affine-shadow-2",
  "--affine-shadow-3",
  "--affine-paragraph-space",
  "--affine-popover-radius",
  "--affine-zoom",
  "--affine-scale",
  ...SIZE_VARIABLES,
  ...COLOR_VARIABLES,
  ...FONT_FAMILY_VARIABLES
];
function isCssVariable(name) {
  return VARIABLES.includes(name);
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/surface-text-editor.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SurfaceTextEditor = class SurfaceTextEditor2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._vEditor = null;
    this._element = null;
    this._edgeless = null;
    this._keeping = false;
  }
  get vEditor() {
    return this._vEditor;
  }
  setKeeping(keeping) {
    this._keeping = keeping;
  }
  _syncRect() {
    const edgeless = this._edgeless;
    const element = this._element;
    if (edgeless && element) {
      const rect = this._virgoContainer.getBoundingClientRect();
      const vLines = Array.from(this._virgoContainer.querySelectorAll("v-line"));
      const lineHeight = vLines[0].getBoundingClientRect().height;
      edgeless.surface.updateElement(element.id, {
        xywh: new Bound(element.x, element.y, rect.width / edgeless.surface.viewport.zoom, vLines.length / edgeless.surface.viewport.zoom * lineHeight).serialize()
      });
      edgeless.slots.selectionUpdated.emit({
        selected: [element],
        active: true
      });
    }
  }
  mount(element, edgeless) {
    this._element = element;
    this._edgeless = edgeless;
    this._vEditor = new VEditor(element.text);
    this._vEditor.slots.updated.on(() => {
      this._syncRect();
    });
    this._disposables.add(edgeless.slots.viewportUpdated.on(() => {
      this.requestUpdate();
      requestAnimationFrame(() => {
        this._syncRect();
      });
    }));
    this.requestUpdate();
    requestAnimationFrame(() => {
      var _a3;
      assertExists(this._vEditor);
      (_a3 = this._element) == null ? void 0 : _a3.setDisplay(false);
      this._vEditor.mount(this._virgoContainer);
      this._virgoContainer.addEventListener("blur", () => {
        if (this._keeping)
          return;
        this._unmount();
      }, {
        once: true
      });
    });
  }
  _unmount() {
    var _a3, _b, _c, _d, _e;
    (_a3 = this.vEditor) == null ? void 0 : _a3.unmount();
    (_b = this._element) == null ? void 0 : _b.setDisplay(true);
    if (((_c = this._element) == null ? void 0 : _c.text.length) === 0) {
      (_e = this._edgeless) == null ? void 0 : _e.surface.removeElement((_d = this._element) == null ? void 0 : _d.id);
    }
    this.remove();
    assertExists(this._edgeless);
    this._edgeless.slots.selectionUpdated.emit({
      selected: [],
      active: false
    });
  }
  render() {
    var _a3;
    const viewport2 = (_a3 = this._edgeless) == null ? void 0 : _a3.surface.viewport;
    let virgoStyle = styleMap({});
    if (viewport2 && this._element && this._edgeless) {
      const zoom = viewport2.zoom;
      const rect = getSelectedRect([this._element], this._edgeless.surface.viewport);
      virgoStyle = styleMap({
        position: "absolute",
        left: rect.x + "px",
        top: rect.y + "px",
        fontSize: this._element.fontSize + "px",
        fontFamily: this._element.fontFamily,
        lineHeight: "initial",
        outline: "none",
        transform: `scale(${zoom}, ${zoom})`,
        transformOrigin: "top left",
        color: isCssVariable(this._element.color) ? `var(${this._element.color})` : this._element.color
      });
    }
    return html`<div style=${virgoStyle} class="virgo-container"></div>`;
  }
};
__decorate9([
  query(".virgo-container")
], SurfaceTextEditor.prototype, "_virgoContainer", void 0);
SurfaceTextEditor = __decorate9([
  customElement("surface-text-editor")
], SurfaceTextEditor);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/utils.js
var FRAME_MIN_WIDTH = 200;
var FRAME_MIN_HEIGHT = 20;
var DEFAULT_FRAME_WIDTH = 448;
var DEFAULT_FRAME_HEIGHT = 72;
var DEFAULT_FRAME_OFFSET_X = 30;
var DEFAULT_FRAME_OFFSET_Y = 40;
var ATTACHED_DISTANCE = 20;
function isTopLevelBlock(selectable) {
  return !!selectable && "flavour" in selectable;
}
function isPhasorElement(selectable) {
  return !isTopLevelBlock(selectable);
}
function isPointIn2(block2, pointX, pointY) {
  const [x, y, w, h] = deserializeXYWH(block2.xywh);
  return isPointIn({ x, y, w, h }, pointX, pointY);
}
function pickTopBlock(blocks, modelX, modelY) {
  for (let i = blocks.length - 1; i >= 0; i--) {
    const block2 = blocks[i];
    if (isPointIn2(block2, modelX, modelY)) {
      return block2;
    }
  }
  return null;
}
function pickBlocksByBound(blocks, bound) {
  return blocks.filter((block2) => {
    const [x, y, w, h] = deserializeXYWH(block2.xywh);
    const blockBound = { x, y, w, h };
    return contains3(bound, blockBound) || intersects(bound, blockBound);
  });
}
function getSelectionBoxBound(viewport2, xywh) {
  const [modelX, modelY, modelW, modelH] = deserializeXYWH(xywh);
  const [x, y] = viewport2.toViewCoord(modelX, modelY);
  return new DOMRect(x, y, modelW * viewport2.zoom, modelH * viewport2.zoom);
}
function getXYWH(element) {
  return isTopLevelBlock(element) ? element.xywh : serializeXYWH(element.x, element.y, element.w, element.h);
}
function stopPropagation(event) {
  event.stopPropagation();
}
function getCursorMode(mouseMode) {
  switch (mouseMode.type) {
    case "default":
      return "default";
    case "pan":
      return mouseMode.panning ? "grabbing" : "grab";
    case "brush":
    case "shape":
    case "connector":
      return "crosshair";
    case "text":
      return "text";
    default:
      return "default";
  }
}
function pickBy(surface, page, x, y, filter2) {
  var _a3;
  const [modelX, modelY] = surface.viewport.toModelCoord(x, y);
  const selectedShapes = surface.pickByPoint(modelX, modelY).filter(filter2);
  return selectedShapes.length ? selectedShapes[selectedShapes.length - 1] : pickTopBlock(((_a3 = page.root) == null ? void 0 : _a3.children).filter((child) => child.flavour === "affine:frame") ?? [], modelX, modelY);
}
function pickById(surface, page, id) {
  var _a3;
  const blocks = ((_a3 = page.root) == null ? void 0 : _a3.children.filter((child) => child.flavour === "affine:frame")) ?? [];
  const element = surface.pickById(id) || blocks.find((b) => b.id === id);
  return element;
}
function generateConnectorPath(startRect, endRect, startPoint, endPoint, originControllers, mode = ConnectorMode.Orthogonal, fixed) {
  if (mode !== ConnectorMode.Orthogonal) {
    return [startPoint, endPoint];
  }
  let customizedStart = Infinity;
  let customizedEnd = -1;
  originControllers.forEach((c, index) => {
    if (c.customized) {
      customizedStart = Math.min(customizedStart, index);
      customizedEnd = Math.max(customizedEnd, index);
    }
  });
  let path = [];
  if (fixed && customizedEnd > -1) {
    const part0EndPoint = originControllers[customizedStart];
    const part0 = fixed === "start" ? originControllers.slice(0, customizedStart + 1) : route(startRect ? [startRect] : [], [startPoint, part0EndPoint]);
    const part1 = originControllers.slice(customizedStart, customizedEnd + 1);
    const part2StartPoint = originControllers[customizedEnd];
    const part2 = fixed === "end" ? originControllers.slice(customizedEnd) : route(endRect ? [endRect] : [], [part2StartPoint, endPoint]);
    path = simplifyPath([...part0.slice(0, -1), ...part1, ...part2.slice(1)]);
  } else {
    path = route([startRect, endRect].filter((r) => !!r), [
      startPoint,
      endPoint
    ]);
  }
  if (path.length < 3) {
    path = [startPoint, endPoint];
  }
  return path;
}
function getAttachedPointByDirection({ x, y, w, h }, direction) {
  switch (direction) {
    case "top": {
      return { x: x + w / 2, y };
    }
    case "right": {
      return { x: x + w, y: y + h / 2 };
    }
    case "bottom": {
      return { x: x + w / 2, y: y + h };
    }
    case "left": {
      return { x, y: y + h / 2 };
    }
    default: {
      throw new Error(`Unknown direction: ${direction}`);
    }
  }
}
function getAttachedPoint(x, y, rect) {
  if (!rect || !rect.contains(x, y)) {
    return { point: { x, y }, position: null };
  }
  const direction = rect.relativeDirection(x, y);
  const position = {
    x: (x - rect.x) / rect.w,
    y: (y - rect.y) / rect.h
  };
  const attachedPoint = getAttachedPointByDirection(rect, direction);
  const distance2 = Math.sqrt(Math.pow(x - attachedPoint.x, 2) + Math.pow(y - attachedPoint.y, 2));
  if (distance2 < ATTACHED_DISTANCE) {
    return {
      point: attachedPoint,
      position: {
        x: (attachedPoint.x - rect.x) / rect.w,
        y: (attachedPoint.y - rect.y) / rect.h
      }
    };
  }
  return { point: { x, y }, position };
}
function getAttachedPointByPosition(rect, position) {
  const x = rect.x + rect.w * position.x;
  const y = rect.y + rect.h * position.y;
  const direction = rect.relativeDirection(x, y);
  const attachedPoint = getAttachedPointByDirection(rect, direction);
  const distance2 = Math.sqrt(Math.pow(x - attachedPoint.x, 2) + Math.pow(y - attachedPoint.y, 2));
  if (distance2 < ATTACHED_DISTANCE) {
    return attachedPoint;
  }
  return { x, y };
}
function getConnectorAttachedInfo(element, surface, page) {
  const { startElement, endElement } = element;
  const start2 = (startElement == null ? void 0 : startElement.id) ? pickById(surface, page, startElement.id) : null;
  const startRect = start2 ? new Rectangle(...deserializeXYWH(getXYWH(start2))) : null;
  const startPoint = startRect && startElement ? getAttachedPointByPosition(startRect, startElement.position) : {
    x: element.x + element.controllers[0].x,
    y: element.y + element.controllers[0].y
  };
  const end2 = (endElement == null ? void 0 : endElement.id) ? pickById(surface, page, endElement.id) : null;
  const endRect = end2 ? new Rectangle(...deserializeXYWH(getXYWH(end2))) : null;
  const endPoint = endRect && endElement ? getAttachedPointByPosition(endRect, endElement.position) : {
    x: element.x + element.controllers[element.controllers.length - 1].x,
    y: element.y + element.controllers[element.controllers.length - 1].y
  };
  return {
    start: {
      element: startElement,
      rect: startRect,
      point: startPoint
    },
    end: {
      element: endElement,
      rect: endRect,
      point: endPoint
    }
  };
}
function isConnectorAndBindingsAllSelected(connector, selected) {
  const connectorSelected = selected.find((s) => s.id === connector.id);
  if (!connectorSelected) {
    return false;
  }
  const { startElement, endElement } = connector;
  const startSelected = selected.find((s) => s.id === (startElement == null ? void 0 : startElement.id));
  const endSelected = selected.find((s) => s.id === (endElement == null ? void 0 : endElement.id));
  if (!startElement && !endElement) {
    return true;
  }
  if (!startElement && endSelected) {
    return true;
  }
  if (!endElement && startSelected) {
    return true;
  }
  if (startSelected && endSelected) {
    return true;
  }
  return false;
}
function handleElementChangedEffectForConnector(element, selected, surface, page) {
  if (element.type !== "connector") {
    const bindingElements = surface.getBindingElements(element.id);
    bindingElements.forEach((bindingElement) => {
      if (bindingElement instanceof ConnectorElement) {
        if (isConnectorAndBindingsAllSelected(bindingElement, selected)) {
          return;
        }
        const { startElement, endElement, id, x, y, controllers, mode } = bindingElement;
        const { start: start2, end: end2 } = getConnectorAttachedInfo(bindingElement, surface, page);
        const fixed = (startElement == null ? void 0 : startElement.id) === element.id ? "end" : (endElement == null ? void 0 : endElement.id) === element.id ? "start" : void 0;
        const routes = generateConnectorPath(start2.rect, end2.rect, start2.point, end2.point, controllers.map((c) => ({ ...c, x: c.x + x, y: c.y + y })), mode, fixed);
        surface.updateElement(id, {
          controllers: routes
        });
      }
    });
  }
}
function getBackgroundGrid(viewportX, viewportY, zoom, showGrid) {
  const step = zoom < 0.5 ? 2 : 1 / (Math.floor(zoom) || 1);
  const gap = 20 * step * zoom;
  const translateX = -viewportX * zoom;
  const translateY = -viewportY * zoom;
  return {
    gap,
    translateX,
    translateY,
    grid: showGrid ? "radial-gradient(var(--affine-edgeless-grid-color) 1px, var(--affine-background-primary-color) 1px)" : "unset"
  };
}
function addNote(edgeless, page, event, width = DEFAULT_FRAME_WIDTH) {
  const frameId = edgeless.addFrameWithPoint(new Point(event.point.x, event.point.y), {
    width
  });
  page.addBlock("affine:paragraph", {}, frameId);
  edgeless.slots.mouseModeUpdated.emit({ type: "default" });
  requestAnimationFrame(() => {
    var _a3;
    const blocks = ((_a3 = page.root) == null ? void 0 : _a3.children.filter((child) => child.flavour === "affine:frame")) ?? [];
    const element = blocks.find((b) => b.id === frameId);
    if (element) {
      edgeless.slots.selectionUpdated.emit({
        selected: [element],
        active: true
      });
      edgeless.updateComplete.then(() => {
        handleNativeRangeAtPoint(event.raw.clientX, event.raw.clientY);
      });
    }
  });
}
function mountTextEditor(textElement, edgeless) {
  var _a3;
  const textEditor = new SurfaceTextEditor();
  const pageBlockContainer = edgeless.pageBlockContainer;
  pageBlockContainer.appendChild(textEditor);
  textEditor.mount(textElement, edgeless);
  (_a3 = textEditor.vEditor) == null ? void 0 : _a3.focusEnd();
  edgeless.selection.switchToDefaultMode({
    selected: [textElement],
    active: true
  });
}
function addText(edgeless, event) {
  const selected = edgeless.surface.pickTop(event.x, event.y);
  if (!selected) {
    const [modelX, modelY] = edgeless.surface.viewport.toModelCoord(event.x, event.y);
    const id = edgeless.surface.addElement("text", {
      xywh: new Bound(modelX, modelY, 32, 32).serialize(),
      text: new YText(),
      textAlign: "left",
      fontSize: 24,
      color: DEFAULT_TEXT_COLOR
    });
    edgeless.page.captureSync();
    const textElement = edgeless.surface.pickById(id);
    assertExists(textElement);
    if (textElement instanceof TextElement) {
      mountTextEditor(textElement, edgeless);
    }
  }
}
function xywhArrayToObject(element) {
  const [x, y, w, h] = deserializeXYWH(element.xywh);
  return {
    x,
    y,
    w,
    h
  };
}

// node_modules/html-to-image/es/util.js
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i)) {
    return url;
  }
  if (url.match(/^\/\//)) {
    return window.location.protocol + url;
  }
  if (url.match(/^[a-z]+:/i)) {
    return url;
  }
  const doc = document.implementation.createHTMLDocument();
  const base = doc.createElement("base");
  const a = doc.createElement("a");
  doc.head.appendChild(base);
  doc.body.appendChild(a);
  if (baseUrl) {
    base.href = baseUrl;
  }
  a.href = url;
  return a.href;
}
var uuid = (() => {
  let counter = 0;
  const random2 = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => {
    counter += 1;
    return `u${random2()}${counter}`;
  };
})();
function toArray(arrayLike) {
  const arr = [];
  for (let i = 0, l = arrayLike.length; i < l; i++) {
    arr.push(arrayLike[i]);
  }
  return arr;
}
function px(node, styleProperty) {
  const win = node.ownerDocument.defaultView || window;
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node) {
  const leftBorder = px(node, "border-left-width");
  const rightBorder = px(node, "border-right-width");
  return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
  const topBorder = px(node, "border-top-width");
  const bottomBorder = px(node, "border-bottom-width");
  return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options2 = {}) {
  const width = options2.width || getNodeWidth(targetNode);
  const height = options2.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio;
  let FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch (e) {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  if (val) {
    ratio = parseInt(val, 10);
    if (Number.isNaN(ratio)) {
      ratio = 1;
    }
  }
  return ratio || window.devicePixelRatio || 1;
}
var canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width;
      canvas.width = canvasDimensionLimit;
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height;
      canvas.height = canvasDimensionLimit;
    }
  }
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.decode = () => resolve(img);
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.src = url;
  });
}
async function svgToDataURL(svg3) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg3)).then(encodeURIComponent).then((html3) => `data:image/svg+xml;charset=utf-8,${html3}`);
}
async function nodeToDataURL(node, width, height) {
  const xmlns = "http://www.w3.org/2000/svg";
  const svg3 = document.createElementNS(xmlns, "svg");
  const foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg3.setAttribute("width", `${width}`);
  svg3.setAttribute("height", `${height}`);
  svg3.setAttribute("viewBox", `0 0 ${width} ${height}`);
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("externalResourcesRequired", "true");
  svg3.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svgToDataURL(svg3);
}
var isInstanceOfElement = (node, instance) => {
  if (node instanceof instance)
    return true;
  const nodePrototype = Object.getPrototypeOf(node);
  if (nodePrototype === null)
    return false;
  return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
};

// node_modules/html-to-image/es/clone-pseudos.js
function formatCSSText(style) {
  const content = style.getPropertyValue("content");
  return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style) {
  return toArray(style).map((name) => {
    const value = style.getPropertyValue(name);
    const priority = style.getPropertyPriority(name);
    return `${name}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style) {
  const selector = `.${className}:${pseudo}`;
  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);
  return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
  const style = window.getComputedStyle(nativeNode, pseudo);
  const content = style.getPropertyValue("content");
  if (content === "" || content === "none") {
    return;
  }
  const className = uuid();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch (err) {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
  clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
  clonePseudoElement(nativeNode, clonedNode, ":before");
  clonePseudoElement(nativeNode, clonedNode, ":after");
}

// node_modules/html-to-image/es/mimes.js
var WOFF = "application/font-woff";
var JPEG = "image/jpeg";
var mimes = {
  woff: WOFF,
  woff2: WOFF,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: JPEG,
  jpeg: JPEG,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function getExtension(url) {
  const match = /\.([^./]*?)$/g.exec(url);
  return match ? match[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}

// node_modules/html-to-image/es/dataurl.js
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process3) {
  const res = await fetch(url, init);
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`);
  }
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onloadend = () => {
      try {
        resolve(process3({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    };
    reader.readAsDataURL(blob);
  });
}
var cache = {};
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  if (includeQueryParams) {
    key = url;
  }
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, "");
  }
  return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options2) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options2.includeQueryParams);
  if (cache[cacheKey] != null) {
    return cache[cacheKey];
  }
  if (options2.cacheBust) {
    resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
  }
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options2.fetchRequestInit, ({ res, result }) => {
      if (!contentType) {
        contentType = res.headers.get("Content-Type") || "";
      }
      return getContentFromDataUrl(result);
    });
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options2.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    if (error) {
      msg = typeof error === "string" ? error : error.message;
    }
    if (msg) {
      console.warn(msg);
    }
  }
  cache[cacheKey] = dataURL;
  return dataURL;
}

// node_modules/html-to-image/es/clone-node.js
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  if (dataURL === "data:,") {
    return canvas.cloneNode(false);
  }
  return createImage(dataURL);
}
async function cloneVideoElement(video, options2) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster;
  const contentType = getMimeType(poster);
  const dataURL = await resourceToDataURL(poster, contentType, options2);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe) {
  var _a3;
  try {
    if ((_a3 = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a3 === void 0 ? void 0 : _a3.body) {
      return await cloneNode(iframe.contentDocument.body, {}, true);
    }
  } catch (_b) {
  }
  return iframe.cloneNode(false);
}
async function cloneSingleNode(node, options2) {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node);
  }
  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options2);
  }
  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node);
  }
  return node.cloneNode(false);
}
var isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
async function cloneChildren(nativeNode, clonedNode, options2) {
  var _a3, _b;
  let children = [];
  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray(nativeNode.assignedNodes());
  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a3 = nativeNode.contentDocument) === null || _a3 === void 0 ? void 0 : _a3.body)) {
    children = toArray(nativeNode.contentDocument.body.childNodes);
  } else {
    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
  }
  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
    return clonedNode;
  }
  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options2)).then((clonedChild) => {
    if (clonedChild) {
      clonedNode.appendChild(clonedChild);
    }
  }), Promise.resolve());
  return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode) {
  const targetStyle = clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    toArray(sourceStyle).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name);
      if (name === "font-size" && value.endsWith("px")) {
        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
        value = `${reducedFont}px`;
      }
      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
        value = "block";
      }
      if (name === "d" && clonedNode.getAttribute("d")) {
        value = `path(${clonedNode.getAttribute("d")})`;
      }
      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
    });
  }
}
function cloneInputValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value;
  }
  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute("value", nativeNode.value);
  }
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode;
    const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
    if (selectedOption) {
      selectedOption.setAttribute("selected", "");
    }
  }
}
function decorate(nativeNode, clonedNode) {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode);
    clonePseudoElements(nativeNode, clonedNode);
    cloneInputValue(nativeNode, clonedNode);
    cloneSelectValue(nativeNode, clonedNode);
  }
  return clonedNode;
}
async function ensureSVGSymbols(clone2, options2) {
  const uses = clone2.querySelectorAll ? clone2.querySelectorAll("use") : [];
  if (uses.length === 0) {
    return clone2;
  }
  const processedDefs = {};
  for (let i = 0; i < uses.length; i++) {
    const use2 = uses[i];
    const id = use2.getAttribute("xlink:href");
    if (id) {
      const exist = clone2.querySelector(id);
      const definition = document.querySelector(id);
      if (!exist && definition && !processedDefs[id]) {
        processedDefs[id] = await cloneNode(definition, options2, true);
      }
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml";
    const svg3 = document.createElementNS(ns, "svg");
    svg3.setAttribute("xmlns", ns);
    svg3.style.position = "absolute";
    svg3.style.width = "0";
    svg3.style.height = "0";
    svg3.style.overflow = "hidden";
    svg3.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg3.appendChild(defs);
    for (let i = 0; i < nodes.length; i++) {
      defs.appendChild(nodes[i]);
    }
    clone2.appendChild(svg3);
  }
  return clone2;
}
async function cloneNode(node, options2, isRoot) {
  if (!isRoot && options2.filter && !options2.filter(node)) {
    return null;
  }
  return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options2)).then((clonedNode) => cloneChildren(node, clonedNode, options2)).then((clonedNode) => decorate(node, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options2));
}

// node_modules/html-to-image/es/embed-resources.js
var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url);
    return raw;
  });
  return urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options2, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    const contentType = getMimeType(resourceURL);
    let dataURL;
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL);
      dataURL = makeDataUrl(content, contentType);
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options2);
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch (error) {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
    while (true) {
      const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
      if (!format) {
        return "";
      }
      if (format === preferredFontFormat) {
        return `src: ${src};`;
      }
    }
  });
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options2) {
  if (!shouldEmbed(cssText)) {
    return cssText;
  }
  const filteredCSSText = filterPreferredFontFormat(cssText, options2);
  const urls = parseURLs(filteredCSSText);
  return urls.reduce((deferred, url) => deferred.then((css2) => embed(css2, url, baseUrl, options2)), Promise.resolve(filteredCSSText));
}

// node_modules/html-to-image/es/embed-images.js
async function embedProp(propName, node, options2) {
  var _a3;
  const propValue = (_a3 = node.style) === null || _a3 === void 0 ? void 0 : _a3.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options2);
    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
    return true;
  }
  return false;
}
async function embedBackground(clonedNode, options2) {
  if (!await embedProp("background", clonedNode, options2)) {
    await embedProp("background-image", clonedNode, options2);
  }
  if (!await embedProp("mask", clonedNode, options2)) {
    await embedProp("mask-image", clonedNode, options2);
  }
}
async function embedImageNode(clonedNode, options2) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
    return;
  }
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
  const dataURL = await resourceToDataURL(url, getMimeType(url), options2);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve;
    clonedNode.onerror = reject;
    const image = clonedNode;
    if (image.decode) {
      image.decode = resolve;
    }
    if (image.loading === "lazy") {
      image.loading = "eager";
    }
    if (isImageElement) {
      clonedNode.srcset = "";
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }
  });
}
async function embedChildren(clonedNode, options2) {
  const children = toArray(clonedNode.childNodes);
  const deferreds = children.map((child) => embedImages(child, options2));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options2) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options2);
    await embedImageNode(clonedNode, options2);
    await embedChildren(clonedNode, options2);
  }
}

// node_modules/html-to-image/es/apply-style.js
function applyStyle(node, options2) {
  const { style } = node;
  if (options2.backgroundColor) {
    style.backgroundColor = options2.backgroundColor;
  }
  if (options2.width) {
    style.width = `${options2.width}px`;
  }
  if (options2.height) {
    style.height = `${options2.height}px`;
  }
  const manual = options2.style;
  if (manual != null) {
    Object.keys(manual).forEach((key) => {
      style[key] = manual[key];
    });
  }
  return node;
}

// node_modules/html-to-image/es/embed-webfonts.js
var cssFetchCache = {};
async function fetchCSS(url) {
  let cache2 = cssFetchCache[url];
  if (cache2 != null) {
    return cache2;
  }
  const res = await fetch(url);
  const cssText = await res.text();
  cache2 = { url, cssText };
  cssFetchCache[url] = cache2;
  return cache2;
}
async function embedFonts(data, options2) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
  const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
  const loadFonts = fontLocs.map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    if (!url.startsWith("https://")) {
      url = new URL(url, data.url).href;
    }
    return fetchAsDataURL(url, options2.fetchRequestInit, ({ result }) => {
      cssText = cssText.replace(loc, `url(${result})`);
      return [loc, result];
    });
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null) {
    return [];
  }
  const result = [];
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  while (true) {
    const matches3 = keyframesRegex.exec(cssText);
    if (matches3 === null) {
      break;
    }
    result.push(matches3[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
  const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
  const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  while (true) {
    let matches3 = importRegex.exec(cssText);
    if (matches3 === null) {
      matches3 = unifiedRegex.exec(cssText);
      if (matches3 === null) {
        break;
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex;
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex;
    }
    result.push(matches3[0]);
  }
  return result;
}
async function getCSSRules(styleSheets, options2) {
  const ret = [];
  const deferreds = [];
  styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet) {
      try {
        toArray(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1;
            const url = item.href;
            const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options2)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e) => {
              console.error("Error loading remote css", e.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e) {
        const inline2 = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
        if (sheet.href != null) {
          deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options2)).then((cssText) => parseCSS(cssText).forEach((rule) => {
            inline2.insertRule(rule, sheet.cssRules.length);
          })).catch((err) => {
            console.error("Error loading remote stylesheet", err);
          }));
        }
        console.error("Error inlining remote css file", e);
      }
    }
  });
  return Promise.all(deferreds).then(() => {
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item) => {
            ret.push(item);
          });
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e);
        }
      }
    });
    return ret;
  });
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node, options2) {
  if (node.ownerDocument == null) {
    throw new Error("Provided element is not within a Document");
  }
  const styleSheets = toArray(node.ownerDocument.styleSheets);
  const cssRules = await getCSSRules(styleSheets, options2);
  return getWebFontRules(cssRules);
}
async function getWebFontCSS(node, options2) {
  const rules2 = await parseWebFontRules(node, options2);
  const cssTexts = await Promise.all(rules2.map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options2);
  }));
  return cssTexts.join("\n");
}
async function embedWebFonts(clonedNode, options2) {
  const cssText = options2.fontEmbedCSS != null ? options2.fontEmbedCSS : options2.skipFonts ? null : await getWebFontCSS(clonedNode, options2);
  if (cssText) {
    const styleNode = document.createElement("style");
    const sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent);
    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild);
    } else {
      clonedNode.appendChild(styleNode);
    }
  }
}

// node_modules/html-to-image/es/index.js
async function toSvg(node, options2 = {}) {
  const { width, height } = getImageSize(node, options2);
  const clonedNode = await cloneNode(node, options2, true);
  await embedWebFonts(clonedNode, options2);
  await embedImages(clonedNode, options2);
  applyStyle(clonedNode, options2);
  const datauri = await nodeToDataURL(clonedNode, width, height);
  return datauri;
}
async function toCanvas(node, options2 = {}) {
  const { width, height } = getImageSize(node, options2);
  const svg3 = await toSvg(node, options2);
  const img = await createImage(svg3);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const ratio = options2.pixelRatio || getPixelRatio();
  const canvasWidth = options2.canvasWidth || width;
  const canvasHeight = options2.canvasHeight || height;
  canvas.width = canvasWidth * ratio;
  canvas.height = canvasHeight * ratio;
  if (!options2.skipAutoScale) {
    checkCanvasDimensions(canvas);
  }
  canvas.style.width = `${canvasWidth}`;
  canvas.style.height = `${canvasHeight}`;
  if (options2.backgroundColor) {
    context.fillStyle = options2.backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  context.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}
async function toPng(node, options2 = {}) {
  const canvas = await toCanvas(node, options2);
  return canvas.toDataURL();
}

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html3, encode) {
  if (encode) {
    if (escapeTest.test(html3)) {
      return html3.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html3)) {
      return html3.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html3;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html3) {
  return html3.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl2(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl2(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset2, str) => {
    let escaped = false, curr = offset2;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top2 = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top2;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line2, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line2 = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line2.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line2.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line2 && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line2.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line2)) {
                break;
              }
              if (headingBeginRegex.test(line2)) {
                break;
              }
              if (hrRegex.test(line2)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line2 = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = "paragraph";
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start2 + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text) {
  return text.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class _Lexer {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules2 = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules2.block = block.pedantic;
      rules2.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules2.block = block.gfm;
      if (this.options.breaks) {
        rules2.inline = inline.breaks;
      } else {
        rules2.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules2;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next2;
    while (next2 = this.inlineQueue.shift()) {
      this.inlineTokens(next2.src, next2.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code3, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code3, lang);
      if (out != null && out !== code3) {
        escaped = true;
        code3 = out;
      }
    }
    code3 = code3.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code3 : escape(code3, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code3 : escape(code3, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html3) {
    return html3;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>
`;
    }
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start2) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text) {
    return `<em>${text}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text) {
    return `<del>${text}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser = class _Parser {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top2 = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start2, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start2 = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start2);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top2 ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var Hooks = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html3) {
    return html3;
  }
};
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError(silent, async, callback) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    if (callback) {
      callback(e);
      return;
    }
    throw e;
  };
}
function parseMarkdown(lexer2, parser2) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer2(src, opt);
      } catch (e) {
        return throwError(e);
      }
      const done = function(err) {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser2(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err, code3) {
              if (err) {
                return done(err);
              }
              if (code3 != null && code3 !== token.text) {
                token.text = code3;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html3) => opt.hooks ? opt.hooks.postprocess(html3) : html3).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html3 = parser2(tokens, opt);
      if (opt.hooks) {
        html3 = opt.hooks.postprocess(html3);
      }
      return html3;
    } catch (e) {
      return throwError(e);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts = { ...pack };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then((ret2) => {
                return prevHook.call(hooks, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks, arg);
            return prevHook.call(hooks, ret);
          };
        } else {
          hooks[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks;
    }
    if (pack.walkTokens) {
      const walkTokens2 = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens2) {
          values = values.concat(walkTokens2.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values = [];
  for (const token of tokens) {
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values = values.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values = values.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values = values.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values;
};
marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = Parser.parse;
var lexer = Lexer.lex;

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/clipboard-item.js
var ClipboardItem = class {
  constructor(mimeType, data) {
    this.mimeType = mimeType;
    this.data = data;
  }
  hasData() {
    return this.data !== null && this.data !== void 0;
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/utils/pure.js
var CLIPBOARD_MIMETYPE;
(function(CLIPBOARD_MIMETYPE2) {
  CLIPBOARD_MIMETYPE2["HTML"] = "text/html";
  CLIPBOARD_MIMETYPE2["TEXT"] = "text/plain";
  CLIPBOARD_MIMETYPE2["BLOCKSUITE_PAGE"] = "blocksuite/page";
  CLIPBOARD_MIMETYPE2["BLOCKSUITE_SURFACE"] = "blocksuite/surface";
})(CLIPBOARD_MIMETYPE || (CLIPBOARD_MIMETYPE = {}));
function extractCustomDataFromHTMLString(type, html3) {
  const dom = new DOMParser().parseFromString(html3, "text/html");
  const ele = dom.querySelector(`blocksuite[data-type="${type}"]`);
  return ele == null ? void 0 : ele.getAttribute("data-clipboard");
}
function getSurfaceClipboardData(e) {
  const clipboardData = e.clipboardData;
  if (!clipboardData) {
    return;
  }
  const data = clipboardData.getData(CLIPBOARD_MIMETYPE.BLOCKSUITE_SURFACE);
  if (data) {
    return JSON.parse(data);
  }
  const HTMLClipboardData = clipboardData.getData(CLIPBOARD_MIMETYPE.HTML);
  const parsedHtmlData = extractCustomDataFromHTMLString(CLIPBOARD_MIMETYPE.BLOCKSUITE_SURFACE, HTMLClipboardData);
  if (parsedHtmlData) {
    return JSON.parse(parsedHtmlData);
  }
}
function isPureFileInClipboard(clipboardData) {
  const types = clipboardData.types;
  return types.length === 1 && types[0] === "Files" || types.length === 2 && (types.includes("text/plain") || types.includes("text/html")) && types.includes("Files");
}
function getFileFromClipboard(clipboardData) {
  const files = clipboardData.files;
  if (files && files[0] && files[0].type.indexOf("image") > -1) {
    return files[0];
  }
  return;
}
function performNativeCopy(items) {
  let success = false;
  const tempElem = document.createElement("textarea");
  tempElem.value = "temp";
  document.body.appendChild(tempElem);
  tempElem.select();
  tempElem.setSelectionRange(0, tempElem.value.length);
  const listener = (e) => {
    const clipboardData = e.clipboardData;
    if (clipboardData) {
      items.forEach((item) => clipboardData.setData(item.mimeType, item.data));
    }
    e.preventDefault();
    e.stopPropagation();
    tempElem.removeEventListener("copy", listener);
  };
  tempElem.addEventListener("copy", listener);
  try {
    success = document.execCommand("copy");
  } finally {
    tempElem.removeEventListener("copy", listener);
    document.body.removeChild(tempElem);
  }
  return success;
}
function createSurfaceClipboardItems(data) {
  const stringifiedData = JSON.stringify(data);
  const surfaceItem = new ClipboardItem(CLIPBOARD_MIMETYPE.BLOCKSUITE_SURFACE, stringifiedData);
  const htmlFallback = new ClipboardItem(CLIPBOARD_MIMETYPE.HTML, createHTMLStringForCustomData(stringifiedData, CLIPBOARD_MIMETYPE.BLOCKSUITE_SURFACE));
  return [surfaceItem, htmlFallback];
}
function createHTMLStringForCustomData(data, type) {
  return `<blocksuite style="display: none" data-type="${type}" data-clipboard="${data.replace(/"/g, "&quot;")}"></blocksuite>`;
}

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat2(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options2) {
    return options2.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options2) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options2.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat2(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat2("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options2) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options2.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start2 = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start2 ? Number(start2) + index : index + 1) + ".  ";
    }
    return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code3 = node.firstChild.textContent;
    var fenceChar = options2.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code3)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat2(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code3.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options2) {
    return "\n\n" + options2.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options2) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference2;
    switch (options2.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference2 = "[" + id + "]: " + href + title;
    }
    this.references.push(reference2);
    return replacement;
  },
  references: [],
  append: function(options2) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options2) {
    if (!content.trim())
      return "";
    return options2.emDelimiter + content + options2.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options2) {
    if (!content.trim())
      return "";
    return options2.strongDelimiter + content + options2.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches3 = content.match(/`+/gm) || [];
    while (matches3.indexOf(delimiter) !== -1)
      delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options2) {
  this.options = options2;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options2.blankReplacement
  };
  this.keepReplacement = options2.keepReplacement;
  this.defaultRule = {
    replacement: options2.defaultReplacement
  };
  this.array = [];
  for (var key in options2.rules)
    this.array.push(options2.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter2) {
    this._keep.unshift({
      filter: filter2,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter2) {
    this._remove.unshift({
      filter: filter2,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options))
      return rule;
    if (rule = findRule(this._keep, node, this.options))
      return rule;
    if (rule = findRule(this._remove, node, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn2) {
    for (var i = 0; i < this.array.length; i++)
      fn2(this.array[i], i);
  }
};
function findRule(rules2, node, options2) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options2))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options2) {
  var filter2 = rule.filter;
  if (typeof filter2 === "string") {
    if (filter2 === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter2)) {
    if (filter2.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter2 === "function") {
    if (filter2.call(rule, node, options2))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options2) {
  var element = options2.element;
  var isBlock2 = options2.isBlock;
  var isVoid2 = options2.isVoid;
  var isPre = options2.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser2 = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser2().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser2 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser2.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser2.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser2;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (window.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options2) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options2.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node2(node, options2) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options2);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options2) {
  if (node.isBlock || options2.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options2)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options2)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options2) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options2.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options2) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options2);
  var defaults2 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults2, options2);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "")
      return "";
    var output = process2.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++)
        this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter2) {
    this.rules.keep(filter2);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter2) {
    this.rules.remove(filter2);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape2) {
      return accumulator.replace(escape2[0], escape2[1]);
    }, string);
  }
};
function process2(parentNode) {
  var self2 = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node2(node, self2.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self2, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self2 = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self2.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process2.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// node_modules/@blocksuite/blocks/dist/__internal__/content-parser/file-exporter/exporter-style.js
var globalCSS = css`
  :root {
    --affine-editor-width: ${EDITOR_WIDTH}px;

    --affine-theme-mode: light;
    --affine-editor-mode: page;
    /* --affine-palette-transparent: special values added for the sake of logical consistency. */
    --affine-palette-transparent: #00000000;

    --affine-popover-shadow: 0px 1px 10px -6px rgba(24, 39, 75, 0.08),
      0px 3px 16px -6px rgba(24, 39, 75, 0.04);
    --affine-font-family: Avenir Next, Poppins, apple-system, BlinkMacSystemFont,
      Helvetica Neue, Tahoma, PingFang SC, Microsoft Yahei, Arial,
      Hiragino Sans GB, sans-serif, Apple Color Emoji, Segoe UI Emoji,
      Segoe UI Symbol, Noto Color Emoji;
    --affine-font-number-family: Roboto Mono, apple-system, BlinkMacSystemFont,
      Helvetica Neue, Tahoma, PingFang SC, Microsoft Yahei, Arial,
      Hiragino Sans GB, sans-serif, Apple Color Emoji, Segoe UI Emoji,
      Segoe UI Symbol, Noto Color Emoji;
    --affine-font-code-family: Space Mono, Consolas, Menlo, Monaco, Courier,
      monospace, apple-system, BlinkMacSystemFont, Helvetica Neue, Tahoma,
      PingFang SC, Microsoft Yahei, Arial, Hiragino Sans GB, sans-serif,
      Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
    --affine-font-h-1: 28px;
    --affine-font-h-2: 26px;
    --affine-font-h-3: 24px;
    --affine-font-h-4: 22px;
    --affine-font-h-5: 20px;
    --affine-font-h-6: 18px;
    --affine-font-base: 16px;
    --affine-font-sm: 14px;
    --affine-font-xs: 12px;
    --affine-line-height: calc(1em + 8px);
    --affine-z-index-modal: 1000;
    --affine-z-index-popover: 1000;
    --affine-paragraph-space: 8px;
    --affine-popover-radius: 10px;
    --affine-zoom: 1;
    --affine-scale: calc(1 / var(--affine-zoom));

    --affine-brand-color: #5438ff;
    --affine-tertiary-color: #f3f0ff;
    --affine-primary-color: #5438ff;
    --affine-secondary-color: #7d91ff;
    --affine-background-success-color: #fff;
    --affine-background-error-color: hsla(0, 0%, 100%, 0.2);
    --affine-background-processing-color: #fff;
    --affine-background-warning-color: #fff;
    --affine-background-primary-color: #fff;
    --affine-background-overlay-panel-color: #fbfbfc;
    --affine-background-secondary-color: #fbfafc;
    --affine-background-tertiary-color: #e9e9ec;
    --affine-background-code-block: #fafbfd;
    --affine-background-modal-color: rgba(0, 0, 0, 0.6);
    --affine-text-primary-color: #424149;
    --affine-text-secondary-color: #8e8d91;
    --affine-text-disable-color: #a9a9ad;
    --affine-text-emphasis-color: #5438ff;
    --affine-hover-color: rgba(0, 0, 0, 0.04);
    --affine-link-color: #7d91ff;
    --affine-quote-color: #645f82;
    --affine-icon-color: #77757d;
    --affine-icon-secondary: hsla(255, 3%, 47%, 0.6);
    --affine-border-color: #e3e2e4;
    --affine-divider-color: #e3e2e4;
    --affine-placeholder-color: #c0bfc1;
    --affine-edgeless-grid-color: #e6e6e6;
    --affine-success-color: #10cb86;
    --affine-warning-color: #ff631f;
    --affine-error-color: #eb4335;
    --affine-processing-color: #2776ff;
    --affine-black-10: rgba(0, 0, 0, 0.1);
    --affine-black-30: rgba(0, 0, 0, 0.3);
    --affine-black-50: rgba(0, 0, 0, 0.5);
    --affine-black-60: rgba(0, 0, 0, 0.6);
    --affine-black-80: rgba(0, 0, 0, 0.8);
    --affine-black-90: rgba(0, 0, 0, 0.9);
    --affine-black: #000;
    --affine-white-10: hsla(0, 0%, 100%, 0.1);
    --affine-white-30: hsla(0, 0%, 100%, 0.3);
    --affine-white-50: hsla(0, 0%, 100%, 0.5);
    --affine-white-60: hsla(0, 0%, 100%, 0.6);
    --affine-white-80: hsla(0, 0%, 100%, 0.8);
    --affine-white-90: hsla(0, 0%, 100%, 0.9);
    --affine-white: #fff;
    --affine-tag-white: #f5f5f5;
    --affine-tag-gray: #e3e2e0;
    --affine-tag-red: #ffe1e1;
    --affine-tag-orange: #ffeaca;
    --affine-tag-yellow: #fff4d8;
    --affine-tag-green: #dff4e8;
    --affine-tag-teal: #dff4f3;
    --affine-tag-blue: #e1efff;
    --affine-tag-purple: #f3f0ff;
    --affine-tag-pink: #fce8ff;
    --affine-palette-line-yellow: #3874ff;
    --affine-palette-line-orange: #ffaf38;
    --affine-palette-line-tangerine: #ff631f;
    --affine-palette-line-red: #fc3f55;
    --affine-palette-line-magenta: #ff38b3;
    --affine-palette-line-purple: #b638ff;
    --affine-palette-line-navy: #3b25cc;
    --affine-palette-line-blue: #4f90ff;
    --affine-palette-line-green: #10cb86;
    --affine-palette-line-white: #fff;
    --affine-palette-line-black: #000;
    --affine-palette-line-grey: #999;
    --affine-palette-shape-yellow: #fff188;
    --affine-palette-shape-orange: #ffcf88;
    --affine-palette-shape-tangerine: #ffa179;
    --affine-palette-shape-red: #fd8c99;
    --affine-palette-shape-magenta: #ff88d1;
    --affine-palette-shape-purple: #d388ff;
    --affine-palette-shape-navy: #897ce0;
    --affine-palette-shape-blue: #95bcff;
    --affine-palette-shape-green: #70e0b6;
    --affine-palette-shape-white: #fff;
    --affine-palette-shape-black: #000;
    --affine-palette-shape-grey: #c2c2c2;
    --affine-tooltip: #424149;
  }
  body {
    font-family: var(--affine-font-family);
    color: var(--affine-text-primary-color);
  }
`;

// node_modules/@blocksuite/blocks/dist/__internal__/content-parser/file-exporter/file-exporter.js
var UNTITLED_PAGE_NAME = "Untitled";
var FileExporter = {
  /**
   * Create a download for the user's browser.
   *
   * @param filename
   * @param text
   * @param mimeType like `"text/plain"`, `"text/html"`, `"application/javascript"`, etc. See {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types mdn docs List of MIME types}.
   *
   * @remarks
   * Only accepts data in utf-8 encoding (html files, javascript source, text files, etc).
   *
   * @example
   * const todoMDText = `# Todo items
   * [ ] Item 1
   * [ ] Item 2
   * `
   * FileExporter.exportFile("Todo list.md", todoMDText, "text/plain")
   *
   * @example
   * const stateJsonContent = JSON.stringify({ a: 1, b: 2, c: 3 })
   * FileExporter.exportFile("state.json", jsonContent, "application/json")
   */
  exportFile(filename, dataURL) {
    const element = document.createElement("a");
    element.setAttribute("href", dataURL);
    const safeFilename = getSafeFileName(filename);
    element.setAttribute("download", safeFilename);
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  },
  exportTextFile(filename, text, mimeType) {
    FileExporter.exportFile(filename, "data:" + mimeType + ";charset=utf-8," + encodeURIComponent(text));
  },
  exportHtml(pageTitle, htmlContent) {
    const title = (pageTitle == null ? void 0 : pageTitle.trim()) || UNTITLED_PAGE_NAME;
    FileExporter.exportTextFile(title + ".html", wrapHtmlWithHtmlDocumentText(title, htmlContent), "text/html");
  },
  exportHtmlAsMarkdown(pageTitle, htmlContent) {
    const turndownService = new turndown_browser_es_default();
    turndownService.addRule("input", {
      //@ts-ignore
      [Symbol.iterator]() {
        return void 0;
      },
      anchor(name) {
        return "";
      },
      big() {
        return "";
      },
      blink() {
        return "";
      },
      bold() {
        return "";
      },
      charAt(pos) {
        return "";
      },
      charCodeAt(index) {
        return 0;
      },
      codePointAt(pos) {
        return void 0;
      },
      concat(strings) {
        return "";
      },
      endsWith(searchString, endPosition) {
        return false;
      },
      fixed() {
        return "";
      },
      fontcolor(color) {
        return "";
      },
      includes(searchString, position) {
        return false;
      },
      indexOf(searchString, position) {
        return 0;
      },
      italics() {
        return "";
      },
      lastIndexOf(searchString, position) {
        return 0;
      },
      length: 0,
      link(url) {
        return "";
      },
      repeat(count) {
        return "";
      },
      slice(start2, end2) {
        return "";
      },
      small() {
        return "";
      },
      startsWith(searchString, position) {
        return false;
      },
      strike() {
        return "";
      },
      sub() {
        return "";
      },
      substr(from, length2) {
        return "";
      },
      substring(start2, end2) {
        return "";
      },
      sup() {
        return "";
      },
      toLocaleLowerCase(locales) {
        return "";
      },
      toLocaleUpperCase(locales) {
        return "";
      },
      toLowerCase() {
        return "";
      },
      toString() {
        return "";
      },
      toUpperCase() {
        return "";
      },
      trim() {
        return "";
      },
      valueOf() {
        return "";
      },
      fontsize(size) {
        return "";
      },
      localeCompare(that, locales, options2) {
        return 0;
      },
      match(matcher) {
        return void 0;
      },
      normalize(form) {
        return "";
      },
      replace(searchValue, replacer) {
        return "";
      },
      search(regexp) {
        return 0;
      },
      split(separator, limit) {
        return [];
      },
      filter: ["input"],
      //@ts-ignore
      replacement: function(content, node) {
        return node.getAttribute("checked") === null ? "[ ] " : "[x] ";
      }
    });
    turndownService.addRule("codeBlock", {
      filter: ["pre"],
      //@ts-ignore
      replacement: function(content, node) {
        const element = node;
        return "```" + element.getAttribute("code-lang") + "\n" + node.textContent + "```\n";
      }
    });
    turndownService.keep(["del", "u"]);
    const markdown = turndownService.turndown(htmlContent);
    const title = (pageTitle == null ? void 0 : pageTitle.trim()) || UNTITLED_PAGE_NAME;
    FileExporter.exportTextFile(title + ".md", markdown, "text/plain");
  },
  exportPng(pageTitle, dataURL) {
    const title = (pageTitle == null ? void 0 : pageTitle.trim()) || UNTITLED_PAGE_NAME;
    FileExporter.exportFile(title + ".png", dataURL);
  }
};
function wrapHtmlWithHtmlDocumentText(pageTitle, htmlContent) {
  const htmlCss = `<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
<style>
  ${globalCSS}
</style>`;
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>${pageTitle}</title>
  ${htmlCss}
</head>
<body>
<div style="margin:0 auto;padding:1rem;max-width:${EDITOR_WIDTH}px">
${htmlContent}
</div>
</body>
</html>
`;
}
function getSafeFileName(string) {
  const replacement = " ";
  const filenameReservedRegex = /[<>:"/\\|?*\u0000-\u001F]/g;
  const windowsReservedNameRegex = /^(con|prn|aux|nul|com\d|lpt\d)$/i;
  const reControlChars = /[\u0000-\u001F\u0080-\u009F]/g;
  const reTrailingPeriods = /\.+$/;
  const allowedLength = 50;
  function trimRepeated(string2, target) {
    const escapeStringRegexp = target.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    const regex = new RegExp(`(?:${escapeStringRegexp}){2,}`, "g");
    return string2.replace(regex, target);
  }
  string = string.normalize("NFD").replace(filenameReservedRegex, replacement).replace(reControlChars, replacement).replace(reTrailingPeriods, "");
  string = trimRepeated(string, replacement);
  string = windowsReservedNameRegex.test(string) ? string + replacement : string;
  const extIndex = string.lastIndexOf(".");
  const filename = string.slice(0, extIndex).trim();
  const extension = string.slice(extIndex);
  string = filename.slice(0, Math.max(1, allowedLength - extension.length)) + extension;
  return string;
}

// node_modules/shiki/dist/index.esm.js
var import_vscode_oniguruma = __toESM(require_main());
var import_vscode_textmate = __toESM(require_main2());
var languages = [
  {
    id: "abap",
    scopeName: "source.abap",
    path: "abap.tmLanguage.json",
    displayName: "ABAP",
    samplePath: "abap.sample"
  },
  {
    id: "actionscript-3",
    scopeName: "source.actionscript.3",
    path: "actionscript-3.tmLanguage.json",
    displayName: "ActionScript",
    samplePath: "actionscript-3.sample"
  },
  {
    id: "ada",
    scopeName: "source.ada",
    path: "ada.tmLanguage.json",
    displayName: "Ada",
    samplePath: "ada.sample"
  },
  {
    id: "apache",
    scopeName: "source.apacheconf",
    path: "apache.tmLanguage.json",
    displayName: "Apache Conf"
  },
  {
    id: "apex",
    scopeName: "source.apex",
    path: "apex.tmLanguage.json",
    displayName: "Apex",
    samplePath: "apex.sample"
  },
  {
    id: "apl",
    scopeName: "source.apl",
    path: "apl.tmLanguage.json",
    displayName: "APL",
    embeddedLangs: ["html", "xml", "css", "javascript", "json"]
  },
  {
    id: "applescript",
    scopeName: "source.applescript",
    path: "applescript.tmLanguage.json",
    displayName: "AppleScript",
    samplePath: "applescript.sample"
  },
  {
    id: "ara",
    scopeName: "source.ara",
    path: "ara.tmLanguage.json",
    displayName: "Ara",
    samplePath: "ara.sample"
  },
  {
    id: "asm",
    scopeName: "source.asm.x86_64",
    path: "asm.tmLanguage.json",
    displayName: "Assembly",
    samplePath: "asm.sample"
  },
  {
    id: "astro",
    scopeName: "source.astro",
    path: "astro.tmLanguage.json",
    displayName: "Astro",
    samplePath: "astro.sample",
    embeddedLangs: ["json", "javascript", "typescript", "stylus", "sass", "css", "scss", "less", "postcss", "tsx"]
  },
  {
    id: "awk",
    scopeName: "source.awk",
    path: "awk.tmLanguage.json",
    displayName: "AWK",
    samplePath: "awk.sample"
  },
  {
    id: "ballerina",
    scopeName: "source.ballerina",
    path: "ballerina.tmLanguage.json",
    displayName: "Ballerina",
    samplePath: "ballerina.sample"
  },
  {
    id: "bat",
    scopeName: "source.batchfile",
    path: "bat.tmLanguage.json",
    displayName: "Batch",
    samplePath: "bat.sample",
    aliases: ["batch"]
  },
  {
    id: "beancount",
    scopeName: "text.beancount",
    path: "beancount.tmLanguage.json",
    displayName: "Beancount",
    samplePath: "beancount.sample"
  },
  {
    id: "berry",
    scopeName: "source.berry",
    path: "berry.tmLanguage.json",
    displayName: "Berry",
    samplePath: "berry.sample",
    aliases: ["be"]
  },
  {
    id: "bibtex",
    scopeName: "text.bibtex",
    path: "bibtex.tmLanguage.json",
    displayName: "BibTeX"
  },
  {
    id: "bicep",
    scopeName: "source.bicep",
    path: "bicep.tmLanguage.json",
    displayName: "Bicep",
    samplePath: "bicep.sample"
  },
  {
    id: "blade",
    scopeName: "text.html.php.blade",
    path: "blade.tmLanguage.json",
    displayName: "Blade",
    samplePath: "blade.sample",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "c",
    scopeName: "source.c",
    path: "c.tmLanguage.json",
    displayName: "C",
    samplePath: "c.sample"
  },
  {
    id: "cadence",
    scopeName: "source.cadence",
    path: "cadence.tmLanguage.json",
    displayName: "Cadence",
    samplePath: "cadence.sample",
    aliases: ["cdc"]
  },
  {
    id: "clarity",
    scopeName: "source.clar",
    path: "clarity.tmLanguage.json",
    displayName: "Clarity",
    samplePath: "clarity.sample"
  },
  {
    id: "clojure",
    scopeName: "source.clojure",
    path: "clojure.tmLanguage.json",
    displayName: "Clojure",
    samplePath: "clojure.sample",
    aliases: ["clj"]
  },
  {
    id: "cmake",
    scopeName: "source.cmake",
    path: "cmake.tmLanguage.json",
    displayName: "CMake",
    samplePath: "cmake.sample"
  },
  {
    id: "cobol",
    scopeName: "source.cobol",
    path: "cobol.tmLanguage.json",
    displayName: "COBOL",
    samplePath: "cobol.sample",
    embeddedLangs: ["sql", "html", "java"]
  },
  {
    id: "codeql",
    scopeName: "source.ql",
    path: "codeql.tmLanguage.json",
    displayName: "CodeQL",
    samplePath: "codeql.sample",
    aliases: ["ql"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "coffee",
    scopeName: "source.coffee",
    path: "coffee.tmLanguage.json",
    displayName: "CoffeeScript",
    samplePath: "coffee.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "cpp",
    scopeName: "source.cpp",
    path: "cpp.tmLanguage.json",
    displayName: "C++",
    samplePath: "cpp.sample",
    embeddedLangs: ["glsl", "sql"]
  },
  {
    id: "crystal",
    scopeName: "source.crystal",
    path: "crystal.tmLanguage.json",
    displayName: "Crystal",
    samplePath: "crystal.sample",
    embeddedLangs: ["html", "sql", "css", "c", "javascript", "shellscript"]
  },
  {
    id: "csharp",
    scopeName: "source.cs",
    path: "csharp.tmLanguage.json",
    displayName: "C#",
    samplePath: "csharp.sample",
    aliases: ["c#", "cs"]
  },
  {
    id: "css",
    scopeName: "source.css",
    path: "css.tmLanguage.json",
    displayName: "CSS",
    samplePath: "css.sample"
  },
  {
    id: "cue",
    scopeName: "source.cue",
    path: "cue.tmLanguage.json",
    displayName: "CUE",
    samplePath: "cue.sample"
  },
  {
    id: "cypher",
    scopeName: "source.cypher",
    path: "cypher.tmLanguage.json",
    displayName: "Cypher",
    samplePath: "cypher.sample",
    aliases: ["cql"]
  },
  {
    id: "d",
    scopeName: "source.d",
    path: "d.tmLanguage.json",
    displayName: "D",
    samplePath: "d.sample"
  },
  {
    id: "dart",
    scopeName: "source.dart",
    path: "dart.tmLanguage.json",
    displayName: "Dart",
    samplePath: "dart.sample"
  },
  {
    id: "dax",
    scopeName: "source.dax",
    path: "dax.tmLanguage.json",
    displayName: "DAX",
    samplePath: "dax.sample"
  },
  {
    id: "diff",
    scopeName: "source.diff",
    path: "diff.tmLanguage.json",
    displayName: "Diff",
    samplePath: "diff.sample"
  },
  {
    id: "docker",
    scopeName: "source.dockerfile",
    path: "docker.tmLanguage.json",
    displayName: "Docker",
    samplePath: "docker.sample",
    aliases: ["dockerfile"]
  },
  {
    id: "dream-maker",
    scopeName: "source.dm",
    path: "dream-maker.tmLanguage.json",
    displayName: "Dream Maker"
  },
  {
    id: "elixir",
    scopeName: "source.elixir",
    path: "elixir.tmLanguage.json",
    displayName: "Elixir",
    samplePath: "elixir.sample",
    embeddedLangs: ["html"]
  },
  {
    id: "elm",
    scopeName: "source.elm",
    path: "elm.tmLanguage.json",
    displayName: "Elm",
    samplePath: "elm.sample",
    embeddedLangs: ["glsl"]
  },
  {
    id: "erb",
    scopeName: "text.html.erb",
    path: "erb.tmLanguage.json",
    displayName: "ERB",
    samplePath: "erb.sample",
    embeddedLangs: ["html", "ruby"]
  },
  {
    id: "erlang",
    scopeName: "source.erlang",
    path: "erlang.tmLanguage.json",
    displayName: "Erlang",
    samplePath: "erlang.sample",
    aliases: ["erl"]
  },
  {
    id: "fish",
    scopeName: "source.fish",
    path: "fish.tmLanguage.json",
    displayName: "Fish",
    samplePath: "fish.sample"
  },
  {
    id: "fsharp",
    scopeName: "source.fsharp",
    path: "fsharp.tmLanguage.json",
    displayName: "F#",
    samplePath: "fsharp.sample",
    aliases: ["f#", "fs"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "gdresource",
    scopeName: "source.gdresource",
    path: "gdresource.tmLanguage.json",
    displayName: "GDResource",
    samplePath: "gdresource.sample",
    embeddedLangs: ["gdshader", "gdscript"]
  },
  {
    id: "gdscript",
    scopeName: "source.gdscript",
    path: "gdscript.tmLanguage.json",
    displayName: "GDScript",
    samplePath: "gdscript.sample"
  },
  {
    id: "gdshader",
    scopeName: "source.gdshader",
    path: "gdshader.tmLanguage.json",
    displayName: "GDShader",
    samplePath: "gdshader.sample"
  },
  {
    id: "gherkin",
    scopeName: "text.gherkin.feature",
    path: "gherkin.tmLanguage.json",
    displayName: "Gherkin"
  },
  {
    id: "git-commit",
    scopeName: "text.git-commit",
    path: "git-commit.tmLanguage.json",
    displayName: "Git Commit Message",
    embeddedLangs: ["diff"]
  },
  {
    id: "git-rebase",
    scopeName: "text.git-rebase",
    path: "git-rebase.tmLanguage.json",
    displayName: "Git Rebase Message",
    embeddedLangs: ["shellscript"]
  },
  {
    id: "glimmer-js",
    scopeName: "source.gjs",
    path: "glimmer-js.tmLanguage.json",
    displayName: "Glimmer JS",
    aliases: ["gjs"],
    embeddedLangs: ["javascript", "handlebars"]
  },
  {
    id: "glimmer-ts",
    scopeName: "source.gts",
    path: "glimmer-ts.tmLanguage.json",
    displayName: "Glimmer TS",
    aliases: ["gts"],
    embeddedLangs: ["typescript", "handlebars"]
  },
  {
    id: "glsl",
    scopeName: "source.glsl",
    path: "glsl.tmLanguage.json",
    displayName: "GLSL",
    samplePath: "glsl.sample",
    embeddedLangs: ["c"]
  },
  {
    id: "gnuplot",
    scopeName: "source.gnuplot",
    path: "gnuplot.tmLanguage.json",
    displayName: "Gnuplot"
  },
  {
    id: "go",
    scopeName: "source.go",
    path: "go.tmLanguage.json",
    displayName: "Go",
    samplePath: "go.sample"
  },
  {
    id: "graphql",
    scopeName: "source.graphql",
    path: "graphql.tmLanguage.json",
    displayName: "GraphQL",
    embeddedLangs: ["javascript", "typescript", "jsx", "tsx"]
  },
  {
    id: "groovy",
    scopeName: "source.groovy",
    path: "groovy.tmLanguage.json",
    displayName: "Groovy"
  },
  {
    id: "hack",
    scopeName: "source.hack",
    path: "hack.tmLanguage.json",
    displayName: "Hack",
    embeddedLangs: ["html", "sql"]
  },
  {
    id: "haml",
    scopeName: "text.haml",
    path: "haml.tmLanguage.json",
    displayName: "Ruby Haml",
    embeddedLangs: ["ruby", "javascript", "sass", "coffee", "markdown", "css"]
  },
  {
    id: "handlebars",
    scopeName: "text.html.handlebars",
    path: "handlebars.tmLanguage.json",
    displayName: "Handlebars",
    aliases: ["hbs"],
    embeddedLangs: ["html", "css", "javascript", "yaml"]
  },
  {
    id: "haskell",
    scopeName: "source.haskell",
    path: "haskell.tmLanguage.json",
    displayName: "Haskell",
    aliases: ["hs"]
  },
  {
    id: "hcl",
    scopeName: "source.hcl",
    path: "hcl.tmLanguage.json",
    displayName: "HashiCorp HCL",
    samplePath: "hcl.sample"
  },
  {
    id: "hjson",
    scopeName: "source.hjson",
    path: "hjson.tmLanguage.json",
    displayName: "Hjson",
    samplePath: "hjson.sample"
  },
  {
    id: "hlsl",
    scopeName: "source.hlsl",
    path: "hlsl.tmLanguage.json",
    displayName: "HLSL"
  },
  {
    id: "html",
    scopeName: "text.html.basic",
    path: "html.tmLanguage.json",
    displayName: "HTML",
    samplePath: "html.sample",
    embeddedLangs: ["javascript", "css"]
  },
  {
    id: "http",
    scopeName: "source.http",
    path: "http.tmLanguage.json",
    displayName: "HTTP",
    samplePath: "http.sample",
    embeddedLangs: ["shellscript", "json", "xml", "graphql"]
  },
  {
    id: "imba",
    scopeName: "source.imba",
    path: "imba.tmLanguage.json",
    displayName: "Imba",
    samplePath: "imba.sample"
  },
  {
    id: "ini",
    scopeName: "source.ini",
    path: "ini.tmLanguage.json",
    displayName: "INI",
    aliases: ["properties"]
  },
  {
    id: "java",
    scopeName: "source.java",
    path: "java.tmLanguage.json",
    displayName: "Java",
    samplePath: "java.sample"
  },
  {
    id: "javascript",
    scopeName: "source.js",
    path: "javascript.tmLanguage.json",
    displayName: "JavaScript",
    samplePath: "javascript.sample",
    aliases: ["js"]
  },
  {
    id: "jinja-html",
    scopeName: "text.html.jinja",
    path: "jinja-html.tmLanguage.json",
    displayName: "Jinja",
    embeddedLangs: ["html"]
  },
  {
    id: "jison",
    scopeName: "source.jison",
    path: "jison.tmLanguage.json",
    displayName: "Jison",
    samplePath: "jison.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "json",
    scopeName: "source.json",
    path: "json.tmLanguage.json",
    displayName: "JSON"
  },
  {
    id: "json5",
    scopeName: "source.json5",
    path: "json5.tmLanguage.json",
    displayName: "JSON5",
    samplePath: "json5.sample"
  },
  {
    id: "jsonc",
    scopeName: "source.json.comments",
    path: "jsonc.tmLanguage.json",
    displayName: "JSON with Comments"
  },
  {
    id: "jsonl",
    scopeName: "source.json.lines",
    path: "jsonl.tmLanguage.json",
    displayName: "JSON Lines"
  },
  {
    id: "jsonnet",
    scopeName: "source.jsonnet",
    path: "jsonnet.tmLanguage.json",
    displayName: "Jsonnet"
  },
  {
    id: "jssm",
    scopeName: "source.jssm",
    path: "jssm.tmLanguage.json",
    displayName: "JSSM",
    samplePath: "jssm.sample",
    aliases: ["fsl"]
  },
  {
    id: "jsx",
    scopeName: "source.js.jsx",
    path: "jsx.tmLanguage.json",
    displayName: "JSX"
  },
  {
    id: "julia",
    scopeName: "source.julia",
    path: "julia.tmLanguage.json",
    displayName: "Julia",
    embeddedLangs: ["cpp", "python", "javascript", "r", "sql"]
  },
  {
    id: "kotlin",
    scopeName: "source.kotlin",
    path: "kotlin.tmLanguage.json",
    displayName: "Kotlin",
    samplePath: "kotlin.sample"
  },
  {
    id: "kusto",
    scopeName: "source.kusto",
    path: "kusto.tmLanguage.json",
    displayName: "Kusto",
    samplePath: "kusto.sample",
    aliases: ["kql"]
  },
  {
    id: "latex",
    scopeName: "text.tex.latex",
    path: "latex.tmLanguage.json",
    displayName: "LaTeX",
    embeddedLangs: ["tex", "css", "haskell", "html", "xml", "java", "lua", "julia", "ruby", "javascript", "typescript", "python", "yaml", "rust", "scala", "gnuplot"]
  },
  {
    id: "less",
    scopeName: "source.css.less",
    path: "less.tmLanguage.json",
    displayName: "Less",
    embeddedLangs: ["css"]
  },
  {
    id: "liquid",
    scopeName: "text.html.liquid",
    path: "liquid.tmLanguage.json",
    displayName: "Liquid",
    samplePath: "liquid.sample",
    embeddedLangs: ["html", "css", "json", "javascript"]
  },
  {
    id: "lisp",
    scopeName: "source.lisp",
    path: "lisp.tmLanguage.json",
    displayName: "Lisp"
  },
  {
    id: "logo",
    scopeName: "source.logo",
    path: "logo.tmLanguage.json",
    displayName: "Logo"
  },
  {
    id: "lua",
    scopeName: "source.lua",
    path: "lua.tmLanguage.json",
    displayName: "Lua",
    embeddedLangs: ["c"]
  },
  {
    id: "make",
    scopeName: "source.makefile",
    path: "make.tmLanguage.json",
    displayName: "Makefile",
    aliases: ["makefile"]
  },
  {
    id: "markdown",
    scopeName: "text.html.markdown",
    path: "markdown.tmLanguage.json",
    displayName: "Markdown",
    aliases: ["md"],
    embeddedLangs: ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "julia", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir", "latex", "bibtex"]
  },
  {
    id: "marko",
    scopeName: "text.marko",
    path: "marko.tmLanguage.json",
    displayName: "Marko",
    embeddedLangs: ["css", "less", "scss", "javascript"]
  },
  {
    id: "matlab",
    scopeName: "source.matlab",
    path: "matlab.tmLanguage.json",
    displayName: "MATLAB"
  },
  {
    id: "mdx",
    scopeName: "source.mdx",
    path: "mdx.tmLanguage.json",
    displayName: "MDX",
    embeddedLangs: ["tsx", "toml", "yaml", "c", "clojure", "coffee", "cpp", "csharp", "css", "diff", "docker", "elixir", "elm", "erlang", "go", "graphql", "haskell", "html", "ini", "java", "javascript", "json", "julia", "kotlin", "less", "lua", "make", "markdown", "objective-c", "perl", "python", "r", "ruby", "rust", "scala", "scss", "shellscript", "sql", "xml", "swift", "typescript"]
  },
  {
    id: "mermaid",
    scopeName: "source.mermaid",
    path: "mermaid.tmLanguage.json",
    displayName: "Mermaid"
  },
  {
    id: "narrat",
    scopeName: "source.narrat",
    path: "narrat.tmLanguage.json",
    displayName: "Narrat Language",
    samplePath: "narrat.sample",
    aliases: ["nar"]
  },
  {
    id: "nextflow",
    scopeName: "source.nextflow",
    path: "nextflow.tmLanguage.json",
    displayName: "Nextflow",
    samplePath: "nextflow.sample",
    aliases: ["nf"]
  },
  {
    id: "nginx",
    scopeName: "source.nginx",
    path: "nginx.tmLanguage.json",
    displayName: "Nginx",
    embeddedLangs: ["lua"]
  },
  {
    id: "nim",
    scopeName: "source.nim",
    path: "nim.tmLanguage.json",
    displayName: "Nim",
    embeddedLangs: ["c", "html", "xml", "javascript", "css", "glsl", "markdown"]
  },
  {
    id: "nix",
    scopeName: "source.nix",
    path: "nix.tmLanguage.json",
    displayName: "Nix"
  },
  {
    id: "objective-c",
    scopeName: "source.objc",
    path: "objective-c.tmLanguage.json",
    displayName: "Objective-C",
    aliases: ["objc"]
  },
  {
    id: "objective-cpp",
    scopeName: "source.objcpp",
    path: "objective-cpp.tmLanguage.json",
    displayName: "Objective-C++"
  },
  {
    id: "ocaml",
    scopeName: "source.ocaml",
    path: "ocaml.tmLanguage.json",
    displayName: "OCaml"
  },
  {
    id: "pascal",
    scopeName: "source.pascal",
    path: "pascal.tmLanguage.json",
    displayName: "Pascal"
  },
  {
    id: "perl",
    scopeName: "source.perl",
    path: "perl.tmLanguage.json",
    displayName: "Perl",
    embeddedLangs: ["html", "xml", "css", "javascript", "sql"]
  },
  {
    id: "php",
    scopeName: "source.php",
    path: "php.tmLanguage.json",
    displayName: "PHP",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "plsql",
    scopeName: "source.plsql.oracle",
    path: "plsql.tmLanguage.json",
    displayName: "PL/SQL"
  },
  {
    id: "postcss",
    scopeName: "source.css.postcss",
    path: "postcss.tmLanguage.json",
    displayName: "PostCSS"
  },
  {
    id: "powerquery",
    scopeName: "source.powerquery",
    path: "powerquery.tmLanguage.json",
    displayName: "PowerQuery",
    samplePath: "powerquery.sample"
  },
  {
    id: "powershell",
    scopeName: "source.powershell",
    path: "powershell.tmLanguage.json",
    displayName: "PowerShell",
    aliases: ["ps", "ps1"]
  },
  {
    id: "prisma",
    scopeName: "source.prisma",
    path: "prisma.tmLanguage.json",
    displayName: "Prisma",
    samplePath: "prisma.sample"
  },
  {
    id: "prolog",
    scopeName: "source.prolog",
    path: "prolog.tmLanguage.json",
    displayName: "Prolog"
  },
  {
    id: "proto",
    scopeName: "source.proto",
    path: "proto.tmLanguage.json",
    displayName: "Protocol Buffer 3",
    samplePath: "proto.sample"
  },
  {
    id: "pug",
    scopeName: "text.pug",
    path: "pug.tmLanguage.json",
    displayName: "Pug",
    aliases: ["jade"],
    embeddedLangs: ["javascript", "css", "sass", "scss", "stylus", "coffee", "html"]
  },
  {
    id: "puppet",
    scopeName: "source.puppet",
    path: "puppet.tmLanguage.json",
    displayName: "Puppet"
  },
  {
    id: "purescript",
    scopeName: "source.purescript",
    path: "purescript.tmLanguage.json",
    displayName: "PureScript"
  },
  {
    id: "python",
    scopeName: "source.python",
    path: "python.tmLanguage.json",
    displayName: "Python",
    samplePath: "python.sample",
    aliases: ["py"]
  },
  {
    id: "r",
    scopeName: "source.r",
    path: "r.tmLanguage.json",
    displayName: "R"
  },
  {
    id: "raku",
    scopeName: "source.perl.6",
    path: "raku.tmLanguage.json",
    displayName: "Perl 6",
    aliases: ["perl6"]
  },
  {
    id: "razor",
    scopeName: "text.aspnetcorerazor",
    path: "razor.tmLanguage.json",
    displayName: "ASP.NET Razor",
    embeddedLangs: ["html", "csharp"]
  },
  {
    id: "reg",
    scopeName: "source.reg",
    path: "reg.tmLanguage.json",
    displayName: "Windows Registry Script",
    samplePath: "reg.sample"
  },
  {
    id: "rel",
    scopeName: "source.rel",
    path: "rel.tmLanguage.json",
    displayName: "Rel",
    samplePath: "rel.sample"
  },
  {
    id: "riscv",
    scopeName: "source.riscv",
    path: "riscv.tmLanguage.json",
    displayName: "RISC-V"
  },
  {
    id: "rst",
    scopeName: "source.rst",
    path: "rst.tmLanguage.json",
    displayName: "reStructuredText",
    embeddedLangs: ["cpp", "python", "javascript", "shellscript", "yaml", "cmake", "ruby"]
  },
  {
    id: "ruby",
    scopeName: "source.ruby",
    path: "ruby.tmLanguage.json",
    displayName: "Ruby",
    samplePath: "ruby.sample",
    aliases: ["rb"],
    embeddedLangs: ["html", "xml", "sql", "css", "c", "javascript", "shellscript", "lua"]
  },
  {
    id: "rust",
    scopeName: "source.rust",
    path: "rust.tmLanguage.json",
    displayName: "Rust",
    aliases: ["rs"]
  },
  {
    id: "sas",
    scopeName: "source.sas",
    path: "sas.tmLanguage.json",
    displayName: "SAS",
    embeddedLangs: ["sql"]
  },
  {
    id: "sass",
    scopeName: "source.sass",
    path: "sass.tmLanguage.json",
    displayName: "Sass"
  },
  {
    id: "scala",
    scopeName: "source.scala",
    path: "scala.tmLanguage.json",
    displayName: "Scala"
  },
  {
    id: "scheme",
    scopeName: "source.scheme",
    path: "scheme.tmLanguage.json",
    displayName: "Scheme"
  },
  {
    id: "scss",
    scopeName: "source.css.scss",
    path: "scss.tmLanguage.json",
    displayName: "SCSS",
    embeddedLangs: ["css"]
  },
  {
    id: "shaderlab",
    scopeName: "source.shaderlab",
    path: "shaderlab.tmLanguage.json",
    displayName: "ShaderLab",
    aliases: ["shader"],
    embeddedLangs: ["hlsl"]
  },
  {
    id: "shellscript",
    scopeName: "source.shell",
    path: "shellscript.tmLanguage.json",
    displayName: "Shell",
    aliases: ["bash", "console", "sh", "shell", "zsh"]
  },
  {
    id: "smalltalk",
    scopeName: "source.smalltalk",
    path: "smalltalk.tmLanguage.json",
    displayName: "Smalltalk"
  },
  {
    id: "solidity",
    scopeName: "source.solidity",
    path: "solidity.tmLanguage.json",
    displayName: "Solidity"
  },
  {
    id: "sparql",
    scopeName: "source.sparql",
    path: "sparql.tmLanguage.json",
    displayName: "SPARQL",
    samplePath: "sparql.sample",
    embeddedLangs: ["turtle"]
  },
  {
    id: "sql",
    scopeName: "source.sql",
    path: "sql.tmLanguage.json",
    displayName: "SQL"
  },
  {
    id: "ssh-config",
    scopeName: "source.ssh-config",
    path: "ssh-config.tmLanguage.json",
    displayName: "SSH Config"
  },
  {
    id: "stata",
    scopeName: "source.stata",
    path: "stata.tmLanguage.json",
    displayName: "Stata",
    samplePath: "stata.sample",
    embeddedLangs: ["sql"]
  },
  {
    id: "stylus",
    scopeName: "source.stylus",
    path: "stylus.tmLanguage.json",
    displayName: "Stylus",
    aliases: ["styl"]
  },
  {
    id: "svelte",
    scopeName: "source.svelte",
    path: "svelte.tmLanguage.json",
    displayName: "Svelte",
    embeddedLangs: ["javascript", "typescript", "coffee", "stylus", "sass", "css", "scss", "less", "postcss", "pug", "markdown"]
  },
  {
    id: "swift",
    scopeName: "source.swift",
    path: "swift.tmLanguage.json",
    displayName: "Swift"
  },
  {
    id: "system-verilog",
    scopeName: "source.systemverilog",
    path: "system-verilog.tmLanguage.json",
    displayName: "SystemVerilog"
  },
  {
    id: "tasl",
    scopeName: "source.tasl",
    path: "tasl.tmLanguage.json",
    displayName: "Tasl",
    samplePath: "tasl.sample"
  },
  {
    id: "tcl",
    scopeName: "source.tcl",
    path: "tcl.tmLanguage.json",
    displayName: "Tcl"
  },
  {
    id: "tex",
    scopeName: "text.tex",
    path: "tex.tmLanguage.json",
    displayName: "TeX",
    embeddedLangs: ["r"]
  },
  {
    id: "toml",
    scopeName: "source.toml",
    path: "toml.tmLanguage.json",
    displayName: "TOML"
  },
  {
    id: "tsx",
    scopeName: "source.tsx",
    path: "tsx.tmLanguage.json",
    displayName: "TSX",
    samplePath: "tsx.sample"
  },
  {
    id: "turtle",
    scopeName: "source.turtle",
    path: "turtle.tmLanguage.json",
    displayName: "Turtle",
    samplePath: "turtle.sample"
  },
  {
    id: "twig",
    scopeName: "text.html.twig",
    path: "twig.tmLanguage.json",
    displayName: "Twig",
    embeddedLangs: ["css", "javascript", "php", "python", "ruby"]
  },
  {
    id: "typescript",
    scopeName: "source.ts",
    path: "typescript.tmLanguage.json",
    displayName: "TypeScript",
    aliases: ["ts"]
  },
  {
    id: "v",
    scopeName: "source.v",
    path: "v.tmLanguage.json",
    displayName: "V",
    samplePath: "v.sample"
  },
  {
    id: "vb",
    scopeName: "source.asp.vb.net",
    path: "vb.tmLanguage.json",
    displayName: "Visual Basic",
    aliases: ["cmd"]
  },
  {
    id: "verilog",
    scopeName: "source.verilog",
    path: "verilog.tmLanguage.json",
    displayName: "Verilog"
  },
  {
    id: "vhdl",
    scopeName: "source.vhdl",
    path: "vhdl.tmLanguage.json",
    displayName: "VHDL"
  },
  {
    id: "viml",
    scopeName: "source.viml",
    path: "viml.tmLanguage.json",
    displayName: "Vim Script",
    aliases: ["vim", "vimscript"]
  },
  {
    id: "vue-html",
    scopeName: "text.html.vue-html",
    path: "vue-html.tmLanguage.json",
    displayName: "Vue HTML",
    embeddedLangs: ["vue", "javascript"]
  },
  {
    id: "vue",
    scopeName: "source.vue",
    path: "vue.tmLanguage.json",
    displayName: "Vue",
    embeddedLangs: ["html", "markdown", "pug", "stylus", "sass", "css", "scss", "less", "javascript", "typescript", "jsx", "tsx", "json", "jsonc", "json5", "yaml", "toml", "graphql"]
  },
  {
    id: "vyper",
    scopeName: "source.vyper",
    path: "vyper.tmLanguage.json",
    displayName: "Vyper",
    samplePath: "vyper.sample",
    aliases: ["vy"]
  },
  {
    id: "wasm",
    scopeName: "source.wat",
    path: "wasm.tmLanguage.json",
    displayName: "WebAssembly"
  },
  {
    id: "wenyan",
    scopeName: "source.wenyan",
    path: "wenyan.tmLanguage.json",
    displayName: "Wenyan",
    aliases: ["文言"]
  },
  {
    id: "wgsl",
    scopeName: "source.wgsl",
    path: "wgsl.tmLanguage.json",
    displayName: "WGSL",
    samplePath: "wgsl.sample"
  },
  {
    id: "wolfram",
    scopeName: "source.wolfram",
    path: "wolfram.tmLanguage.json",
    displayName: "Wolfram",
    samplePath: "wolfram.sample"
  },
  {
    id: "xml",
    scopeName: "text.xml",
    path: "xml.tmLanguage.json",
    displayName: "XML",
    embeddedLangs: ["java"]
  },
  {
    id: "xsl",
    scopeName: "text.xml.xsl",
    path: "xsl.tmLanguage.json",
    displayName: "XSL",
    embeddedLangs: ["xml"]
  },
  {
    id: "yaml",
    scopeName: "source.yaml",
    path: "yaml.tmLanguage.json",
    displayName: "YAML",
    aliases: ["yml"]
  },
  {
    id: "zenscript",
    scopeName: "source.zenscript",
    path: "zenscript.tmLanguage.json",
    displayName: "ZenScript",
    samplePath: "zenscript.sample"
  }
];
var FontStyle = ((FontStyle2) => {
  FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
  FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
  FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
  return FontStyle2;
})(FontStyle || {});
var StackElementMetadata = class _StackElementMetadata {
  static toBinaryStr(metadata) {
    let r = metadata.toString(2);
    while (r.length < 32) {
      r = "0" + r;
    }
    return r;
  }
  static printMetadata(metadata) {
    let languageId = _StackElementMetadata.getLanguageId(metadata);
    let tokenType = _StackElementMetadata.getTokenType(metadata);
    let fontStyle = _StackElementMetadata.getFontStyle(metadata);
    let foreground = _StackElementMetadata.getForeground(metadata);
    let background = _StackElementMetadata.getBackground(metadata);
    console.log({
      languageId,
      tokenType,
      fontStyle,
      foreground,
      background
    });
  }
  static getLanguageId(metadata) {
    return (metadata & 255) >>> 0;
  }
  static getTokenType(metadata) {
    return (metadata & 768) >>> 8;
  }
  static getFontStyle(metadata) {
    return (metadata & 14336) >>> 11;
  }
  static getForeground(metadata) {
    return (metadata & 8372224) >>> 15;
  }
  static getBackground(metadata) {
    return (metadata & 4286578688) >>> 24;
  }
  static containsBalancedBrackets(metadata) {
    return (metadata & 1024) !== 0;
  }
  static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
    let _languageId = _StackElementMetadata.getLanguageId(metadata);
    let _tokenType = _StackElementMetadata.getTokenType(metadata);
    let _fontStyle = _StackElementMetadata.getFontStyle(metadata);
    let _foreground = _StackElementMetadata.getForeground(metadata);
    let _background = _StackElementMetadata.getBackground(metadata);
    let _containsBalancedBracketsBit = _StackElementMetadata.containsBalancedBrackets(
      metadata
    ) ? 1 : 0;
    if (languageId !== 0) {
      _languageId = languageId;
    }
    if (tokenType !== 0) {
      _tokenType = tokenType === 8 ? 0 : tokenType;
    }
    if (fontStyle !== -1) {
      _fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      _foreground = foreground;
    }
    if (background !== 0) {
      _background = background;
    }
    return (_languageId << 0 | _tokenType << 8 | _fontStyle << 11 | _containsBalancedBracketsBit << 10 | _foreground << 15 | _background << 24) >>> 0;
  }
};
function trimEndSlash(str) {
  if (str.endsWith("/") || str.endsWith("\\"))
    return str.slice(0, -1);
  return str;
}
function trimStartDot(str) {
  if (str.startsWith("./"))
    return str.slice(2);
  return str;
}
function dirpathparts(str) {
  const parts = str.split(/[\/\\]/g);
  return parts.slice(0, parts.length - 1);
}
function join2(...parts) {
  return parts.map(trimEndSlash).map(trimStartDot).join("/");
}
function groupBy2(elements, keyGetter) {
  const map = /* @__PURE__ */ new Map();
  for (const element of elements) {
    const key = keyGetter(element);
    if (map.has(key)) {
      const group = map.get(key);
      group.push(element);
    } else {
      map.set(key, [element]);
    }
  }
  return map;
}
function createScanner(text, ignoreTrivia = false) {
  const len3 = text.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count || !exact) {
      let ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start2 = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start2, pos);
      }
    }
    let end2 = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end2 = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start2, end2);
  }
  function scanString() {
    let result = "", start2 = pos;
    while (true) {
      if (pos >= len3) {
        result += text.substring(start2, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start2, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start2, pos);
        pos++;
        if (pos >= len3) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start2 = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start2, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len3) {
      tokenOffset = len3;
      return token = 17;
    }
    let code3 = text.charCodeAt(pos);
    if (isWhiteSpace(code3)) {
      do {
        pos++;
        value += String.fromCharCode(code3);
        code3 = text.charCodeAt(pos);
      } while (isWhiteSpace(code3));
      return token = 15;
    }
    if (isLineBreak(code3)) {
      pos++;
      value += String.fromCharCode(code3);
      if (code3 === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code3) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        const start2 = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len3) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start2, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len3 - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start2, pos);
          return token = 13;
        }
        value += String.fromCharCode(code3);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code3);
        pos++;
        if (pos === len3 || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len3 && isUnknownContentCharacter(code3)) {
          pos++;
          code3 = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code3);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code3) {
    if (isWhiteSpace(code3) || isLineBreak(code3)) {
      return false;
    }
    switch (code3) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
  CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
  CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
  CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
  CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
  CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
  CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
  CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
  CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
  CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
  CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
  CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
  CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
  CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
  CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
  CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
  CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
  CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
  CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
  CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
  CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
  CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
  CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
  CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
  CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
  CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
  CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
  CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
  CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
  CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
  CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
  CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
  CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
  CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
  CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
  CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
  CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
  CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
  CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
  CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
  CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
  CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
  CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
  CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
  CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
  CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
  CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
  CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
  CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
  CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
  CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
  CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
  CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
  CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
  CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
  CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
  CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
  CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
  CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
  CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
  CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
  CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
  CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
  CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
  CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
  CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
  CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
  CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
  CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
  CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
  CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
  CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
  CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
  CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
  CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
  CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
  CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
  CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
  CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
  CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
})(CharacterCodes || (CharacterCodes = {}));
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse$1(text, errors = [], options2 = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name) => {
      currentProperty = name;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error, offset2, length2) => {
      errors.push({ error, offset: offset2, length: length2 });
    }
  };
  visit(text, visitor, options2);
  return currentParent[0];
}
function visit(text, visitor, options2 = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  const _jsonPath = [];
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toNoArgVisitWithPath(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError2 = toOneArgVisit(visitor.onError);
  const disallowComments = options2 && options2.disallowComments;
  const allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter = [], skipUntil = []) {
    onError2(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
var ScanError;
(function(ScanError2) {
  ScanError2[ScanError2["None"] = 0] = "None";
  ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
  ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
  ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
  ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
  ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
  ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind2) {
  SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
  SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
  SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
  SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
  SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
  SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
  SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
  SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
  SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
  SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
  SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
  SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
  SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
  SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
  SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
  SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
  SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
var parse = parse$1;
var ParseErrorCode;
(function(ParseErrorCode2) {
  ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
  ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
  ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
  ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
  ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
  ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
  ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
  ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
  ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
  ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
  ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));
var isWebWorker = typeof self !== "undefined" && typeof self.WorkerGlobalScope !== "undefined";
var isNode = "process" in globalThis && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node";
var isBrowser = isWebWorker || !isNode;
var CDN_ROOT = "";
var WASM = "";
var WASM_PATH = "dist/";
var _onigurumaPromise = null;
async function getOniguruma(wasmPath) {
  if (!_onigurumaPromise) {
    let loader;
    if (isBrowser) {
      if (typeof WASM === "string") {
        loader = (0, import_vscode_oniguruma.loadWASM)({
          data: await fetch(_resolvePath(join2(...dirpathparts(wasmPath), "onig.wasm")))
        });
      } else {
        loader = (0, import_vscode_oniguruma.loadWASM)({
          data: WASM
        });
      }
    } else {
      const path = require_path();
      const wasmPath2 = path.join(__require.resolve("vscode-oniguruma"), "../onig.wasm");
      const fs = require_fs();
      const wasmBin = fs.readFileSync(wasmPath2).buffer;
      loader = (0, import_vscode_oniguruma.loadWASM)(wasmBin);
    }
    _onigurumaPromise = loader.then(() => {
      return {
        createOnigScanner(patterns) {
          return (0, import_vscode_oniguruma.createOnigScanner)(patterns);
        },
        createOnigString(s) {
          return (0, import_vscode_oniguruma.createOnigString)(s);
        }
      };
    });
  }
  return _onigurumaPromise;
}
function _resolvePath(filepath) {
  if (isBrowser) {
    return `${CDN_ROOT}${filepath}`;
  } else {
    const path = require_path();
    if (path.isAbsolute(filepath)) {
      return filepath;
    } else {
      return path.resolve(__dirname, "..", filepath);
    }
  }
}
async function _fetchAssets(filepath) {
  const path = _resolvePath(filepath);
  if (isBrowser) {
    return await fetch(path).then((r) => r.text());
  } else {
    const fs = require_fs();
    return await fs.promises.readFile(path, "utf-8");
  }
}
async function _fetchJSONAssets(filepath) {
  const errors = [];
  const assetString = await _fetchAssets(filepath);
  let rawAsset;
  try {
    rawAsset = JSON.parse(assetString);
  } catch (e) {
    rawAsset = parse(assetString, errors, {
      allowTrailingComma: true
    });
    if (errors.length) {
      throw errors[0];
    }
  }
  return rawAsset;
}
async function fetchTheme(themePath) {
  let theme = await _fetchJSONAssets(themePath);
  const shikiTheme = toShikiTheme(theme);
  if (shikiTheme.include) {
    const includedTheme = await fetchTheme(join2(...dirpathparts(themePath), shikiTheme.include));
    if (includedTheme.settings) {
      shikiTheme.settings = includedTheme.settings.concat(shikiTheme.settings);
    }
    if (includedTheme.bg && !shikiTheme.bg) {
      shikiTheme.bg = includedTheme.bg;
    }
    if (includedTheme.colors) {
      shikiTheme.colors = { ...includedTheme.colors, ...shikiTheme.colors };
    }
    delete shikiTheme.include;
  }
  return shikiTheme;
}
async function fetchGrammar(filepath) {
  return await _fetchJSONAssets(filepath);
}
function repairTheme(theme) {
  if (!theme.settings)
    theme.settings = [];
  if (theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope) {
    return;
  }
  theme.settings.unshift({
    settings: {
      foreground: theme.fg,
      background: theme.bg
    }
  });
}
function toShikiTheme(rawTheme) {
  const type = rawTheme.type || "dark";
  const shikiTheme = {
    name: rawTheme.name,
    type,
    ...rawTheme,
    ...getThemeDefaultColors(rawTheme)
  };
  if (rawTheme.include) {
    shikiTheme.include = rawTheme.include;
  }
  if (rawTheme.tokenColors) {
    shikiTheme.settings = rawTheme.tokenColors;
    delete shikiTheme.tokenColors;
  }
  repairTheme(shikiTheme);
  return shikiTheme;
}
var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
function getThemeDefaultColors(theme) {
  var _a3, _b, _c, _d;
  let fg, bg;
  let settings = theme.settings ? theme.settings : theme.tokenColors;
  const globalSetting = settings ? settings.find((s) => {
    return !s.name && !s.scope;
  }) : void 0;
  if ((_a3 = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _a3.foreground) {
    fg = globalSetting.settings.foreground;
  }
  if ((_b = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _b.background) {
    bg = globalSetting.settings.background;
  }
  if (!fg && ((_c = theme == null ? void 0 : theme.colors) == null ? void 0 : _c["editor.foreground"])) {
    fg = theme.colors["editor.foreground"];
  }
  if (!bg && ((_d = theme == null ? void 0 : theme.colors) == null ? void 0 : _d["editor.background"])) {
    bg = theme.colors["editor.background"];
  }
  if (!fg) {
    fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
  }
  if (!bg) {
    bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
  }
  return {
    fg,
    bg
  };
}
var Resolver = class {
  constructor(onigLibPromise, onigLibName) {
    this.languagesPath = "languages/";
    this.languageMap = {};
    this.scopeToLangMap = {};
    this._onigLibPromise = onigLibPromise;
    this._onigLibName = onigLibName;
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getOnigLibName() {
    return this._onigLibName;
  }
  getLangRegistration(langIdOrAlias) {
    return this.languageMap[langIdOrAlias];
  }
  async loadGrammar(scopeName) {
    const lang = this.scopeToLangMap[scopeName];
    if (!lang) {
      return null;
    }
    if (lang.grammar) {
      return lang.grammar;
    }
    const g = await fetchGrammar(
      languages.includes(lang) ? `${this.languagesPath}${lang.path}` : lang.path
    );
    lang.grammar = g;
    return g;
  }
  addLanguage(l) {
    this.languageMap[l.id] = l;
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this.languageMap[a] = l;
      });
    }
    this.scopeToLangMap[l.scopeName] = l;
  }
};
function tokenizeWithTheme(theme, colorMap, fileContents, grammar, options2) {
  let lines = fileContents.split(/\r\n|\r|\n/);
  let ruleStack = import_vscode_textmate.INITIAL;
  let actual = [];
  let final = [];
  for (let i = 0, len3 = lines.length; i < len3; i++) {
    let line2 = lines[i];
    if (line2 === "") {
      actual = [];
      final.push([]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options2.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line2, ruleStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    let result = grammar.tokenizeLine2(line2, ruleStack);
    let tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      let startIndex = result.tokens[2 * j];
      let nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line2.length;
      if (startIndex === nextStartIndex) {
        continue;
      }
      let metadata = result.tokens[2 * j + 1];
      let foreground = StackElementMetadata.getForeground(metadata);
      let foregroundColor = colorMap[foreground];
      let fontStyle = StackElementMetadata.getFontStyle(metadata);
      let explanation = [];
      if (options2.includeExplanation) {
        let offset2 = 0;
        while (startIndex + offset2 < nextStartIndex) {
          let tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          let tokenWithScopesText = line2.substring(
            tokenWithScopes.startIndex,
            tokenWithScopes.endIndex
          );
          offset2 += tokenWithScopesText.length;
          explanation.push({
            content: tokenWithScopesText,
            scopes: explainThemeScopes(theme, tokenWithScopes.scopes)
          });
          tokensWithScopesIndex++;
        }
      }
      actual.push({
        content: line2.substring(startIndex, nextStartIndex),
        color: foregroundColor,
        fontStyle,
        explanation
      });
    }
    final.push(actual);
    actual = [];
    ruleStack = result.ruleStack;
  }
  return final;
}
function explainThemeScopes(theme, scopes) {
  let result = [];
  for (let i = 0, len3 = scopes.length; i < len3; i++) {
    let parentScopes = scopes.slice(0, i);
    let scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(theme, scope, parentScopes)
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  let selectorPrefix = selector + ".";
  if (selector === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
    return true;
  }
  return false;
}
function matches(selector, selectorParentScopes, scope, parentScopes) {
  if (!matchesOne(selector, scope)) {
    return false;
  }
  let selectorParentIndex = selectorParentScopes.length - 1;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
      selectorParentIndex--;
    }
    parentIndex--;
  }
  if (selectorParentIndex === -1) {
    return true;
  }
  return false;
}
function explainThemeScope(theme, scope, parentScopes) {
  let result = [], resultLen = 0;
  for (let i = 0, len3 = theme.settings.length; i < len3; i++) {
    let setting = theme.settings[i];
    let selectors;
    if (typeof setting.scope === "string") {
      selectors = setting.scope.split(/,/).map((scope2) => scope2.trim());
    } else if (Array.isArray(setting.scope)) {
      selectors = setting.scope;
    } else {
      continue;
    }
    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      let rawSelector = selectors[j];
      let rawSelectorPieces = rawSelector.split(/ /);
      let selector = rawSelectorPieces[rawSelectorPieces.length - 1];
      let selectorParentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
      if (matches(selector, selectorParentScopes, scope, parentScopes)) {
        result[resultLen++] = setting;
        j = lenJ;
      }
    }
  }
  return result;
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function findSequence(value, position) {
  const nextEscape = value.indexOf("\x1B", position);
  if (nextEscape !== -1) {
    if (value[nextEscape + 1] === "[") {
      const nextClose = value.indexOf("m", nextEscape);
      return {
        sequence: value.substring(nextEscape + 2, nextClose).split(";"),
        startPosition: nextEscape,
        position: nextClose + 1
      };
    }
  }
  return {
    position: value.length
  };
}
function parseColor(sequence) {
  const colorMode = sequence.shift();
  if (colorMode === "2") {
    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));
    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))
      return;
    return {
      type: "rgb",
      rgb
    };
  } else if (colorMode === "5") {
    const index = sequence.shift();
    if (index) {
      return { type: "table", index: Number(index) };
    }
  }
}
function parseSequence(sequence) {
  const commands = [];
  while (sequence.length > 0) {
    const code3 = sequence.shift();
    if (!code3)
      continue;
    const codeInt = Number.parseInt(code3);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setForegroundColor",
          value: color
        });
      }
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setBackgroundColor",
          value: color
        });
      }
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position = 0;
      do {
        const findResult = findSequence(value, position);
        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text.length > 0) {
          tokens.push({
            value: text,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index) {
    return getColorTable()[index];
  }
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return {
    value
  };
}
function tokenizeAnsiWithTheme(theme, fileContents) {
  const lines = fileContents.split(/\r?\n/);
  const colorPalette = createColorPalette(
    Object.fromEntries(
      namedColors.map((name) => [
        name,
        theme.colors[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]
      ])
    )
  );
  const parser2 = createAnsiSequenceParser();
  return lines.map(
    (line2) => parser2.parse(line2).map((token) => {
      let color;
      if (token.decorations.has("reverse")) {
        color = token.background ? colorPalette.value(token.background) : theme.bg;
      } else {
        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
      }
      if (token.decorations.has("dim")) {
        color = dimColor(color);
      }
      let fontStyle = FontStyle.None;
      if (token.decorations.has("bold")) {
        fontStyle |= FontStyle.Bold;
      }
      if (token.decorations.has("italic")) {
        fontStyle |= FontStyle.Italic;
      }
      if (token.decorations.has("underline")) {
        fontStyle |= FontStyle.Underline;
      }
      return {
        content: token.value,
        color,
        fontStyle
      };
    })
  );
}
function dimColor(color) {
  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) {
    if (hexMatch[3]) {
      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
    } else if (hexMatch[2]) {
      return `#${hexMatch[1]}${hexMatch[2]}80`;
    } else {
      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join("")}80`;
    }
  }
  const cssVarMatch = color.match(/var\((--shiki-color-ansi-[\w-]+)\)/);
  if (cssVarMatch) {
    return `var(${cssVarMatch[1]}-dim)`;
  }
  return color;
}
var defaultElements = {
  pre({ className, style, children }) {
    return `<pre class="${className}" style="${style}" tabindex="0">${children}</pre>`;
  },
  code({ children }) {
    return `<code>${children}</code>`;
  },
  line({ className, children }) {
    return `<span class="${className}">${children}</span>`;
  },
  token({ style, children }) {
    return `<span style="${style}">${children}</span>`;
  }
};
function renderToHtml(lines, options2 = {}) {
  const bg = options2.bg || "#fff";
  const optionsByLineNumber = groupBy2(options2.lineOptions ?? [], (option) => option.line);
  const userElements = options2.elements || {};
  function h(type = "", props = {}, children) {
    const element = userElements[type] || defaultElements[type];
    if (element) {
      children = children.filter(Boolean);
      return element({
        ...props,
        children: type === "code" ? children.join("\n") : children.join("")
      });
    }
    return "";
  }
  return h(
    "pre",
    { className: "shiki " + (options2.themeName || ""), style: `background-color: ${bg}` },
    [
      options2.langId ? `<div class="language-id">${options2.langId}</div>` : "",
      h(
        "code",
        {},
        lines.map((line2, index) => {
          const lineNumber = index + 1;
          const lineOptions = optionsByLineNumber.get(lineNumber) ?? [];
          const lineClasses = getLineClasses(lineOptions).join(" ");
          return h(
            "line",
            {
              className: lineClasses,
              lines,
              line: line2,
              index
            },
            line2.map((token, index2) => {
              const cssDeclarations = [`color: ${token.color || options2.fg}`];
              if (token.fontStyle & FontStyle.Italic) {
                cssDeclarations.push("font-style: italic");
              }
              if (token.fontStyle & FontStyle.Bold) {
                cssDeclarations.push("font-weight: bold");
              }
              if (token.fontStyle & FontStyle.Underline) {
                cssDeclarations.push("text-decoration: underline");
              }
              return h(
                "token",
                {
                  style: cssDeclarations.join("; "),
                  tokens: line2,
                  token,
                  index: index2
                },
                [escapeHtml(token.content)]
              );
            })
          );
        })
      )
    ]
  );
}
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHtml(html3) {
  return html3.replace(/[&<>"']/g, (chr) => htmlEscapes[chr]);
}
function getLineClasses(lineOptions) {
  const lineClasses = /* @__PURE__ */ new Set(["line"]);
  for (const lineOption of lineOptions) {
    for (const lineClass of lineOption.classes ?? []) {
      lineClasses.add(lineClass);
    }
  }
  return Array.from(lineClasses);
}
var Registry = class extends import_vscode_textmate.Registry {
  constructor(_resolver) {
    super(_resolver);
    this._resolver = _resolver;
    this.themesPath = "themes/";
    this._resolvedThemes = {};
    this._resolvedGrammars = {};
    this._langGraph = /* @__PURE__ */ new Map();
    this._langMap = languages.reduce((acc, lang) => {
      acc[lang.id] = lang;
      return acc;
    }, {});
  }
  getTheme(theme) {
    if (typeof theme === "string") {
      return this._resolvedThemes[theme];
    } else {
      return theme;
    }
  }
  async loadTheme(theme) {
    if (typeof theme === "string") {
      if (!this._resolvedThemes[theme]) {
        this._resolvedThemes[theme] = await fetchTheme(`${this.themesPath}${theme}.json`);
      }
      return this._resolvedThemes[theme];
    } else {
      theme = toShikiTheme(theme);
      if (theme.name) {
        this._resolvedThemes[theme.name] = theme;
      }
      return theme;
    }
  }
  async loadThemes(themes) {
    return await Promise.all(themes.map((theme) => this.loadTheme(theme)));
  }
  getLoadedThemes() {
    return Object.keys(this._resolvedThemes);
  }
  getGrammar(name) {
    return this._resolvedGrammars[name];
  }
  async loadLanguage(lang) {
    var _a3;
    const embeddedLanguages = (_a3 = lang.embeddedLangs) == null ? void 0 : _a3.reduce(async (acc, l, idx) => {
      if (!this.getLoadedLanguages().includes(l) && this._resolver.getLangRegistration(l)) {
        await this._resolver.loadGrammar(this._resolver.getLangRegistration(l).scopeName);
        acc[this._resolver.getLangRegistration(l).scopeName] = idx + 2;
        return acc;
      }
    }, {});
    const grammarConfig = {
      embeddedLanguages,
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    const g = await this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    this._resolvedGrammars[lang.id] = g;
    if (lang.aliases) {
      lang.aliases.forEach((la) => {
        this._resolvedGrammars[la] = g;
      });
    }
  }
  async loadLanguages(langs) {
    for (const lang of langs) {
      this.resolveEmbeddedLanguages(lang);
    }
    const langsGraphArray = Array.from(this._langGraph.values());
    for (const lang of langsGraphArray) {
      this._resolver.addLanguage(lang);
    }
    for (const lang of langsGraphArray) {
      await this.loadLanguage(lang);
    }
  }
  getLoadedLanguages() {
    return Object.keys(this._resolvedGrammars);
  }
  resolveEmbeddedLanguages(lang) {
    if (!this._langGraph.has(lang.id)) {
      this._langGraph.set(lang.id, lang);
    }
    if (lang.embeddedLangs) {
      for (const embeddedLang of lang.embeddedLangs) {
        this._langGraph.set(embeddedLang, this._langMap[embeddedLang]);
      }
    }
  }
};
function resolveLang(lang) {
  return typeof lang === "string" ? languages.find((l) => {
    var _a3;
    return l.id === lang || ((_a3 = l.aliases) == null ? void 0 : _a3.includes(lang));
  }) : lang;
}
function resolveOptions(options2) {
  var _a3;
  let _languages = languages;
  let _themes = options2.themes || [];
  let _wasmPath = ((_a3 = options2.paths) == null ? void 0 : _a3.wasm) ? options2.paths.wasm.endsWith("/") ? options2.paths.wasm : options2.paths.wasm + "/" : WASM_PATH;
  if (options2.langs) {
    _languages = options2.langs.map(resolveLang);
  }
  if (options2.theme) {
    _themes.unshift(options2.theme);
  }
  if (!_themes.length) {
    _themes = ["nord"];
  }
  return { _languages, _themes, _wasmPath };
}
function generateDefaultColorReplacements() {
  const replacements = {
    "#000001": "var(--shiki-color-text)",
    "#000002": "var(--shiki-color-background)",
    "#000004": "var(--shiki-token-constant)",
    "#000005": "var(--shiki-token-string)",
    "#000006": "var(--shiki-token-comment)",
    "#000007": "var(--shiki-token-keyword)",
    "#000008": "var(--shiki-token-parameter)",
    "#000009": "var(--shiki-token-function)",
    "#000010": "var(--shiki-token-string-expression)",
    "#000011": "var(--shiki-token-punctuation)",
    "#000012": "var(--shiki-token-link)"
  };
  for (let i = 0; i < namedColors.length; i++) {
    const code3 = `#A${i.toString().padStart(5, "0")}`;
    const colorNameKebab = namedColors[i].replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    replacements[code3] = `var(--shiki-color-ansi-${colorNameKebab})`;
  }
  return replacements;
}
async function getHighlighter(options2) {
  var _a3, _b;
  const { _languages, _themes, _wasmPath } = resolveOptions(options2);
  const _resolver = new Resolver(getOniguruma(_wasmPath), "vscode-oniguruma");
  const _registry = new Registry(_resolver);
  if ((_a3 = options2.paths) == null ? void 0 : _a3.themes) {
    _registry.themesPath = options2.paths.themes.endsWith("/") ? options2.paths.themes : options2.paths.themes + "/";
  }
  if ((_b = options2.paths) == null ? void 0 : _b.languages) {
    _resolver.languagesPath = options2.paths.languages.endsWith("/") ? options2.paths.languages : options2.paths.languages + "/";
  }
  const themes = await _registry.loadThemes(_themes);
  const _defaultTheme = themes[0];
  let _currentTheme;
  await _registry.loadLanguages(_languages);
  let COLOR_REPLACEMENTS = generateDefaultColorReplacements();
  function setColorReplacements(map) {
    COLOR_REPLACEMENTS = map;
  }
  function fixCssVariablesTheme(theme, colorMap) {
    theme.bg = COLOR_REPLACEMENTS[theme.bg] || theme.bg;
    theme.fg = COLOR_REPLACEMENTS[theme.fg] || theme.fg;
    Object.entries(theme.colors).forEach(([key, value]) => {
      theme.colors[key] = COLOR_REPLACEMENTS[value] || value;
    });
    colorMap.forEach((val, i) => {
      colorMap[i] = COLOR_REPLACEMENTS[val] || val;
    });
  }
  function getTheme(theme) {
    const _theme = theme ? _registry.getTheme(theme) : _defaultTheme;
    if (!_theme) {
      throw Error(`No theme registration for ${theme}`);
    }
    if (!_currentTheme || _currentTheme.name !== _theme.name) {
      _registry.setTheme(_theme);
      _currentTheme = _theme;
    }
    const _colorMap = _registry.getColorMap();
    if (_theme.type === "css") {
      fixCssVariablesTheme(_theme, _colorMap);
    }
    return { _theme, _colorMap };
  }
  function getGrammar(lang) {
    const _grammar = _registry.getGrammar(lang);
    if (!_grammar) {
      throw Error(`No language registration for ${lang}`);
    }
    return { _grammar };
  }
  function codeToThemedTokens(code3, lang = "text", theme, options22 = { includeExplanation: true }) {
    if (isPlaintext(lang)) {
      const lines = code3.split(/\r\n|\r|\n/);
      return [...lines.map((line2) => [{ content: line2 }])];
    }
    const { _grammar } = getGrammar(lang);
    const { _theme, _colorMap } = getTheme(theme);
    return tokenizeWithTheme(_theme, _colorMap, code3, _grammar, options22);
  }
  function ansiToThemedTokens(ansi, theme) {
    const { _theme } = getTheme(theme);
    return tokenizeAnsiWithTheme(_theme, ansi);
  }
  function codeToHtml(code3, arg1 = "text", arg2) {
    let options22;
    if (typeof arg1 === "object") {
      options22 = arg1;
    } else {
      options22 = {
        lang: arg1,
        theme: arg2
      };
    }
    const tokens = codeToThemedTokens(code3, options22.lang, options22.theme, {
      includeExplanation: false
    });
    const { _theme } = getTheme(options22.theme);
    return renderToHtml(tokens, {
      fg: _theme.fg,
      bg: _theme.bg,
      lineOptions: options22 == null ? void 0 : options22.lineOptions,
      themeName: _theme.name
    });
  }
  function ansiToHtml(ansi, options22) {
    const tokens = ansiToThemedTokens(ansi, options22 == null ? void 0 : options22.theme);
    const { _theme } = getTheme(options22 == null ? void 0 : options22.theme);
    return renderToHtml(tokens, {
      fg: _theme.fg,
      bg: _theme.bg,
      lineOptions: options22 == null ? void 0 : options22.lineOptions,
      themeName: _theme.name
    });
  }
  async function loadTheme(theme) {
    await _registry.loadTheme(theme);
  }
  async function loadLanguage(lang) {
    const _lang = resolveLang(lang);
    _resolver.addLanguage(_lang);
    await _registry.loadLanguage(_lang);
  }
  function getLoadedThemes() {
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    return _registry.getLoadedLanguages();
  }
  function getBackgroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.bg;
  }
  function getForegroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.fg;
  }
  return {
    codeToThemedTokens,
    codeToHtml,
    ansiToThemedTokens,
    ansiToHtml,
    getTheme: (theme) => {
      return getTheme(theme)._theme;
    },
    loadTheme,
    loadLanguage,
    getBackgroundColor,
    getForegroundColor,
    getLoadedThemes,
    getLoadedLanguages,
    setColorReplacements
  };
}
function isPlaintext(lang) {
  return !lang || ["plaintext", "txt", "text"].includes(lang);
}

// node_modules/@blocksuite/blocks/dist/code-block/utils/consts.js
var DARK_THEME = "gh/fisheva/Eva-Theme@master/themes/Eva-Dark";
var LIGHT_THEME = "npm/shiki@0.14.1/themes/github-light";
var FALLBACK_LANG = "Plain Text";
var PLAIN_TEXT_REGISTRATION = {
  id: FALLBACK_LANG,
  scopeName: "source.plaintext",
  /**
   * Do not use this path. It is only used to match the type of `ILanguageRegistration`
   *
   * @deprecated
   */
  path: "PLEASE-DO-NOT-USE-THIS",
  aliases: ["plaintext", "txt", "text"]
};

// node_modules/@blocksuite/blocks/dist/code-block/utils/code-languages.js
var PopularLanguages = [
  // 1-20
  "python",
  "c",
  "java",
  "cpp",
  "csharp",
  "vb",
  "javascript",
  "php",
  "sql",
  "asm",
  "pascal",
  "go",
  // 'scratch',
  "swift",
  "matlab",
  "r",
  "rust",
  "ruby",
  // 'fortran',
  // 'classic-visual-basic',
  // 21-50
  "sas",
  // '(Visual) FoxPro',
  "ada",
  "perl",
  "objective-c",
  "cobol",
  "lisp",
  "dart",
  "lua",
  "julia",
  // 'transact-SQL',
  "d",
  "kotlin",
  "logo",
  "scala",
  "haskell",
  "fsharp",
  "scheme",
  // 'cfml',
  "typescript",
  "groovy",
  "abap",
  "prolog",
  "plsql",
  // 'ml',
  // 'bourne shell',
  // 'forth',
  // 'crystal',
  "bash",
  "apex",
  // ⬆️ 50
  // Other
  "markdown",
  "json",
  "html",
  "css",
  "diff",
  "jsx",
  "tsx",
  "vue"
];
var POPULAR_LANGUAGES_MAP = PopularLanguages.reduce((acc, lang, i) => {
  return {
    [lang]: i,
    ...acc
  };
}, {});
function isPlaintext2(lang) {
  return [
    PLAIN_TEXT_REGISTRATION.id,
    ...PLAIN_TEXT_REGISTRATION.aliases
  ].includes(lang.toLowerCase());
}
var getStandardLanguage = (languageName) => {
  if (!languageName)
    return null;
  if (isPlaintext2(languageName)) {
    return null;
  }
  const language = languages.find((codeLanguage) => {
    var _a3;
    return codeLanguage.id.toLowerCase() === languageName.toLowerCase() || ((_a3 = codeLanguage.aliases) == null ? void 0 : _a3.includes(languageName.toLowerCase()));
  });
  return language ?? null;
};

// node_modules/@blocksuite/blocks/dist/__internal__/content-parser/parse-html.js
var INLINE_TAGS = [
  "DEL",
  "STRONG",
  "B",
  "EM",
  "I",
  "U",
  "S",
  "SPAN",
  "A",
  "INPUT",
  "MARK",
  "CODE",
  "LABEL",
  "BIG",
  "SMALL",
  "ABBR",
  "CITE",
  "BDI",
  "TIME"
];
var HtmlParser = class {
  constructor(contentParser, page, fetchFileHandler, textStyleHandler, tableParserHandler) {
    this._fetchFileHandler = async (fileName) => {
      if (this._customFetchFileHandler) {
        const customBlob = await this._customFetchFileHandler(fileName);
        if (customBlob && customBlob.size > 0) {
          return customBlob;
        }
      }
      let resp;
      try {
        resp = await fetch(fileName, {
          cache: "no-cache",
          mode: "cors",
          headers: {
            Origin: window.location.origin
          }
        });
      } catch (error) {
        console.error(error);
        return null;
      }
      const imgBlob = await resp.blob();
      if (!imgBlob.type.startsWith("image/")) {
        return null;
      }
      return imgBlob;
    };
    this._nodeParser = async (node) => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
      let result;
      result = await ((_a3 = this._contentParser.getParserHtmlText2Block("customNodeParser")) == null ? void 0 : _a3(node));
      if (result && result.length > 0) {
        return result;
      }
      const tagName = node.tagName;
      const isInlineOrLeaf = node instanceof Text || INLINE_TAGS.includes(tagName);
      if (isInlineOrLeaf && ((_b = node.textContent) == null ? void 0 : _b.length)) {
        result = await ((_c = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _c({
          element: node,
          flavour: "affine:paragraph",
          type: "text"
        }));
      } else {
        switch (tagName) {
          case "H1":
          case "H2":
          case "H3":
          case "H4":
          case "H5":
          case "H6":
            result = await ((_d = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _d({
              element: node,
              flavour: "affine:paragraph",
              type: tagName.toLowerCase()
            }));
            break;
          case "BLOCKQUOTE":
            result = await ((_e = this._contentParser.getParserHtmlText2Block("blockQuoteParser")) == null ? void 0 : _e(node));
            break;
          case "P":
            if (node.firstChild instanceof Text && (((_f = node.firstChild.textContent) == null ? void 0 : _f.startsWith("[] ")) || ((_g = node.firstChild.textContent) == null ? void 0 : _g.startsWith("[ ] ")) || ((_h = node.firstChild.textContent) == null ? void 0 : _h.startsWith("[x] ")))) {
              result = await ((_i = this._contentParser.getParserHtmlText2Block("listItemParser")) == null ? void 0 : _i(node));
            } else if (node.firstChild instanceof HTMLImageElement) {
              result = await ((_j = this._contentParser.getParserHtmlText2Block("embedItemParser")) == null ? void 0 : _j(node.firstChild));
            } else if (((_k = node.firstElementChild) == null ? void 0 : _k.tagName) === "A" || ((_m = (_l = node.firstElementChild) == null ? void 0 : _l.getAttribute("href")) == null ? void 0 : _m.endsWith(".csv"))) {
              result = await ((_n = this._contentParser.getParserHtmlText2Block("tableParser")) == null ? void 0 : _n(node.firstChild));
            } else {
              result = await ((_o = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _o({
                element: node,
                flavour: "affine:paragraph",
                type: "text"
              }));
            }
            break;
          case "LI":
            result = await ((_p = this._contentParser.getParserHtmlText2Block("listItemParser")) == null ? void 0 : _p(node));
            break;
          case "HR":
            result = await ((_q = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _q({
              element: node,
              flavour: "affine:divider"
            }));
            break;
          case "PRE":
            result = await ((_r = this._contentParser.getParserHtmlText2Block("codeBlockParser")) == null ? void 0 : _r(node));
            break;
          case "FIGURE":
          case "IMG":
            {
              result = await ((_s = this._contentParser.getParserHtmlText2Block("embedItemParser")) == null ? void 0 : _s(node));
            }
            break;
          case "HEADER":
            result = await ((_t = this._contentParser.getParserHtmlText2Block("headerParser")) == null ? void 0 : _t(node));
            break;
          case "TABLE":
            result = await ((_u = this._contentParser.getParserHtmlText2Block("tableParser")) == null ? void 0 : _u(node));
            break;
          default:
            break;
        }
      }
      if (result && result.length > 0) {
        return result;
      }
      if (node.childNodes.length > 0) {
        const hasNonInlineOrNonLeaf = Array.from(node.childNodes).some((child) => {
          if (child.nodeType === Node.TEXT_NODE) {
            return false;
          }
          if (child.nodeType === Node.ELEMENT_NODE) {
            const childElement = child;
            const isInlineElement = INLINE_TAGS.includes(childElement.tagName) || childElement.tagName.includes("-") && checkWebComponentIfInline(childElement);
            return !isInlineElement;
          }
          return true;
        });
        if (!hasNonInlineOrNonLeaf) {
          const allInlineResult = await this._commonHTML2Block(node, "affine:paragraph", "text");
          if (allInlineResult) {
            return [allInlineResult];
          }
        }
      }
      const openBlockPromises = Array.from(node.children).map(async (childElement) => {
        var _a4;
        const clipBlockInfos = await ((_a4 = this._contentParser.getParserHtmlText2Block("nodeParser")) == null ? void 0 : _a4(childElement)) || [];
        return clipBlockInfos;
      });
      const results = [];
      for (const item of openBlockPromises) {
        results.push(await item);
      }
      return results.flat().filter((v) => v);
    };
    this._commonParser = async ({ element, flavour, type, checked, ignoreEmptyElement = true }) => {
      const res = await this._commonHTML2Block(element, flavour, type, checked, ignoreEmptyElement);
      return res ? [res] : null;
    };
    this._listItemParser = async (element) => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const tagName = (_a3 = element.parentElement) == null ? void 0 : _a3.tagName;
      let type = tagName === "OL" ? "numbered" : "bulleted";
      if (((_b = element.firstElementChild) == null ? void 0 : _b.tagName) === "DETAIL" || ((_d = (_c = element.firstElementChild) == null ? void 0 : _c.firstElementChild) == null ? void 0 : _d.tagName) === "SUMMARY") {
        const summary = await ((_e = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _e({
          element: element.firstElementChild.firstElementChild,
          flavour: "affine:list",
          type
        }));
        const childNodes = element.firstElementChild.childNodes;
        const children = [];
        for (let i = 1; i < childNodes.length; i++) {
          const node = childNodes.item(i);
          if (!node)
            continue;
          if (node instanceof Element) {
            const childNode = await this._nodeParser(node);
            childNode && children.push(...childNode);
          }
        }
        if (summary && summary.length > 0) {
          summary[0].children = [...summary[0].children || [], ...children];
        }
        return summary;
      }
      let checked;
      let inputEl;
      if (((_f = inputEl = element.firstElementChild) == null ? void 0 : _f.tagName) === "INPUT" || ((_h = inputEl = (_g = element.firstElementChild) == null ? void 0 : _g.firstElementChild) == null ? void 0 : _h.tagName) === "INPUT") {
        type = "todo";
        checked = (inputEl == null ? void 0 : inputEl.getAttribute("checked")) !== null;
      }
      if (element.firstChild instanceof Text) {
        if ((_i = element.firstChild.textContent) == null ? void 0 : _i.startsWith("[] ")) {
          element.firstChild.textContent = element.firstChild.textContent.slice(3);
          type = "todo";
          checked = false;
        } else if ((_j = element.firstChild.textContent) == null ? void 0 : _j.startsWith("[ ] ")) {
          element.firstChild.textContent = element.firstChild.textContent.slice(4);
          type = "todo";
          checked = false;
        } else if ((_k = element.firstChild.textContent) == null ? void 0 : _k.startsWith("[x] ")) {
          element.firstChild.textContent = element.firstChild.textContent.slice(4);
          type = "todo";
          checked = true;
        }
      }
      return (_l = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _l({
        element,
        flavour: "affine:list",
        type,
        checked
      });
    };
    this._blockQuoteParser = async (element) => {
      var _a3;
      const getText = (list) => {
        const result = [];
        list.forEach((item) => {
          var _a4;
          const texts = ((_a4 = item.text) == null ? void 0 : _a4.filter((textItem) => textItem.insert)) || [];
          if (result.length > 0 && texts.length > 0) {
            result.push({ insert: "\n" });
          }
          result.push(...texts);
          const childTexts = getText(item.children || []) || [];
          if (result.length > 0 && childTexts.length > 0) {
            result.push({ insert: "\n" });
          }
          result.push(...childTexts);
        });
        return result;
      };
      const commonResult = await ((_a3 = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _a3({
        element,
        flavour: "affine:paragraph",
        type: "text"
      }));
      if (!commonResult) {
        return null;
      }
      return [
        {
          flavour: "affine:paragraph",
          type: "quote",
          text: getText(commonResult),
          children: []
        }
      ];
    };
    this._codeBlockParser = async (element) => {
      var _a3, _b, _c;
      const firstChild = element.children[0];
      const languageTag = (_a3 = firstChild == null ? void 0 : firstChild.getAttribute("class")) == null ? void 0 : _a3.split("-");
      const isNormalMarkdown = firstChild.tagName === "Code" && (languageTag == null ? void 0 : languageTag[0]) === "language";
      let content = "";
      let language = FALLBACK_LANG;
      if (isNormalMarkdown) {
        content = ((_b = element.firstChild) == null ? void 0 : _b.textContent) || "";
        language = ((_c = getStandardLanguage(languageTag == null ? void 0 : languageTag[1])) == null ? void 0 : _c.id) || FALLBACK_LANG;
      } else {
        content = element.textContent || "";
      }
      return [
        {
          flavour: "affine:code",
          text: [
            {
              insert: content
            }
          ],
          children: [],
          language
        }
      ];
    };
    this._embedItemParser = async (element) => {
      var _a3;
      let result = [];
      let imgElement = null;
      const texts = [];
      if (element.tagName === "FIGURE") {
        imgElement = element.querySelector("img");
        const figcaptionElement = element.querySelector("figcaption");
        if (figcaptionElement) {
          const captionResult = await ((_a3 = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _a3({
            element: figcaptionElement,
            flavour: "affine:paragraph",
            type: "text"
          }));
          if (captionResult && captionResult.length > 0) {
            texts.push(...captionResult[0].text || []);
          }
        }
      } else if (element instanceof HTMLImageElement) {
        imgElement = element;
        texts.push({ insert: "" });
      }
      if (imgElement) {
        const imgUrl = imgElement.getAttribute("src") || "";
        const imgBlob = await this._fetchFileHandler(imgUrl);
        if (!imgBlob || imgBlob.size === 0) {
          const texts2 = [
            {
              insert: imgUrl,
              attributes: {
                link: imgUrl
              }
            }
          ];
          result = [
            {
              flavour: "affine:paragraph",
              type: "text",
              children: [],
              text: texts2
            }
          ];
        } else {
          const storage = this._page.blobs;
          assertExists(storage);
          const id = await storage.set(imgBlob);
          result = [
            {
              flavour: "affine:embed",
              type: "image",
              sourceId: id,
              children: [],
              text: texts
            }
          ];
        }
      }
      return result;
    };
    this._tableParser = async (element) => {
      let result = [];
      if (this._customTableParserHandler) {
        result = await this._customTableParserHandler(element);
        if (result && result.length > 0) {
          return result;
        }
      }
      if (element.tagName === "TABLE") {
        const theadElement = element.querySelector("thead");
        const tbodyElement = element.querySelector("tbody");
        const titleTrEle = theadElement == null ? void 0 : theadElement.querySelector("tr");
        let id = 1;
        const titles = [];
        titleTrEle == null ? void 0 : titleTrEle.querySelectorAll("th").forEach((ele) => {
          titles.push(ele.textContent || "");
        });
        const rows = [];
        tbodyElement == null ? void 0 : tbodyElement.querySelectorAll("tr").forEach((ele) => {
          const row = [];
          ele.querySelectorAll("td").forEach((ele2) => {
            row.push(ele2.textContent || "");
          });
          rows.push(row);
        });
        const columns = titles.slice(1).map((value, index) => {
          return {
            name: value,
            type: "rich-text",
            width: 200,
            hide: false,
            id: "" + id++
          };
        });
        if (rows.length > 0) {
          let maxLen = rows[0].length;
          for (let i = 1; i < rows.length; i++) {
            maxLen = Math.max(maxLen, rows[i].length);
          }
          const addNum = maxLen - columns.length;
          for (let i = 0; i < addNum; i++) {
            columns.push({
              name: "",
              type: "rich-text",
              width: 200,
              hide: false,
              id: "" + id++
            });
          }
        }
        const databasePropsId = id++;
        const cells = {};
        const children = [];
        rows.forEach((row) => {
          children.push({
            flavour: "affine:paragraph",
            type: "text",
            text: [{ insert: row[0] }],
            children: []
          });
          const rowId = "" + id++;
          cells[rowId] = {};
          row.slice(1).forEach((value, index) => {
            cells[rowId][columns[index].id] = {
              columnId: columns[index].id,
              value
            };
          });
        });
        result = [
          {
            flavour: "affine:database",
            databaseProps: {
              id: "" + databasePropsId,
              title: "Database",
              titleColumnName: titles[0],
              titleColumnWidth: 432,
              rowIds: Object.keys(cells),
              cells,
              columns
            },
            children
          }
        ];
      }
      return result;
    };
    this._headerParser = async (element) => {
      var _a3;
      let node = element;
      if (element.getElementsByClassName("page-title").length > 0) {
        node = element.getElementsByClassName("page-title")[0];
      }
      const tagName = node.tagName;
      const result = await ((_a3 = this._contentParser.getParserHtmlText2Block("commonParser")) == null ? void 0 : _a3({
        element: node,
        flavour: "affine:page",
        type: tagName.toLowerCase()
      }));
      return result;
    };
    this._contentParser = contentParser;
    this._page = page;
    this._customFetchFileHandler = fetchFileHandler;
    this._customTextStyleHandler = textStyleHandler;
    this._customTableParserHandler = tableParserHandler;
  }
  registerParsers() {
    this._contentParser.registerParserHtmlText2Block("nodeParser", this._nodeParser);
    this._contentParser.registerParserHtmlText2Block("commonParser", this._commonParser);
    this._contentParser.registerParserHtmlText2Block("listItemParser", this._listItemParser);
    this._contentParser.registerParserHtmlText2Block("blockQuoteParser", this._blockQuoteParser);
    this._contentParser.registerParserHtmlText2Block("codeBlockParser", this._codeBlockParser);
    this._contentParser.registerParserHtmlText2Block("embedItemParser", this._embedItemParser);
    this._contentParser.registerParserHtmlText2Block("tableParser", this._tableParser);
    this._contentParser.registerParserHtmlText2Block("headerParser", this._headerParser);
  }
  async _commonHTML2Block(element, flavour, type, checked, ignoreEmptyElement = true) {
    const childNodes = element.childNodes;
    let isChildNode = false;
    const textValues = [];
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes.item(i);
      if (!node)
        continue;
      if (node.nodeName === "#comment")
        continue;
      if (node.nodeName === "STYLE")
        continue;
      if (!isChildNode) {
        if (node instanceof Text) {
          textValues.push(...this._commonHTML2Text(node, {}, ignoreEmptyElement));
          continue;
        }
        const htmlElement = node;
        if (INLINE_TAGS.includes(htmlElement.tagName) || htmlElement.tagName.includes("-") && checkWebComponentIfInline(htmlElement)) {
          textValues.push(...this._commonHTML2Text(node, {}, ignoreEmptyElement));
          continue;
        }
      }
      if (node instanceof Element) {
        const childNode = await this._nodeParser(node);
        childNode && children.push(...childNode);
      }
      isChildNode = true;
    }
    if (textValues.length === 0 && children.length === 1) {
      return {
        flavour,
        type,
        checked,
        text: children[0].text,
        children: children[0].children
      };
    }
    if (textValues.length === 0 && children.length > 0 && flavour === "affine:list") {
      return {
        flavour,
        type,
        checked,
        text: children[0].text,
        children: children.slice(1)
      };
    }
    return {
      flavour,
      type,
      checked,
      text: textValues,
      children
    };
  }
  _commonHTML2Text(element, textStyle = {}, ignoreEmptyText = true) {
    if (element instanceof Text) {
      let isLinkPage = false;
      if (textStyle.reference) {
        isLinkPage = textStyle.reference.type === "LinkedPage";
      }
      return (element.textContent || "").split("\n").map((text) => {
        return {
          insert: isLinkPage ? " " : text,
          attributes: textStyle
        };
      });
    }
    const htmlElement = element;
    if (htmlElement.classList.contains("katex-mathml")) {
      return [];
    }
    const childNodes = Array.from(htmlElement.childNodes);
    const currentTextStyle = getTextStyle(htmlElement);
    this._customTextStyleHandler && this._customTextStyleHandler(htmlElement, currentTextStyle);
    if (!childNodes.length) {
      return ignoreEmptyText ? [] : [
        {
          insert: "",
          attributes: currentTextStyle
        }
      ];
    }
    return childNodes.reduce((result, childNode) => {
      const textBlocks = this._commonHTML2Text(childNode, {
        ...textStyle,
        ...currentTextStyle
      }, ignoreEmptyText);
      result.push(...textBlocks);
      return result;
    }, []).filter((v) => v);
  }
};
var getIsLink = (htmlElement) => {
  return ["A"].includes(htmlElement.tagName);
};
var getTextStyle = (htmlElement) => {
  const tagName = htmlElement.tagName;
  const textStyle = {};
  const style = (htmlElement.getAttribute("style") || "").split(";").reduce((style2, styleString) => {
    const [key, value] = styleString.split(":");
    if (key && value) {
      style2[key] = value;
    }
    return style2;
  }, {});
  if (style["font-weight"] === "bold" || Number(style["font-weight"]) > 400 || ["STRONG", "B", "H1", "H2", "H3", "H4", "H5", "H6"].includes(htmlElement.tagName)) {
    textStyle["bold"] = true;
  }
  if (getIsLink(htmlElement)) {
    const linkUrl = htmlElement.getAttribute("href") || htmlElement.getAttribute("src");
    textStyle["link"] = linkUrl;
  }
  if (tagName === "EM" || style["fontStyle"] === "italic") {
    textStyle["italic"] = true;
  }
  if (tagName === "U" || style["text-decoration"] && style["text-decoration"].indexOf("underline") !== -1 || style["border-bottom"]) {
    textStyle["underline"] = true;
  }
  if (tagName === "CODE") {
    textStyle["code"] = true;
  }
  if (tagName === "S" || tagName === "DEL" || style["text-decoration"] && style["text-decoration"].indexOf("line-through") !== -1) {
    textStyle["strike"] = true;
  }
  if (tagName === "MARK") {
    textStyle["background"] = "yellow";
  }
  return textStyle;
};
var checkWebComponentIfInline = (element) => {
  const style = window.getComputedStyle(element);
  return style.display.includes("inline") || element.style.display.includes("inline");
};

// node_modules/@blocksuite/blocks/dist/__internal__/content-parser/index.js
var ContentParser = class {
  constructor(page, fetchFileHandler, textStyleHandler, tableParserHandler) {
    this.slots = {
      beforeHtml2Block: new Slot()
    };
    this._parsers = {};
    this.urlPattern = new RegExp("(?<=\\s|^)https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)(?=\\s|$)", "g");
    this._page = page;
    this._htmlParser = new HtmlParser(this, page, fetchFileHandler, textStyleHandler, tableParserHandler);
    this._htmlParser.registerParsers();
  }
  async exportHtml() {
    const root2 = this._page.root;
    if (!root2)
      return;
    const htmlContent = await this.block2Html(this._getSelectedBlock(root2).children[1].children);
    FileExporter.exportHtml(root2.title.toString(), htmlContent);
  }
  async exportMarkdown() {
    const root2 = this._page.root;
    if (!root2)
      return;
    const htmlContent = await this.block2Html(this._getSelectedBlock(root2).children[1].children);
    FileExporter.exportHtmlAsMarkdown(root2.title.toString(), htmlContent);
  }
  async exportPng() {
    const root2 = this._page.root;
    if (!root2)
      return;
    const editorContainer = getEditorContainer(this._page);
    const styleElement = document.createElement("style");
    styleElement.textContent = "editor-container,.affine-editor-container {height: auto;}";
    editorContainer.appendChild(styleElement);
    FileExporter.exportPng(root2.title.toString(), await toPng(editorContainer, {
      cacheBust: true
    }));
    editorContainer.removeChild(styleElement);
  }
  async exportPdf() {
    const root2 = this._page.root;
    if (!root2)
      return;
    window.print();
  }
  async block2Html(blocks) {
    let htmlText = "";
    for (let currentIndex = 0; currentIndex < blocks.length; currentIndex++) {
      htmlText = htmlText + await this._getHtmlInfoBySelectionInfo(blocks[currentIndex]);
    }
    return htmlText;
  }
  async block2Text(blocks) {
    return (await Promise.all(blocks.map((block2) => this._getTextInfoBySelectionInfo(block2)))).reduce((text, block2) => text + block2, "");
  }
  async htmlText2Block(html3) {
    var _a3;
    const htmlEl = document.createElement("html");
    htmlEl.innerHTML = html3;
    (_a3 = htmlEl.querySelector("head")) == null ? void 0 : _a3.remove();
    this.slots.beforeHtml2Block.emit(htmlEl);
    return this._convertHtml2Blocks(htmlEl);
  }
  async file2Blocks(clipboardData) {
    const file = getFileFromClipboard(clipboardData);
    if (file) {
      if (file.type.includes("image")) {
        const storage = this._page.blobs;
        assertExists(storage);
        const id = await storage.set(file);
        return [
          {
            flavour: "affine:embed",
            type: "image",
            sourceId: id,
            children: []
          }
        ];
      }
    }
    return [];
  }
  async markdown2Block(text) {
    const underline = {
      name: "underline",
      level: "inline",
      start(src) {
        return src.indexOf("~");
      },
      tokenizer(src) {
        const rule = /^~([^~]+)~/;
        const match = rule.exec(src);
        if (match) {
          return {
            type: "underline",
            raw: match[0],
            text: match[1].trim()
            // You can add additional properties to your tokens to pass along to the renderer
          };
        }
        return;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      renderer(token) {
        return `<u>${token.text}</u>`;
      }
    };
    const inlineCode = {
      name: "inlineCode",
      level: "inline",
      start(src) {
        return src.indexOf("`");
      },
      tokenizer(src) {
        const rule = /^(?:`)(`{2,}?|[^`]+)(?:`)$/g;
        const match = rule.exec(src);
        if (match) {
          return {
            type: "inlineCode",
            raw: match[0],
            text: match[1].trim()
            // You can add additional properties to your tokens to pass along to the renderer
          };
        }
        return;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      renderer(token) {
        return `<code>${token.text}</code>`;
      }
    };
    marked.use({ extensions: [underline, inlineCode] });
    const md2html = marked.parse(text);
    return this.htmlText2Block(md2html);
  }
  async importMarkdown(text, insertPositionId) {
    const blocks = await this.markdown2Block(text);
    const insertBlockModel = this._page.getBlockById(insertPositionId);
    assertExists(insertBlockModel);
    const { getServiceOrRegister: getServiceOrRegister2 } = await import("./service-X4XNEGV7.js");
    const service = await getServiceOrRegister2(insertBlockModel.flavour);
    service.json2Block(insertBlockModel, blocks);
  }
  async importHtml(text, insertPositionId) {
    const blocks = await this.htmlText2Block(text);
    const insertBlockModel = this._page.getBlockById(insertPositionId);
    assertExists(insertBlockModel);
    const { getServiceOrRegister: getServiceOrRegister2 } = await import("./service-X4XNEGV7.js");
    const service = await getServiceOrRegister2(insertBlockModel.flavour);
    service.json2Block(insertBlockModel, blocks);
  }
  registerParserHtmlText2Block(name, handler) {
    this._parsers[name] = handler;
  }
  getParserHtmlText2Block(name) {
    return this._parsers[name] || null;
  }
  text2blocks(text) {
    return text.split("\n").map((str) => {
      const splitText = str.split(this.urlPattern);
      const urls = str.match(this.urlPattern);
      const result = [];
      for (let i = 0; i < splitText.length; i++) {
        if (splitText[i]) {
          result.push({ insert: splitText[i] });
        }
        if (urls && urls[i]) {
          result.push({ insert: urls[i], attributes: { link: urls[i] } });
        }
      }
      return {
        flavour: "affine:paragraph",
        type: "text",
        text: result,
        children: []
      };
    });
  }
  _getSelectedBlock(model) {
    return {
      id: model.id,
      children: model.children.map((child) => this._getSelectedBlock(child))
    };
  }
  async _getHtmlInfoBySelectionInfo(block2) {
    const model = this._page.getBlockById(block2.id);
    if (!model) {
      return "";
    }
    const children = [];
    for (let currentIndex = 0; currentIndex < block2.children.length; currentIndex++) {
      const childText = await this._getHtmlInfoBySelectionInfo(block2.children[currentIndex]);
      childText && children.push(childText);
    }
    const { getServiceOrRegister: getServiceOrRegister2 } = await import("./service-X4XNEGV7.js");
    const service = await getServiceOrRegister2(model.flavour);
    return service.block2html(model, {
      childText: children.join(""),
      begin: block2.startPos,
      end: block2.endPos
    });
  }
  async _getTextInfoBySelectionInfo(selectedBlock) {
    const model = this._page.getBlockById(selectedBlock.id);
    if (!model) {
      return "";
    }
    const children = [];
    for (const child of selectedBlock.children) {
      const childText = await this._getTextInfoBySelectionInfo(child);
      childText && children.push(childText);
    }
    const { getServiceOrRegister: getServiceOrRegister2 } = await import("./service-X4XNEGV7.js");
    const service = await getServiceOrRegister2(model.flavour);
    return service.block2Text(model, {
      childText: children.join(""),
      begin: selectedBlock.startPos,
      end: selectedBlock.endPos
    });
  }
  async _convertHtml2Blocks(element) {
    const openBlockPromises = Array.from(element.children).map(async (childElement) => {
      var _a3;
      return await ((_a3 = this.getParserHtmlText2Block("nodeParser")) == null ? void 0 : _a3(childElement)) || [];
    });
    const results = [];
    for (const item of openBlockPromises) {
      results.push(await item);
    }
    return results.flat().filter((v) => v);
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/utils/markdown.js
var MarkdownUtils = class _MarkdownUtils {
  /** Extract some grammar rules to check whether a piece of text contains markdown grammar */
  checkIfTextContainsMd(text) {
    text = text.replace(/¨/g, "¨T");
    text = text.replace(/\$/g, "¨D");
    text = text.replace(/\r\n/g, "\n");
    text = text.replace(/\r/g, "\n");
    text = text.replace(/\u00A0/g, "&nbsp;");
    text = `

${text}

`;
    text = _MarkdownUtils._detab(text);
    for (let i = 0; i < _MarkdownUtils._checkRegArr.length; i++) {
      const text1 = i === 3 ? `${text}¨0` : text;
      if (_MarkdownUtils._checkRegArr[i].test(text1)) {
        return true;
      }
    }
    return false;
  }
  static _detab(text) {
    text = text.replace(/\t(?=\t)/g, " ");
    text = text.replace(/\t/g, "¨A¨B");
    text = text.replace(/¨B(.+?)¨A/g, (_wholeMatch, m1) => {
      let leadingText = m1;
      const numSpaces = 4 - leadingText.length % 4;
      for (let i = 0; i < numSpaces; i++) {
        leadingText += " ";
      }
      return leadingText;
    });
    text = text.replace(/¨A/g, " ");
    text = text.replace(/¨B/g, "");
    return text;
  }
};
MarkdownUtils._checkRegArr = [
  /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm,
  /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
  /(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g,
  /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
  /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
  /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
  /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
  /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
  // eslint-disable-next-line
  /!\[([^\[\]]+)]()()()()()/g,
  // eslint-disable-next-line
  /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
  // eslint-disable-next-line
  /\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g,
  // eslint-disable-next-line
  /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
  // eslint-disable-next-line
  /\[([^\[\]]+)]()()()()()/g
  // abbreviationlink
];
var markdown_default = new MarkdownUtils();

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/utils/commons.js
function getBlockClipboardInfo(model, begin, end2) {
  const service = getService(model.flavour);
  const html3 = service.block2html(model, { begin, end: end2 });
  const text = service.block2Text(model, { begin, end: end2 });
  const json = service.block2Json(model, begin, end2);
  return {
    html: html3,
    text,
    json,
    model
  };
}
function createPageClipboardItems(range) {
  const clipGroups = range.models.map((model, index) => {
    if (index === 0) {
      return getBlockClipboardInfo(model, range.startOffset, index === range.models.length - 1 ? range.endOffset : void 0);
    }
    if (index === range.models.length - 1) {
      return getBlockClipboardInfo(model, void 0, range.endOffset);
    }
    return getBlockClipboardInfo(model);
  });
  const stringifiesData = JSON.stringify(clipGroups.filter((group) => {
    if (!group.json) {
      return false;
    }
    return !isChildBlock(range.models, group.model);
  }).map((group) => group.json));
  const customClipboardFragment = createHTMLStringForCustomData(stringifiesData, CLIPBOARD_MIMETYPE.BLOCKSUITE_PAGE);
  const textClipboardItem = new ClipboardItem(CLIPBOARD_MIMETYPE.TEXT, clipGroups.reduce((text, group, index) => {
    return `${text}${group.text}${index === clipGroups.length - 1 ? "" : "\n"}`;
  }, ""));
  const htmlClipboardItem = new ClipboardItem(CLIPBOARD_MIMETYPE.HTML, `${clipGroups.map((group) => group.html).join("")}${customClipboardFragment}`);
  const pageClipboardItem = new ClipboardItem(CLIPBOARD_MIMETYPE.BLOCKSUITE_PAGE, stringifiesData);
  return [textClipboardItem, htmlClipboardItem, pageClipboardItem];
}
function copyBlocks(range) {
  const clipboardItems = createPageClipboardItems(range);
  const savedRange = hasNativeSelection() ? getCurrentNativeRange() : null;
  performNativeCopy(clipboardItems);
  if (savedRange) {
    resetNativeSelection(savedRange);
  }
}
function isChildBlock(blocks, block2) {
  for (let i = 0; i < blocks.length; i++) {
    const parentBlock = blocks[i];
    if (parentBlock.children) {
      if (parentBlock.children.findIndex((childBlock) => childBlock.id === block2.id) > -1) {
        return true;
      }
      if (isChildBlock(parentBlock.children, block2)) {
        return true;
      }
    }
  }
  return false;
}
async function clipboardData2Blocks(page, clipboardData) {
  if (!clipboardData) {
    return [];
  }
  const contentParser = new ContentParser(page);
  if (isPureFileInClipboard(clipboardData)) {
    return contentParser.file2Blocks(clipboardData);
  }
  const HTMLClipboardData = clipboardData.getData(CLIPBOARD_MIMETYPE.HTML);
  if (HTMLClipboardData) {
    const blockSuiteClipboardData = extractCustomDataFromHTMLString(CLIPBOARD_MIMETYPE.BLOCKSUITE_PAGE, clipboardData.getData(CLIPBOARD_MIMETYPE.HTML));
    if (blockSuiteClipboardData) {
      return JSON.parse(blockSuiteClipboardData);
    }
  }
  const textClipData = clipboardData.getData(CLIPBOARD_MIMETYPE.TEXT);
  const shouldConvertMarkdown = markdown_default.checkIfTextContainsMd(textClipData);
  if (HTMLClipboardData && !shouldConvertMarkdown) {
    return await contentParser.htmlText2Block(HTMLClipboardData);
  }
  if (shouldConvertMarkdown) {
    return await contentParser.markdown2Block(textClipData);
  }
  return contentParser.text2blocks(textClipData);
}
function normalizeDelta(page, deltas) {
  const backlinkIndexer = page.workspace.indexer.backlink;
  deltas.forEach((delta) => {
    if (!(delta && delta.attributes && delta.attributes.reference && delta.attributes.reference.type === "Subpage")) {
      return;
    }
    const refNode = delta.attributes.reference;
    const parentPage = backlinkIndexer.getParentPage(refNode.pageId);
    if (!parentPage) {
      return;
    }
    delta.attributes = {
      ...delta.attributes,
      reference: {
        ...refNode,
        type: "LinkedPage"
      }
    };
  });
  return deltas;
}
function normalizePasteBlocks(page, blocks) {
  blocks.filter((block2) => block2.text).forEach((block2) => {
    normalizeDelta(page, block2.text);
  });
  return blocks;
}
function copySurfaceText(edgeless) {
  const surfaceTextEditor = edgeless.querySelector("surface-text-editor");
  if (surfaceTextEditor) {
    const vEditor = surfaceTextEditor.vEditor;
    assertExists(vEditor);
    const vRange = vEditor.getVRange();
    if (vRange) {
      const text = vEditor.yText.toString().slice(vRange.index, vRange.index + vRange.length);
      const clipboardItem = new ClipboardItem(CLIPBOARD_MIMETYPE.TEXT, text);
      surfaceTextEditor.setKeeping(true);
      performNativeCopy([clipboardItem]);
      surfaceTextEditor.setKeeping(false);
      vEditor.rootElement.focus();
      vEditor.setVRange(vRange);
    }
  }
}

// node_modules/@blocksuite/blocks/dist/components/database-modal/styles.js
var styles2 = css`
  :host {
    font-family: var(--affine-font-family);
  }
  :host * {
    box-sizing: border-box;
  }
  .overlay-mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.6);
    z-index: var(--affine-z-index-modal);
  }
  .modal-container {
    position: absolute;
    z-index: var(--affine-z-index-modal);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    width: 720px;
    padding: 24px 40px;
    border-radius: 24px;
    background: var(--affine-background-overlay-panel-color);
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .modal-header-title {
    color: var(--affine-text-primary-color);
    font-size: 20px;
    font-weight: 600;
  }
  .modal-header-close-icon {
    display: flex;
    align-items: center;
    color: var(--affine-icon-color);
    cursor: pointer;
  }
  .modal-header-close-icon svg {
    width: 24px;
    height: 24px;
  }
  .modal-footer {
    color: var(--affine-text-secondary-color);
    font-size: 14px;
    text-align: center;
  }
  .modal-body {
    padding: 24px 0;
  }
  .modal-desc {
    margin-bottom: 38px;
    color: var(--affine-text-primary-color);
    font-size: 14px;
  }
  .modal-view-container {
    display: flex;
    justify-content: center;
    gap: 18px;
  }
  .modal-view-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
    cursor: pointer;
  }
  .modal-view-item.coming-soon {
    cursor: not-allowed;
  }
  .modal-view-item.coming-soon .modal-view-item-content {
    pointer-events: none;
  }
  .modal-view-item-content:hover {
    background: var(--affine-hover-color);
  }
  .modal-view-item-content:hover .modal-view-item-text,
  .modal-view-item-content:hover svg {
    fill: var(--affine-primary-color);
    color: var(--affine-primary-color);
  }
  .modal-view-item-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 18px 0;
    gap: 6px;
    width: 108px;
    height: 108px;
    border: 2px solid var(--affine-border-color);
    border-radius: 8px;
  }
  .modal-view-item-icon {
    width: 42px;
    height: 42px;
  }
  .modal-view-item-icon svg {
    width: 42px;
    height: 42px;
    fill: var(--affine-black-50);
  }
  .modal-view-item-text {
    font-size: 14px;
    color: var(--affine-black-50);
  }
  .modal-view-item-description {
    font-size: 12px;
    color: var(--affine-text-secondary-color);
    text-align: center;
  }
`;

// node_modules/@blocksuite/blocks/dist/components/database-modal/database-modal.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var databaseViews = [
  {
    type: "table",
    text: "Table view",
    icon: DatabaseTableViewIcon
  },
  {
    type: "kanban",
    text: "Kanban view",
    icon: DatabaseKanbanViewIcon,
    description: "Coming soon",
    isComingSoon: true
  }
];
var DatabaseModal = class DatabaseModal2 extends LitElement {
  constructor() {
    super(...arguments);
    this._selectedView = "table";
  }
  _convertToDatabase(viewType) {
    if (viewType !== "table")
      return;
    this._hide();
    this.page.captureSync();
    const range = getCurrentBlockRange(this.page);
    assertExists(range);
    const models = range.models;
    const parentModel = this.page.getParent(models[0]);
    assertExists(parentModel);
    const id = this.page.addBlock("affine:database", {
      columns: [],
      titleColumnName: "Title"
    }, parentModel, parentModel.children.indexOf(models[0]));
    const databaseModel = this.page.getBlockById(id);
    assertExists(databaseModel);
    databaseModel.updateColumn({
      name: "Tag",
      type: "multi-select",
      width: 200,
      hide: false,
      selection: []
    });
    databaseModel.applyColumnUpdate();
    this.page.moveBlocks(models, databaseModel);
    const defaultPageBlock = getDefaultPage(this.page);
    assertExists(defaultPageBlock);
    if (!defaultPageBlock.selection) {
      return;
    }
    defaultPageBlock.selection.clear();
  }
  _hide() {
    this.abortController.abort();
  }
  render() {
    return html`<div class="overlay-root">
      <div class="overlay-mask" @click=${this._hide}></div>
      <div class="modal-container">
        <div class="modal-header">
          <div class="modal-header-title">Select Database View</div>
          <div class="modal-header-close-icon" @click=${this._hide}>
            ${DatabaseSearchClose}
          </div>
        </div>
        <div class="modal-body">
          <div class="modal-desc">
            Group as Database can quickly convert selected blocks into Database
            for easy structuring of data.
          </div>
          <div class="modal-view-container">
            ${databaseViews.map((view) => {
      const isSelected = view.type === this._selectedView;
      return html`
                <div
                  class="modal-view-item ${view.type} ${view.isComingSoon ? "coming-soon" : ""}"
                  @click=${() => this._convertToDatabase(view.type)}
                >
                  <div
                    class="modal-view-item-content ${isSelected ? "selected" : ""}"
                  >
                    <div class="modal-view-item-icon">${view.icon}</div>
                    <div class="modal-view-item-text">${view.text}</div>
                  </div>
                  <div class="modal-view-item-description">
                    ${view.description}
                  </div>
                </div>
              `;
    })}
          </div>
        </div>
        <div class="modal-footer">More views are on the way.</div>
      </div>
    </div>`;
  }
};
DatabaseModal.styles = styles2;
__decorate10([
  property()
], DatabaseModal.prototype, "page", void 0);
__decorate10([
  state()
], DatabaseModal.prototype, "_selectedView", void 0);
__decorate10([
  property()
], DatabaseModal.prototype, "abortController", void 0);
DatabaseModal = __decorate10([
  customElement("affine-database-modal")
], DatabaseModal);

// node_modules/@blocksuite/blocks/dist/components/database-modal/index.js
function showDatabaseModal({ page, container = document.body, abortController = new AbortController() }) {
  const disposables = new DisposableGroup();
  abortController.signal.addEventListener("abort", () => disposables.dispose());
  const databaseModal = new DatabaseModal();
  databaseModal.page = page;
  databaseModal.abortController = abortController;
  container.appendChild(databaseModal);
  disposables.add(() => databaseModal.remove());
  return databaseModal;
}

// node_modules/@blocksuite/blocks/dist/page-block/utils/const.js
var DATABASE_WHITE_LIST = ["affine:list", "affine:paragraph"];
var actionConfig = [
  {
    id: "copy",
    name: "Copy",
    disabledToolTip: void 0,
    icon: CopyIcon,
    hotkey: void 0,
    showWhen: () => true,
    enabledWhen: () => true,
    action: ({ page }) => {
      const range = getCurrentBlockRange(page);
      assertExists(range);
      copyBlocks(range);
      toast("Copied to clipboard");
    }
  },
  {
    id: "convert-to-database",
    name: "Group as Database",
    disabledToolTip: "Contains Block types that cannot be converted to Database. Learn more",
    icon: DatabaseTableViewIcon,
    hotkey: `${SHORT_KEY}+g`,
    showWhen: (page, models) => {
      if (models.length === 1 && matchFlavours(models[0], ["affine:database"])) {
        return false;
      }
      const range = getCurrentBlockRange(page);
      const isShow = (range == null ? void 0 : range.type) === "Block";
      return isShow;
    },
    enabledWhen: (page) => {
      const range = getCurrentBlockRange(page);
      if (!range)
        return false;
      return range.models.every((model) => DATABASE_WHITE_LIST.includes(model.flavour));
    },
    action: ({ page }) => {
      showDatabaseModal({
        page
      });
    }
  }
];

// node_modules/@blocksuite/blocks/dist/components/link-popover/styles.js
var editLinkStyle = css`
  .affine-link-edit-popover {
    box-sizing: border-box;
    width: 404px;
    height: 112px;
    padding: 12px;
    box-shadow: var(--affine-shadow-2);
    background: var(--affine-background-overlay-panel-color);
    border-radius: 8px;
    display: grid;
    grid-template-columns: auto auto auto;
    grid-template-rows: repeat(2, 1fr);
    gap: 12px;
    grid-template-areas:
      'text-area .'
      'link-area btn';
    justify-items: center;
    align-items: center;
    /* breaks 'basic link' test in chromium */
    /* user-select: none; */
  }

  .affine-edit-text-area {
    grid-area: text-area;
    width: 338px;
    display: grid;
    gap: 6px;
    grid-template-columns: auto auto auto;
    grid-template-rows: repeat(1, 1fr);
    grid-template-areas: 'text span text-input';
    justify-items: center;
    align-items: center;
    user-select: none;
  }

  .affine-edit-link-area {
    grid-area: link-area;
    width: 338px;
    display: grid;
    gap: 6px;
    grid-template-columns: auto auto auto;
    grid-template-rows: repeat(1, 1fr);
    grid-template-areas: 'link span link-input';
    justify-items: center;
    align-items: center;
  }

  .affine-link-popover-dividing-line {
    grid-area: span;
  }
  .affine-edit-text-text {
    grid-area: text;
  }

  .affine-edit-text-input {
    grid-area: text-input;
  }

  .affine-edit-link-text {
    grid-area: link;
  }

  .affine-edit-link-input {
    grid-area: link-input;
  }

  .affine-confirm-button {
    grid-area: btn;
    user-select: none;
    fill: var(--affine-icon-color);
  }
  .affine-confirm-button[disabled],
  .affine-confirm-button:disabled {
    fill: var(--affine-icon-color);
  }
`;
var linkPopoverStyle = css`
  .popover-container {
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-base);
    font-style: normal;
    line-height: 24px;
    color: var(--affine-popover-color);
    z-index: var(--affine-z-index-popover);
    animation: affine-popover-fade-in 0.2s ease;
  }

  @keyframes affine-popover-fade-in {
    from {
      opacity: 0;
      transform: translateY(-3px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .overlay-mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: var(--affine-z-index-popover);
  }
  .affine-edit-text-area {
    border: 1px solid var(--affine-border-color);
    outline: none;
    border-radius: 10px;
    background: transparent;
  }
  .affine-edit-text-area:focus-within {
    border: 1px solid var(--affine-primary-color);
  }
  .affine-edit-link-area {
    border: 1px solid var(--affine-border-color);
    outline: none;
    border-radius: 10px;
    background: transparent;
  }
  .affine-edit-link-area:focus-within {
    border: 1px solid var(--affine-primary-color);
  }

  label {
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-sm);
    box-sizing: border-box;
    padding: 6px 0 6px 12px;
    color: var(--affine-icon-color);
  }

  input {
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-base);
    box-sizing: border-box;
    padding: 6px 12px 6px 0;
    width: 260px;
    height: 34px;
    color: inherit;
    border: none;
    background: transparent;
  }
  input::placeholder {
    color: var(--affine-placeholder-color);
  }
  input:focus {
    outline: none;
  }
  input:focus ~ label,
  input:active ~ label {
    color: var(--affine-primary-color);
  }

  .affine-link-popover {
    display: flex;
    align-items: center;
    height: 40px;
    padding: 0 12px;

    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-shadow-2);
    border-radius: 8px;
  }

  .affine-link-popover-input {
    border: none;
  }
  .affine-link-popover-input::placeholder {
    color: var(--affine-placeholder-color);
  }
  .affine-link-popover-input:focus {
    border: none;
  }

  .affine-link-preview {
    width: 260px;
    height: 28px;
    display: flex;
    align-items: center;
    user-select: none;
    cursor: pointer;
    white-space: nowrap;
  }

  .affine-link-popover-dividing-line {
    margin: 0 6px;
    width: 1px;
    height: 20px;
    background-color: var(--affine-border-color);
  }

  ${editLinkStyle}
  ${tooltipStyle}
`;

// node_modules/@blocksuite/blocks/dist/components/link-popover/link-popover.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ALLOWED_SCHEMES = [
  "http",
  "https",
  "ftp",
  "sftp",
  "mailto",
  "tel"
  // may need support other schemes
];
var MAIL_REGEX = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;
var URL_REGEX2 = new RegExp("^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$", "i");
function normalizeUrl(url) {
  const hasScheme = ALLOWED_SCHEMES.some((scheme) => url.startsWith(scheme + ":"));
  if (hasScheme) {
    return url;
  }
  const isEmail = MAIL_REGEX.test(url);
  if (isEmail) {
    return "mailto:" + url;
  }
  return "http://" + url;
}
var isValidLink = (str) => {
  if (!str) {
    return false;
  }
  const url = normalizeUrl(str);
  if (url === str) {
    return true;
  }
  return URL_REGEX2.test(url);
};
var LinkPopover = class LinkPopover2 extends LitElement {
  constructor() {
    super(...arguments);
    this.left = "0";
    this.top = "0";
    this.type = "create";
    this.showMask = true;
    this.text = "";
    this.previewLink = "";
    this.showBookmarkOperation = false;
    this._bodyOverflowStyle = "";
    this._disableConfirm = true;
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.showMask) {
      this._bodyOverflowStyle = document.body.style.overflow;
      document.body.style.overflow = "hidden";
    }
  }
  firstUpdated(_changedProperties) {
    super.firstUpdated(_changedProperties);
    if (this.linkInput) {
      this.linkInput.focus();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.showMask) {
      document.body.style.overflow = this._bodyOverflowStyle;
    }
  }
  _hide() {
    this.dispatchEvent(new CustomEvent("updateLink", {
      detail: { type: "cancel" }
    }));
  }
  _onConfirm() {
    var _a3;
    if (this._disableConfirm) {
      return;
    }
    if (!this.linkInput) {
      throw new Error("Failed to update link! Link input not found!");
    }
    const link = normalizeUrl(this.linkInput.value);
    const text = ((_a3 = this.textInput) == null ? void 0 : _a3.value) ?? void 0;
    if (!link) {
      return;
    }
    this.dispatchEvent(createEvent("updateLink", {
      type: "confirm",
      link,
      text
    }));
    return;
  }
  _onCopy(e) {
    navigator.clipboard.writeText(this.previewLink);
    toast("Copied link to clipboard");
  }
  _onUnlink(e) {
    this.dispatchEvent(createEvent("updateLink", { type: "remove" }));
  }
  _onLinkToCard(e) {
    this.dispatchEvent(new CustomEvent("updateLink", {
      detail: { type: "toBookmark" }
    }));
  }
  _onEdit(e) {
    this.dispatchEvent(createEvent("editLink", null));
    this._disableConfirm = false;
  }
  _onInput(e) {
    if (!this.linkInput) {
      throw new Error("Failed to update link! Link input not found!");
    }
    const isValid = isValidLink(this.linkInput.value);
    this._disableConfirm = isValid ? false : true;
  }
  _onKeydown(e) {
    if (e.key === "Enter" && !e.isComposing) {
      e.preventDefault();
      this._onConfirm();
    }
    return;
  }
  confirmBtnTemplate() {
    return html`<icon-button
      class="affine-confirm-button"
      ?disabled=${this._disableConfirm}
      @click=${this._onConfirm}
      >${ConfirmIcon}</icon-button
    >`;
  }
  createLinkTemplate() {
    return html`<div class="affine-link-popover">
      <input
        id="link-input"
        class="affine-link-popover-input"
        type="text"
        spellcheck="false"
        placeholder="Paste or type a link"
        value=${this.previewLink}
        @keydown=${this._onKeydown}
        @input=${this._onInput}
      />
      <span class="affine-link-popover-dividing-line"></span>
      ${this.confirmBtnTemplate()}
    </div>`;
  }
  previewTemplate() {
    return html`<div class="affine-link-popover">
      <div class="affine-link-preview has-tool-tip" @click=${this._onCopy}>
        <tool-tip inert role="tooltip">Click to copy link</tool-tip>
        <span style="overflow: hidden;">${this.previewLink}</span>
      </div>
      <span class="affine-link-popover-dividing-line"></span>
      ${this.showBookmarkOperation ? html`<icon-button
              class="has-tool-tip"
              data-testid="unlink"
              @click=${this._onLinkToCard}
            >
              ${LinkToCardIcon}
              <tool-tip inert role="tooltip">Turn into Card view</tool-tip>
            </icon-button>
            <span class="affine-link-popover-dividing-line"></span>` : ""}
      <icon-button
        class="has-tool-tip"
        data-testid="unlink"
        @click=${this._onUnlink}
      >
        ${UnlinkIcon}
        <tool-tip inert role="tooltip">Remove</tool-tip>
      </icon-button>

      <icon-button
        class="has-tool-tip"
        data-testid="edit"
        @click=${this._onEdit}
      >
        ${EditIcon}
        <tool-tip inert role="tooltip">Edit</tool-tip>
      </icon-button>
    </div>`;
  }
  simpleTemplate() {
    const isCreateLink = !this.previewLink;
    return isCreateLink ? this.createLinkTemplate() : this.previewTemplate();
  }
  /**
   * ```
   * ┌─────────────────┐
   * │ ┌──────────┐    │
   * │ │Text      │    │
   * │ └──────────┘    │
   * │ ┌──────────┐    │
   * │ │Link      │ X  │
   * │ └──────────┘    │
   * └─────────────────┘
   * ```
   */
  editTemplate() {
    return html`<div class="affine-link-edit-popover">
      <div class="affine-edit-text-area">
        <input
          class="affine-edit-text-input"
          id="text-input"
          type="text"
          placeholder="Enter text"
          value=${this.text}
          @keydown=${this._onKeydown}
        />
        <span class="affine-link-popover-dividing-line"></span>
        <label class="affine-edit-text-text" for="text-input">Text</label>
      </div>
      <div class="affine-edit-link-area">
        <input
          id="link-input"
          class="affine-edit-link-input"
          type="text"
          spellcheck="false"
          placeholder="Paste or type a link"
          value=${this.previewLink}
          @keydown=${this._onKeydown}
        />
        <span class="affine-link-popover-dividing-line"></span>
        <label class="affine-edit-link-text" for="link-input">Link</label>
      </div>
      ${this.confirmBtnTemplate()}
    </div>`;
  }
  render() {
    const mask = this.showMask ? html`<div class="overlay-mask" @click="${this._hide}"></div>` : html``;
    const popover = this.type === "create" ? this.simpleTemplate() : this.editTemplate();
    return html`
      <div class="overlay-root">
        ${mask}
        <div
          class="popover-container"
          style="position: absolute; left: ${this.left}; top: ${this.top};${this.style.cssText}"
        >
          ${popover}
        </div>
      </div>
    `;
  }
};
LinkPopover.styles = linkPopoverStyle;
__decorate11([
  property()
], LinkPopover.prototype, "left", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "top", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "type", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "showMask", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "text", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "previewLink", void 0);
__decorate11([
  property()
], LinkPopover.prototype, "showBookmarkOperation", void 0);
__decorate11([
  state()
], LinkPopover.prototype, "_bodyOverflowStyle", void 0);
__decorate11([
  state()
], LinkPopover.prototype, "_disableConfirm", void 0);
__decorate11([
  query("#text-input")
], LinkPopover.prototype, "textInput", void 0);
__decorate11([
  query("#link-input")
], LinkPopover.prototype, "linkInput", void 0);
__decorate11([
  query(".popover-container")
], LinkPopover.prototype, "popoverContainer", void 0);
LinkPopover = __decorate11([
  customElement("edit-link-panel")
], LinkPopover);

// node_modules/@blocksuite/blocks/dist/components/link-popover/create-link-popover.js
function updatePosition(element, anchorEl) {
  var _a3;
  const rect = anchorEl.getBoundingClientRect();
  const offsetY = 5;
  const safeCoordinate = calcSafeCoordinate({
    positioningPoint: { x: rect.x, y: rect.top + rect.height + offsetY },
    objRect: (_a3 = element.popoverContainer) == null ? void 0 : _a3.getBoundingClientRect(),
    offsetY
  });
  element.left = `${safeCoordinate.x}px`;
  element.top = `${safeCoordinate.y}px`;
}
function createEditLinkElement(anchorEl, container, { showMask, previewLink, page }) {
  const linkPanel = document.createElement("edit-link-panel");
  linkPanel.showMask = showMask;
  linkPanel.previewLink = previewLink;
  linkPanel.showBookmarkOperation = !!page.awarenessStore.getFlag("enable_bookmark_operation");
  container.appendChild(linkPanel);
  requestAnimationFrame(() => {
    updatePosition(linkPanel, anchorEl);
  });
  return linkPanel;
}
function bindHoverState(target, popover, controller) {
  const hoverCloseDelay = 300;
  let timer;
  const handleMouseEnter = (e) => {
    clearTimeout(timer);
  };
  const handleMouseLeave = (e) => {
    timer = window.setTimeout(() => {
      controller.abort();
    }, hoverCloseDelay);
  };
  const abortHandler = () => {
    controller.abort();
  };
  target.addEventListener("mouseover", handleMouseEnter);
  target.addEventListener("mouseout", handleMouseLeave);
  popover.addEventListener("mouseover", handleMouseEnter);
  popover.addEventListener("mouseout", handleMouseLeave);
  const model = getModelByElement(target);
  const pageBlock = getDefaultPage(model.page);
  const viewport2 = pageBlock == null ? void 0 : pageBlock.viewportElement;
  viewport2 == null ? void 0 : viewport2.addEventListener("scroll", abortHandler);
  return () => {
    target.removeEventListener("mouseover", handleMouseEnter);
    target.removeEventListener("mouseout", handleMouseLeave);
    popover.removeEventListener("mouseover", handleMouseEnter);
    popover.removeEventListener("mouseout", handleMouseLeave);
    viewport2 == null ? void 0 : viewport2.removeEventListener("scroll", abortHandler);
  };
}
async function showLinkPopover({ anchorEl, page, container = document.body, text = "", link = "", showMask = true, interactionKind = "always", abortController = new AbortController() }) {
  assertExists(anchorEl, "Can't show tooltip without anchor element!");
  if (abortController.signal.aborted) {
    return Promise.resolve({ type: "cancel" });
  }
  const editLinkEle = createEditLinkElement(anchorEl, container, {
    showMask,
    previewLink: link,
    page
  });
  const unsubscribeHoverAbort = interactionKind === "hover" ? bindHoverState(anchorEl, editLinkEle, abortController) : noop;
  return new Promise((res) => {
    abortController.signal.addEventListener("abort", () => {
      editLinkEle.remove();
      res({ type: "cancel" });
    });
    editLinkEle.addEventListener("editLink", (e) => {
      if (abortController.signal.aborted) {
        return;
      }
      editLinkEle.type = "edit";
      editLinkEle.showMask = true;
      editLinkEle.text = text;
      unsubscribeHoverAbort();
      requestAnimationFrame(() => {
        updatePosition(editLinkEle, anchorEl);
      });
    });
    editLinkEle.addEventListener("updateLink", (e) => {
      if (abortController.signal.aborted) {
        return;
      }
      editLinkEle.remove();
      res(e.detail);
    });
  });
}

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/virgo/affine-text.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function affineTextStyles(props, override) {
  let textDecorations = "";
  if (props.underline) {
    textDecorations += "underline";
  }
  if (props.strike) {
    textDecorations += " line-through";
  }
  let inlineCodeStyle = {};
  if (props.code) {
    inlineCodeStyle = {
      "font-family": "var(--affine-font-code-family)",
      background: "var(--affine-background-code-block)",
      color: "var(--affine-text-primary-color)",
      "border-radius": "4px",
      padding: "3px 6px",
      "font-size": "calc(var(--affine-font-base) - 4px)",
      "font-variant-ligatures": "none",
      "line-height": "var(--affine-font-base)",
      border: "1px solid var(--affine-border-color)"
    };
  }
  return styleMap({
    "font-weight": props.bold ? "bold" : "normal",
    "font-style": props.italic ? "italic" : "normal",
    "text-decoration": textDecorations.length > 0 ? textDecorations : "none",
    ...inlineCodeStyle,
    ...override
  });
}
var AffineText = class AffineText2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.delta = {
      insert: ZERO_WIDTH_SPACE
    };
  }
  render() {
    const style = this.delta.attributes ? affineTextStyles(this.delta.attributes) : styleMap({});
    return html`<span style=${style}
      ><v-text .str=${this.delta.insert}></v-text
    ></span>`;
  }
};
AffineText.styles = css`
    affine-text {
      white-space: break-spaces;
      word-break: break-word;
    }
  `;
__decorate12([
  property({ type: Object })
], AffineText.prototype, "delta", void 0);
AffineText = __decorate12([
  customElement("affine-text")
], AffineText);

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/link-node/affine-link.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AffineLink = class AffineLink2 extends ShadowlessElement {
  get link() {
    var _a3;
    const link = (_a3 = this.delta.attributes) == null ? void 0 : _a3.link;
    if (!link) {
      return "";
    }
    return link;
  }
  constructor() {
    super();
    this.delta = {
      insert: ZERO_WIDTH_SPACE
    };
    this.popoverHoverOpenDelay = 150;
    this._popoverTimer = 0;
    this._isHovering = false;
    this.addEventListener("mouseenter", this.onHover);
    this.addEventListener("mouseleave", this._onHoverEnd);
  }
  onHover(e) {
    if (this._isHovering) {
      return;
    } else {
      this._isHovering = true;
    }
    const model = getModelByElement(this);
    if (model.page.readonly)
      return;
    this._popoverTimer = window.setTimeout(() => {
      this.onDelayHover(e);
    }, this.popoverHoverOpenDelay);
  }
  async onDelayHover(e) {
    if (!(e.target instanceof HTMLElement) || !document.contains(e.target)) {
      return;
    }
    const model = getModelByElement(this);
    const text = this.delta.insert;
    const linkState = await showLinkPopover({
      anchorEl: e.target,
      page: model.page,
      text,
      link: this.link,
      showMask: false,
      interactionKind: "hover"
    });
    if (linkState.type === "confirm") {
      const link = linkState.link;
      const newText = linkState.text;
      const isUpdateText = newText !== text;
      this._updateLink(link, isUpdateText ? newText : void 0);
      return;
    }
    if (linkState.type === "remove") {
      this._updateLink();
      return;
    }
    if (linkState.type === "toBookmark") {
      this._onConvertToBookmark();
      return;
    }
  }
  /**
   * If no pass text, use the original text
   */
  _updateLink(link, text) {
    const model = getModelByElement(this);
    const { page } = model;
    const oldStr = this.delta.insert;
    const oldTextAttributes = this.delta.attributes;
    const textElement = this.querySelector('[data-virgo-text="true"]');
    assertExists(textElement);
    const textNode = Array.from(textElement.childNodes).find((node) => node instanceof Text);
    assertExists(textNode);
    const richText = this.closest("rich-text");
    assertExists(richText);
    const domPoint = VEditor.textPointToDomPoint(textNode, 0, richText.virgoContainer);
    assertExists(domPoint);
    const vEditor = richText.vEditor;
    assertExists(vEditor);
    if (link) {
      if (text) {
        page.captureSync();
        vEditor.deleteText({
          index: domPoint.index,
          length: textNode.length
        });
        vEditor.insertText({ index: domPoint.index, length: 0 }, text);
        vEditor.formatText({
          index: domPoint.index,
          length: text.length
        }, { link });
      } else {
        page.captureSync();
        vEditor.formatText({
          index: domPoint.index,
          length: oldStr.length
        }, { link });
      }
    } else {
      page.captureSync();
      const newAttributes = { ...oldTextAttributes };
      delete newAttributes.link;
      vEditor.formatText({
        index: domPoint.index,
        length: oldStr.length
      }, newAttributes, {
        mode: "replace"
      });
    }
  }
  _onConvertToBookmark() {
    const model = getModelByElement(this);
    const { page } = model;
    const textElement = this.querySelector('[data-virgo-text="true"]');
    assertExists(textElement);
    const textNode = Array.from(textElement.childNodes).find((node) => node instanceof Text);
    assertExists(textNode);
    const richText = this.closest("rich-text");
    assertExists(richText);
    const domPoint = VEditor.textPointToDomPoint(textNode, 0, richText.virgoContainer);
    assertExists(domPoint);
    const vEditor = richText.vEditor;
    assertExists(vEditor);
    const parent = page.getParent(model);
    assertExists(parent);
    const index = parent.children.indexOf(model);
    page.addBlock("affine:bookmark", { url: this.link, title: this.delta.insert }, parent, index + 1);
    vEditor.deleteText({
      index: domPoint.index,
      length: textNode.length
    });
  }
  _onHoverEnd(e) {
    this._isHovering = false;
    clearTimeout(this._popoverTimer);
  }
  // Workaround for links not working in contenteditable div
  // see also https://stackoverflow.com/questions/12059211/how-to-make-clickable-anchor-in-contenteditable-div
  //
  // Note: We cannot use JS to directly open a new page as this may be blocked by the browser.
  //
  // Please also note that when readonly mode active,
  // this workaround is not necessary and links work normally.
  // see https://github.com/toeverything/AFFiNE/issues/1540
  _onMouseUp(e) {
    const anchorElement = this.querySelector("a");
    assertExists(anchorElement);
    if (!anchorElement.isContentEditable)
      return;
    anchorElement.contentEditable = "false";
    setTimeout(() => {
      anchorElement.removeAttribute("contenteditable");
    }, 0);
  }
  render() {
    const style = this.delta.attributes ? affineTextStyles(this.delta.attributes) : styleMap({});
    return html`<a
      href=${this.link}
      rel="noopener noreferrer"
      target="_blank"
      style=${style}
      @mouseup=${this._onMouseUp}
      >${FontLinkIcon}<v-text .str=${this.delta.insert}></v-text
    ></a>`;
  }
};
AffineLink.styles = css`
    affine-link > a {
      white-space: nowrap;
      word-break: break-word;
      color: var(--affine-link-color);
      fill: var(--affine-link-color);
      text-decoration: none;
      cursor: pointer;
    }

    affine-link > a:hover [data-virgo-text='true'] {
      text-decoration: underline;
    }

    affine-link > a > v-text {
      white-space: break-spaces;
    }
  `;
__decorate13([
  property({ type: Object })
], AffineLink.prototype, "delta", void 0);
__decorate13([
  property()
], AffineLink.prototype, "popoverHoverOpenDelay", void 0);
__decorate13([
  state()
], AffineLink.prototype, "_popoverTimer", void 0);
AffineLink = __decorate13([
  customElement("affine-link")
], AffineLink);

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/link-node/mock-selection.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LinkMockSelection = class LinkMockSelection2 extends LitElement {
  constructor(rects) {
    super();
    this.rects = rects;
  }
  render() {
    return html`
      ${this.rects.map((rect) => html`<div
          style="${styleMap({
      position: "absolute",
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      top: `${rect.top}px`,
      left: `${rect.left}px`,
      backgroundColor: "rgba(35, 131, 226, 0.28)"
    })}"
        ></div>`)}
    `;
  }
};
LinkMockSelection = __decorate14([
  customElement("link-mock-selection")
], LinkMockSelection);

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/link-node/create-link.js
function createLink(page) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange)
    return;
  if (blockRange.models.length > 1) {
    throw new Error("Can't create link with multiple blocks for now");
  }
  const startModel = blockRange.models[0];
  if (!startModel)
    return;
  const vEditor = getVirgoByModel(startModel);
  assertExists(vEditor);
  const vRange = {
    index: blockRange.startOffset,
    length: blockRange.endOffset - blockRange.startOffset
  };
  if (vRange.length === 0) {
    return;
  }
  const format = vEditor.getFormat(vRange);
  if (format.link) {
    page.captureSync();
    vEditor.formatText(vRange, { link: null });
    vEditor.setVRange(vRange);
    return;
  }
  const range = blockRangeToNativeRange(blockRange);
  assertExists(range);
  const rects = Array.from(range.getClientRects());
  const container = getEditorContainer(page);
  assertExists(container);
  const containerRect = container.getBoundingClientRect();
  const mockSelection = new LinkMockSelection(rects.map((rect) => new DOMRect(rect.left - containerRect.left, rect.top - containerRect.top, rect.width, rect.height)));
  const affineEditorContainer = getEditorContainer(page);
  assertExists(affineEditorContainer);
  affineEditorContainer.appendChild(mockSelection);
  setTimeout(async () => {
    var _a3;
    const linkState = await showLinkPopover({
      anchorEl: (_a3 = mockSelection.shadowRoot) == null ? void 0 : _a3.querySelector("div"),
      page
    });
    mockSelection.remove();
    if (linkState.type !== "confirm")
      return;
    const link = linkState.link;
    page.captureSync();
    vEditor.formatText(vRange, { link });
    vEditor.setVRange(vRange);
  });
}

// node_modules/@blocksuite/blocks/dist/page-block/utils/format-config.js
var formatConfig = [
  {
    id: "bold",
    name: "Bold",
    icon: BoldIcon,
    hotkey: `${SHORT_KEY}+b`,
    activeWhen: (format) => "bold" in format,
    showWhen: (models) => noneCodeBlockSelected(models),
    action: ({ page }) => {
      handleFormat(page, "bold");
    }
  },
  {
    id: "italic",
    name: "Italic",
    icon: ItalicIcon,
    hotkey: `${SHORT_KEY}+i`,
    activeWhen: (format) => "italic" in format,
    showWhen: (models) => noneCodeBlockSelected(models),
    action: ({ page }) => {
      handleFormat(page, "italic");
    }
  },
  {
    id: "underline",
    name: "Underline",
    icon: UnderlineIcon,
    hotkey: `${SHORT_KEY}+u`,
    activeWhen: (format) => "underline" in format,
    showWhen: (models) => noneCodeBlockSelected(models),
    action: ({ page }) => {
      handleFormat(page, "underline");
    }
  },
  {
    id: "strike",
    name: "Strikethrough",
    icon: StrikethroughIcon,
    hotkey: `${SHORT_KEY}+shift+s`,
    activeWhen: (format) => "strike" in format,
    showWhen: (models) => noneCodeBlockSelected(models),
    action: ({ page }) => {
      handleFormat(page, "strike");
    }
  },
  {
    id: "code",
    name: "Code",
    icon: InlineCodeIcon,
    hotkey: `${SHORT_KEY}+e`,
    activeWhen: (format) => "code" in format,
    showWhen: (models) => noneCodeBlockSelected(models),
    action: ({ page }) => {
      handleFormat(page, "code");
    }
  },
  {
    id: "link",
    name: "Link",
    icon: LinkIcon,
    hotkey: `${SHORT_KEY}+k`,
    activeWhen: (format) => "link" in format,
    // Only can show link button when selection is in one line paragraph
    showWhen: (models) => models.length === 1 && noneCodeBlockSelected(models) && // can't create link when selection includes reference node
    // XXX get loose format at here is not a good practice
    !getCurrentCombinedFormat(models[0].page, true).reference,
    action: ({ page, abortController, format }) => {
      createLink(page);
      if (format && abortController && !("link" in format)) {
        abortController.abort();
      }
    }
  }
];
function noneCodeBlockSelected(models) {
  return !models.every((model) => model.flavour === "affine:code");
}

// node_modules/@blocksuite/blocks/dist/components/format-quick-bar/styles.js
var paragraphPanelStyle = css`
  .paragraph-button > svg:nth-child(2) {
    transition-duration: 0.3s;
  }
  .paragraph-button:is(:hover, :focus-visible, :active) > svg:nth-child(2) {
    transform: rotate(180deg);
  }

  .paragraph-panel {
    font-size: var(--affine-font-sm);
    box-sizing: border-box;
    position: absolute;
    min-width: 173px;
    padding: 8px 4px;
    overflow-y: auto;

    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-shadow-2);
    border-radius: 8px;
    z-index: var(--affine-z-index-popover);
  }
`;
var formatQuickBarStyle = css`
  .format-quick-bar {
    box-sizing: border-box;
    position: fixed;
    display: flex;
    align-items: center;
    padding: 4px 8px;
    gap: 4px;
    height: 40px;

    border-radius: 8px;
    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-shadow-2);
    z-index: var(--affine-z-index-popover);
    user-select: none;
  }

  .divider {
    width: 1px;
    height: 24px;
    background-color: var(--affine-border-color);
  }

  format-bar-button svg {
    width: 20px;
    height: 20px;
  }

  ${paragraphPanelStyle}
  ${tooltipStyle}
`;

// node_modules/@blocksuite/blocks/dist/components/format-quick-bar/format-bar-node.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FormatQuickBar_1;
function ParagraphPanel(showParagraphPanel, paragraphPanelMaxHeight, paragraphType, models, positionUpdated, onHover, onHoverEnd, onUpdateModels, onParagraphTypeChange) {
  if (showParagraphPanel === "hidden") {
    return html``;
  }
  const page = models[0].page;
  assertExists(page);
  const styles15 = styleMap({
    left: "0",
    top: showParagraphPanel === "bottom" ? "calc(100% + 4px)" : null,
    bottom: showParagraphPanel === "top" ? "calc(100% + 4px)" : null,
    maxHeight: paragraphPanelMaxHeight
  });
  const updateParagraphType = (flavour, type) => {
    const alreadyTargetType = paragraphType === `${flavour}/${type}`;
    const { flavour: defaultFlavour, type: defaultType } = paragraphConfig[0];
    const targetFlavour = alreadyTargetType ? defaultFlavour : flavour;
    const targetType = alreadyTargetType ? defaultType : type;
    const newModels = updateBlockType(models, targetFlavour, targetType);
    if (targetFlavour === "affine:code") {
      if (newModels.length !== 1) {
        throw new Error("Failed to reset selection! New model length isn't 1");
      }
      const codeModel = newModels[0];
      onModelElementUpdated(codeModel, () => {
        var _a3;
        restoreSelection({
          type: "Block",
          startOffset: 0,
          endOffset: ((_a3 = codeModel.text) == null ? void 0 : _a3.length) ?? 0,
          models: [codeModel]
        });
      });
    }
    onUpdateModels(newModels);
    onParagraphTypeChange(`${targetFlavour}/${targetType}`);
    positionUpdated.emit();
  };
  return html` <div
    class="paragraph-panel"
    style="${styles15}"
    @mouseover="${onHover}"
    @mouseout="${onHoverEnd}"
  >
    ${paragraphConfig.filter(({ flavour }) => flavour !== "affine:divider").filter(({ flavour }) => page.schema.flavourSchemaMap.has(flavour)).map(({ flavour, type, name, icon }) => html`<format-bar-button
          width="100%"
          style="padding-left: 12px; justify-content: flex-start;"
          text="${name}"
          data-testid="${flavour}/${type}"
          @click="${() => updateParagraphType(flavour, type)}"
        >
          ${icon}
        </format-bar-button>`)}
  </div>`;
}
var FormatQuickBar = FormatQuickBar_1 = class FormatQuickBar2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.left = null;
    this.top = null;
    this.abortController = new AbortController();
    this.positionUpdated = new Slot();
    this.models = [];
    this._paragraphType = `${paragraphConfig[0].flavour}/${paragraphConfig[0].type}`;
    this._paragraphPanelHoverDelay = 150;
    this._paragraphPanelTimer = 0;
    this._showParagraphPanel = "hidden";
    this.paragraphPanelMaxHeight = null;
    this._format = {};
    this._customElements = [];
    this._selectionChangeHandler = () => {
      const blockRange = getCurrentBlockRange(this.page);
      if (!blockRange) {
        this.abortController.abort();
        return;
      }
      if (blockRange.type === "Native" && blockRange.models.length === 1 && blockRange.startOffset === blockRange.endOffset) {
        this.abortController.abort();
        return;
      }
      this._format = getCurrentCombinedFormat(this.page);
      this.positionUpdated.emit();
    };
  }
  update(changedProperties) {
    super.update(changedProperties);
    if (this._customElements.length === 0 && FormatQuickBar_1.customElements.length !== 0) {
      this._customElements = FormatQuickBar_1.customElements.map((element) => element(this.page, () => getCurrentBlockRange(this.page)));
      this.customItemsElement.append(...this._customElements);
      this._disposables.add(() => {
        this._customElements.forEach((element) => {
          element.remove();
        });
        this._customElements = [];
        this.customItemsElement.innerHTML = "";
      });
    }
  }
  connectedCallback() {
    super.connectedCallback();
    const startModel = this.models[0];
    this._paragraphType = `${startModel.flavour}/${startModel.type}`;
    this._format = getCurrentCombinedFormat(this.page);
    this.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    this.abortController.signal.addEventListener("abort", () => {
      this.remove();
    });
    document.addEventListener("selectionchange", this._selectionChangeHandler);
    const mutationObserver = new MutationObserver(() => {
      if (!this.page) {
        return;
      }
      this._format = getCurrentCombinedFormat(this.page);
    });
    this.models.forEach((model) => {
      const richText = getRichTextByModel(model);
      if (!richText) {
        console.warn("Format quick bar may not work properly! Cannot find rich text node by model. model:", model);
        return;
      }
      mutationObserver.observe(richText, {
        // One or more children have been added to and/or removed
        // from the tree.
        childList: true,
        // Omit (or set to false) to observe only changes to the parent node
        subtree: true
      });
    });
    this._disposables.add(() => mutationObserver.disconnect());
    this._disposables.add(() => document.removeEventListener("selectionchange", this._selectionChangeHandler));
  }
  _onHover() {
    if (this._showParagraphPanel !== "hidden") {
      clearTimeout(this._paragraphPanelTimer);
      return;
    }
    this._paragraphPanelTimer = window.setTimeout(async () => {
      const { placement, height } = compareTopAndBottomSpace(this.formatQuickBarElement, document.body, 10);
      this._showParagraphPanel = placement;
      this.paragraphPanelMaxHeight = height + "px";
    }, this._paragraphPanelHoverDelay);
  }
  _onHoverEnd() {
    if (this._showParagraphPanel !== "hidden") {
      this._paragraphPanelTimer = window.setTimeout(async () => {
        this._showParagraphPanel = "hidden";
      }, this._paragraphPanelHoverDelay * 2);
      return;
    }
    clearTimeout(this._paragraphPanelTimer);
  }
  render() {
    var _a3;
    const page = this.page;
    if (!this.models.length || !page) {
      console.error("Failed to render format-quick-bar! no model or page not found!", this.models, page);
      return html``;
    }
    const styles15 = styleMap({
      left: this.left,
      top: this.top
    });
    const actionItems = actionConfig.filter(({ showWhen = () => true }) => showWhen(page, this.models)).map(({ id, name, icon, action, enabledWhen, disabledToolTip }) => {
      const enabled = enabledWhen(page);
      const toolTip = enabled ? html`<tool-tip inert role="tooltip">${name}</tool-tip>` : html`<tool-tip tip-position="top" inert role="tooltip"
              >${disabledToolTip}</tool-tip
            >`;
      return html`<format-bar-button
          class="has-tool-tip"
          data-testid=${id}
          ?disabled=${!enabled}
          @click=${() => enabled && action({ page })}
        >
          ${icon}${toolTip}
        </format-bar-button>`;
    });
    if (this.models.length === 1 && matchFlavours(this.models[0], ["affine:database"])) {
      return html`<div
        class="format-quick-bar"
        style="${styles15}"
        @pointerdown=${stopPropagation}
      >
        ${actionItems}
      </div>`;
    }
    const paragraphIcon = ((_a3 = paragraphConfig.find(({ flavour, type }) => `${flavour}/${type}` === this._paragraphType)) == null ? void 0 : _a3.icon) ?? paragraphConfig[0].icon;
    const paragraphItems = html` <format-bar-button
      class="paragraph-button"
      width="52px"
      @mouseover="${this._onHover}"
      @mouseout="${this._onHoverEnd}"
    >
      ${paragraphIcon} ${ArrowDownIcon}
    </format-bar-button>`;
    const paragraphPanel = ParagraphPanel(this._showParagraphPanel, this.paragraphPanelMaxHeight, this._paragraphType, this.models, this.positionUpdated, this._onHover, this._onHoverEnd, (newModels) => this.models = newModels, (paragraphType) => this._paragraphType = paragraphType);
    const formatItems = formatConfig.filter(({ showWhen = () => true }) => showWhen(this.models)).map(({ id, name, icon, action, activeWhen }) => html` <format-bar-button
          class="has-tool-tip"
          data-testid=${id}
          ?active=${activeWhen(this._format)}
          @click=${() => {
      action({
        page,
        abortController: this.abortController,
        format: this._format
      });
      this._format = getCurrentCombinedFormat(page);
      this.positionUpdated.emit();
    }}
        >
          ${icon}
          <tool-tip inert role="tooltip">${name}</tool-tip>
        </format-bar-button>`);
    return html` <div
      class="format-quick-bar"
      style="${styles15}"
      @pointerdown=${stopPropagation}
    >
      <div class="custom-items"></div>
      ${this._customElements.length > 0 ? html`<div class="divider"></div>` : null}
      ${paragraphItems}
      <div class="divider"></div>
      ${formatItems}
      ${formatItems.length ? html` <div class="divider"></div>` : ""}
      ${actionItems} ${paragraphPanel}
    </div>`;
  }
};
FormatQuickBar.styles = formatQuickBarStyle;
FormatQuickBar.customElements = [];
__decorate15([
  property()
], FormatQuickBar.prototype, "page", void 0);
__decorate15([
  property()
], FormatQuickBar.prototype, "left", void 0);
__decorate15([
  property()
], FormatQuickBar.prototype, "top", void 0);
__decorate15([
  property()
], FormatQuickBar.prototype, "abortController", void 0);
__decorate15([
  property()
], FormatQuickBar.prototype, "positionUpdated", void 0);
__decorate15([
  property()
], FormatQuickBar.prototype, "models", void 0);
__decorate15([
  state()
], FormatQuickBar.prototype, "_paragraphType", void 0);
__decorate15([
  state()
], FormatQuickBar.prototype, "_paragraphPanelHoverDelay", void 0);
__decorate15([
  state()
], FormatQuickBar.prototype, "_paragraphPanelTimer", void 0);
__decorate15([
  state()
], FormatQuickBar.prototype, "_showParagraphPanel", void 0);
__decorate15([
  state()
], FormatQuickBar.prototype, "_format", void 0);
__decorate15([
  query(".format-quick-bar")
], FormatQuickBar.prototype, "formatQuickBarElement", void 0);
__decorate15([
  query(".custom-items")
], FormatQuickBar.prototype, "customItemsElement", void 0);
FormatQuickBar = FormatQuickBar_1 = __decorate15([
  customElement("format-quick-bar")
], FormatQuickBar);

// node_modules/@blocksuite/blocks/dist/components/format-quick-bar/index.js
var formatQuickBarInstance = null;
var showFormatQuickBar = async ({ page, anchorEl, direction = "right-bottom", container = document.body, abortController = new AbortController() }) => {
  if (formatQuickBarInstance) {
    return;
  }
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange) {
    return;
  }
  blockRange.models = blockRange.models.filter((model) => matchFlavours(model, [
    "affine:paragraph",
    "affine:list",
    "affine:code",
    "affine:database"
  ]));
  const models = blockRange.models;
  if (models.length === 0) {
    return;
  }
  if (matchFlavours(models[0], ["affine:database"]) && blockRange.type === "Native") {
    return;
  }
  const formatQuickBar = new FormatQuickBar();
  formatQuickBar.page = page;
  formatQuickBar.models = models;
  formatQuickBar.abortController = abortController;
  const positionUpdatedSlot = new Slot();
  formatQuickBar.positionUpdated = positionUpdatedSlot;
  formatQuickBarInstance = formatQuickBar;
  abortController.signal.addEventListener("abort", () => {
    formatQuickBarInstance = null;
  });
  const updatePos = throttle(() => {
    if (abortController.signal.aborted) {
      return;
    }
    const positioningPoint = anchorEl instanceof Range ? calcPositionPointByRange(anchorEl, direction) : anchorEl.getBoundingClientRect();
    const boundaryRect = document.body.getBoundingClientRect();
    const formatBarRect = formatQuickBar.formatQuickBarElement.getBoundingClientRect();
    const gapY = 5;
    const isBottom = direction.includes("bottom");
    const safeCoordinate = calcSafeCoordinate({
      positioningPoint,
      objRect: formatBarRect,
      boundaryRect,
      // place the format bar in the center of the position point
      offsetX: -formatBarRect.width / 2,
      offsetY: isBottom ? gapY : -formatBarRect.height - gapY
    });
    formatQuickBar.left = `${safeCoordinate.x}px`;
    formatQuickBar.top = `${safeCoordinate.y}px`;
  }, 10);
  if (!page.root) {
    throw new Error("Failed to get page's root element");
  }
  const scrollContainer = getViewportElement(page);
  if (scrollContainer) {
    scrollContainer.addEventListener("scroll", updatePos, { passive: true });
  }
  positionUpdatedSlot.on(updatePos);
  window.addEventListener("resize", updatePos, { passive: true });
  container.appendChild(formatQuickBar);
  const pointerDownHandler = (e) => {
    if (e.target === formatQuickBar) {
      return;
    }
    abortController.abort();
  };
  const popstateHandler = () => {
    abortController.abort();
  };
  document.addEventListener("pointerdown", pointerDownHandler);
  window.addEventListener("popstate", popstateHandler);
  onModelElementUpdated(blockRange.models[0], updatePos);
  abortController.signal.addEventListener("abort", () => {
    scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", updatePos);
    window.removeEventListener("resize", updatePos);
    document.removeEventListener("pointerdown", pointerDownHandler);
    window.removeEventListener("popstate", popstateHandler);
    positionUpdatedSlot.dispose();
  });
  return formatQuickBar;
};

// node_modules/@blocksuite/blocks/dist/components/utils.js
var createKeydownObserver = ({ target, onUpdateQuery, onMove, onConfirm, onEsc, interceptor = (e, next2) => next2(), abortController }) => {
  var _a3;
  let query2 = "";
  const vEditor = target.vEditor;
  assertExists(vEditor, "Failed to observer keyboard! virgo editor is not exist.");
  const startIndex = ((_a3 = vEditor == null ? void 0 : vEditor.getVRange()) == null ? void 0 : _a3.index) ?? 0;
  const updateQuery = async () => {
    var _a4;
    await sleep(0);
    const range = getCurrentNativeRange();
    if (range.startContainer !== range.endContainer) {
      console.warn("Failed to parse query! Current range is not collapsed.", range);
      abortController.abort();
      return;
    }
    const textNode = range.startContainer;
    if (textNode.nodeType !== Node.TEXT_NODE) {
      console.warn("Failed to parse query! Current range is not a text node.", range);
      abortController.abort();
      return;
    }
    const curIndex = ((_a4 = vEditor.getVRange()) == null ? void 0 : _a4.index) ?? 0;
    const text = vEditor.yText.toString();
    const previousQuery = query2;
    query2 = text.slice(startIndex, curIndex);
    if (query2 !== previousQuery) {
      onUpdateQuery(query2);
    }
  };
  const keyDownListener = (e) => {
    e.stopPropagation();
    if (e.defaultPrevented)
      return;
    if (isControlledKeyboardEvent(e)) {
      const isOnlyCmd = (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey;
      if (isOnlyCmd && e.key.length === 1) {
        switch (e.key) {
          case "P":
          case "p": {
            onMove(-1);
            e.preventDefault();
            return;
          }
          case "N":
          case "n": {
            onMove(1);
            e.preventDefault();
            return;
          }
        }
      }
      if (e.key === "Control" || e.key === "Meta" || e.key === "Alt") {
        return;
      }
      abortController.abort();
      return;
    }
    if (isControlledKeyboardEvent(e) || e.key.length !== 1) {
      switch (e.key) {
        case "Escape": {
          abortController.abort();
          return;
        }
        case "Backspace": {
          if (!query2.length) {
            abortController.abort();
          }
          updateQuery();
          return;
        }
        case "Enter": {
          if (e.isComposing) {
            return;
          }
          if (e.shiftKey) {
            abortController.abort();
            return;
          }
          onConfirm();
          e.preventDefault();
          return;
        }
        case "Tab": {
          if (e.shiftKey) {
            onMove(-1);
          } else {
            onMove(1);
          }
          e.preventDefault();
          return;
        }
        case "ArrowUp": {
          if (e.shiftKey) {
            abortController.abort();
            return;
          }
          onMove(-1);
          e.preventDefault();
          return;
        }
        case "ArrowDown": {
          if (e.shiftKey) {
            abortController.abort();
            return;
          }
          onMove(1);
          e.preventDefault();
          return;
        }
        case "ArrowLeft":
        case "ArrowRight": {
          abortController.abort();
          return;
        }
        default:
          return;
      }
    }
    updateQuery();
  };
  target.addEventListener("keydown", (e) => interceptor(e, () => keyDownListener(e)), {
    // Workaround: Use capture to prevent the event from triggering the keyboard bindings action
    capture: true,
    signal: abortController.signal
  });
  target.addEventListener("input", updateQuery, {
    signal: abortController.signal
  });
  if (onEsc) {
    const escListener = (e) => {
      if (e.key === "Escape") {
        onEsc();
      }
    };
    window.addEventListener("keydown", escListener, {
      signal: abortController.signal
    });
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/reference-node.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var REFERENCE_NODE = " ";
var DEFAULT_PAGE_NAME2 = "Untitled";
var AffineReference = class AffineReference2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this.delta = {
      insert: ZERO_WIDTH_SPACE,
      attributes: {}
    };
    this._refAttribute = {
      type: "LinkedPage",
      pageId: "0"
    };
    this._updateRefMeta = (page) => {
      var _a3;
      const refAttribute = (_a3 = this.delta.attributes) == null ? void 0 : _a3.reference;
      assertExists(refAttribute, "Failed to get reference attribute!");
      this._refAttribute = refAttribute;
      this._refMeta = page.workspace.meta.pageMetas.find((page2) => page2.id === refAttribute.pageId);
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.delta.insert !== REFERENCE_NODE) {
      console.error(`Reference node must be initialized with '${REFERENCE_NODE}', but got '${this.delta.insert}'`);
    }
    const model = getModelByElement(this);
    const page = model.page;
    this._updateRefMeta(page);
    this._disposables.add(model.page.workspace.slots.pagesUpdated.on(() => this._updateRefMeta(page)));
  }
  _onClick(e) {
    const refMeta = this._refMeta;
    const model = getModelByElement(this);
    if (!refMeta) {
      console.warn("The page is deleted", this._refAttribute.pageId);
      return;
    }
    if (refMeta.id === model.page.id) {
      return;
    }
    const targetPageId = refMeta.id;
    const root2 = model.page.root;
    assertExists(root2);
    const element = getBlockElementById(root2 == null ? void 0 : root2.id);
    assertExists(element);
    element.slots.pageLinkClicked.emit({ pageId: targetPageId });
  }
  render() {
    var _a3;
    const refMeta = this._refMeta;
    const unavailable = !refMeta;
    const title = unavailable ? (
      // Maybe the page is deleted
      "Deleted page"
    ) : refMeta.title;
    const attributes = this.delta.attributes;
    assertExists(attributes, "Failed to get attributes!");
    const type = (_a3 = attributes.reference) == null ? void 0 : _a3.type;
    assertExists(type, "Unable to get reference type!");
    const style = affineTextStyles(attributes, unavailable ? {
      color: "var(--affine-text-disable-color)",
      fill: "var(--affine-text-disable-color)"
    } : {});
    return html`<span
      class="affine-reference"
      style=${style}
      @click=${this._onClick}
      >${type === "LinkedPage" ? FontLinkedPageIcon : FontPageIcon}<span
        class="affine-reference-title"
        data-title=${title || DEFAULT_PAGE_NAME2}
        data-virgo-text="true"
        data-virgo-text-value=${ZERO_WIDTH_NON_JOINER}
        >${ZERO_WIDTH_NON_JOINER}</span
      ></span
    >`;
  }
};
AffineReference.styles = css`
    .affine-reference {
      white-space: nowrap;
      word-break: break-word;
      color: var(--affine-link-color);
      fill: var(--affine-link-color);
      border-radius: 2px;
      text-decoration: none;
      cursor: pointer;
      user-select: none;
      padding: 0 2px;
      margin: 0 2px;
    }
    .affine-reference:hover {
      background: var(--affine-hover-color);
    }

    .affine-reference > svg {
      margin-right: 4px;
    }

    .affine-reference > span {
      white-space: break-spaces;
    }

    .affine-reference-title {
      color: var(--affine-text-primary-color);
    }
    .affine-reference-title::before {
      content: attr(data-title);
      color: var(--affine-link-color);
    }
  `;
__decorate16([
  property({ type: Object })
], AffineReference.prototype, "delta", void 0);
__decorate16([
  state()
], AffineReference.prototype, "_refMeta", void 0);
AffineReference = __decorate16([
  customElement("affine-reference")
], AffineReference);

// node_modules/lit-html/development/directives/class-map.js
var ClassMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a3;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class" || ((_a3 = partInfo.strings) === null || _a3 === void 0 ? void 0 : _a3.length) > 2) {
      throw new Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
  }
  render(classInfo) {
    return " " + Object.keys(classInfo).filter((key) => classInfo[key]).join(" ") + " ";
  }
  update(part, [classInfo]) {
    var _a3, _b;
    if (this._previousClasses === void 0) {
      this._previousClasses = /* @__PURE__ */ new Set();
      if (part.strings !== void 0) {
        this._staticClasses = new Set(part.strings.join(" ").split(/\s/).filter((s) => s !== ""));
      }
      for (const name in classInfo) {
        if (classInfo[name] && !((_a3 = this._staticClasses) === null || _a3 === void 0 ? void 0 : _a3.has(name))) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    this._previousClasses.forEach((name) => {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    });
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (value !== this._previousClasses.has(name) && !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
};
var classMap = directive(ClassMapDirective);

// node_modules/@blocksuite/blocks/dist/components/drag-handle.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var handlePreventDocumentDragOverDelay = (event) => {
  event.preventDefault();
};
var DragIndicator = class DragIndicator2 extends LitElement {
  constructor() {
    super(...arguments);
    this.rect = null;
  }
  render() {
    if (!this.rect) {
      return null;
    }
    const { left: left2, top: top2, width, height } = this.rect;
    const style = styleMap({
      width: `${width}px`,
      height: `${height}px`,
      transform: `translate(${left2}px, ${top2}px)`
    });
    return html`<div class="affine-drag-indicator" style=${style}></div>`;
  }
};
DragIndicator.styles = css`
    .affine-drag-indicator {
      position: absolute;
      top: 0;
      left: 0;
      background: var(--affine-primary-color);
      transition-property: width, height, transform;
      transition-duration: 100ms;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-delay: 0s;
      transform-origin: 0 0;
      pointer-events: none;
      z-index: 1;
    }
  `;
__decorate17([
  property()
], DragIndicator.prototype, "rect", void 0);
DragIndicator = __decorate17([
  customElement("affine-drag-indicator")
], DragIndicator);
var DragPreview = class DragPreview2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.offset = { x: 0, y: 0 };
  }
  render() {
    return html`<style>
      affine-drag-preview {
        --x: 0px;
        --y: 0px;
        height: auto;
        display: block;
        position: absolute;
        box-sizing: border-box;
        font-family: var(--affine-font-family);
        font-size: var(--affine-font-base);
        line-height: var(--affine-line-height);
        color: var(--affine-text-primary-color);
        font-weight: 400;
        top: 0;
        left: 0;
        opacity: 0.843;
        cursor: none;
        user-select: none;
        pointer-events: none;
        caret-color: transparent;
        transform-origin: 0 0;
        z-index: 2;
      }

      affine-drag-preview > .affine-block-element {
        pointer-events: none;
      }

      affine-drag-preview > .affine-block-element:first-child > *:first-child {
        margin-top: 0;
      }

      affine-drag-preview .affine-rich-text {
        user-modify: read-only;
        -webkit-user-modify: read-only;
      }

      affine-drag-preview.grabbing {
        cursor: grabbing;
        pointer-events: auto;
      }

      affine-drag-preview.grabbing:after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 24px;
        height: 24px;
        transform: translate(var(--x), var(--y));
      }
    </style>`;
  }
};
__decorate17([
  property()
], DragPreview.prototype, "offset", void 0);
DragPreview = __decorate17([
  customElement("affine-drag-preview")
], DragPreview);
var DRAG_HANDLE_HEIGHT = 16;
var DRAG_HANDLE_WIDTH = 24;
var DragHandle = class DragHandle2 extends WithDisposable(LitElement) {
  constructor(options2) {
    super();
    this._draggingElements = [];
    this._scale = 1;
    this._currentClientX = 0;
    this._currentClientY = 0;
    this._stopPropagation = false;
    this._handleAnchorState = null;
    this._handleAnchorDisposable = null;
    this._lastDroppingTarget = null;
    this._lastDroppingType = "none";
    this._indicator = null;
    this._dragPreview = null;
    this._onClick = (e) => {
      const { selectedBlocks } = this;
      let { _handleAnchorState: modelState } = this;
      const element = modelState == null ? void 0 : modelState.element;
      if (modelState && selectedBlocks.length && element === selectedBlocks[0]) {
        modelState = null;
      }
      this.setSelectedBlock(modelState, element);
      this.toggleAttribute("data-selected", Boolean(modelState));
      e.stopPropagation();
    };
    this._onDragOverDocument = (e) => {
      if (!isFirefox) {
        throw new Error("FireFox only");
      }
      this._currentClientX = e.clientX;
      this._currentClientY = e.clientY;
    };
    this.onDragStart = (e, draggable = false) => {
      if (this._dragPreview || !e.dataTransfer)
        return;
      e.dataTransfer.effectAllowed = "move";
      const modelState = this._handleAnchorState;
      let draggingBlockElements = this.selectedBlocks;
      if (modelState && !draggingBlockElements.includes(modelState.element)) {
        draggingBlockElements = [modelState.element];
        this.setSelectedBlock(modelState);
      }
      this._draggingElements = draggingBlockElements;
      this._createDragPreview(e, getBlockElementsExcludeSubtrees(draggingBlockElements), draggable);
      this.setDragType(true);
    };
    this.onDrag = (e, passed, isScrolling) => {
      this._dragHandle.style.cursor = "grabbing";
      let x = e.clientX;
      let y = e.clientY;
      if (!passed && isFirefox) {
        x = this._currentClientX;
        y = this._currentClientY;
      }
      if (!this._indicator || !passed && this._indicator.rect && this._indicator.rect.left === x && this._indicator.rect.top === y) {
        return;
      }
      if (this._dragPreview && e.screenY) {
        const { x: offsetX, y: offsetY } = this._dragPreview.offset;
        const l = x + offsetX;
        const t = y + offsetY;
        const s = this._scale;
        this._dragPreview.style.transform = `translate(${l}px, ${t}px) scale(${s})`;
      }
      if (isScrolling)
        return;
      const point = new Point(x, y);
      const element = this._getClosestBlockElement(point.clone());
      let type = "none";
      let rect = null;
      let lastModelState = null;
      if (element) {
        if (!this._draggingElements.includes(element) && !isContainedIn(this._draggingElements, element)) {
          const model = getModelByBlockElement(element);
          const result = calcDropTarget(point, model, element, this._draggingElements, this._scale);
          if (result) {
            type = result.type;
            rect = result.rect;
            lastModelState = result.modelState;
          }
        }
      }
      this._indicator.rect = rect;
      this._lastDroppingType = type;
      this._lastDroppingTarget = lastModelState;
    };
    this.onDragEnd = (e, passed) => {
      var _a3, _b, _c, _d;
      this._stopPropagation = false;
      const dropEffect = ((_a3 = e.dataTransfer) == null ? void 0 : _a3.dropEffect) ?? "none";
      this._removeDragPreview();
      this.setDragType(false);
      if (!passed && dropEffect === "none") {
        this.hide(true);
        return;
      }
      assertExists(this._draggingElements);
      (_d = this.onDropCallback) == null ? void 0 : _d.call(
        this,
        ((_c = (_b = this._indicator) == null ? void 0 : _b.rect) == null ? void 0 : _c.min) ?? new Point(e.clientX, e.clientY),
        // blockElements include subtrees
        this._draggingElements,
        this._lastDroppingTarget,
        this._lastDroppingType
      );
      this.hide(true);
    };
    this.getDropAllowedBlocks = () => {
      console.warn("you may forget to set `getAllowedBlocks`");
      return [];
    };
    this.addEventListener("beforeprint", () => this.hide(true));
    this.onDropCallback = options2 == null ? void 0 : options2.onDropCallback;
    this.setDragType = options2 == null ? void 0 : options2.setDragType;
    this.setSelectedBlock = options2 == null ? void 0 : options2.setSelectedBlock;
    this._getSelectedBlocks = options2 == null ? void 0 : options2.getSelectedBlocks;
    this._getClosestBlockElement = options2 == null ? void 0 : options2.getClosestBlockElement;
    options2 == null ? void 0 : options2.container.appendChild(this);
    this._container = options2 == null ? void 0 : options2.container;
  }
  get selectedBlocks() {
    return this._getSelectedBlocks() ?? [];
  }
  onContainerMouseMove(event, modelState) {
    const frameBlock = this._container.querySelector(".affine-frame-block-container");
    assertExists(frameBlock);
    const frameBlockRect = frameBlock.getBoundingClientRect();
    if (event.raw.clientY < frameBlockRect.y) {
      this.hide();
    }
    if (modelState) {
      const { rect, element } = modelState;
      let startX = rect.left;
      let startY = rect.top;
      let height = rect.height;
      let selected = false;
      const selectedBlocks = this.selectedBlocks;
      if (selectedBlocks.includes(element)) {
        selected = true;
        if (selectedBlocks.length > 1) {
          const tempSelectedBlocks = getBlockElementsExcludeSubtrees(selectedBlocks);
          const first = getRectByBlockElement(tempSelectedBlocks[0]);
          const last = getRectByBlockElement(tempSelectedBlocks[tempSelectedBlocks.length - 1]);
          startX = first.left;
          startY = first.top;
          height = last.bottom - first.top;
        }
      }
      this.toggleAttribute("data-selected", selected);
      this._handleAnchorState = modelState;
      this.style.display = "block";
      this.style.height = `${height / this._scale}px`;
      this.style.width = `${DRAG_HANDLE_WIDTH}px`;
      const containerRect = this._container.getBoundingClientRect();
      const posX = startX - containerRect.left - (DRAG_HANDLE_WIDTH + DRAG_HANDLE_OFFSET_LEFT) * this._scale;
      const posY = startY - containerRect.top;
      this.style.transform = `translate(${posX}px, ${posY}px) scale(${this._scale})`;
      this.style.opacity = `${(1 - (event.raw.clientX - startX) / rect.width).toFixed(2)}`;
      const top2 = this._calcDragHandleY(event.raw.clientY, startY, height, this._scale);
      this._dragHandle.style.transform = `translateY(${top2}px)`;
      if (this._handleAnchorDisposable) {
        this._handleAnchorDisposable.dispose();
      }
      this._handleAnchorDisposable = modelState.model.propsUpdated.on(() => {
        this.hide();
      });
      return;
    }
    this.hide();
  }
  hide(force = false) {
    this.style.display = "none";
    if (force)
      this.reset();
  }
  reset() {
    this._handleAnchorState = null;
    this._lastDroppingType = "none";
    this._lastDroppingTarget = null;
    if (this._indicator) {
      this._indicator.rect = null;
    }
    this._draggingElements.forEach((e) => {
      e.style.opacity = "1";
    });
    this._draggingElements = [];
  }
  setPointerEvents(value) {
    this.style.pointerEvents = value;
  }
  setScale(value = 1) {
    this._scale = value;
  }
  firstUpdated() {
    this.style.display = "none";
    this.style.position = "absolute";
    this._indicator = document.querySelector("affine-drag-indicator");
    if (!this._indicator) {
      this._indicator = document.createElement("affine-drag-indicator");
      document.body.appendChild(this._indicator);
    }
    const disposables = this._disposables;
    if (isFirefox) {
      disposables.addFromEvent(this._container, "dragover", this._onDragOverDocument);
    }
    disposables.addFromEvent(document.body, "dragover", handlePreventDocumentDragOverDelay, false);
    disposables.addFromEvent(this, "mousemove", this._onMouseMoveOnHost);
    disposables.addFromEvent(this._dragHandle, "click", this._onClick);
    disposables.addFromEvent(this._dragHandle, "dragstart", this.onDragStart);
    disposables.addFromEvent(this._dragHandle, "drag", this.onDrag);
    disposables.addFromEvent(this._dragHandle, "dragend", this.onDragEnd);
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    this.hide(true);
    (_a3 = this._handleAnchorDisposable) == null ? void 0 : _a3.dispose();
  }
  _onMouseMoveOnHost(e) {
    if (isFirefox) {
      this._currentClientX = e.clientX;
      this._currentClientY = e.clientY;
    }
    if (this._stopPropagation) {
      e.stopPropagation();
    }
    if (!this._handleAnchorState) {
      return;
    }
    const { rect, element } = this._handleAnchorState;
    const selectedBlocks = this.selectedBlocks;
    let startY = rect.top;
    let height = rect.height;
    if (selectedBlocks.includes(element) && selectedBlocks.length > 1) {
      const tempSelectedBlocks = getBlockElementsExcludeSubtrees(selectedBlocks);
      const first = getRectByBlockElement(tempSelectedBlocks[0]);
      const last = getRectByBlockElement(tempSelectedBlocks[tempSelectedBlocks.length - 1]);
      startY = first.top;
      height = last.bottom - first.top;
    }
    const top2 = this._calcDragHandleY(e.clientY, startY, height, this._scale);
    this._dragHandle.style.cursor = "grab";
    this._dragHandle.style.transform = `translateY(${top2}px)`;
  }
  _calcDragHandleY(clientY, startY, height, scale) {
    return Math.max(0, Math.min(clientY - startY - DRAG_HANDLE_HEIGHT * scale / 2, height - DRAG_HANDLE_HEIGHT * scale)) / scale;
  }
  _createDragPreview(e, blockElements2, grabbing = false) {
    const dragPreview = this._dragPreview = new DragPreview();
    const containerRect = this._container.getBoundingClientRect();
    const rect = blockElements2[0].getBoundingClientRect();
    const { clientX, clientY } = e;
    const s = this._scale;
    const l = rect.left - containerRect.left;
    const t = rect.top - containerRect.top;
    dragPreview.offset.x = l - clientX;
    dragPreview.offset.y = t - clientY;
    dragPreview.style.width = `${rect.width / s}px`;
    dragPreview.style.transform = `translate(${l}px, ${t}px) scale(${s})`;
    const x = -dragPreview.offset.x - containerRect.left - 24 / 2;
    const y = -dragPreview.offset.y - containerRect.top - 24 / 2;
    dragPreview.style.setProperty("--x", `${x}px`);
    dragPreview.style.setProperty("--y", `${y}px`);
    const fragment = document.createDocumentFragment();
    blockElements2.forEach((e2) => {
      const c = document.createElement("div");
      c.classList.add("affine-block-element");
      render(e2.render(), c);
      fragment.appendChild(c);
    });
    dragPreview.appendChild(fragment);
    this._container.appendChild(dragPreview);
    if (grabbing) {
      dragPreview.classList.add("grabbing");
    }
    requestAnimationFrame(() => {
      var _a3, _b;
      (_b = (_a3 = dragPreview.querySelector("rich-text")) == null ? void 0 : _a3.vEditor) == null ? void 0 : _b.rootElement.blur();
    });
  }
  _removeDragPreview() {
    if (this._dragPreview) {
      this._dragPreview.remove();
      this._dragPreview = null;
    }
  }
  render() {
    return html`
      <div class="affine-drag-handle-line"></div>
      <div class="affine-drag-handle" draggable="true">
        <svg
          class="affine-drag-handle-normal"
          width="16"
          height="18"
          viewBox="0 0 16 12"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <rect
            x="7.7782"
            y="0.707107"
            width="10"
            height="10"
            rx="2.5"
            transform="rotate(45 7.7782 0.707107)"
          />
        </svg>

        <svg
          class="affine-drag-handle-hover"
          width="16"
          height="18"
          viewBox="0 0 16 12"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M2.41421 6.58579L6.58579 2.41421C7.36684 1.63317 8.63316 1.63316 9.41421 2.41421L13.5858 6.58579C14.3668 7.36684 14.3668 8.63316 13.5858 9.41421L9.41421 13.5858C8.63316 14.3668 7.36684 14.3668 6.58579 13.5858L2.41421 9.41421C1.63317 8.63316 1.63316 7.36684 2.41421 6.58579Z"
            stroke-width="1.5"
          />
          <path
            class="ok"
            d="M5 8.5L7.5 10.5L10.5 7"
            stroke-width="1.5"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </div>
    `;
  }
};
DragHandle.styles = css`
    :host {
      top: 0;
      left: 0;
      overflow: hidden;
      width: ${DRAG_HANDLE_WIDTH + 8}px;
      transform-origin: 0 0;
      pointer-events: none;
      user-select: none;
    }

    :host(:hover) > .affine-drag-handle-line {
      opacity: 1;
    }

    .affine-drag-handle-line {
      opacity: 0;
      width: 1px;
      height: 100%;
      position: absolute;
      left: ${(DRAG_HANDLE_WIDTH - 1) / 2}px;
      background-color: var(--affine-icon-color);
      transition: opacity ease-in-out 300ms;
      pointer-events: none;
    }

    .affine-drag-handle {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      width: ${DRAG_HANDLE_WIDTH}px;
      height: ${DRAG_HANDLE_HEIGHT}px;
      /* background-color: var(--affine-white-90); */
      pointer-events: auto;
      color: var(--affine-icon-color);
    }

    @media print {
      .affine-drag-handle-line {
        display: none;
      }

      .affine-drag-handle {
        display: none;
      }
    }

    .affine-drag-handle-normal {
      display: flex;
      stroke: currentcolor;
    }

    .affine-drag-handle-hover {
      fill: currentcolor;
      transition: opacity ease-in-out 300ms;
    }

    .affine-drag-handle-hover path.ok {
      stroke: var(--affine-white-90);
    }

    .affine-drag-handle-hover {
      display: none;
    }

    :host(:hover) .affine-drag-handle-normal,
    :host([data-selected]) .affine-drag-handle-normal {
      display: none !important;
    }

    :host(:hover) .affine-drag-handle-hover,
    :host([data-selected]) .affine-drag-handle-hover {
      display: flex !important;
      /* padding-top: 5px !important; FIXME */
    }
  `;
__decorate17([
  query(".affine-drag-handle")
], DragHandle.prototype, "_dragHandle", void 0);
DragHandle = __decorate17([
  customElement("affine-drag-handle")
], DragHandle);

// node_modules/@blocksuite/blocks/dist/components/block-hub.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles3 = css`
  affine-block-hub {
    position: absolute;
    z-index: 1;
    user-select: none;
  }

  @media print {
    affine-block-hub {
      display: none;
    }
  }

  .affine-block-hub-container {
    width: 274px;
    position: absolute;
    right: calc(100% + 8px);
    overflow-y: unset;
    display: none;
    justify-content: center;
    fill: var(--affine-icon-color);
    color: var(--affine-icon-color);
    font-size: var(--affine-font-sm);
    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-menu-shadow);
    border-radius: 8px;
  }

  .affine-block-hub-container[type='text'] {
    top: unset;
    bottom: 0;
    transform: unset;
    right: calc(100% + 4px);
  }

  .visible {
    display: block;
  }

  .invisible {
    display: none;
  }

  .card-container-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    position: relative;
  }

  .card-container {
    display: flex;
    position: relative;
    align-items: center;
    width: 250px;
    height: 54px;
    background: var(--affine-white-80);
    box-shadow: var(--affine-shadow-1);
    border-radius: 8px;
    margin-bottom: 12px;
    cursor: grab;
    top: 0;
    left: 0;
    transition: all 0.1s ease-in-out;
  }

  .card-icon-container {
    display: flex;
    align-items: center;
    position: absolute;
    right: 12px;
  }

  .card-icon-container > svg {
    width: 20px;
    height: 20px;
  }

  .card-container-inner:hover .card-container {
    background: var(--affine-hover-color);
    top: -2px;
    left: -2px;
  }

  .card-container-inner:hover .card-container.grabbing {
    top: unset;
    left: unset;
    box-shadow: var(--affine-shadow-2);
  }

  .card-description-container {
    display: block;
    width: 190px;
    color: var(--affine-text-primary-color);
    font-size: var(--affine-font-base);
    line-height: var(--affine-line-height);
    margin: 8px 0 8px 12px;
    text-align: justify;
  }

  .affine-block-hub-container .description {
    font-size: var(--affine-font-sm);
    line-height: var(--affine-line-height);
    color: var(--affine-text-secondary-color);
    white-space: pre;
  }

  .grabbing {
    cursor: grabbing;
  }

  .grab {
    cursor: grab;
  }

  .affine-block-hub-title-container {
    margin: 16px 0 20px 12px;
    color: var(--affine-text-secondary-color);
    font-size: var(--affine-font-base);
    user-select: none;
  }

  .prominent {
    z-index: 1;
  }

  .block-hub-menu-container {
    display: flex;
    font-family: var(--affine-font-family);
    flex-flow: column;
    justify-content: center;
    align-items: center;
    position: fixed;
    width: 44px;
    background: var(--affine-background-primary-color);
    border-radius: 8px;
  }

  .block-hub-menu-container[expanded] {
    box-shadow: var(--affine-menu-shadow);
    background: var(--affine-background-overlay-panel-color);
  }

  .block-hub-icon-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 8px;
    position: relative;
    border-radius: 4px;
    fill: var(--affine-icon-color);
    color: var(--affine-icon-color);
    height: 36px;
  }
  .block-hub-icon-container svg {
    width: 24px;
    height: 24px;
  }

  .block-hub-icon-container[selected='true'] {
    background: var(--affine-hover-color);
  }

  .block-hub-icon-container:hover {
    background: var(--affine-hover-color);
    border-radius: 4px;
  }

  .new-icon {
    width: 44px;
    height: 44px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    fill: var(--affine-icon-color);
  }

  .new-icon-in-edgeless {
    box-shadow: var(--affine-menu-shadow);
  }
  .block-hub-menu-container[expanded] .new-icon {
    border-radius: 4px;
    box-shadow: unset;
  }

  .new-icon:hover {
    box-shadow: var(--affine-menu-shadow);
    background: var(--affine-white);
  }

  .icon-expanded {
    width: 36px;
    height: 36px;
  }

  .icon-expanded:hover {
    background: var(--affine-hover-color);
  }

  .divider {
    height: 1px;
    width: 36px;
    background: var(--affine-border-color);
    margin: 4px 0;
  }

  [role='menuitem'] tool-tip {
    font-size: var(--affine-font-sm);
  }

  .block-hub-icons-container {
    overflow: hidden;
    transition: all 0.2s cubic-bezier(0, 0, 0.55, 1.6);
  }

  ${tooltipStyle}
`;
var TRANSITION_DELAY = 200;
var BOTTOM_OFFSET = 70;
var RIGHT_OFFSET = 24;
var TOP_DISTANCE = 24;
function shouldDisplayCard(type, expanded, isCardListVisible, visibleCardType) {
  return expanded && isCardListVisible && visibleCardType === type;
}
function BlockHubCards(blockHubItems, type, title, maxHeight, shouldDisplayCard2, isGrabbing, showTooltip) {
  const shouldScroll = maxHeight < 800;
  const styles15 = styleMap({
    maxHeight: `${maxHeight}px`,
    overflowY: shouldScroll ? "scroll" : "unset"
  });
  return html`
    <div
      class="affine-block-hub-container ${shouldDisplayCard2 ? "visible" : ""}"
      style="${styles15}"
      type=${type}
    >
      <div class="affine-block-hub-title-container">${title}</div>
      ${blockHubItems.map(({ flavour, type: type2, name, description, icon, tooltip }, index) => {
    return html`
            <div class="card-container-wrapper">
              <div class="card-container-inner">
                <div
                  class="card-container has-tool-tip ${isGrabbing ? "grabbing" : ""}"
                  draggable="true"
                  affine-flavour=${flavour}
                  affine-type=${type2 ?? ""}
                >
                  <div class="card-description-container">
                    <div>${name}</div>
                    <div class="description">${description}</div>
                  </div>
                  <div class="card-icon-container">${icon}</div>
                  <tool-tip
                    tip-position=${shouldScroll && index === blockHubItems.length - 1 ? "top" : "bottom"}
                    style="${showTooltip ? "" : "display: none"}; z-index: ${blockHubItems.length - index}"
                    >${tooltip}</tool-tip
                  >
                </div>
              </div>
            </div>
          `;
  })}
    </div>
  `;
}
function BlockHubMenu(enableDatabase, expanded, isGrabbing, visibleCardType, isCardListVisible, showTooltip, maxHeight, page) {
  const menuNum = enableDatabase ? 5 : 4;
  const height = menuNum * 44 + 10;
  const blockHubListCards = BlockHubCards(BLOCKHUB_LIST_ITEMS, "list", "List", maxHeight, shouldDisplayCard("list", expanded, isCardListVisible, visibleCardType), isGrabbing, showTooltip);
  const blockHubFileCards = BlockHubCards(BLOCKHUB_FILE_ITEMS.filter(({ flavour }) => {
    if (flavour === "affine:bookmark") {
      return page.awarenessStore.getFlag("enable_bookmark_operation");
    }
    return true;
  }), "file", "Content & Media", maxHeight, shouldDisplayCard("file", expanded, isCardListVisible, visibleCardType), isGrabbing, showTooltip);
  return html`
    <div
      class="block-hub-icons-container"
      ?transition=${expanded}
      style="height: ${expanded ? `${height}px` : "0"};"
    >
      <div
        class="block-hub-icon-container has-tool-tip ${isGrabbing ? "grabbing" : "grab"}"
        selected=${visibleCardType === "blank" ? "true" : "false"}
        type="blank"
        draggable="true"
        affine-flavour="affine:paragraph"
        affine-type="text"
      >
        ${BlockHubRoundedRectangleIcon}
        <tool-tip
          inert
          role="tooltip"
          tip-position="left"
          ?hidden=${!showTooltip}
          >Drag to insert blank line
        </tool-tip>
      </div>
      <div
        class="block-hub-icon-container"
        type="text"
        selected=${visibleCardType === "text" ? "true" : "false"}
      >
        ${TextIconLarge}
      </div>
      <div
        class="block-hub-icon-container"
        type="list"
        selected=${visibleCardType === "list" ? "true" : "false"}
      >
        ${blockHubListCards} ${NumberedListIconLarge}
      </div>
      <div
        class="block-hub-icon-container"
        type="file"
        selected=${visibleCardType === "file" ? "true" : "false"}
      >
        ${blockHubFileCards} ${EmbedIcon}
      </div>
      ${enableDatabase ? html`
            <div
              class="block-hub-icon-container has-tool-tip"
              type="database"
              draggable="true"
              affine-flavour="affine:database"
              selected=${visibleCardType === "database" ? "true" : "false"}
            >
              ${DatabaseTableViewIcon}
              <tool-tip
                inert
                role="tooltip"
                tip-position="left"
                ?hidden=${!showTooltip}
              >
                Drag to create a database
              </tool-tip>
            </div>
          ` : null}
      <div class="divider"></div>
    </div>
  `;
}
var BlockHub = class BlockHub2 extends WithDisposable(ShadowlessElement) {
  constructor(options2) {
    super();
    this._expanded = false;
    this._isGrabbing = false;
    this._visibleCardType = null;
    this._showTooltip = true;
    this._inEdgelessMode = false;
    this._maxHeight = 2e3;
    this._currentClientX = 0;
    this._currentClientY = 0;
    this._isCardListVisible = false;
    this._lastDroppingTarget = null;
    this._lastDroppingType = "none";
    this._lastDraggingFlavour = null;
    this._timer = null;
    this._onTransitionStart = (_) => {
      if (this._timer) {
        clearTimeout(this._timer);
      }
      if (!this._expanded) {
        this._blockHubMenuContainer.style.padding = "0 4px";
        this._timer = window.setTimeout(() => {
          this._blockHubIconsContainer.style.overflow = "hidden";
        }, TRANSITION_DELAY);
      } else {
        this._blockHubMenuContainer.style.padding = "4px";
        this._timer = window.setTimeout(() => {
          this._blockHubIconsContainer.style.overflow = "unset";
        }, TRANSITION_DELAY);
      }
    };
    this._onClickOutside = (e) => {
      const target = e.target;
      if (target instanceof HTMLElement && !target.closest("affine-block-hub")) {
        this._hideCardList();
      }
    };
    this._onClickCard = (e, blockHubElement) => {
      const affineType = blockHubElement.getAttribute("affine-type");
      assertExists(affineType);
      const data = {
        flavour: blockHubElement.getAttribute("affine-flavour") ?? ""
      };
      if (affineType) {
        data.type = affineType;
      }
      this._onClickCardCallback(data);
    };
    this._onBlockHubButtonClick = (_) => {
      this._expanded = !this._expanded;
      if (!this._expanded) {
        this._hideCardList();
      }
    };
    this._onDragStart = (event) => {
      this._showTooltip = false;
      assertExists(event.dataTransfer);
      event.dataTransfer.effectAllowed = "move";
      const blockHubElement = event.target;
      const affineType = blockHubElement.getAttribute("affine-type");
      const data = {
        flavour: blockHubElement.getAttribute("affine-flavour")
      };
      if (affineType) {
        data.type = affineType;
      }
      event.dataTransfer.setData("affine/block-hub", JSON.stringify(data));
      this._lastDraggingFlavour = data.flavour;
      this._onDragStartCallback();
    };
    this._onMouseDown = (e) => {
      if (isFirefox) {
        this._currentClientX = e.clientX;
        this._currentClientY = e.clientY;
      }
    };
    this._onDrag = (e) => {
      this._hideCardList();
      let x = e.clientX;
      let y = e.clientY;
      if (isFirefox) {
        x = this._currentClientX;
        y = this._currentClientY;
      }
      if (!this._indicator || this._indicator.rect && this._indicator.rect.left === x && this._indicator.rect.top === y) {
        return;
      }
      const point = new Point(x, y);
      const { container, rect: frameRect, scale } = this.getHoveringFrameState(point.clone());
      if (!frameRect) {
        this._resetDropState();
        return;
      }
      const element = getClosestBlockElementByPoint(point, { container, rect: frameRect, snapToEdge: { x: false, y: true } }, scale);
      if (!element) {
        this._resetDropState();
        return;
      }
      let type = "none";
      let rect = null;
      let lastModelState = null;
      const model = getModelByBlockElement(element);
      const result = calcDropTarget(point, model, element, [], scale, this._lastDraggingFlavour);
      if (result) {
        type = result.type;
        rect = result.rect;
        lastModelState = result.modelState;
      }
      this._lastDroppingType = type;
      this._indicator.rect = rect;
      this._lastDroppingTarget = lastModelState;
    };
    this._onDragOver = (e) => {
      e.preventDefault();
    };
    this._onDragOverDocument = (e) => {
      if (!isFirefox) {
        throw new Error("FireFox only");
      }
      this._currentClientX = e.clientX;
      this._currentClientY = e.clientY;
    };
    this._onDragEnd = (_) => {
      this._showTooltip = true;
      this._isGrabbing = false;
      this._lastDraggingFlavour = null;
      this._resetDropState();
    };
    this._resetDropState = () => {
      this._lastDroppingType = "none";
      this._indicator.rect = null;
      this._lastDroppingTarget = null;
    };
    this._onDrop = (e) => {
      var _a3, _b;
      assertExists(e.dataTransfer);
      if (!e.dataTransfer.getData("affine/block-hub"))
        return;
      this._onDropCallback(
        e,
        // `drag.clientY` !== `dragend.clientY` in chrome.
        ((_b = (_a3 = this._indicator) == null ? void 0 : _a3.rect) == null ? void 0 : _b.min) ?? new Point(e.clientX, e.clientY),
        this._lastDroppingTarget,
        this._lastDroppingType
      );
    };
    this._onCardMouseDown = (_) => {
      this._isGrabbing = true;
    };
    this._onCardMouseUp = (_) => {
      this._isGrabbing = false;
    };
    this._onBlankMenuMouseDown = () => {
      this._isGrabbing = true;
    };
    this._onBlankMenuMouseUp = () => {
      this._isGrabbing = false;
    };
    this._onBlockHubMenuMouseOver = (e) => {
      const menu = e.currentTarget;
      const cardType = menu.getAttribute("type");
      assertExists(cardType);
      this._isCardListVisible = true;
      this._visibleCardType = cardType;
    };
    this._onBlockHubEntryMouseOver = () => {
      this._isCardListVisible = false;
    };
    this._onResize = () => {
      const boundingClientRect = document.body.getBoundingClientRect();
      this._maxHeight = boundingClientRect.height - TOP_DISTANCE - BOTTOM_OFFSET;
    };
    this._page = options2.page;
    this._mouseRoot = options2.mouseRoot;
    this._enableDatabase = options2.enableDatabase;
    this.getAllowedBlocks = options2.getAllowedBlocks;
    this.getHoveringFrameState = options2.getHoveringFrameState;
    this._onDragStartCallback = options2.onDragStart;
    this._onDropCallback = options2.onDrop;
    this._onClickCardCallback = options2.onClickCard;
  }
  connectedCallback() {
    super.connectedCallback();
    const disposables = this._disposables;
    disposables.addFromEvent(this, "dragstart", this._onDragStart);
    disposables.addFromEvent(this, "drag", this._onDrag);
    disposables.addFromEvent(this, "dragend", this._onDragEnd);
    disposables.addFromEvent(this._mouseRoot, "dragover", this._onDragOver);
    disposables.addFromEvent(this._mouseRoot, "drop", this._onDrop);
    disposables.addFromEvent(this, "mousedown", this._onMouseDown);
    disposables.add(this._mouseRoot.slots.pageModeSwitched.on((mode) => {
      this._inEdgelessMode = mode === "edgeless";
    }));
    if (isFirefox) {
      disposables.addFromEvent(this._mouseRoot, "dragover", this._onDragOverDocument);
    }
    this._onResize();
  }
  firstUpdated() {
    const disposables = this._disposables;
    this._blockHubCards.forEach((card) => {
      disposables.addFromEvent(card, "mousedown", this._onCardMouseDown);
      disposables.addFromEvent(card, "mouseup", this._onCardMouseUp);
      disposables.addFromEvent(card, "click", (e) => this._onClickCard(e, card));
    });
    for (const blockHubMenu of this._blockHubMenus) {
      disposables.addFromEvent(blockHubMenu, "mouseover", this._onBlockHubMenuMouseOver);
      if (blockHubMenu.getAttribute("type") === "blank") {
        disposables.addFromEvent(blockHubMenu, "mousedown", this._onBlankMenuMouseDown);
        disposables.addFromEvent(blockHubMenu, "mouseup", this._onBlankMenuMouseUp);
      }
    }
    disposables.addFromEvent(this._blockHubMenuEntry, "mouseover", this._onBlockHubEntryMouseOver);
    disposables.addFromEvent(document, "click", this._onClickOutside);
    disposables.addFromEvent(this._blockHubButton, "click", this._onBlockHubButtonClick);
    disposables.addFromEvent(this._blockHubButton, "mousedown", (e) => {
      e.preventDefault();
    });
    disposables.addFromEvent(this._blockHubIconsContainer, "transitionstart", this._onTransitionStart);
    disposables.addFromEvent(window, "resize", this._onResize);
    this._indicator = document.createElement("affine-drag-indicator");
    document.body.appendChild(this._indicator);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._disposables.dispose();
  }
  toggleMenu() {
    this._expanded = !this._expanded;
    if (!this._expanded)
      this._hideCardList();
  }
  _hideCardList() {
    if (this._visibleCardType) {
      this._visibleCardType = null;
      this._isCardListVisible = false;
    }
  }
  render() {
    const blockHubMenu = BlockHubMenu(this._enableDatabase, this._expanded, this._isGrabbing, this._visibleCardType, this._isCardListVisible, this._showTooltip, this._maxHeight, this._page);
    const blockHubCards = BlockHubCards(BLOCKHUB_TEXT_ITEMS, "text", "Text block", this._maxHeight, shouldDisplayCard("text", this._expanded, this._isCardListVisible, this._visibleCardType), this._isGrabbing, this._showTooltip);
    const classes = classMap({
      "icon-expanded": this._expanded,
      "new-icon-in-edgeless": this._inEdgelessMode && !this._expanded,
      "has-tool-tip": true,
      "new-icon": true
    });
    return html`
      <div
        class="block-hub-menu-container"
        ?expanded=${this._expanded}
        style="bottom: ${BOTTOM_OFFSET}px; right: ${RIGHT_OFFSET}px;"
      >
        ${blockHubMenu}
        <div class=${classes} role="menuitem" style="cursor:pointer;">
          ${this._expanded ? CrossIcon : BlockHubIcon}
          <tool-tip
            class=${this._expanded ? "invisible" : ""}
            inert
            tip-position="left"
            role="tooltip"
            >Insert blocks
          </tool-tip>
        </div>
        ${blockHubCards}
      </div>
    `;
  }
};
BlockHub.styles = styles3;
__decorate18([
  property()
], BlockHub.prototype, "getAllowedBlocks", void 0);
__decorate18([
  property()
], BlockHub.prototype, "getHoveringFrameState", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_expanded", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_isGrabbing", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_visibleCardType", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_showTooltip", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_inEdgelessMode", void 0);
__decorate18([
  state()
], BlockHub.prototype, "_maxHeight", void 0);
__decorate18([
  queryAll(".card-container")
], BlockHub.prototype, "_blockHubCards", void 0);
__decorate18([
  queryAll(".block-hub-icon-container[type]")
], BlockHub.prototype, "_blockHubMenus", void 0);
__decorate18([
  query(".new-icon")
], BlockHub.prototype, "_blockHubButton", void 0);
__decorate18([
  query(".block-hub-icons-container")
], BlockHub.prototype, "_blockHubIconsContainer", void 0);
__decorate18([
  query(".block-hub-menu-container")
], BlockHub.prototype, "_blockHubMenuContainer", void 0);
__decorate18([
  query('[role="menuitem"]')
], BlockHub.prototype, "_blockHubMenuEntry", void 0);
BlockHub = __decorate18([
  customElement("affine-block-hub")
], BlockHub);

// node_modules/@blocksuite/blocks/dist/components/loader.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Loader = class Loader2 extends LitElement {
  constructor() {
    super();
    this.hostModel = null;
    this.radius = "8px";
    this.width = "150px";
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hostModel) {
      this.setAttribute(BLOCK_ID_ATTR, this.hostModel.id);
      this.setAttribute(BLOCK_SERVICE_LOADING_ATTR, "true");
    }
    const width = this.width;
    this.style.setProperty("--loader-width", typeof width === "string" ? width : `${width}px`);
  }
  render() {
    return html`
      <div class="load-container">
        <div class="load load1"></div>
        <div class="load load2"></div>
        <div class="load"></div>
      </div>
    `;
  }
};
Loader.styles = css`
    .load-container {
      margin: 10px auto;
      width: var(--loader-width);
      text-align: center;
    }

    .load-container .load {
      width: 8px;
      height: 8px;
      background-color: var(--affine-text-primary-color);

      border-radius: 100%;
      display: inline-block;
      -webkit-animation: bouncedelay 1.4s infinite ease-in-out;
      animation: bouncedelay 1.4s infinite ease-in-out;
      /* Prevent first frame from flickering when animation starts */
      -webkit-animation-fill-mode: both;
      animation-fill-mode: both;
    }
    .load-container .load1 {
      -webkit-animation-delay: -0.32s;
      animation-delay: -0.32s;
    }
    .load-container .load2 {
      -webkit-animation-delay: -0.16s;
      animation-delay: -0.16s;
    }

    @-webkit-keyframes bouncedelay {
      0%,
      80%,
      100% {
        -webkit-transform: scale(0.625);
      }
      40% {
        -webkit-transform: scale(1);
      }
    }

    @keyframes bouncedelay {
      0%,
      80%,
      100% {
        transform: scale(0);
        -webkit-transform: scale(0.625);
      }
      40% {
        transform: scale(1);
        -webkit-transform: scale(1);
      }
    }
  `;
__decorate19([
  property()
], Loader.prototype, "hostModel", void 0);
__decorate19([
  property()
], Loader.prototype, "radius", void 0);
__decorate19([
  property()
], Loader.prototype, "width", void 0);
Loader = __decorate19([
  customElement("loader-element")
], Loader);

// node_modules/@blocksuite/blocks/dist/components/import-page/import-page.js
var import_jszip = __toESM(require_jszip_min(), 1);

// node_modules/@blocksuite/blocks/dist/components/import-page/styles.js
var styles4 = css`
  :host {
    position: absolute;
    width: 480px;
    left: calc(50% - 480px / 2);
    top: calc(50% - 270px / 2);
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-base);
    line-height: var(--affine-line-height);
    padding: 20px 40px 24px 40px;
    gap: 19px;
    display: flex;
    flex-direction: column;
    background: var(--affine-background-primary-color);
    box-shadow: var(--affine-shadow-2);
    border-radius: 16px;
    z-index: var(--affine-z-index-popover);
  }

  :host([hidden]) {
    display: none;
  }

  header {
    cursor: move;
    user-select: none;
    font-size: var(--affine-font-h-6);
    font-weight: 600;
  }

  a {
    white-space: nowrap;
    word-break: break-word;
    color: var(--affine-link-color);
    fill: var(--affine-link-color);
    text-decoration: none;
    cursor: pointer;
  }

  header icon-button {
    margin-left: auto;
  }

  .button-container {
    display: flex;
    justify-content: space-between;
  }

  .button-container icon-button {
    padding: 8px;
    justify-content: flex-start;
    gap: 8px;
    width: 190px;
    height: 40px;
    box-shadow: var(--affine-shadow-1);
  }

  .footer {
    display: flex;
    align-items: center;
    color: var(--affine-text-secondary-color);
  }

  .loading-header {
    display: flex;
    align-items: center;
  }

  .has-tool-tip {
    display: flex;
    margin-left: auto;
  }

  ${tooltipStyle}
`;

// node_modules/@blocksuite/blocks/dist/components/import-page/import-page.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SHOW_LOADING_SIZE = 1024 * 200;
var ImportPage = class ImportPage2 extends WithDisposable(LitElement) {
  constructor(workspace, multiple, onSuccess, abortController = new AbortController()) {
    super();
    this.workspace = workspace;
    this.multiple = multiple;
    this.onSuccess = onSuccess;
    this.abortController = abortController;
    this._loading = false;
    this.x = 0;
    this.y = 0;
    this._startX = 0;
    this._startY = 0;
    this._loading = false;
    this.x = 0;
    this.y = 0;
    this._startX = 0;
    this._startY = 0;
    this._onMouseMove = this._onMouseMove.bind(this);
  }
  loading() {
    return this._loading;
  }
  updated(changedProps) {
    if (changedProps.has("x") || changedProps.has("y")) {
      this.style.transform = `translate(${this.x}px, ${this.y}px)`;
    }
  }
  _onMouseDown(event) {
    this._startX = event.clientX - this.x;
    this._startY = event.clientY - this.y;
    window.addEventListener("mousemove", this._onMouseMove);
  }
  _onMouseUp() {
    window.removeEventListener("mousemove", this._onMouseMove);
  }
  _onMouseMove(event) {
    this.x = event.clientX - this._startX;
    this.y = event.clientY - this._startY;
  }
  _onCloseClick(event) {
    event.stopPropagation();
    this.abortController.abort();
  }
  async _selectFile(accept) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = accept;
    input.multiple = this.multiple;
    input.click();
    return new Promise((resolve, reject) => {
      input.onchange = () => {
        const files = input.files;
        if (!files) {
          reject();
          return;
        }
        resolve(Array.from(files));
      };
      input.onerror = () => {
        reject();
      };
    });
  }
  _onImportSuccess(pageIds) {
    var _a3;
    toast(`Successfully imported ${pageIds.length} Page${pageIds.length > 1 ? "s" : ""}.`);
    (_a3 = this.onSuccess) == null ? void 0 : _a3.call(this, pageIds);
  }
  async _importFile(fileExtension, needLoadingHandler, parseContentHandler) {
    this.hidden = true;
    const files = await this._selectFile(fileExtension);
    const needLoading = await needLoadingHandler(files);
    if (needLoading) {
      this.hidden = false;
      this._loading = true;
    } else {
      this.abortController.abort();
    }
    const pageIds = [];
    for (const file of files) {
      const importPageIds = await parseContentHandler(file);
      pageIds.push(...importPageIds);
    }
    this._onImportSuccess(pageIds);
    needLoading && this.abortController.abort();
  }
  async _importMarkDown() {
    await this._importFile(".md", async (files) => {
      let totalSize = 0;
      for (const file of files) {
        totalSize += file.size;
        if (totalSize > SHOW_LOADING_SIZE)
          return true;
      }
      return false;
    }, async (file) => {
      var _a3;
      const text = await file.text();
      const page = this.workspace.createPage({
        init: {
          title: ""
        }
      });
      const rootId = (_a3 = page.root) == null ? void 0 : _a3.id;
      const contentParser = new ContentParser(page);
      if (rootId) {
        await contentParser.importMarkdown(text, rootId);
        return [page.id];
      }
      return [];
    });
  }
  async _importHtml() {
    await this._importFile(".html", async (files) => {
      let totalSize = 0;
      for (const file of files) {
        totalSize += file.size;
        if (totalSize > SHOW_LOADING_SIZE)
          return true;
      }
      return false;
    }, async (file) => {
      var _a3;
      const text = await file.text();
      const page = this.workspace.createPage({
        init: {
          title: ""
        }
      });
      const rootId = (_a3 = page.root) == null ? void 0 : _a3.id;
      const contentParser = new ContentParser(page);
      if (rootId) {
        await contentParser.importHtml(text, rootId);
        return [page.id];
      }
      return [];
    });
  }
  async _importNotion() {
    await this._importFile(".zip", async (files) => {
      let totalSize = 0;
      for (const file of files) {
        const zip = new import_jszip.default();
        const zipFile = await zip.loadAsync(file);
        const fileArray = Object.values(zipFile.files);
        for (const file2 of fileArray) {
          if (file2.dir)
            continue;
          const fileContent = await file2.async("uint8array");
          totalSize += fileContent.length;
          if (totalSize > SHOW_LOADING_SIZE)
            return true;
        }
      }
      return false;
    }, async (file) => {
      const pageIds = [];
      const allPageMap = [];
      const parseZipFile = async (file2) => {
        var _a3;
        const zip = new import_jszip.default();
        const zipFile = await zip.loadAsync(file2);
        const pageMap = /* @__PURE__ */ new Map();
        allPageMap.push(pageMap);
        const files = Object.keys(zipFile.files);
        const promises = [];
        const csvFiles = files.filter((file3) => file3.endsWith(".csv")).map((file3) => file3.substring(0, file3.length - 4));
        for (let i = 0; i < files.length; i++) {
          const file3 = files[i];
          if (file3.startsWith("__MACOSX/"))
            continue;
          const lastSplitIndex = file3.lastIndexOf("/");
          if (csvFiles.includes(file3.substring(0, lastSplitIndex)))
            continue;
          const fileName = file3.substring(lastSplitIndex + 1);
          if (fileName.endsWith(".html") || fileName.endsWith(".md")) {
            const page = this.workspace.createPage({
              init: {
                title: ""
              }
            });
            pageMap.set(file3, page);
          }
          if (fileName.endsWith(".zip")) {
            const innerZipFile = await ((_a3 = zipFile.file(fileName)) == null ? void 0 : _a3.async("blob"));
            if (innerZipFile) {
              promises.push(...await parseZipFile(innerZipFile));
            }
          }
        }
        const pagePromises = Array.from(pageMap.keys()).map(async (file3) => {
          var _a4, _b;
          const page = pageMap.get(file3);
          if (!page)
            return;
          const lastSplitIndex = file3.lastIndexOf("/");
          const folder = file3.substring(0, lastSplitIndex) || "";
          const fileName = file3.substring(lastSplitIndex + 1);
          if (fileName.endsWith(".html") || fileName.endsWith(".md")) {
            const isHtml = fileName.endsWith(".html");
            const rootId = (_a4 = page.root) == null ? void 0 : _a4.id;
            const fetchFileHandler = async (url) => {
              var _a5;
              const fileName2 = this.joinWebPaths(folder, decodeURI(url));
              return await ((_a5 = zipFile.file(fileName2)) == null ? void 0 : _a5.async("blob")) || new Blob();
            };
            const textStyleHandler = (element, textStyle) => {
              if (textStyle["link"]) {
                const link = textStyle["link"];
                const subPageLink = this.joinWebPaths(folder, decodeURI(link));
                const linkPage = pageMap.get(subPageLink);
                if (linkPage) {
                  textStyle["reference"] = {
                    pageId: linkPage.id,
                    type: "LinkedPage"
                  };
                  delete textStyle["link"];
                }
              }
            };
            const tableParserHandler = async (element) => {
              var _a5, _b2;
              if (element.tagName === "A" && ((_a5 = element.getAttribute("href")) == null ? void 0 : _a5.endsWith(".csv"))) {
                const href = element.getAttribute("href") || "";
                const fileName2 = this.joinWebPaths(folder, decodeURI(href));
                const tableString = await ((_b2 = zipFile.file(fileName2)) == null ? void 0 : _b2.async("string"));
                let result = [];
                let id = 1;
                const titles = [];
                const rows = [];
                tableString == null ? void 0 : tableString.split("\n").forEach((row, index) => {
                  if (index === 0) {
                    titles.push(...row.split(","));
                  } else {
                    const rowArray = row.split(",");
                    rows.push(rowArray);
                  }
                });
                const columns = titles.slice(1).map((value, index) => {
                  return {
                    name: value,
                    type: "rich-text",
                    width: 200,
                    hide: false,
                    id: "" + id++
                  };
                });
                if (rows.length > 0) {
                  let maxLen = rows[0].length;
                  for (let i = 1; i < rows.length; i++) {
                    maxLen = Math.max(maxLen, rows[i].length);
                  }
                  const addNum = maxLen - columns.length;
                  for (let i = 0; i < addNum; i++) {
                    columns.push({
                      name: "",
                      type: "rich-text",
                      width: 200,
                      hide: false,
                      id: "" + id++
                    });
                  }
                }
                const databasePropsId = id++;
                const cells = {};
                const children = [];
                rows.forEach((row) => {
                  children.push({
                    flavour: "affine:paragraph",
                    type: "text",
                    text: [{ insert: row[0] }],
                    children: []
                  });
                  const rowId = "" + id++;
                  cells[rowId] = {};
                  row.slice(1).forEach((value, index) => {
                    cells[rowId][columns[index].id] = {
                      columnId: columns[index].id,
                      value
                    };
                  });
                });
                result = [
                  {
                    flavour: "affine:database",
                    databaseProps: {
                      id: "" + databasePropsId,
                      title: element.textContent || "Database",
                      titleColumnName: titles[0],
                      titleColumnWidth: 432,
                      rowIds: Object.keys(cells),
                      cells,
                      columns
                    },
                    children
                  }
                ];
                return result;
              }
              return null;
            };
            const contentParser = new ContentParser(page, fetchFileHandler, textStyleHandler, tableParserHandler);
            const text = await ((_b = zipFile.file(file3)) == null ? void 0 : _b.async("string")) || "";
            if (rootId) {
              pageIds.push(page.id);
              if (isHtml) {
                await contentParser.importHtml(text, rootId);
              } else {
                await contentParser.importMarkdown(text, rootId);
              }
            }
          }
        });
        promises.push(...pagePromises);
        return promises;
      };
      const allPromises = await parseZipFile(file);
      await Promise.all(allPromises.flat());
      return pageIds;
    });
  }
  joinWebPaths(...paths) {
    const fullPath = paths.join("/").replace(/\/+/g, "/");
    const parts = fullPath.split("/").filter(Boolean);
    const resolvedParts = [];
    parts.forEach((part) => {
      if (part === ".") {
        return;
      }
      if (part === "..") {
        resolvedParts.pop();
      } else {
        resolvedParts.push(part);
      }
    });
    return resolvedParts.join("/");
  }
  _openLearnImportLink(event) {
    event.stopPropagation();
    window.open("https://affine.pro/blog/import-your-data-from-notion-into-affine", "_blank");
  }
  render() {
    if (this._loading) {
      return html`
        <header
          class="loading-header"
          @mousedown=${this._onMouseDown}
          @mouseup=${this._onMouseUp}
        >
          <div>Import</div>
          <loader-element width="50px"></loader-element>
        </header>
        <div>
          Importing the file may take some time. It depends on document size and
          complexity.
        </div>
      `;
    }
    return html`
      <header @mousedown=${this._onMouseDown} @mouseup=${this._onMouseUp}>
        <icon-button height="16px" @click=${this._onCloseClick}>
          ${CloseIcon}
        </icon-button>
        <div>Import</div>
      </header>
      <div>
        AFFiNE will gradually support more and more file types for import.
        <a
          href="https://community.affine.pro/c/feature-requests/import-export"
          target="_blank"
          >Provide feedback.</a
        >
      </div>
      <div class="button-container">
        <icon-button
          class="button-item"
          text="Markdown"
          @click=${this._importMarkDown}
        >
          ${ExportToMarkdownIcon}
        </icon-button>
        <icon-button class="button-item" text="HTML" @click=${this._importHtml}>
          ${ExportToHTMLIcon}
        </icon-button>
      </div>
      <div class="button-container">
        <icon-button
          class="button-item"
          text="Notion"
          @click=${this._importNotion}
        >
          ${NotionIcon}
          <div
            slot="optional"
            class="has-tool-tip"
            @click=${this._openLearnImportLink}
          >
            ${HelpIcon}
            <tool-tip inert arrow tip-position="top" role="tooltip">
              Learn how to Import your Notion pages into AFFiNE.
            </tool-tip>
          </div>
        </icon-button>
        <icon-button class="button-item" text="Coming soon..." disabled="true">
          ${NewIcon}
        </icon-button>
      </div>
      <!-- <div class="footer">
        <div>Migrate from other versions of AFFiNE?</div>
      </div> -->
    `;
  }
};
ImportPage.styles = styles4;
__decorate20([
  state()
], ImportPage.prototype, "_loading", void 0);
__decorate20([
  state()
], ImportPage.prototype, "x", void 0);
__decorate20([
  state()
], ImportPage.prototype, "y", void 0);
__decorate20([
  state()
], ImportPage.prototype, "_startX", void 0);
__decorate20([
  state()
], ImportPage.prototype, "_startY", void 0);
ImportPage = __decorate20([
  customElement("import-page")
], ImportPage);

// node_modules/@blocksuite/blocks/dist/components/import-page/index.js
function showImportModal({ workspace, onSuccess, multiple = true, container = document.body, abortController = new AbortController() }) {
  const importPage = new ImportPage(workspace, multiple, onSuccess, abortController);
  container.appendChild(importPage);
  const disposables = new DisposableGroup();
  abortController.signal.addEventListener("abort", () => disposables.dispose());
  disposables.add(() => importPage.remove());
  disposables.addFromEvent(window, "mousedown", (e) => {
    if (e.target === importPage || importPage.loading())
      return;
    abortController.abort();
  });
  return importPage;
}

// node_modules/@blocksuite/blocks/dist/components/menu-divider.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MenuDivider = class MenuDivider2 extends LitElement {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  render() {
    return html`<div
      class="divider ${this.vertical ? "vertical" : "horizontal"}"
    ></div>`;
  }
};
MenuDivider.styles = css`
    :host {
      display: inline-block;
    }

    .divider {
      background-color: var(--affine-border-color);
    }

    .divider.vertical {
      width: 1px;
      height: 100%;
      margin: 0 7px;
    }

    .divider.horizontal {
      width: 100%;
      height: 1px;
      margin: 7px 0;
    }
  `;
__decorate21([
  property()
], MenuDivider.prototype, "vertical", void 0);
MenuDivider = __decorate21([
  customElement("menu-divider")
], MenuDivider);

// node_modules/@blocksuite/blocks/dist/components/remote-selection/remote-selection.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function addAlpha(hexColor, opacity) {
  const normalized = Math.round(Math.min(Math.max(opacity, 0), 1) * 255);
  return hexColor + normalized.toString(16).toUpperCase();
}
function randomColor() {
  const hex = Math.floor(Math.random() * 16777215).toString(16);
  return `#${hex}`;
}
function selectionStyle(rect, color) {
  return styleMap({
    position: "absolute",
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    top: `${rect.top}px`,
    left: `${rect.left}px`,
    backgroundColor: color
  });
}
function cursorStyle(rect, color) {
  return styleMap({
    position: "absolute",
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    top: `${rect.top}px`,
    left: `${rect.left}px`,
    backgroundColor: color
  });
}
var RemoteSelection = class RemoteSelection2 extends LitElement {
  constructor() {
    super(...arguments);
    this.page = null;
    this._ranges = [];
    this._colorMap = /* @__PURE__ */ new Map();
    this._resizeObserver = new ResizeObserver(() => {
      this.requestUpdate();
    });
    this._abortController = new AbortController();
  }
  firstUpdated() {
    assertExists(this.page);
    this.page.awarenessStore.slots.update.subscribe((msg) => msg, (msg) => {
      var _a3, _b;
      if (!msg || !((_a3 = msg.state) == null ? void 0 : _a3.rangeMap)) {
        return;
      }
      if (msg.id === ((_b = this.page) == null ? void 0 : _b.awarenessStore.awareness.clientID)) {
        return;
      }
      assertExists(this.page);
      const page = this.page;
      const { user, rangeMap } = msg.state;
      if (msg.type === "update") {
        const index = this._ranges.findIndex((range) => range.id === msg.id);
        if (index === -1) {
          this._ranges.push({
            id: msg.id,
            userRange: rangeMap[page.prefixedId],
            user
          });
        } else {
          this._ranges[index] = {
            id: msg.id,
            userRange: rangeMap[page.prefixedId],
            user
          };
        }
      } else if (msg.type === "add") {
        this._ranges.push({
          id: msg.id,
          userRange: rangeMap[page.prefixedId],
          user
        });
      } else if (msg.type === "remove") {
        const index = this._ranges.findIndex((range) => range.id === msg.id);
        this._ranges.splice(index, 1);
      }
      this.requestUpdate();
    });
    this.page.history.on("stack-item-popped", (event) => {
      const userRange = event.stackItem.meta.get("cursor-location");
      if (!userRange) {
        return;
      }
      assertExists(this.page);
      const models = userRange.blockIds.map((id) => {
        assertExists(this.page);
        return this.page.getBlockById(id);
      }).filter(Boolean);
      if (!models.length) {
        return;
      }
      requestAnimationFrame(() => {
        assertExists(this.page);
        if (models.length === 1 && models[0] === this.page.root) {
          restoreSelection({
            type: "Title",
            startOffset: userRange.startOffset,
            endOffset: userRange.endOffset,
            models: [this.page.root]
          });
          return;
        }
        restoreSelection({
          type: "Native",
          startOffset: userRange.startOffset,
          endOffset: userRange.endOffset,
          models
        });
      });
    });
    this._resizeObserver.observe(document.body);
    const viewportElement = document.querySelector(".affine-default-viewport");
    viewportElement == null ? void 0 : viewportElement.addEventListener("scroll", () => this.requestUpdate(), {
      signal: this._abortController.signal
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._resizeObserver.disconnect();
    this._abortController.abort();
  }
  _getSelectionRect(userRange) {
    assertExists(this.page);
    const models = userRange.blockIds.map((id) => {
      assertExists(this.page);
      return this.page.getBlockById(id);
    }).filter(Boolean);
    let nativeRange = null;
    if (models.length === 1 && models[0] === this.page.root) {
      nativeRange = blockRangeToNativeRange({
        type: "Title",
        startOffset: userRange.startOffset,
        endOffset: userRange.endOffset,
        models: [this.page.root]
      });
    } else {
      nativeRange = blockRangeToNativeRange({
        type: "Native",
        startOffset: userRange.startOffset,
        endOffset: userRange.endOffset,
        models
      });
    }
    if (!nativeRange) {
      return [];
    }
    const container = getEditorContainer(this.page);
    assertExists(container);
    const containerRect = container.getBoundingClientRect();
    const nativeRects = Array.from(nativeRange.getClientRects());
    return nativeRects.map((rect) => ({
      width: rect.width,
      height: rect.height,
      top: rect.top - containerRect.top,
      left: rect.left - containerRect.left
    })).filter((rect) => rect.width > 1 && rect.height > 0 || userRange.blockIds.length === 1);
  }
  _getCursorRect(userRange) {
    assertExists(this.page);
    const endBlockId = userRange.blockIds[userRange.blockIds.length - 1];
    const endOffset = userRange.endOffset;
    const endModel = this.page.getBlockById(endBlockId);
    if (!endModel || !endModel.text) {
      return null;
    }
    const nativeRange = blockRangeToNativeRange({
      type: "Native",
      startOffset: endOffset,
      endOffset,
      models: [endModel]
    });
    if (!nativeRange) {
      return null;
    }
    const container = getEditorContainer(this.page);
    assertExists(container);
    const containerRect = container.getBoundingClientRect();
    const nativeRects = Array.from(nativeRange.getClientRects());
    if (nativeRects.length === 1) {
      const rect = nativeRects[0];
      return {
        width: 2,
        height: rect.height + 4,
        top: rect.top - 2 - containerRect.top,
        left: rect.left - containerRect.left
      };
    }
    return null;
  }
  render() {
    if (!this.page || this._ranges.length === 0) {
      this._colorMap.clear();
      return html``;
    }
    const selections = this._ranges.filter((range) => range.userRange).map((range) => ({
      id: range.id,
      userRange: range.userRange,
      rects: this._getSelectionRect(range.userRange),
      user: range.user
    }));
    return html`<div>
      ${selections.flatMap((selection) => {
      var _a3;
      if (selection.user) {
        this._colorMap.set(selection.id, selection.user.color);
      }
      if (!this._colorMap.has(selection.id)) {
        this._colorMap.set(selection.id, randomColor());
      }
      const color = this._colorMap.get(selection.id);
      const cursorRect = this._getCursorRect(selection.userRange);
      return selection.rects.map((r) => html`
              <div style="${selectionStyle(r, addAlpha(color, 0.5))}"></div>
            `).concat([
        html`
              <div
                style="${cursorRect ? cursorStyle(cursorRect, color) : styleMap({
          display: "none"
        })}"
              >
                <div
                  style="${styleMap({
          position: "relative",
          height: "100%"
        })}"
                >
                  <div
                    style="${styleMap({
          position: "absolute",
          bottom: `${cursorRect == null ? void 0 : cursorRect.height}px`,
          padding: "2px",
          "background-color": color,
          color: "white"
        })}"
                  >
                    ${(_a3 = selection.user) == null ? void 0 : _a3.name}
                  </div>
                </div>
              </div>
            `
      ]);
    })}
    </div>`;
  }
};
RemoteSelection.styles = css`
    :host {
      position: absolute;
      pointer-events: none;
      left: 0;
      top: 0;
    }
  `;
__decorate22([
  property()
], RemoteSelection.prototype, "page", void 0);
RemoteSelection = __decorate22([
  customElement("remote-selection")
], RemoteSelection);

// node_modules/@blocksuite/blocks/dist/components/selected-blocks.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AffineSelectedBlocks = class AffineSelectedBlocks2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.offset = { x: 0, y: 0 };
    this.state = { rects: [], grab: false };
  }
  _onPointerUp({ clientX, clientY, shiftKey }) {
    this.removeAttribute("data-grab");
    document.dispatchEvent(new PointerEvent("pointerup", {
      bubbles: true,
      clientX,
      clientY,
      shiftKey
    }));
  }
  connectedCallback() {
    super.connectedCallback();
    this._disposables.addFromEvent(this, "pointerup", this._onPointerUp);
  }
  willUpdate() {
    const { rects: [firstRect], grab } = this.state;
    if (firstRect) {
      const { x, y } = this.offset;
      this.style.top = `${firstRect.top + y}px`;
      this.style.left = `${firstRect.left + x}px`;
    }
    this.toggleAttribute("data-grab", Boolean(firstRect && grab));
  }
  render() {
    const { rects } = this.state;
    const firstRect = rects[0];
    return firstRect ? repeat(rects, (rect) => html`<div
            style=${styleMap({
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      top: `${rect.top - firstRect.top}px`,
      left: `${rect.left - firstRect.left}px`
    })}
          ></div>`) : nothing;
  }
};
AffineSelectedBlocks.styles = css`
    :host {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    :host([data-grab]) {
      pointer-events: auto;
    }

    :host([data-grab]:hover) {
      cursor: grab;
    }

    :host > div {
      position: absolute;
      border-radius: 5px;
      background: var(--affine-hover-color);
    }
  `;
__decorate23([
  property()
], AffineSelectedBlocks.prototype, "mouseRoot", void 0);
__decorate23([
  property()
], AffineSelectedBlocks.prototype, "offset", void 0);
__decorate23([
  property()
], AffineSelectedBlocks.prototype, "state", void 0);
AffineSelectedBlocks = __decorate23([
  customElement("affine-selected-blocks")
], AffineSelectedBlocks);

// node_modules/@blocksuite/blocks/dist/page-block/default/utils.js
var offscreen = document.createElement("div");
async function downloadImage(model) {
  const img = await getUrlByModel(model);
  if (!img) {
    return;
  }
  const arrayBuffer = await img.arrayBuffer();
  const buffer = new Uint8Array(arrayBuffer);
  let fileType;
  if (buffer[0] === 71 && buffer[1] === 73 && buffer[2] === 70 && buffer[3] === 56) {
    fileType = "image/gif";
  } else if (buffer[0] === 137 && buffer[1] === 80 && buffer[2] === 78 && buffer[3] === 71) {
    fileType = "image/png";
  } else if (buffer[0] === 255 && buffer[1] === 216 && buffer[2] === 255 && buffer[3] === 224) {
    fileType = "image/jpeg";
  } else {
    console.error("unknown image type");
    fileType = "image/png";
  }
  const downloadUrl = URL.createObjectURL(new Blob([arrayBuffer], { type: fileType }));
  const a = document.createElement("a");
  const event = new MouseEvent("click");
  a.download = "image";
  a.href = downloadUrl;
  a.dispatchEvent(event);
  a.remove();
  URL.revokeObjectURL(downloadUrl);
}
async function copyImage(model) {
  copyBlocks({
    type: "Block",
    models: [model],
    startOffset: 0,
    endOffset: 0
  });
  toast("Copied image to clipboard");
}
function getTextDelta(model) {
  if (!model.text) {
    return [];
  }
  return model.text.toDelta();
}
async function copyBlock(model) {
  var _a3;
  const copyType = "blocksuite/x-c+w";
  const delta = getTextDelta(model);
  const copyData = {
    data: [
      {
        type: model.type,
        flavour: model.flavour,
        sourceId: model.sourceId,
        text: delta,
        children: []
      }
    ]
  };
  const copySuccess = performNativeCopy2([
    { mimeType: copyType, data: JSON.stringify(copyData) },
    { mimeType: "text/plain", data: ((_a3 = model.text) == null ? void 0 : _a3.toString()) || "" }
  ]);
  return copySuccess;
}
function performNativeCopy2(items) {
  let success = false;
  const tempElem = document.createElement("textarea");
  tempElem.value = "temp";
  document.body.appendChild(tempElem);
  tempElem.select();
  tempElem.setSelectionRange(0, tempElem.value.length);
  const listener = (e) => {
    const clipboardData = e.clipboardData;
    if (clipboardData) {
      items.forEach((item) => clipboardData.setData(item.mimeType, item.data));
    }
    e.preventDefault();
    e.stopPropagation();
    tempElem.removeEventListener("copy", listener);
  };
  tempElem.addEventListener("copy", listener);
  try {
    success = document.execCommand("copy");
  } finally {
    tempElem.removeEventListener("copy", listener);
    document.body.removeChild(tempElem);
  }
  return success;
}
function focusCaption(model) {
  const blockEle = getBlockElementByModel(model);
  assertExists(blockEle);
  const dom = blockEle.querySelector(".affine-embed-wrapper-caption");
  dom.classList.add("caption-show");
  dom.focus();
}
async function getUrlByModel(model) {
  assertExists(model.sourceId);
  const store = await model.page.blobs;
  const url = store == null ? void 0 : store.get(model.sourceId);
  return url;
}
function copyCode(codeBlockModel) {
  copyBlocks({
    type: "Block",
    models: [codeBlockModel],
    startOffset: 0,
    endOffset: 0
  });
  toast("Copied to clipboard");
}
function getAllowSelectedBlocks(model) {
  const result = [];
  const blocks = model.children.slice();
  const dfs = (blocks2) => {
    for (const block2 of blocks2) {
      if (block2.flavour !== "affine:frame") {
        result.push(block2);
      }
      block2.children.length && dfs(block2.children);
    }
  };
  dfs(blocks);
  return result;
}
function createDragHandle(pageBlock) {
  return new DragHandle({
    // drag handle should be the same level with editor-container
    container: pageBlock.mouseRoot,
    onDropCallback(_point, blockElements2, editingState, type) {
      if (!editingState || type === "none")
        return;
      const { model } = editingState;
      const page = pageBlock.page;
      const models = getBlockElementsExcludeSubtrees(blockElements2).map(getModelByBlockElement);
      if (models.length === 1 && isInSamePath(page, model, models[0]))
        return;
      page.captureSync();
      const parent = page.getParent(model);
      const dragBlockParent = page.getParent(models[0]);
      if (type === "database") {
        page.moveBlocks(models, model);
      } else {
        assertExists(parent);
        page.moveBlocks(models, parent, model, type === "before");
      }
      pageBlock.updateComplete.then(() => {
        if (dragBlockParent && matchFlavours(dragBlockParent, ["affine:database"])) {
          const service = getService("affine:database");
          service.refreshRowSelection();
        }
        if (parent && matchFlavours(parent, ["affine:database"])) {
          pageBlock.selection.clear();
          return;
        }
        requestAnimationFrame(() => {
          pageBlock.selection.setSelectedBlocks(blockElements2.map((b) => getBlockElementById(b.model.id)).filter((b) => !!b));
        });
      });
    },
    setDragType(dragging) {
      pageBlock.selection.state.type = dragging ? "block:drag" : "block";
    },
    setSelectedBlock(modelState, element) {
      if (element && element.closest("affine-database")) {
        const service2 = getService("affine:database");
        const toggled = service2.toggleRowSelection(element);
        if (toggled) {
          pageBlock.selection.clear();
          return;
        }
      }
      const model = modelState == null ? void 0 : modelState.model;
      if (model) {
        const parent = model.page.getParent(model);
        if (parent && matchFlavours(parent, ["affine:database"])) {
          const service2 = getService("affine:database");
          service2.setRowSelectionByElement(modelState.element);
          return;
        }
      }
      pageBlock.selection.selectOneBlock(modelState == null ? void 0 : modelState.element, modelState == null ? void 0 : modelState.rect);
      const service = getServiceOrRegister("affine:database");
      Promise.resolve(service).then((service2) => {
        const rowSelection = service2.getLastRowSelection();
        if (rowSelection) {
          service2.clearRowSelection();
        }
      });
    },
    getSelectedBlocks() {
      return pageBlock.selection.state.selectedBlocks;
    },
    getClosestBlockElement(point) {
      return getClosestBlockElementByPoint(point, {
        rect: pageBlock.innerRect
      });
    }
  });
}

// node_modules/@blocksuite/blocks/dist/components/linked-page/styles.js
var styles5 = css`
  :host {
    position: absolute;
  }

  .linked-page-popover {
    position: fixed;
    left: 0;
    top: 0;
    box-sizing: border-box;
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-base);
    padding: 12px 8px;
    display: flex;
    flex-direction: column;

    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-shadow-2);
    border-radius: 12px;
    z-index: var(--affine-z-index-popover);
  }

  .linked-page-popover icon-button {
    padding: 8px;
    justify-content: flex-start;
    gap: 8px;
  }

  .linked-page-popover .group-title {
    color: var(--affine-text-secondary-color);
    margin: 8px 12px;
  }

  .linked-page-popover .divider {
    margin: 6px 12px;
    height: 1px;
    background: var(--affine-border-color);
  }

  ::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }
  ::-webkit-scrollbar-thumb {
    border-radius: 2px;
    background-color: #b1b1b1;
  }
`;

// node_modules/@blocksuite/blocks/dist/components/linked-page/linked-page-popover.js
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function cleanSpecifiedTail(vEditor, str) {
  const vRange = vEditor.getVRange();
  assertExists(vRange);
  const idx = vRange.index - str.length;
  const textStr = vEditor.yText.toString().slice(idx, idx + str.length);
  if (textStr !== str) {
    console.warn(`Failed to clean text! Text mismatch expected: ${str} but actual: ${textStr}`);
    return;
  }
  vEditor.deleteText({ index: idx, length: str.length });
  vEditor.setVRange({
    index: idx,
    length: 0
  });
}
var DEFAULT_PAGE_NAME3 = "Untitled";
var LinkedPagePopover = class LinkedPagePopover2 extends WithDisposable(LitElement) {
  get _actionList() {
    const DISPLAY_LENGTH = 8;
    const pageName = this._query || DEFAULT_PAGE_NAME3;
    const displayPageName = pageName.slice(0, DISPLAY_LENGTH) + (pageName.length > DISPLAY_LENGTH ? ".." : "");
    const filteredPageList = this._pageList.filter(({ title }) => isFuzzyMatch(title, this._query));
    return [
      ...filteredPageList.map((page, idx) => ({
        key: page.id,
        name: page.title || DEFAULT_PAGE_NAME3,
        active: idx === this._activatedItemIndex,
        icon: PageIcon,
        action: () => this._insertLinkedNode("LinkedPage", page.id)
      })),
      // The active condition is a bit tricky here
      {
        key: "create-linked-page",
        name: `Create "${displayPageName}" page`,
        active: filteredPageList.length === this._activatedItemIndex,
        icon: DualLinkIcon,
        action: () => this._createPage()
      },
      // {
      //   key: 'create-subpage',
      //   name: `Create "${displayPageName}" subpage`,
      //   active: filteredPageList.length + 1 === this._activatedItemIndex,
      //   icon: NewPageIcon,
      //   action: () => this._createSubpage(),
      // },
      {
        key: "import-linked-page",
        name: `Import`,
        active: filteredPageList.length === this._activatedItemIndex,
        icon: ImportIcon,
        action: () => this._importPage()
      }
    ];
  }
  get _page() {
    return this.model.page;
  }
  constructor(model, abortController = new AbortController()) {
    super();
    this.model = model;
    this.abortController = abortController;
    this._position = null;
    this._query = "";
    this._pageList = [];
    this._activatedItemIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback();
    const richText = getRichTextByModel(this.model);
    assertExists(richText, "RichText not found");
    createKeydownObserver({
      target: richText,
      onUpdateQuery: (str) => {
        this._query = str;
        this._activatedItemIndex = 0;
      },
      abortController: this.abortController,
      onMove: (step) => {
        this._activatedItemIndex = (this._actionList.length + this._activatedItemIndex + step) % this._actionList.length;
        const item = this._actionList[this._activatedItemIndex];
        if (item.key === "create-linked-page" || item.key === "import-linked-page") {
          return;
        }
        const shadowRoot = this.shadowRoot;
        if (!shadowRoot) {
          console.warn("Failed to find the shadow root!", this);
          return;
        }
        const ele = shadowRoot.querySelector(`icon-button[data-id="${item.key}"]`);
        if (!ele) {
          console.warn("Failed to find the active item!", item);
          return;
        }
        ele.scrollIntoView({
          block: "nearest"
        });
      },
      onConfirm: () => {
        this._actionList[this._activatedItemIndex].action();
      },
      onEsc: () => {
        this.abortController.abort();
      }
    });
    this._disposables.addFromEvent(this, "mousedown", (e) => {
      e.preventDefault();
    });
    this._pageList = this._page.workspace.meta.pageMetas;
    this._disposables.add(this.model.page.workspace.slots.pagesUpdated.on(() => {
      this._pageList = this._page.workspace.meta.pageMetas;
    }));
  }
  updatePosition(position) {
    this._position = position;
  }
  _insertLinkedNode(type, pageId) {
    this.abortController.abort();
    const vEditor = getVirgoByModel(this.model);
    assertExists(vEditor, "Editor not found");
    cleanSpecifiedTail(vEditor, "@" + this._query);
    const vRange = vEditor.getVRange();
    assertExists(vRange);
    vEditor.insertText(vRange, REFERENCE_NODE, { reference: { type, pageId } });
    vEditor.setVRange({
      index: vRange.index + 1,
      length: 0
    });
  }
  _createPage() {
    const pageName = this._query;
    const page = this._page.workspace.createPage({
      init: {
        title: pageName
      }
    });
    this._insertLinkedNode("LinkedPage", page.id);
  }
  _importPage() {
    this.abortController.abort();
    const onSuccess = (pageIds) => {
      if (pageIds.length === 0) {
        return;
      }
      const pageId = pageIds[0];
      this._insertLinkedNode("LinkedPage", pageId);
    };
    showImportModal({
      workspace: this._page.workspace,
      multiple: false,
      onSuccess
    });
  }
  // private _createSubpage() {
  //   const pageName = this._query;
  //   const page = this._page.workspace.createPage({
  //     init: {
  //       title: pageName,
  //     },
  //   });
  //   this._insertLinkedNode('Subpage', page.id);
  // }
  render() {
    const MAX_HEIGHT = 396;
    const style = this._position ? styleMap({
      transform: `translate(${this._position.x}, ${this._position.y})`,
      maxHeight: `${Math.min(this._position.height, MAX_HEIGHT)}px`
    }) : styleMap({
      visibility: "hidden"
    });
    const pageList = this._actionList.slice(0, -2).map(({ key, name, action, active, icon }, index) => html`<icon-button
        width="280px"
        height="32px"
        data-id=${key}
        text=${name}
        ?hover=${active}
        @click=${action}
        @mousemove=${() => {
      this._activatedItemIndex = index;
    }}
        >${icon}</icon-button
      >`);
    const createList = this._actionList.slice(-2).map(({ key, name, action, active, icon }, index) => html`<icon-button
        width="280px"
        height="32px"
        data-id=${key}
        text=${name}
        ?hover=${active}
        @click=${action}
        @mousemove=${() => {
      this._activatedItemIndex = this._actionList.length - 1 + index;
    }}
        >${icon}</icon-button
      >`);
    return html`<div class="linked-page-popover" style="${style}">
      ${pageList.length ? html`<div class="group-title">Link to page</div>
            <div class="group" style="overflow-y: scroll; max-height: 224px;">
              ${pageList}
            </div>
            <div class="divider"></div>` : null}

      <div class="group-title">New page</div>
      ${createList}
    </div>`;
  }
};
LinkedPagePopover.styles = styles5;
__decorate24([
  state()
], LinkedPagePopover.prototype, "_position", void 0);
__decorate24([
  state()
], LinkedPagePopover.prototype, "_query", void 0);
__decorate24([
  state()
], LinkedPagePopover.prototype, "_pageList", void 0);
__decorate24([
  state()
], LinkedPagePopover.prototype, "_activatedItemIndex", void 0);
__decorate24([
  query(".linked-page-popover")
], LinkedPagePopover.prototype, "linkedPageElement", void 0);
LinkedPagePopover = __decorate24([
  customElement("affine-linked-page-popover")
], LinkedPagePopover);

// node_modules/@blocksuite/blocks/dist/components/linked-page/index.js
function showLinkedPagePopover({ model, range, container = document.body, abortController = new AbortController() }) {
  const disposables = new DisposableGroup();
  abortController.signal.addEventListener("abort", () => disposables.dispose());
  const linkedPage = new LinkedPagePopover(model, abortController);
  container.appendChild(linkedPage);
  disposables.add(() => linkedPage.remove());
  const updatePosition2 = throttle(() => {
    const linkedPageElement = linkedPage.linkedPageElement;
    assertExists(linkedPageElement, "You should render the linked page node even if no position");
    const position = getPopperPosition(linkedPageElement, range);
    linkedPage.updatePosition(position);
  }, 10);
  disposables.addFromEvent(window, "resize", updatePosition2);
  const scrollContainer = getViewportElement(model.page);
  if (scrollContainer) {
    disposables.addFromEvent(scrollContainer, "scroll", updatePosition2, {
      passive: true
    });
  }
  setTimeout(updatePosition2);
  disposables.addFromEvent(window, "mousedown", (e) => {
    if (e.target === linkedPage)
      return;
    abortController.abort();
  });
  return linkedPage;
}

// node_modules/@blocksuite/blocks/dist/components/slash-menu/config.js
function insertContent(model, text, attributes) {
  if (!model.text) {
    throw new Error("Can't insert text! Text not found");
  }
  const vEditor = getVirgoByModel(model);
  if (!vEditor) {
    throw new Error("Can't insert text! vEditor not found");
  }
  const vRange = vEditor.getVRange();
  const index = vRange ? vRange.index : model.text.length;
  model.text.insert(text, index, attributes);
  vEditor.setVRange({
    index: index + text.length,
    length: 0
  });
}
function formatDate(date) {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const day = date.getDate().toString().padStart(2, "0");
  const strTime = `${year}-${month}-${day}`;
  return strTime;
}
function insideDatabase(model) {
  return utils_exports.isInsideBlockByFlavour(model.page, model, "affine:database");
}
var menuGroups = [
  {
    name: "Text",
    items: [
      ...paragraphConfig.filter((i) => i.flavour !== "affine:list").map(({ name, icon, flavour, type }) => ({
        name,
        icon,
        showWhen: (model) => {
          if (!model.page.schema.flavourSchemaMap.has(flavour)) {
            return false;
          }
          if (["Quote", "Code Block", "Divider"].includes(name)) {
            return !insideDatabase(model);
          }
          return true;
        },
        action: ({ model }) => {
          const newModels = updateBlockType([model], flavour, type);
          if (flavour === "affine:code") {
            if (newModels.length !== 1) {
              throw new Error("Failed to reset selection! New model length isn't 1");
            }
            const codeModel = newModels[0];
            onModelTextUpdated(codeModel, () => {
              restoreSelection({
                type: "Native",
                startOffset: 0,
                endOffset: 0,
                models: [codeModel]
              });
            });
          }
        }
      }))
    ]
  },
  {
    name: "Style",
    items: formatConfig.filter((i) => !["Link", "Code"].includes(i.name)).map(({ name, icon, id }) => ({
      name,
      icon,
      action: ({ model }) => {
        if (!model.text) {
          return;
        }
        const len3 = model.text.length;
        if (!len3) {
          const vEditor = getVirgoByModel(model);
          assertExists(vEditor, "Can't set style mark! vEditor not found");
          vEditor.setMarks({
            [id]: true
          });
          clearMarksOnDiscontinuousInput(vEditor);
          return;
        }
        model.text.format(0, len3, {
          [id]: true
        });
      }
    }))
  },
  {
    name: "List",
    items: paragraphConfig.filter((i) => i.flavour === "affine:list").map(({ name, icon, flavour, type }) => ({
      name,
      icon,
      showWhen: (model) => {
        if (!model.page.schema.flavourSchemaMap.has(flavour)) {
          return false;
        }
        return true;
      },
      action: ({ model }) => updateBlockType([model], flavour, type)
    }))
  },
  {
    name: "Pages",
    items: [
      {
        name: "New Page",
        icon: NewPageIcon,
        showWhen: (model) => !!model.page.awarenessStore.getFlag("enable_linked_page"),
        action: ({ page, model }) => {
          const newPage = page.workspace.createPage({
            init: true
          });
          insertContent(model, REFERENCE_NODE, {
            reference: { type: "LinkedPage", pageId: newPage.id }
          });
        }
      },
      {
        name: "Link Page",
        alias: ["dual link"],
        icon: DualLinkIcon,
        showWhen: (model) => !!model.page.awarenessStore.getFlag("enable_linked_page"),
        action: ({ model }) => {
          insertContent(model, "@");
          showLinkedPagePopover({ model, range: getCurrentNativeRange() });
        }
      }
    ]
  },
  {
    name: "Content & Media",
    items: [
      {
        name: "Image",
        icon: ImageIcon20,
        showWhen: (model) => {
          if (!model.page.schema.flavourSchemaMap.has("affine:embed")) {
            return false;
          }
          if (insideDatabase(model)) {
            return false;
          }
          return true;
        },
        async action({ page, model }) {
          const parent = page.getParent(model);
          if (!parent) {
            return;
          }
          parent.children.indexOf(model);
          const props = await uploadImageFromLocal(page);
          page.addSiblingBlocks(model, props);
        }
      },
      {
        name: "Bookmark",
        icon: BookmarkIcon,
        showWhen: (model) => {
          if (!model.page.awarenessStore.getFlag("enable_bookmark_operation")) {
            return false;
          }
          if (!model.page.schema.flavourSchemaMap.has("affine:embed")) {
            return false;
          }
          return !insideDatabase(model);
        },
        async action({ page, model }) {
          const parent = page.getParent(model);
          if (!parent) {
            return;
          }
          const index = parent.children.indexOf(model);
          createBookmarkBlock(parent, index + 1);
        }
      }
    ]
  },
  {
    name: "Date & Time",
    items: [
      {
        name: "Today",
        icon: TodayIcon,
        action: ({ model }) => {
          const date = /* @__PURE__ */ new Date();
          insertContent(model, formatDate(date));
        }
      },
      {
        name: "Tomorrow",
        icon: TomorrowIcon,
        action: ({ model }) => {
          const date = /* @__PURE__ */ new Date();
          date.setDate(date.getDate() + 1);
          insertContent(model, formatDate(date));
        }
      },
      {
        name: "Yesterday",
        icon: YesterdayIcon,
        action: ({ model }) => {
          const date = /* @__PURE__ */ new Date();
          date.setDate(date.getDate() - 1);
          insertContent(model, formatDate(date));
        }
      },
      {
        name: "Now",
        icon: NowIcon,
        action: ({ model }) => {
          const date = /* @__PURE__ */ new Date();
          let hours = date.getHours();
          const minutes = date.getMinutes().toString().padStart(2, "0");
          const amOrPm = hours >= 12 ? "pm" : "am";
          hours = hours % 12;
          hours = hours ? hours : 12;
          const strTime = hours + ":" + minutes + " " + amOrPm;
          insertContent(model, strTime);
        }
      }
    ]
  },
  {
    name: "Database",
    items: [
      {
        name: "Table View",
        alias: ["database"],
        icon: DatabaseTableViewIcon,
        showWhen: (model) => {
          if (!model.page.awarenessStore.getFlag("enable_database")) {
            return false;
          }
          if (!model.page.schema.flavourSchemaMap.has("affine:database")) {
            return false;
          }
          if (insideDatabase(model)) {
            return false;
          }
          return true;
        },
        action: async ({ page, model }) => {
          const parent = page.getParent(model);
          assertExists(parent);
          const index = parent.children.indexOf(model);
          const id = page.addBlock("affine:database", {}, page.getParent(model), index);
          const service = await getServiceOrRegister("affine:database");
          service.initDatabaseBlock(page, model, id, false);
        }
      },
      {
        name: "Kanban View",
        alias: ["database"],
        disabled: true,
        icon: DatabaseKanbanViewIcon,
        showWhen: (model) => {
          if (!model.page.awarenessStore.getFlag("enable_database")) {
            return false;
          }
          if (!model.page.schema.flavourSchemaMap.has("affine:database")) {
            return false;
          }
          if (insideDatabase(model)) {
            return false;
          }
          return true;
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        action: ({ model }) => {
        }
      }
    ]
  },
  {
    name: "Actions",
    items: [
      {
        name: "Copy",
        icon: CopyIcon,
        action: async ({ model }) => {
          const curRange = getCurrentNativeRange();
          await copyBlock(model);
          resetNativeSelection(curRange);
          toast("Copied to clipboard");
        }
      },
      // {
      //   name: 'Paste',
      //   icon: PasteIcon,
      //   action: async ({ model }) => {
      //     const copiedText = await navigator.clipboard.readText();
      //     console.log('copiedText', copiedText);
      //     insertContent(model, copiedText);
      //   },
      // },
      {
        name: "Duplicate",
        icon: DuplicateIcon,
        action: ({ page, model }) => {
          if (!model.text || !(model.text instanceof Text2)) {
            throw new Error("Can't duplicate a block without text");
          }
          const parent = page.getParent(model);
          if (!parent) {
            throw new Error("Failed to duplicate block! Parent not found");
          }
          const index = parent.children.indexOf(model);
          page.addBlock(model.flavour, {
            type: model.type,
            text: page.Text.fromDelta(normalizeDelta(page, model.text.toDelta())),
            // @ts-expect-error
            checked: model.checked
          }, page.getParent(model), index);
        }
      },
      {
        name: "Delete",
        icon: DeleteIcon,
        action: ({ page, model }) => {
          page.deleteBlock(model);
        }
      }
    ]
  }
].map((group) => ({
  name: group.name,
  items: group.items.map((item) => ({ ...item, groupName: group.name }))
}));

// node_modules/@blocksuite/blocks/dist/components/slash-menu/styles.js
var styles6 = css`
  .overlay-mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: var(--affine-z-index-popover);
  }

  .slash-menu-container {
    z-index: var(--affine-z-index-popover);
    user-select: none;
  }

  .slash-menu {
    position: fixed;
    left: 0;
    top: 0;
    box-sizing: border-box;
    font-size: var(--affine-font-base);
    padding: 12px 0;
    display: flex;

    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-shadow-2);
    border-radius: 12px;
    z-index: var(--affine-z-index-popover);
    /* transition: max-height 0.2s ease-in-out; */
  }

  .slash-category {
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
    width: 150px;
    max-width: 150px;
    display: flex;
    flex-direction: column;
    color: var(--affine-text-secondary-color);
    gap: 5px;
    margin-bottom: 20px;
    /* transition: max-width 0.2s ease-in-out; */
  }
  .slash-category::before {
    content: '';
    position: absolute;
    top: 10px;
    right: 0;
    height: 100%;
    width: 1px;
    background-color: var(--affine-border-color);
  }

  .slash-category-hide {
    max-width: 0;
    padding: 0;
    margin: 0;
    height: 0;
  }

  .slash-category-name {
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-sm);
    white-space: nowrap;
    cursor: pointer;
    padding: 4px 20px;
  }

  .slash-active-category {
    position: relative;
    box-sizing: border-box;
    color: var(--affine-primary-color);
  }

  .slash-active-category::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 12px;
    background: linear-gradient(
      180deg,
      var(--affine-text-emphasis-color) 0%,
      var(--affine-palette-purple) 100%
    );
    border-radius: 1px;
  }

  .slash-item-container {
    box-sizing: border-box;
    overflow-y: auto;
    padding: 0 8px;
    width: 200px;
  }

  ::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }
  ::-webkit-scrollbar-thumb {
    border-radius: 2px;
    background-color: #b1b1b1;
  }

  .slash-item-divider {
    border-top: 1px dashed var(--affine-border-color);
    margin: 8px 0;
  }

  format-bar-button svg {
    width: 20px;
    height: 20px;
  }
`;

// node_modules/@blocksuite/blocks/dist/components/slash-menu/slash-menu-popover.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function collectGroupNames(menuItem) {
  return menuItem.reduce((acc, item) => {
    if (!acc.length || acc[acc.length - 1] !== item.groupName) {
      acc.push(item.groupName);
    }
    return acc;
  }, []);
}
var SlashMenu = class SlashMenu2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._leftPanelActivated = false;
    this._activatedItemIndex = 0;
    this._filterItems = [];
    this._hide = false;
    this._position = null;
    this.abortController = new AbortController();
    this._searchString = "";
    this._onClickAway = (e) => {
      if (!this._hide)
        return;
      this.abortController.abort();
    };
  }
  get menuGroups() {
    return menuGroups;
  }
  connectedCallback() {
    super.connectedCallback();
    this._disposables.addFromEvent(window, "mousedown", this._onClickAway);
    this._disposables.addFromEvent(this, "mousedown", (e) => {
      e.preventDefault();
    });
    this._filterItems = this._updateItem("");
    const richText = getRichTextByModel(this.model);
    if (!richText) {
      console.warn("Slash Menu may not work properly! No rich text found for model", this.model);
      return;
    }
    createKeydownObserver({
      target: richText,
      abortController: this.abortController,
      interceptor: (e, next2) => {
        if (e.key === "/") {
          return;
        }
        if (this._hide && e.key !== "Backspace") {
          this.abortController.abort();
          return;
        }
        if (e.key === " ") {
          this._hide = true;
          next2();
          return;
        }
        if (this._hide) {
          this._hide = false;
        }
        const isControlled = isControlledKeyboardEvent(e);
        const isShift = e.shiftKey;
        if (e.key === "ArrowLeft" && !isControlled && !isShift) {
          e.stopPropagation();
          e.preventDefault();
          if (this._searchString.length)
            return;
          this._leftPanelActivated = true;
          return;
        }
        if (e.key === "ArrowRight" && !isControlled && !isShift) {
          e.stopPropagation();
          e.preventDefault();
          this._leftPanelActivated = false;
          return;
        }
        next2();
      },
      onUpdateQuery: (val) => {
        const newFilteredItems = this._updateItem(val);
        this._filterItems = newFilteredItems;
        if (!newFilteredItems.length) {
          this._hide = true;
        }
      },
      onMove: (step) => {
        const configLen = this._filterItems.length;
        if (this._leftPanelActivated) {
          const groupNames = collectGroupNames(this._filterItems);
          const nowGroupIdx = groupNames.findIndex((groupName) => groupName === this._filterItems[this._activatedItemIndex].groupName);
          const targetGroup = groupNames[(nowGroupIdx + step + groupNames.length) % groupNames.length];
          this._handleClickCategory(targetGroup);
          return;
        }
        let ejectedCnt = configLen;
        do {
          this._activatedItemIndex = (this._activatedItemIndex + step + configLen) % configLen;
        } while (this._filterItems[this._activatedItemIndex].disabled && // If all items are disabled, the loop will never end
        ejectedCnt--);
        this._scrollToItem(this._filterItems[this._activatedItemIndex], false);
      },
      onConfirm: () => {
        this._handleClickItem(this._activatedItemIndex);
      },
      onEsc: () => {
        this.abortController.abort();
      }
    });
  }
  updatePosition(position) {
    this._position = position;
  }
  _updateItem(query2) {
    this._searchString = query2;
    this._activatedItemIndex = 0;
    if (this._leftPanelActivated) {
      this._leftPanelActivated = false;
    }
    const searchStr = this._searchString.toLowerCase();
    let allMenus = this.menuGroups.flatMap((group) => group.items);
    allMenus = allMenus.filter(({ showWhen = () => true }) => showWhen(this.model));
    if (!searchStr) {
      return allMenus;
    }
    return allMenus.filter(({ name, alias = [] }) => [name, ...alias].some((str) => isFuzzyMatch(str, searchStr)));
  }
  _scrollToItem(item, force = true) {
    const shadowRoot = this.shadowRoot;
    if (!shadowRoot) {
      return;
    }
    const ele = shadowRoot.querySelector(`format-bar-button[text="${item.name}"]`);
    if (!ele) {
      return;
    }
    if (force) {
      ele.scrollIntoView(true);
      return;
    }
    ele.scrollIntoView({
      block: "nearest"
    });
  }
  _handleClickItem(index) {
    if (this._leftPanelActivated || index < 0 || index >= this._filterItems.length) {
      return;
    }
    this.abortController.abort(this._searchString);
    const { action } = this._filterItems[index];
    action({ page: this.model.page, model: this.model });
  }
  _handleClickCategory(groupName) {
    const item = this._filterItems.find((item2) => item2.groupName === groupName);
    if (!item)
      return;
    this._scrollToItem(item);
    this._activatedItemIndex = this._filterItems.findIndex((i) => i.name === item.name);
  }
  _categoryTemplate() {
    var _a3;
    const showCategory = !this._searchString.length;
    const activatedGroupName = (_a3 = this._filterItems[this._activatedItemIndex]) == null ? void 0 : _a3.groupName;
    const groups = collectGroupNames(this._filterItems);
    return html`<div
      class="slash-category ${!showCategory ? "slash-category-hide" : ""}"
    >
      ${groups.map((groupName) => html`<div
            class="slash-category-name ${activatedGroupName === groupName ? "slash-active-category" : ""}"
            @click=${() => this._handleClickCategory(groupName)}
          >
            ${groupName}
          </div>`)}
    </div>`;
  }
  render() {
    if (this._hide) {
      return nothing;
    }
    const MAX_HEIGHT_WITH_CATEGORY = 408;
    const MAX_HEIGHT = 344;
    const showCategory = !this._searchString.length;
    const slashMenuStyles = this._position ? styleMap({
      transform: `translate(${this._position.x}, ${this._position.y})`,
      maxHeight: `${Math.min(this._position.height, showCategory ? MAX_HEIGHT_WITH_CATEGORY : MAX_HEIGHT)}px`
    }) : styleMap({
      visibility: "hidden"
    });
    const btnItems = this._filterItems.map(({ name, icon, disabled = false, groupName }, index) => {
      const showDivider = index !== 0 && this._filterItems[index - 1].groupName !== groupName;
      return html`<div
            class="slash-item-divider"
            ?hidden=${!showDivider || !!this._searchString.length}
          ></div>
          <format-bar-button
            ?disabled=${disabled}
            width="100%"
            style="padding-left: 12px; justify-content: flex-start;"
            ?hover=${!disabled && !this._leftPanelActivated && this._activatedItemIndex === index}
            text="${name}"
            data-testid="${name}"
            @mousemove=${() => {
        this._leftPanelActivated = false;
        this._activatedItemIndex = index;
      }}
            @click=${() => {
        this._handleClickItem(index);
      }}
          >
            ${icon}
          </format-bar-button>`;
    });
    return html`<div class="slash-menu-container">
      <div
        class="overlay-mask"
        @click="${() => this.abortController.abort()}"
      ></div>
      <div class="slash-menu" style="${slashMenuStyles}">
        ${this._categoryTemplate()}
        <div class="slash-item-container">${btnItems}</div>
      </div>
    </div>`;
  }
};
SlashMenu.styles = styles6;
__decorate25([
  property()
], SlashMenu.prototype, "model", void 0);
__decorate25([
  query(".slash-menu")
], SlashMenu.prototype, "slashMenuElement", void 0);
__decorate25([
  state()
], SlashMenu.prototype, "_leftPanelActivated", void 0);
__decorate25([
  state()
], SlashMenu.prototype, "_activatedItemIndex", void 0);
__decorate25([
  state()
], SlashMenu.prototype, "_filterItems", void 0);
__decorate25([
  state()
], SlashMenu.prototype, "_hide", void 0);
__decorate25([
  state()
], SlashMenu.prototype, "_position", void 0);
SlashMenu = __decorate25([
  customElement("slash-menu")
], SlashMenu);

// node_modules/@blocksuite/blocks/dist/components/slash-menu/index.js
var globalAbortController = new AbortController();
function onAbort(e, slashMenu, positionCallback, model) {
  slashMenu.remove();
  window.removeEventListener("resize", positionCallback);
  if (!e.target || !(e.target instanceof AbortSignal)) {
    throw new Error("Failed to clean slash search text! Unknown abort event");
  }
  if (e.target.reason instanceof DOMException) {
    return;
  }
  if (typeof e.target.reason !== "string") {
    throw new Error("Failed to clean slash search text! Unknown abort reason");
  }
  const searchStr = "/" + e.target.reason;
  const text = model.text;
  if (!text) {
    console.warn("Failed to clean slash search text! No text found for model", model);
    return;
  }
  const vEditor = getVirgoByModel(model);
  if (!vEditor) {
    console.warn("Failed to clean slash search text! No vEditor found for model, model:", model);
    return;
  }
  const vRange = vEditor.getVRange();
  assertExists(vRange);
  const idx = vRange.index - searchStr.length;
  const textStr = text.toString().slice(idx, idx + searchStr.length);
  if (textStr !== searchStr) {
    console.warn(`Failed to clean slash search text! Text mismatch expected: ${searchStr} but actual: ${textStr}`);
    return;
  }
  text.delete(idx, searchStr.length);
  vEditor.setVRange({
    index: idx,
    length: 0
  });
}
function showSlashMenu({ model, range, container = document.body, abortController = new AbortController() }) {
  globalAbortController.abort();
  globalAbortController = abortController;
  const slashMenu = new SlashMenu();
  slashMenu.model = model;
  slashMenu.abortController = abortController;
  const updatePosition2 = throttle(() => {
    const slashMenuElement = slashMenu.slashMenuElement;
    assertExists(slashMenuElement, "You should render the slash menu node even if no position");
    const position = getPopperPosition(slashMenuElement, range);
    slashMenu.updatePosition(position);
  }, 10);
  window.addEventListener("resize", updatePosition2);
  container.appendChild(slashMenu);
  setTimeout(updatePosition2);
  abortController.signal.addEventListener("abort", (e) => {
    onAbort(e, slashMenu, updatePosition2, model);
  });
  return slashMenu;
}

// node_modules/@blocksuite/blocks/dist/page-block/utils/container-operations.js
function handleBlockSelectionBatchDelete(page, models) {
  const parentModel = page.getParent(models[0]);
  assertExists(parentModel);
  const index = parentModel.children.indexOf(models[0]);
  page.captureSync();
  models.forEach((model) => page.deleteBlock(model));
  const id = page.addBlock("affine:paragraph", { type: "text" }, parentModel, index);
  const newBlock = page.getBlockById(id);
  const defaultPageBlock = getDefaultPage(models[0].page);
  if (!defaultPageBlock) {
    return null;
  }
  defaultPageBlock.selection.clear();
  asyncFocusRichText(page, id);
  return newBlock;
}
function deleteModelsByRange(page, blockRange = getCurrentBlockRange(page)) {
  if (!blockRange) {
    return null;
  }
  if (blockRange.type === "Block") {
    const newBlock = handleBlockSelectionBatchDelete(page, blockRange.models);
    return newBlock;
  }
  const startModel = blockRange.models[0];
  const endModel = blockRange.models[blockRange.models.length - 1];
  if (!startModel.text || !endModel.text) {
    throw new Error("startModel or endModel does not have text");
  }
  const vEditor = getVirgoByModel(startModel);
  assertExists(vEditor);
  if (startModel === endModel) {
    page.captureSync();
    if (blockRange.startOffset === blockRange.endOffset && blockRange.startOffset > 0) {
      return startModel;
    }
    startModel.text.delete(blockRange.startOffset, blockRange.endOffset - blockRange.startOffset);
    vEditor.setVRange({
      index: blockRange.startOffset,
      length: 0
    });
    return startModel;
  }
  page.captureSync();
  startModel.text.delete(blockRange.startOffset, startModel.text.length - blockRange.startOffset);
  endModel.text.delete(0, blockRange.endOffset);
  startModel.text.join(endModel.text);
  blockRange.models.slice(1).forEach((model) => {
    page.deleteBlock(model);
  });
  vEditor.setVRange({
    index: blockRange.startOffset,
    length: 0
  });
  return startModel;
}
function mergeToCodeBlocks(page, models) {
  const parent = page.getParent(models[0]);
  assertExists(parent);
  const index = parent.children.indexOf(models[0]);
  const text = models.map((model) => {
    if (model.text instanceof Text2) {
      return model.text.toString();
    }
    return null;
  }).filter(Boolean).join("\n");
  models.map((model) => page.deleteBlock(model));
  const id = page.addBlock("affine:code", { text: new Text2(text) }, parent, index);
  return id;
}
function updateBlockType(models, flavour, type) {
  if (!models.length) {
    return [];
  }
  const page = models[0].page;
  const hasSamePage = models.every((model) => model.page === page);
  if (!hasSamePage) {
    console.error("Not all models have the same page instanceof, the result for update text type may not be correct", models);
  }
  page.captureSync();
  const savedBlockRange = getCurrentBlockRange(page);
  if (flavour === "affine:code") {
    const id = mergeToCodeBlocks(page, models);
    const model = page.getBlockById(id);
    if (!model) {
      throw new Error("Failed to get model after merge code block!");
    }
    return [model];
  }
  if (flavour === "affine:divider") {
    const model = models.at(-1);
    if (!model) {
      return [];
    }
    const parent = page.getParent(model);
    if (!parent) {
      return [];
    }
    const index = parent.children.indexOf(model);
    const nextSibling = page.getNextSibling(model);
    let nextSiblingId = nextSibling == null ? void 0 : nextSibling.id;
    const id = page.addBlock("affine:divider", {}, parent, index + 1);
    if (!nextSibling) {
      nextSiblingId = page.addBlock("affine:paragraph", {}, parent);
    }
    asyncFocusRichText(page, nextSiblingId);
    const newModel = page.getBlockById(id);
    if (!newModel) {
      throw new Error("Failed to get model after add divider block!");
    }
    return [newModel];
  }
  const newModels = [];
  models.forEach((model) => {
    assertFlavours(model, ["affine:paragraph", "affine:list", "affine:code"]);
    if (model.flavour === flavour) {
      page.updateBlock(model, { type });
      newModels.push(model);
      return;
    }
    const newId = transformBlock(model, flavour, type);
    const newModel = page.getBlockById(newId);
    if (!newModel) {
      throw new Error("Failed to get new model after transform block!");
    }
    savedBlockRange && updateBlockRange(savedBlockRange, model, newModel);
    newModels.push(newModel);
  });
  const allTextUpdated = savedBlockRange == null ? void 0 : savedBlockRange.models.map((model) => new Promise((resolve) => onModelTextUpdated(model, resolve)));
  if (allTextUpdated && savedBlockRange) {
    Promise.all(allTextUpdated).then(() => {
      restoreSelection(savedBlockRange);
    });
  }
  return newModels;
}
function transformBlock(model, flavour, type) {
  var _a3;
  const page = model.page;
  const parent = page.getParent(model);
  assertExists(parent);
  const blockProps = {
    type,
    text: (_a3 = model == null ? void 0 : model.text) == null ? void 0 : _a3.clone(),
    children: model.children
  };
  const index = parent.children.indexOf(model);
  page.deleteBlock(model);
  return page.addBlock(flavour, blockProps, parent, index);
}
function mergeFormat(formatArr, loose) {
  if (!formatArr.length) {
    return {};
  }
  if (loose) {
    return formatArr.reduce((acc, cur) => ({ ...acc, ...cur }));
  }
  return formatArr.reduce((acc, cur) => {
    const newFormat = {};
    for (const key in acc) {
      const typedKey = key;
      if (acc[typedKey] === cur[typedKey]) {
        newFormat[typedKey] = acc[typedKey];
      }
    }
    return newFormat;
  });
}
function getCombinedFormat(blockRange, loose = false) {
  if (blockRange.models.length === 1) {
    const vEditor = getVirgoByModel(blockRange.models[0]);
    assertExists(vEditor);
    const format = vEditor.getFormat({
      index: blockRange.startOffset,
      length: blockRange.endOffset - blockRange.startOffset
    }, loose);
    return format;
  }
  const formatArr = [];
  const startModel = blockRange.models[0];
  if (!matchFlavours(startModel, ["affine:code"]) && startModel.text && startModel.text.length) {
    const vEditor = getVirgoByModel(startModel);
    assertExists(vEditor);
    const startFormat = vEditor.getFormat({
      index: blockRange.startOffset,
      length: vEditor.yText.length - blockRange.startOffset
    }, loose);
    formatArr.push(startFormat);
  }
  const endModel = blockRange.models[blockRange.models.length - 1];
  if (!matchFlavours(endModel, ["affine:code"]) && endModel.text && endModel.text.length) {
    const vEditor = getVirgoByModel(endModel);
    assertExists(vEditor);
    const endFormat = vEditor.getFormat({
      index: 0,
      length: blockRange.endOffset
    }, loose);
    formatArr.push(endFormat);
  }
  blockRange.models.slice(1, -1).filter((model) => !matchFlavours(model, ["affine:code"])).filter((model) => model.text && model.text.length).forEach((model) => {
    const vEditor = getVirgoByModel(model);
    assertExists(vEditor);
    const format = vEditor.getFormat({
      index: 0,
      length: vEditor.yText.length - 1
    });
    formatArr.push(format);
  }, loose);
  return mergeFormat(formatArr, loose);
}
function getCurrentCombinedFormat(page, loose = false) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange || blockRange.models.every((model) => !model.text)) {
    return {};
  }
  return getCombinedFormat(blockRange, loose);
}
function formatBlockRange(blockRange, key) {
  var _a3, _b, _c;
  const { startOffset, endOffset } = blockRange;
  const startModel = blockRange.models[0];
  const endModel = blockRange.models[blockRange.models.length - 1];
  if (blockRange.models.length === 1 && startOffset === endOffset) {
    const vEditor = getVirgoByModel(startModel);
    const delta = vEditor == null ? void 0 : vEditor.getDeltaByRangeIndex(startOffset);
    if (!vEditor || !delta)
      return;
    vEditor.setMarks({
      ...vEditor.marks,
      [key]: vEditor.marks && vEditor.marks[key] || delta.attributes && delta.attributes[key] ? null : true
    });
    clearMarksOnDiscontinuousInput(vEditor);
    return;
  }
  const format = getCombinedFormat(blockRange);
  if (blockRange.models.length === 1) {
    if (matchFlavours(startModel, ["affine:code"]))
      return;
    const vEditor = getVirgoByModel(startModel);
    vEditor == null ? void 0 : vEditor.slots.updated.once(() => {
      restoreSelection(blockRange);
    });
    (_a3 = startModel.text) == null ? void 0 : _a3.format(startOffset, endOffset - startOffset, {
      [key]: format[key] ? null : true
    });
    return;
  }
  if (!matchFlavours(startModel, ["affine:code"])) {
    (_b = startModel.text) == null ? void 0 : _b.format(startOffset, startModel.text.length - startOffset, {
      [key]: format[key] ? null : true
    });
  }
  if (!matchFlavours(endModel, ["affine:code"])) {
    (_c = endModel.text) == null ? void 0 : _c.format(0, endOffset, { [key]: format[key] ? null : true });
  }
  blockRange.models.slice(1, -1).filter((model) => !matchFlavours(model, ["affine:code"])).forEach((model) => {
    var _a4;
    (_a4 = model.text) == null ? void 0 : _a4.format(0, model.text.length, {
      [key]: format[key] ? null : true
    });
  });
  if (blockRange.type === "Native") {
    const allTextUpdated = blockRange.models.filter((model) => !matchFlavours(model, ["affine:code"])).map((model) => (
      // We can not use `onModelTextUpdated` here because it is asynchronous, which
      // will make updated event emit before we observe it.
      new Promise((resolve) => {
        const vEditor = getVirgoByModel(model);
        vEditor == null ? void 0 : vEditor.slots.updated.once(() => {
          resolve(vEditor);
        });
      })
    ));
    Promise.all(allTextUpdated).then(() => {
      restoreSelection(blockRange);
    });
  }
}
function handleFormat(page, key) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange)
    return;
  page.captureSync();
  formatBlockRange(blockRange, key);
}
function handleSelectAll(selection) {
  var _a3;
  const currentSelection = window.getSelection();
  if (selection.state.selectedBlocks.length === 0 && ((_a3 = currentSelection == null ? void 0 : currentSelection.focusNode) == null ? void 0 : _a3.nodeName) === "#text") {
    selection.selectOneBlock(getClosestBlockElementByElement(currentSelection.focusNode.parentElement));
  } else {
    selection.selectAllBlocks();
  }
  resetNativeSelection(null);
}
function handleKeydownAfterSelectBlocks({ page, keyboardEvent, selectedBlocks }) {
  const { key } = keyboardEvent;
  const parent = page.getParent(selectedBlocks[0]);
  const index = parent == null ? void 0 : parent.children.indexOf(selectedBlocks[0]);
  selectedBlocks.forEach((block2) => {
    page.deleteBlock(block2);
  });
  const id = page.addBlock("affine:paragraph", {
    text: new page.Text(key)
  }, parent, index);
  requestAnimationFrame(() => {
    const defaultPage = getDefaultPage(page);
    const newBlock = page.getBlockById(id);
    defaultPage == null ? void 0 : defaultPage.selection.clear();
    focusBlockByModel(newBlock, "end");
    if (key === "/") {
      const curRange = getCurrentNativeRange();
      const model = page.getBlockById(id);
      assertExists(model);
      showSlashMenu({ model, range: curRange });
    }
  });
}
async function onModelTextUpdated(model, callback) {
  var _a3;
  const richText = await asyncGetRichTextByModel(model);
  (_a3 = richText == null ? void 0 : richText.vEditor) == null ? void 0 : _a3.slots.updated.once(() => {
    callback(richText);
  });
}
async function onModelElementUpdated(model, callback) {
  const element = await asyncGetBlockElementByModel(model);
  if (element) {
    callback(element);
  }
}
function tryUpdateFrameSize(page, zoom) {
  requestAnimationFrame(() => {
    if (!page.root)
      return;
    const frames = page.root.children.filter((child) => child.flavour === "affine:frame");
    frames.forEach((model) => {
      const blockElement = getBlockElementByModel(model);
      if (!blockElement)
        return;
      const bound = blockElement.getBoundingClientRect();
      const [x, y, w, h] = deserializeXYWH(model.xywh);
      const newModelHeight = bound.height / zoom + EDGELESS_BLOCK_CHILD_PADDING * 2;
      if (!almostEqual(newModelHeight, h)) {
        page.updateBlock(model, {
          xywh: JSON.stringify([x, y, w, Math.round(newModelHeight)])
        });
      }
    });
  });
}
function showFormatQuickBarByClicks(type, e, page, container, state2) {
  const range = type === "double" ? handleNativeRangeDblClick() : handleNativeRangeTripleClick(e);
  if (e.raw.target instanceof HTMLTextAreaElement)
    return;
  if (!range || range.collapsed)
    return;
  if (page.readonly)
    return;
  const direction = "center-bottom";
  showFormatQuickBar({
    page,
    container,
    direction,
    anchorEl: {
      getBoundingClientRect: () => {
        return calcCurrentSelectionPosition(direction, state2);
      }
    }
  });
}

// node_modules/@blocksuite/blocks/dist/page-block/utils/bind-hotkey.js
function bindCommonHotkey(page) {
  if (page.readonly)
    return;
  formatConfig.forEach(({ hotkey: hotkeyStr, action }) => {
    hotkey.addListener(hotkeyStr, (e) => {
      e.preventDefault();
      if (page.awarenessStore.isReadonly(page))
        return;
      action({ page });
    });
  });
  actionConfig.forEach(({ hotkey: hotkeyStr, action, enabledWhen }) => {
    if (!hotkeyStr)
      return;
    hotkey.addListener(hotkeyStr, (e) => {
      e.preventDefault();
      if (!enabledWhen(page))
        return;
      if (page.awarenessStore.isReadonly(page))
        return;
      action({ page });
    });
  });
  paragraphConfig.forEach(({ flavour, type, hotkey: hotkeyStr }) => {
    if (!hotkeyStr)
      return;
    hotkey.addListener(hotkeyStr, () => {
      const blockRange = getCurrentBlockRange(page);
      if (!blockRange)
        return;
      updateBlockType(blockRange.models, flavour, type);
    });
  });
  hotkey.addListener(HOTKEYS.UNDO, (e) => {
    e.preventDefault();
    if (page.canUndo)
      clearSelection(page);
    page.undo();
  });
  hotkey.addListener(HOTKEYS.REDO, (e) => {
    e.preventDefault();
    if (page.canRedo)
      clearSelection(page);
    page.redo();
  });
  hotkey.addListener(HOTKEYS.ANY_KEY, (e) => {
    if (!isPrintableKeyEvent(e) || page.readonly)
      return;
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    if (blockRange.type === "Block") {
      handleKeydownAfterSelectBlocks({
        page,
        keyboardEvent: e,
        selectedBlocks: blockRange.models
      });
      return;
    }
    const range = blockRangeToNativeRange(blockRange);
    if (!range || !isMultiBlockRange(range))
      return;
    deleteModelsByRange(page);
  });
}
function removeCommonHotKey() {
  hotkey.removeListener([
    ...formatConfig.map(({ hotkey: hotkeyStr }) => hotkeyStr),
    ...paragraphConfig.map(({ hotkey: hotkeyStr }) => hotkeyStr).filter((i) => !!i),
    HOTKEYS.UNDO,
    HOTKEYS.REDO,
    HOTKEYS.ANY_KEY
  ]);
}
function handleUp(e, page, { selection, zoom } = {
  zoom: 1
}) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange)
    return;
  if (blockRange.type === "Block") {
    if (!selection) {
      console.error("Failed to handle up: selection is not provided", blockRange);
      return;
    }
    const selectedModel = getModelByElement(selection.state.selectedBlocks[0]);
    selection.clear();
    const pageBlock = getDefaultPage(page);
    assertExists(pageBlock);
    focusPreviousBlock(selectedModel, pageBlock.lastSelectionPosition instanceof Point ? pageBlock.lastSelectionPosition : "end");
    e.preventDefault();
    return;
  }
  if (blockRange.type === "Native") {
    assertEquals(blockRange.models.length, 1, "Failed to handle up! range is not collapsed");
    const model = blockRange.models[0];
    const previousBlock = getPreviousBlock(model);
    const range = getCurrentNativeRange();
    const { left: left2, top: top2 } = range.getBoundingClientRect();
    if (!previousBlock && isPageMode(page)) {
      focusTitle(page);
      return;
    }
    if (left2 === 0 && top2 === 0) {
      if (!(range.startContainer instanceof HTMLElement)) {
        console.warn("Failed to calculate caret position! range.getBoundingClientRect() is zero and it's startContainer not an HTMLElement.", range);
        focusPreviousBlock(model);
        return;
      }
      const rect = range.startContainer.getBoundingClientRect();
      focusPreviousBlock(model, new Point(rect.left, rect.top), zoom);
      return;
    }
    focusPreviousBlock(model, new Point(left2, top2), zoom);
  }
}
function handleDown(e, page, { selection, zoom } = {
  zoom: 1
}) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange)
    return;
  if (blockRange.type === "Block") {
    if (!selection) {
      console.error("Failed to handle down: selection is not provided", blockRange);
      return;
    }
    const lastEle = selection.state.selectedBlocks.at(-1);
    if (!lastEle) {
      throw new Error("Failed to handleDown! Can't find last selected element!");
    }
    const selectedModel = getModelByElement(lastEle);
    selection.clear();
    const pageBlock = getDefaultPage(page);
    assertExists(pageBlock);
    focusNextBlock(selectedModel, pageBlock.lastSelectionPosition instanceof Point ? pageBlock.lastSelectionPosition : "start");
    e.preventDefault();
  }
  if (blockRange.type === "Native") {
    assertEquals(blockRange.models.length, 1, "Failed to handle down! range is not collapsed");
    const model = blockRange.models[0];
    if (matchFlavours(model, ["affine:code"]) || matchFlavours(model, ["affine:page"])) {
      return;
    }
    const range = getCurrentNativeRange();
    const atLineEdge = isAtLineEdge(range);
    const { left: left2, bottom: bottom2 } = range.getBoundingClientRect();
    const isAtEmptyLine = left2 === 0 && bottom2 === 0;
    if (atLineEdge || isAtEmptyLine) {
      const richText = getRichTextByModel(model);
      assertExists(richText);
      const richTextRect = richText.getBoundingClientRect();
      focusNextBlock(model, new Point(richTextRect.left, richTextRect.top), zoom);
      return;
    }
    focusNextBlock(model, new Point(left2, bottom2), zoom);
  }
}
function handleTab(e, page, selection) {
  const blockRange = getCurrentBlockRange(page);
  if (!blockRange)
    return;
  e.preventDefault();
  const models = blockRange.models;
  handleMultiBlockIndent(page, models);
  if (blockRange.type === "Block") {
    requestAnimationFrame(() => {
      selection.refreshSelectedBlocksRectsByModels(models);
    });
  }
}
function bindHotkeys(page, selection) {
  const { BACKSPACE, SELECT_ALL, SHIFT_UP, SHIFT_DOWN, UP, DOWN, LEFT, RIGHT, ENTER, TAB, SPACE } = HOTKEYS;
  bindCommonHotkey(page);
  hotkey.addListener(SELECT_ALL, (e) => {
    e.preventDefault();
    handleSelectAll(selection);
    selection.state.type = "block";
  });
  if (page.readonly)
    return;
  hotkey.addListener(ENTER, (e) => {
    var _a3, _b;
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    if (blockRange.type === "Block") {
      e.preventDefault();
      const endModel2 = blockRange.models[blockRange.models.length - 1];
      const parentModel = page.getParent(endModel2);
      const index = parentModel == null ? void 0 : parentModel.children.indexOf(endModel2);
      assertExists(index);
      assertExists(parentModel);
      const id = page.addBlock("affine:paragraph", { type: "text" }, parentModel, index + 1);
      asyncFocusRichText(page, id);
      selection.clear();
      return;
    }
    e.preventDefault();
    const startModel = blockRange.models[0];
    (_a3 = startModel.text) == null ? void 0 : _a3.delete(blockRange.startOffset, startModel.text.length - blockRange.startOffset);
    const endModel = blockRange.models[blockRange.models.length - 1];
    (_b = endModel.text) == null ? void 0 : _b.delete(0, blockRange.endOffset);
    blockRange.models.slice(1, -1).forEach((model) => {
      page.deleteBlock(model);
    });
    const vEditor = getVirgoByModel(endModel);
    vEditor == null ? void 0 : vEditor.slots.updated.once(() => {
      focusBlockByModel(endModel, "start");
    });
  });
  hotkey.addListener(BACKSPACE, (e) => {
    deleteModelsByRange(page);
    e.preventDefault();
  });
  hotkey.addListener(UP, (e) => {
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    const parent = page.getParent(blockRange.models[0]);
    if (parent && matchFlavours(parent, ["affine:database"])) {
      const service = getService("affine:database");
      if (service.getLastCellSelection())
        return;
    }
    handleUp(e, page, { selection });
  });
  hotkey.addListener(DOWN, (e) => {
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    const parent = page.getParent(blockRange.models[0]);
    if (parent && matchFlavours(parent, ["affine:database"])) {
      const service = getService("affine:database");
      if (service.getLastCellSelection())
        return;
    }
    handleDown(e, page, { selection });
  });
  hotkey.addListener(LEFT, (e) => {
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    if (blockRange.type === "Block")
      return;
    if (blockRange.models.length > 1) {
      e.preventDefault();
      const selection2 = getSelection();
      if (selection2) {
        const range = blockRange.nativeRange.cloneRange();
        range.collapse(true);
        selection2.removeAllRanges();
        selection2.addRange(range);
      }
      return;
    }
    focusPreviousBlock(blockRange.models[0], "end");
  });
  hotkey.addListener(RIGHT, (e) => {
    const blockRange = getCurrentBlockRange(page);
    if (!blockRange)
      return;
    if (matchFlavours(blockRange.models[0], ["affine:database"])) {
      const service = getService("affine:database");
      if (service.getLastCellSelection())
        return;
    }
    if (blockRange.type === "Block")
      return;
    if (blockRange.models.length > 1) {
      e.preventDefault();
      const selection2 = getSelection();
      if (selection2) {
        const range = blockRange.nativeRange.cloneRange();
        range.collapse(false);
        selection2.removeAllRanges();
        selection2.addRange(range);
      }
      return;
    }
    focusNextBlock(blockRange.models[0], "start");
  });
  hotkey.addListener(TAB, (e) => handleTab(e, page, selection));
  hotkey.addListener(SHIFT_UP, (e) => {
  });
  hotkey.addListener(SHIFT_DOWN, (e) => {
  });
  hotkey.addListener(SPACE, (e) => {
    if (selection.state.type === "block") {
      e.preventDefault();
    }
  });
}
function removeHotkeys() {
  removeCommonHotKey();
  hotkey.removeListener([
    HOTKEYS.BACKSPACE,
    HOTKEYS.SELECT_ALL,
    HOTKEYS.SHIFT_UP,
    HOTKEYS.SHIFT_DOWN,
    HOTKEYS.UP,
    HOTKEYS.DOWN,
    HOTKEYS.LEFT,
    HOTKEYS.RIGHT,
    HOTKEYS.ENTER,
    HOTKEYS.TAB,
    HOTKEYS.SPACE
  ]);
}

// node_modules/@blocksuite/blocks/dist/page-block/default/components.js
function DraggingArea(rect) {
  if (rect === null)
    return null;
  const style = {
    left: rect.left + "px",
    top: rect.top + "px",
    width: rect.width + "px",
    height: rect.height + "px"
  };
  return html`
    <style>
      .affine-page-dragging-area {
        position: absolute;
        background: var(--affine-hover-color);
        z-index: 1;
        pointer-events: none;
      }
    </style>
    <div class="affine-page-dragging-area" style=${styleMap(style)}></div>
  `;
}
function EmbedSelectedRectsContainer(rects, viewportOffset) {
  return html`
    <style>
      .affine-page-selected-embed-rects-container > div {
        position: absolute;
        display: block;
        border: 2px solid var(--affine-primary-color);
        user-select: none;
      }
    </style>
    <div class="affine-page-selected-embed-rects-container resizable">
      ${rects.map((rect) => {
    const style = {
      left: rect.left + viewportOffset.x + "px",
      top: rect.top + viewportOffset.y + "px",
      width: rect.width + "px",
      height: rect.height + "px"
    };
    return html`
          <div class="resizes" style=${styleMap(style)}>
            <div class="resize top-left"></div>
            <div class="resize top-right"></div>
            <div class="resize bottom-left"></div>
            <div class="resize bottom-right"></div>
          </div>
        `;
  })}
    </div>
  `;
}
function EmbedEditingContainer(embedEditingState, slots, viewportOffset) {
  if (!embedEditingState)
    return null;
  const { rect: { x, y }, model } = embedEditingState;
  const style = {
    left: x + viewportOffset.x + "px",
    top: y + viewportOffset.y + "px"
  };
  return html`
    <style>
      .affine-embed-editing-state-container > div {
        position: absolute;
        display: block;
        z-index: 1;
      }
      ${tooltipStyle}
    </style>

    <div
      class="affine-embed-editing-state-container"
      @pointerdown=${stopPropagation}
    >
      <div style=${styleMap(style)} class="embed-editing-state">
        <format-bar-button
          class="has-tool-tip"
          width="100%"
          @click=${() => {
    focusCaption(model);
    slots.embedRectsUpdated.emit([]);
  }}
        >
          ${CaptionIcon}
          <tool-tip inert tip-position="right" role="tooltip">Caption</tool-tip>
        </format-bar-button>
        <format-bar-button
          class="has-tool-tip"
          width="100%"
          @click=${() => {
    downloadImage(model);
  }}
        >
          ${DownloadIcon}
          <tool-tip inert tip-position="right" role="tooltip"
            >Download
          </tool-tip>
        </format-bar-button>
        <format-bar-button
          class="has-tool-tip"
          width="100%"
          @click=${() => {
    copyImage(model);
  }}
        >
          ${CopyIcon}
          <tool-tip inert tip-position="right" role="tooltip"
            >Copy to clipboard
          </tool-tip>
        </format-bar-button>
        <format-bar-button
          class="has-tool-tip"
          width="100%"
          @click="${() => {
    model.page.deleteBlock(model);
    slots.embedRectsUpdated.emit([]);
  }}"
        >
          ${DeleteIcon}
          <tool-tip inert tip-position="right" role="tooltip">Delete</tool-tip>
        </format-bar-button>
      </div>
    </div>
  `;
}

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/utils.js
var threshold = SCROLL_THRESHOLD / 2;
function intersects2(a, b, offset2) {
  return a.left + offset2.x < b.right && a.right + offset2.x > b.left && a.top + offset2.y < b.bottom && a.bottom + offset2.y > b.top;
}
function filterBlocksExcludeSubtrees(blockCache, bound, offset2) {
  const entries = Array.from(blockCache.entries());
  const len3 = entries.length;
  const results = [];
  if (len3 === 0)
    return results;
  let prevIndex = -1;
  for (let i = 0; i < len3; i++) {
    const [block2, rect] = entries[i];
    if (intersects2(rect, bound, offset2)) {
      if (prevIndex === -1) {
        prevIndex = i;
      } else {
        let prevBlock = entries[prevIndex][0];
        if (contains(prevBlock, block2)) {
          if (matchFlavours(prevBlock.model, ["affine:database"])) {
            continue;
          } else {
            if (results.length > 1) {
              continue;
            }
            prevIndex = i;
            results.shift();
          }
        } else {
          const { previousElementSibling } = block2;
          if (previousElementSibling && previousElementSibling !== prevBlock && contains(previousElementSibling, prevBlock)) {
            let n = i;
            let m = results.length;
            while (n--) {
              prevBlock = entries[n][0];
              if (prevBlock === previousElementSibling) {
                results.push({ block: prevBlock, index: n });
                break;
              } else if (m > 0) {
                results.pop();
                m--;
              }
            }
          }
          prevIndex = i;
        }
      }
      results.push({ block: block2, index: i });
    }
  }
  return results;
}
function updateLocalSelectionRange(page) {
  const blockRange = getExtendBlockRange(page);
  if (!blockRange || blockRange.type === "Block") {
    return;
  }
  const userRange = {
    startOffset: blockRange.startOffset,
    endOffset: blockRange.endOffset,
    blockIds: blockRange.models.map((m) => m.id)
  };
  page.awarenessStore.setLocalRange(page, userRange);
}
function setSelectedBlocks(state2, slots, selectedBlocks, rects) {
  state2.selectedBlocks = selectedBlocks;
  if (rects) {
    slots.selectedRectsUpdated.emit(rects);
    return;
  }
  const calculatedRects = [];
  for (const block2 of getBlockElementsExcludeSubtrees(selectedBlocks)) {
    calculatedRects.push(getRectByBlockElement(block2));
  }
  slots.selectedRectsUpdated.emit(calculatedRects);
}
function autoScroll(selection, e, hooks) {
  const { state: state2 } = selection;
  const { y } = e.point;
  const { viewportElement } = selection;
  const { viewport: viewport2 } = state2;
  const { scrollHeight, clientHeight } = viewport2;
  let { scrollTop } = viewport2;
  const max2 = scrollHeight - clientHeight;
  hooks.init();
  let auto2 = true;
  const autoScroll2 = () => {
    if (!auto2) {
      state2.clearRaf();
      return;
    } else {
      state2.rafID = requestAnimationFrame(autoScroll2);
    }
    if (Math.ceil(scrollTop) < max2 && clientHeight - y < threshold) {
      const d = (threshold - (clientHeight - y)) * 0.25;
      scrollTop += d;
      auto2 = Math.ceil(scrollTop) < max2;
      viewportElement.scrollTop = scrollTop;
      hooks.onScroll(d);
    } else if (scrollTop > 0 && y < threshold) {
      const d = (y - threshold) * 0.25;
      scrollTop += d;
      auto2 = scrollTop > 0;
      viewportElement.scrollTop = scrollTop;
      hooks.onScroll(d);
    } else {
      auto2 = false;
      hooks.onMove();
    }
  };
  state2.clearRaf();
  state2.rafID = requestAnimationFrame(autoScroll2);
}

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/block-drag-handlers.js
var BlockDragHandlers = {
  onStart(selection, e) {
    const { state: state2 } = selection;
    state2.blur();
    state2.type = "block";
    selection.updateViewport();
    const { scrollLeft, scrollTop } = state2.viewport;
    state2.resetDraggingArea(e, {
      scrollTop,
      scrollLeft
    });
    state2.refreshBlockRectCache();
  },
  onMove(selection, e) {
    autoScroll(selection, e, {
      init() {
        const { x, y } = e.point;
        const { draggingArea, viewport: { scrollLeft, scrollTop } } = selection.state;
        assertExists(draggingArea);
        draggingArea.end.x = x + scrollLeft;
        draggingArea.end.y = y + scrollTop;
      },
      onScroll(d) {
        const { draggingArea } = selection.state;
        assertExists(draggingArea);
        draggingArea.end.y += d;
        selection.updateDraggingArea(draggingArea);
      },
      onMove() {
        const { blockCache, draggingArea, viewportOffset } = selection.state;
        assertExists(draggingArea);
        const rect = selection.updateDraggingArea(draggingArea);
        selection.selectBlocksByDraggingArea(blockCache, rect, viewportOffset);
      }
    });
  },
  onEnd(selection, _) {
    selection.state.type = "block";
    selection.state.clearDraggingArea();
    selection.slots.draggingAreaUpdated.emit(null);
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/embed-resize-manager.js
var EmbedResizeManager = class {
  constructor(state2, slots) {
    this._originPosition = { x: 0, y: 0 };
    this._dropContainer = null;
    this._dropContainerSize = {
      w: 0,
      h: 0,
      left: 0
    };
    this._dragMoveTarget = "right";
    this.state = state2;
    this.slots = slots;
  }
  onStart(e) {
    var _a3;
    this._originPosition.x = e.raw.pageX;
    this._originPosition.y = e.raw.pageY;
    this._dropContainer = e.raw.target.closest(".resizes");
    const rect = (_a3 = this._dropContainer) == null ? void 0 : _a3.getBoundingClientRect();
    this._dropContainerSize.w = rect.width;
    this._dropContainerSize.h = rect.height;
    this._dropContainerSize.left = rect.left;
    if (e.raw.target.className.includes("right")) {
      this._dragMoveTarget = "right";
    } else {
      this._dragMoveTarget = "left";
    }
  }
  onMove(e) {
    var _a3;
    const activeComponent = this.state.activeComponent || this.state.selectedEmbeds[0];
    if (!activeComponent)
      return;
    let width = 0;
    let height = 0;
    let left2 = 0;
    if (this._dragMoveTarget === "right") {
      width = this._dropContainerSize.w + (e.raw.pageX - this._originPosition.x);
    } else {
      width = this._dropContainerSize.w - (e.raw.pageX - this._originPosition.x);
    }
    if (width < activeComponent.getBoundingClientRect().width && width >= 50) {
      if (this._dragMoveTarget === "right") {
        left2 = this._dropContainerSize.left - (e.raw.pageX - this._originPosition.x) / 2;
      } else {
        left2 = this._dropContainerSize.left + (e.raw.pageX - this._originPosition.x) / 2;
      }
      height = width * (this._dropContainerSize.h / this._dropContainerSize.w);
      if (this._dropContainer) {
        this.slots.embedRectsUpdated.emit([
          new DOMRect(left2, this._dropContainer.getBoundingClientRect().top, width, height)
        ]);
        const activeImg = (_a3 = this.state.activeComponent) == null ? void 0 : _a3.querySelector(".resizable-img");
        if (activeImg) {
          activeImg.style.width = width + "px";
          activeImg.style.height = height + "px";
        }
      }
    }
  }
  onEnd() {
    assertExists(this.state.activeComponent);
    const dragModel = getModelByElement(this.state.activeComponent);
    dragModel.page.captureSync();
    assertExists(this._dropContainer);
    const { width, height } = this._dropContainer.getBoundingClientRect();
    dragModel.page.updateBlock(dragModel, { width, height });
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/native-drag-handlers.js
var NativeDragHandlers = {
  onStart(selection, e) {
    selection.state.resetStartRange(e);
    selection.state.type = "native";
  },
  onMove(selection, e) {
    autoScroll(selection, e, {
      init() {
        selection.state.lastPoint = new Point(e.raw.clientX, e.raw.clientY);
        handleNativeRangeDragMove(selection.state.startRange, e);
      },
      onMove: noop,
      onScroll: noop
    });
  },
  onEnd(selection, _) {
    selection.state.clearRaf();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/preview-drag-handlers.js
var PreviewDragHandlers = {
  onStart(selection, e) {
    var _a3;
    const { container, state: state2 } = selection;
    state2.blur();
    (_a3 = container.components.dragHandle) == null ? void 0 : _a3.onDragStart(createDragEvent("dragstart", e.raw), true);
  },
  onMove(selection, e) {
    autoScroll(selection, e, {
      init() {
        const { state: state2 } = selection;
        const { raw: { clientX, clientY } } = e;
        state2.lastPoint = new Point(clientX, clientY);
      },
      onScroll(_) {
        var _a3;
        const { container, state: { lastPoint } } = selection;
        assertExists(lastPoint);
        (_a3 = container.components.dragHandle) == null ? void 0 : _a3.onDrag(createDragEvent("drag", new MouseEvent("mousemove", {
          clientX: lastPoint.x,
          clientY: lastPoint.y,
          screenY: 1
        })), true, true);
      },
      onMove() {
        var _a3;
        const { raw } = e;
        const { container } = selection;
        (_a3 = container.components.dragHandle) == null ? void 0 : _a3.onDrag(createDragEvent("drag", raw), true);
      }
    });
  },
  onEnd(selection, e) {
    var _a3;
    const { container, state: state2 } = selection;
    state2.clearRaf();
    state2.lastPoint = null;
    (_a3 = container.components.dragHandle) == null ? void 0 : _a3.onDragEnd(createDragEvent("dragend", e.raw), true);
  },
  clear(selection) {
    var _a3;
    const { container } = selection;
    (_a3 = container.components.dragHandle) == null ? void 0 : _a3.onDragEnd(createDragEvent("dragend"));
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/selection-state.js
var PageSelectionState = class {
  constructor(type) {
    this.viewport = {
      left: 0,
      top: 0,
      scrollLeft: 0,
      scrollTop: 0,
      scrollHeight: 0,
      clientHeight: 0,
      clientWidth: 0
    };
    this.draggingArea = null;
    this.selectedEmbeds = [];
    this.selectedBlocks = [];
    this.focusedBlock = null;
    this.lastPoint = null;
    this._startRange = null;
    this._richTextCache = /* @__PURE__ */ new Map();
    this._blockCache = /* @__PURE__ */ new Map();
    this._embedCache = /* @__PURE__ */ new Map();
    this._activeComponent = null;
    this.type = type;
  }
  get activeComponent() {
    return this._activeComponent;
  }
  set activeComponent(component) {
    this._activeComponent = component;
  }
  get startRange() {
    return this._startRange;
  }
  get richTextCache() {
    return this._richTextCache;
  }
  get blockCache() {
    return this._blockCache;
  }
  get embedCache() {
    return this._embedCache;
  }
  get viewportOffset() {
    const { viewport: { left: left2, top: top2, scrollLeft, scrollTop } } = this;
    return {
      x: scrollLeft - left2,
      y: scrollTop - top2
    };
  }
  resetStartRange(e) {
    const { clientX, clientY } = e.raw;
    this._startRange = caretRangeFromPoint(clientX, clientY);
    this.lastPoint = new Point(clientX, clientY);
  }
  resetDraggingArea(e, offset2 = {
    scrollLeft: 0,
    scrollTop: 0
  }) {
    const { scrollLeft, scrollTop } = offset2;
    let { x, y } = e.point;
    x += scrollLeft;
    y += scrollTop;
    const end2 = new Point(x, y);
    this.draggingArea = {
      start: end2.clone(),
      end: end2
    };
  }
  refreshBlockRectCache() {
    this._blockCache.clear();
    const allBlocks = getBlockElementsByElement(document);
    for (const block2 of allBlocks) {
      this._blockCache.set(block2, getRectByBlockElement(block2));
    }
  }
  blur() {
    resetNativeSelection(null);
    if (document.activeElement && document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
  }
  clearRaf() {
    if (this.rafID) {
      this.rafID = void cancelAnimationFrame(this.rafID);
    }
  }
  clearDraggingArea() {
    this.clearRaf();
    this.draggingArea = null;
  }
  clearNativeSelection() {
    this.clearRaf();
    this.type = "none";
    this._richTextCache.clear();
    this._startRange = null;
    this.lastPoint = null;
    resetNativeSelection(null);
  }
  clearBlockSelection() {
    this.type = "none";
    this._activeComponent = null;
    this.focusedBlock = null;
    this.selectedBlocks = [];
    this.clearDraggingArea();
  }
  clearEmbedSelection() {
    this.type = "none";
    this.selectedEmbeds = [];
    this._activeComponent = null;
  }
  clearSelection() {
    this.clearBlockSelection();
    this.clearEmbedSelection();
    this.clearNativeSelection();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/selection-manager/selection-manager.js
function shouldFilterMouseEvent(event) {
  const target = event.target;
  if (!target || !(target instanceof HTMLElement)) {
    return false;
  }
  if (target.tagName === "INPUT") {
    return true;
  }
  if (target.tagName === "FORMAT-QUICK-BAR") {
    return true;
  }
  return false;
}
var DefaultSelectionManager = class extends AbstractSelectionManager {
  constructor({ container, dispatcher, page, mouseRoot, slots }) {
    super(container, dispatcher);
    this.state = new PageSelectionState("none");
    this._add = (name, fn2) => {
      this._disposables.add(this._dispatcher.add(name, fn2));
    };
    this._onContainerDragStart = (ctx) => {
      var _a3;
      const e = ctx.get("pointerState");
      const target = e.raw.target;
      if (isInsidePageTitle(target) || isDatabaseInput(target)) {
        this.state.type = "none";
        return;
      }
      if (isElement(target) && (isDragHandle(target) || isSelectedBlocks(target))) {
        PreviewDragHandlers.onStart(this, e);
        return;
      }
      if (isEmbed(e)) {
        this.state.type = "embed";
        this._embedResizeManager.onStart(e);
        return;
      }
      (_a3 = this.container.components.dragHandle) == null ? void 0 : _a3.setPointerEvents("none");
      this.clear();
      if (isBlankArea(e)) {
        BlockDragHandlers.onStart(this, e);
      } else {
        NativeDragHandlers.onStart(this, e);
      }
    };
    this._onContainerDragMove = (ctx) => {
      const e = ctx.get("pointerState");
      if (this.state.type === "native") {
        NativeDragHandlers.onMove(this, e);
        return;
      }
      if (this.page.readonly)
        return;
      if (this.state.type === "block:drag") {
        PreviewDragHandlers.onMove(this, e);
        return;
      }
      if (this.state.type === "block") {
        BlockDragHandlers.onMove(this, e);
        return;
      }
      if (this.state.type === "embed") {
        return this._embedResizeManager.onMove(e);
      }
    };
    this._onContainerDragEnd = (ctx) => {
      var _a3;
      const e = ctx.get("pointerState");
      (_a3 = this.container.components.dragHandle) == null ? void 0 : _a3.setPointerEvents("auto");
      if (this.state.type === "block:drag") {
        PreviewDragHandlers.onEnd(this, e);
        return;
      }
      if (this.state.type === "native") {
        NativeDragHandlers.onEnd(this, e);
      } else if (this.state.type === "block") {
        BlockDragHandlers.onEnd(this, e);
      } else if (this.state.type === "embed") {
        this._embedResizeManager.onEnd();
      }
      if (this.page.readonly)
        return;
      if (this.state.type === "native") {
        const { direction, selectedType } = getNativeSelectionMouseDragInfo(e);
        if (selectedType === "Caret")
          return;
        showFormatQuickBar({
          page: this.page,
          container: this.container,
          direction,
          anchorEl: {
            getBoundingClientRect: () => {
              return calcCurrentSelectionPosition(direction, this.state);
            }
          }
        });
      } else if (this.state.type === "block") {
        if (!this.page.awarenessStore.getFlag("enable_block_selection_format_bar")) {
          return;
        }
        if (!this.state.selectedBlocks.length) {
          return;
        }
        const direction = e.start.y < e.point.y ? "center-bottom" : "center-top";
        showFormatQuickBar({
          page: this.page,
          container: this.container,
          direction,
          anchorEl: {
            // After update block type, the block selection will be cleared and refreshed.
            // So we need to get the targe block's rect dynamic.
            getBoundingClientRect: () => {
              return calcCurrentSelectionPosition(direction, this.state);
            }
          }
        });
      }
    };
    this._onContainerPointerDown = (ctx) => {
      const e = ctx.get("pointerState");
      if (e.keys.shift) {
        e.raw.preventDefault();
      }
    };
    this._onContainerClick = (ctx) => {
      var _a3;
      const e = ctx.get("pointerState");
      const { point: { x, y }, raw: { target, clientX, clientY, pageX }, keys: { shift } } = e;
      const hasAddedFrame = this._ensureFrameExists();
      if (hasAddedFrame && isInsidePageTitle(target)) {
        requestAnimationFrame(() => {
          handleNativeRangeClick(this.page, e, this.container);
        });
      }
      const container2 = getEditorContainerByElement(this.container);
      activeEditorManager.setActive(container2);
      const { state: state2 } = this;
      const { viewport: viewport2 } = state2;
      let { type } = state2;
      if (pageX >= viewport2.clientWidth + viewport2.left)
        return;
      if (isElement(target) && isDragHandle(target)) {
        return;
      }
      if (shift) {
        if (type === "none") {
          type = state2.type = "native";
        }
        if (type === "native") {
          state2.lastPoint = new Point(clientX, clientY);
          handleNativeRangeDragMove(state2.startRange, e);
        } else if (type === "block") {
          this.selectedBlocksWithShiftClick(x, y);
        }
        return;
      }
      this.clear();
      state2.resetStartRange(e);
      const allCaptions = Array.from(document.querySelectorAll(".affine-embed-wrapper-caption"));
      allCaptions.forEach((el) => {
        if (el !== target) {
          el.blur();
        }
      });
      let clickBlockInfo = null;
      const element = getClosestBlockElementByPoint(new Point(clientX, clientY), {
        rect: this.container.innerRect
      });
      if (element) {
        clickBlockInfo = {
          model: getModelByBlockElement(element),
          rect: getSelectedStateRectByBlockElement(element),
          element
        };
      }
      if (clickBlockInfo && clickBlockInfo.model) {
        const { element: element2 } = clickBlockInfo;
        this.container.lastSelectionPosition = "start";
        state2.focusedBlock = element2;
      }
      if (clickBlockInfo && matchFlavours(clickBlockInfo.model, ["affine:embed", "affine:divider"])) {
        (_a3 = window.getSelection()) == null ? void 0 : _a3.removeAllRanges();
        state2.activeComponent = clickBlockInfo.element;
        assertExists(this.state.activeComponent);
        if (clickBlockInfo.model.type === "image") {
          state2.type = "embed";
          state2.selectedEmbeds.push(state2.activeComponent);
          this.slots.embedRectsUpdated.emit([clickBlockInfo.rect]);
        } else {
          state2.type = "block";
          state2.selectedBlocks.push(state2.activeComponent);
          this.slots.selectedRectsUpdated.emit([clickBlockInfo.rect]);
        }
        return;
      }
      if (isInsidePageTitle(target) || isDatabaseInput(target) || // TODO It's a workaround, we need remove the ad-hoc code
      // Fix https://github.com/toeverything/blocksuite/issues/2459
      target instanceof HTMLInputElement)
        return;
      handleNativeRangeClick(this.page, e, this.container);
    };
    this._onContainerDblClick = (ctx) => {
      const e = ctx.get("pointerState");
      this.clear();
      NativeDragHandlers.onStart(this, e);
      {
        const { raw: { clientX, clientY } } = e;
        const element = getClosestBlockElementByPoint(new Point(clientX, clientY), {
          rect: this.container.innerRect
        });
        if (element) {
          const targetModel = getModelByBlockElement(element);
          if (targetModel.flavour === "affine:embed") {
            window.dispatchEvent(new CustomEvent("affine.embed-block-db-click", {
              detail: {
                blockId: targetModel.id
              }
            }));
          }
        }
      }
      showFormatQuickBarByClicks("double", e, this.page, this.container, this.state);
    };
    this._onContainerTripleClick = (ctx) => {
      const e = ctx.get("pointerState");
      showFormatQuickBarByClicks("triple", e, this.page, this.container, this.state);
    };
    this._onContainerContextMenu = (ctx) => {
      const e = ctx.get("defaultState");
      repairContextMenuRange(e.event);
    };
    this._onContainerPointerMove = (ctx) => {
      var _a3;
      const e = ctx.get("pointerState");
      const { dragging, raw } = e;
      if (dragging || raw.target.closest(".embed-editing-state"))
        return;
      const point = new Point(raw.clientX, raw.clientY);
      let hoverEditingState = null;
      const { innerRect } = this.container;
      const element = getClosestBlockElementByPoint(point.clone(), {
        rect: innerRect
      });
      if (element) {
        const { left: left2, top: top2, width, height } = getRectByBlockElement(element);
        hoverEditingState = {
          element,
          model: getModelByBlockElement(element),
          rect: new DOMRect(Math.max(left2, innerRect.left + PAGE_BLOCK_CHILD_PADDING), top2, width, height)
        };
      }
      (_a3 = this.container.components.dragHandle) == null ? void 0 : _a3.onContainerMouseMove(e, hoverEditingState);
      if (hoverEditingState) {
        const { model, element: element2 } = hoverEditingState;
        let shouldClear = true;
        if (model.type === "image") {
          const { state: { viewport: { left: left2, clientWidth } } } = this;
          const rect = getSelectedStateRectByBlockElement(element2);
          const tempRect = Rect.fromDOMRect(rect);
          const isOutside = rect.right + 60 < left2 + clientWidth;
          tempRect.right += isOutside ? 60 : 0;
          if (tempRect.isPointIn(point)) {
            rect.x = rect.right + (isOutside ? 10 : -50);
            hoverEditingState.rect = rect;
            shouldClear = false;
          }
        }
        if (shouldClear) {
          hoverEditingState = null;
        }
      }
      this.slots.embedEditingStateUpdated.emit(hoverEditingState);
    };
    this._onSelectionChangeWithDebounce = () => {
      const selection = window.getSelection();
      if (!selection)
        return;
      if (isInsidePageTitle(selection.anchorNode) || isInsidePageTitle(selection.focusNode)) {
        return;
      }
      if (!selection.containsNode(this.container, true)) {
        return;
      }
      const range = getCurrentNativeRange(selection);
      if (range.collapsed)
        return;
      if (this.page.readonly)
        return;
      const offsetDelta = selection.anchorOffset - selection.focusOffset;
      let selectionDirection = "none";
      if (offsetDelta > 0) {
        selectionDirection = "right-left";
      } else if (offsetDelta < 0) {
        selectionDirection = "left-right";
      }
      const direction = selectionDirection === "left-right" ? "right-bottom" : "left-top";
      showFormatQuickBar({
        page: this.page,
        container: this.container,
        direction,
        anchorEl: {
          getBoundingClientRect: () => {
            return calcCurrentSelectionPosition(direction, this.state);
          }
        }
      });
    };
    this._onSelectionChangeWithoutDebounce = () => {
      updateLocalSelectionRange(this.page);
    };
    this.slots = slots;
    this._embedResizeManager = new EmbedResizeManager(this.state, slots);
    let isDragging = false;
    this._add("dragStart", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target)) {
        event.raw.preventDefault();
      }
      isDragging = true;
      this._onContainerDragStart(ctx);
    });
    this._add("dragMove", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerDragMove(ctx);
    });
    this._dispatcher.add("dragEnd", (ctx) => {
      const event = ctx.get("pointerState");
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target)) {
        event.raw.preventDefault();
      }
      isDragging = false;
      this._onContainerDragEnd(ctx);
    });
    this._add("click", (ctx) => {
      const event = ctx.get("pointerState");
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerClick(ctx);
    });
    this._add("doubleClick", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent(event.raw))
        return;
      this._onContainerDblClick(ctx);
    });
    this._add("tripleClick", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent(event.raw))
        return;
      this._onContainerTripleClick(ctx);
    });
    this._add("pointerDown", this._onContainerPointerDown);
    this._add("pointerMove", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target)) {
        event.raw.preventDefault();
      }
      if (this.page.hasFlavour("affine:frame")) {
        this._onContainerPointerMove(ctx);
      }
    });
    this._add("contextMenu", this._onContainerContextMenu);
    this._add("virgo-vrange-updated", () => {
      this._onSelectionChangeWithoutDebounce();
    });
    this._add("virgo-vrange-updated", debounce((ctx) => {
      const { event } = ctx.get("defaultState");
      if (shouldFilterMouseEvent(event))
        return;
      if (isDragging) {
        return;
      }
      this._onSelectionChangeWithDebounce();
    }, 300));
  }
  _ensureFrameExists() {
    const hasFrame = this.page.hasFlavour("affine:frame");
    if (!hasFrame) {
      const frameId = this.page.addBlock("affine:frame", {}, this.page.root);
      this.page.addBlock("affine:paragraph", {}, frameId);
      return true;
    }
    return false;
  }
  get viewportElement() {
    return this.container.viewportElement;
  }
  updateDraggingArea(draggingArea) {
    if (this.state.focusedBlock !== null) {
      this.state.focusedBlock = null;
    }
    const rect = Rect.fromPoints(draggingArea.start, draggingArea.end).toDOMRect();
    this.slots.draggingAreaUpdated.emit(rect);
    return rect;
  }
  updateViewport() {
    const { viewportElement } = this.container;
    const { clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop } = viewportElement;
    const { top: top2, left: left2 } = viewportElement.getBoundingClientRect();
    this.state.viewport = {
      top: top2,
      left: left2,
      clientHeight,
      clientWidth,
      scrollHeight,
      scrollLeft,
      scrollTop
    };
  }
  updateRects() {
    const { type } = this.state;
    if (type === "block") {
      this.refreshSelectedBlocksRects();
    } else if (type === "embed") {
      this.refreshEmbedRects();
    }
  }
  refreshDraggingArea(viewportOffset) {
    const { blockCache, draggingArea } = this.state;
    if (draggingArea) {
      this.selectBlocksByDraggingArea(blockCache, Rect.fromPoints(draggingArea.start, draggingArea.end).toDOMRect(), viewportOffset, true);
    } else {
      this.state.draggingArea = null;
      this.slots.draggingAreaUpdated.emit(null);
      this.refreshSelectedBlocksRects();
    }
  }
  refreshSelectedBlocksRects() {
    const { focusedBlock, selectedBlocks } = this.state;
    if (selectedBlocks.length === 0)
      return;
    if (focusedBlock === null) {
      const rects = getBlockElementsExcludeSubtrees(selectedBlocks).map(getRectByBlockElement);
      this.slots.selectedRectsUpdated.emit(rects);
    } else {
      this.slots.selectedRectsUpdated.emit([
        getRectByBlockElement(focusedBlock)
      ]);
    }
  }
  refreshSelectedBlocksRectsByModels(models) {
    this.state.selectedBlocks = models.map(getBlockElementByModel).filter((block2) => block2 !== null);
    this.refreshSelectedBlocksRects();
  }
  refreshEmbedRects(hoverEditingState = null) {
    const { activeComponent, selectedEmbeds, viewport: viewport2 } = this.state;
    if (activeComponent && selectedEmbeds.length) {
      const rect = getSelectedStateRectByBlockElement(activeComponent);
      const embedRects = [
        new DOMRect(rect.left, rect.top, rect.width, rect.height)
      ];
      if (hoverEditingState && isImage(activeComponent)) {
        const isOutside = rect.right + 60 < viewport2.left + viewport2.clientWidth;
        rect.x = rect.right + (isOutside ? 10 : -50);
        hoverEditingState.rect = rect;
      }
      this.slots.embedRectsUpdated.emit(embedRects);
    }
  }
  refreshRemoteSelection() {
    const element = this.container.querySelector("remote-selection");
    if (element) {
      element.requestUpdate();
    }
  }
  selectOneBlock(element, rect) {
    this.clear();
    this.state.blur();
    this.state.type = "block";
    this.state.focusedBlock = element;
    if (!element)
      return;
    if (!rect) {
      rect = getRectByBlockElement(this.state.focusedBlock);
    }
    const selectedBlocks = getBlockElementsIncludeSubtrees([element]);
    setSelectedBlocks(this.state, this.slots, selectedBlocks, [rect]);
  }
  selectAllBlocks() {
    this.clear();
    this.state.type = "block";
    this.state.focusedBlock = null;
    const selectedBlocks = getBlockElementsByElement(this.container);
    const rects = getBlockElementsExcludeSubtrees(selectedBlocks).map(getRectByBlockElement);
    setSelectedBlocks(this.state, this.slots, selectedBlocks, rects);
  }
  selectBlocksByDraggingArea(blockCache, draggingArea, viewportOffset, isScrolling = false) {
    if (isScrolling) {
      this.state.refreshBlockRectCache();
    }
    const blocks = filterBlocksExcludeSubtrees(
      blockCache,
      draggingArea,
      // subtracting the left/top of the container is required.
      viewportOffset
    );
    const [selectedBlocks, rects] = blocks.reduce((data, { block: block2 }) => {
      data[0].push(...getBlockElementsIncludeSubtrees([block2]));
      data[1].push(getRectByBlockElement(block2));
      return data;
    }, [[], []]);
    setSelectedBlocks(this.state, this.slots, selectedBlocks, rects);
  }
  selectedBlocksWithShiftClick(x, y) {
    const { state: state2 } = this;
    const { viewport: { scrollLeft, scrollTop }, viewportOffset, selectedBlocks } = state2;
    const lastIndex = selectedBlocks.length - 1;
    if (lastIndex === -1)
      return;
    const hasOneBlock = lastIndex === 0;
    const first = selectedBlocks[0];
    const last = hasOneBlock ? first : selectedBlocks[lastIndex];
    const firstRect = getRectByBlockElement(first);
    const lastRect = hasOneBlock ? firstRect : getRectByBlockElement(last);
    const rect = Rect.fromPoints(new Point(firstRect.left + viewportOffset.x, firstRect.top + viewportOffset.y), new Point(lastRect.right + viewportOffset.x, lastRect.bottom + viewportOffset.y));
    const point = new Point(x + scrollLeft, y + scrollTop);
    let start2;
    let end2;
    let pos = true;
    if (hasOneBlock) {
      if (rect.isPointIn(point)) {
        return;
      }
      if (point.y < rect.top) {
        start2 = point;
        end2 = rect.max;
        pos = false;
      } else {
        start2 = rect.min;
        end2 = point;
      }
    } else {
      if (rect.isPointIn(point)) {
        if (point.y >= rect.top + rect.height / 2) {
          start2 = point;
          end2 = rect.max;
          pos = false;
        } else {
          start2 = rect.min;
          end2 = point;
        }
      } else if (point.y < rect.top) {
        start2 = point;
        end2 = rect.max;
        pos = false;
      } else {
        start2 = rect.min;
        end2 = point;
      }
    }
    if (start2 && end2) {
      this.selectBlocksByDraggingArea(state2.blockCache, Rect.fromPoints(start2, end2).toDOMRect(), viewportOffset, true);
    }
    const direction = pos ? "center-bottom" : "center-top";
    showFormatQuickBar({
      page: this.page,
      container: this.container,
      direction,
      anchorEl: {
        // After update block type, the block selection will be cleared and refreshed.
        // So we need to get the targe block's rect dynamic.
        getBoundingClientRect: () => {
          return calcCurrentSelectionPosition(direction, state2);
        }
      }
    });
  }
  setSelectedBlocks(selectedBlocks, rects) {
    setSelectedBlocks(this.state, this.slots, selectedBlocks, rects);
  }
  setFocusedBlock(blockElement) {
    this.state.focusedBlock = blockElement;
  }
  // clear selection: `block`, `block:drag`, `embed`, `native`
  clear() {
    var _a3;
    const { state: state2, slots } = this;
    let { type } = state2;
    if (type === "block:drag") {
      PreviewDragHandlers.clear(this);
      type = "block";
    }
    if (type === "block") {
      state2.clearBlockSelection();
      slots.selectedRectsUpdated.emit([]);
      slots.draggingAreaUpdated.emit(null);
      (_a3 = this.container.querySelector("format-quick-bar")) == null ? void 0 : _a3.remove();
    } else if (type === "embed") {
      state2.clearEmbedSelection();
      slots.embedRectsUpdated.emit([]);
      slots.embedEditingStateUpdated.emit(null);
    } else if (type === "native") {
      state2.clearNativeSelection();
    }
  }
  dispose() {
    this.slots.selectedRectsUpdated.dispose();
    this.slots.draggingAreaUpdated.dispose();
    this.slots.embedEditingStateUpdated.dispose();
    this.slots.embedRectsUpdated.dispose();
    this._disposables.dispose();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/default/default-page-block.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultPageBlockComponent = class DefaultPageBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this.flavour = "affine:page";
    this.clipboard = new PageClipboard(this);
    this.getService = getService;
    this.lastSelectionPosition = "start";
    this.components = {
      dragHandle: null
    };
    this._draggingArea = null;
    this._selectedRects = [];
    this._selectedEmbedRects = [];
    this._isComposing = false;
    this._resizeObserver = null;
    this.slots = {
      draggingAreaUpdated: new Slot(),
      selectedRectsUpdated: new Slot(),
      embedRectsUpdated: new Slot(),
      embedEditingStateUpdated: new Slot(),
      nativeSelectionToggled: new Slot(),
      pageLinkClicked: new Slot()
    };
    this._titleVEditor = null;
    this._updateTitleInMeta = () => {
      this.page.workspace.setPageMeta(this.page.id, {
        title: this.model.title.toString()
      });
    };
    this._onTitleKeyDown = (e) => {
      if (e.isComposing || this.page.readonly)
        return;
      const hasContent = !this.page.isEmpty;
      const { page, model } = this;
      const defaultFrame = model.children.find((child) => child.flavour === "affine:frame");
      if (e.key === "Enter" && hasContent) {
        e.preventDefault();
        assertExists(this._titleVEditor);
        const vRange = this._titleVEditor.getVRange();
        assertExists(vRange);
        const right2 = model.title.split(vRange.index);
        const newFirstParagraphId = page.addBlock("affine:paragraph", { text: right2 }, defaultFrame, 0);
        asyncFocusRichText(page, newFirstParagraphId);
        return;
      } else if (e.key === "ArrowDown" && hasContent) {
        e.preventDefault();
        const firstText = defaultFrame == null ? void 0 : defaultFrame.children.find((block2) => matchFlavours(block2, ["affine:paragraph", "affine:list", "affine:code"]));
        if (firstText) {
          asyncFocusRichText(page, firstText.id);
        } else {
          const newFirstParagraphId = page.addBlock("affine:paragraph", {}, defaultFrame, 0);
          asyncFocusRichText(page, newFirstParagraphId);
        }
        return;
      } else if (e.key === "Tab") {
        e.preventDefault();
      }
    };
    this._onTitlePaste = (event) => {
      var _a3;
      const vEditor = this._titleVEditor;
      if (!vEditor)
        return;
      const vRange = vEditor.getVRange();
      if (!vRange)
        return;
      const data = (_a3 = event.clipboardData) == null ? void 0 : _a3.getData("text/plain");
      if (data) {
        const text = data.replace(/(\r\n|\r|\n)/g, "\n");
        vEditor.insertText(vRange, text);
        vEditor.setVRange({
          index: vRange.index + text.length,
          length: 0
        });
      }
    };
    this._onWheel = (e) => {
      const { selection } = this;
      const { state: state2 } = selection;
      const { type, viewport: viewport2 } = state2;
      if (type === "native") {
        return;
      }
      if (type.startsWith("block")) {
        e.preventDefault();
        const { viewportElement } = this;
        const { scrollTop, scrollHeight, clientHeight } = viewport2;
        const max2 = scrollHeight - clientHeight;
        let top2 = e.deltaY / 2;
        if (top2 > 0) {
          if (Math.ceil(scrollTop) === max2)
            return;
          top2 = Math.min(top2, max2 - scrollTop);
        } else if (top2 < 0) {
          if (scrollTop === 0)
            return;
          top2 = Math.max(top2, -scrollTop);
        }
        viewport2.scrollTop += top2;
        viewportElement.scrollTop += top2;
        if (type === "block") {
          const { draggingArea } = state2;
          if (draggingArea) {
            draggingArea.end.y += top2;
            selection.updateDraggingArea(draggingArea);
          }
        }
      }
    };
    this._onScroll = (e) => {
      const { selection } = this;
      const { type, viewport: viewport2 } = selection.state;
      const { scrollLeft, scrollTop } = e.target;
      viewport2.scrollLeft = scrollLeft;
      viewport2.scrollTop = scrollTop;
      if (type === "block") {
        selection.refreshDraggingArea(selection.state.viewportOffset);
        return;
      }
      if (type === "embed") {
        selection.refreshEmbedRects(this._embedEditingState);
        return;
      }
      let point;
      if (type === "native") {
        point = selection.state.startRange && selection.state.lastPoint;
      } else if (type === "block:drag") {
        point = selection.state.lastPoint;
      }
      if (point) {
        const evt = new PointerEvent("pointermove", {
          clientX: point.x,
          clientY: point.y
        });
        document.dispatchEvent(evt);
      }
    };
    this._initDragHandle = () => {
      const createHandle = () => {
        this.components.dragHandle = createDragHandle(this);
        this.components.dragHandle.getDropAllowedBlocks = (draggingBlockIds) => {
          if (draggingBlockIds && draggingBlockIds.length === 1 && utils_exports.isInsideBlockByFlavour(this.page, draggingBlockIds[0], "affine:database")) {
            return getAllowSelectedBlocks(this.page.getParent(draggingBlockIds[0]));
          }
          if (!draggingBlockIds || draggingBlockIds.length === 1) {
            return getAllowSelectedBlocks(this.model);
          } else {
            return getAllowSelectedBlocks(this.model).filter((block2) => {
              return !(draggingBlockIds == null ? void 0 : draggingBlockIds.includes(block2.id));
            });
          }
        };
      };
      if (this.page.awarenessStore.getFlag("enable_drag_handle") && !this.components.dragHandle) {
        createHandle();
      }
      this._disposables.add(this.page.awarenessStore.slots.update.subscribe((msg) => {
        var _a3;
        return (_a3 = msg.state) == null ? void 0 : _a3.flags.enable_drag_handle;
      }, (enable) => {
        var _a3;
        if (enable) {
          if (!this.components.dragHandle) {
            createHandle();
          }
        } else {
          (_a3 = this.components.dragHandle) == null ? void 0 : _a3.remove();
          this.components.dragHandle = null;
        }
      }, {
        filter: (msg) => msg.id === this.page.doc.clientID
      }));
    };
  }
  get titleVEditor() {
    assertExists(this._titleVEditor);
    return this._titleVEditor;
  }
  get innerRect() {
    const { left: left2, width } = this.pageBlockContainer.getBoundingClientRect();
    const { clientHeight, top: top2 } = this.selection.state.viewport;
    return Rect.fromLWTH(left2, Math.min(width, window.innerWidth), top2, Math.min(clientHeight, window.innerHeight));
  }
  _initTitleVEditor() {
    const { model } = this;
    const title = model.title;
    this._titleVEditor = new VEditor(title.yText, {
      active: () => activeEditorManager.isActive(this)
    });
    this._titleVEditor.mount(this._titleContainer);
    this._titleVEditor.bindHandlers({
      keydown: this._onTitleKeyDown,
      paste: this._onTitlePaste
    });
    this._disposables.addFromEvent(this._titleContainer, "compositionstart", () => this._isComposing = true);
    this._disposables.addFromEvent(this._titleContainer, "compositionend", () => this._isComposing = false);
    this.model.title.yText.observe(() => {
      this._updateTitleInMeta();
      this.requestUpdate();
    });
    this._titleVEditor.setReadonly(this.page.readonly);
  }
  updated(changedProperties) {
    if (changedProperties.has("model")) {
      if (this.model && !this._titleVEditor) {
        this._initTitleVEditor();
      }
    }
  }
  _initSlotEffects() {
    const { slots } = this;
    slots.draggingAreaUpdated.on((rect) => {
      this._draggingArea = rect;
    });
    slots.selectedRectsUpdated.on((rects) => {
      this._selectedRects = rects;
    });
    slots.embedRectsUpdated.on((rects) => {
      this._selectedEmbedRects = rects;
      if (rects.length === 0) {
        this._embedEditingState = null;
      }
    });
    slots.embedEditingStateUpdated.on((embedEditingState) => {
      this._embedEditingState = embedEditingState;
    });
    this.model.childrenUpdated.on(() => this.requestUpdate());
  }
  _initFrameSizeEffect() {
    tryUpdateFrameSize(this.page, 1);
    this.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey || e.shiftKey)
        return;
      tryUpdateFrameSize(this.page, 1);
    });
  }
  _initResizeEffect() {
    const resizeObserver = new ResizeObserver((entries) => {
      for (const { target } of entries) {
        if (target === this.viewportElement) {
          this.selection.updateViewport();
          this.selection.updateRects();
          break;
        }
      }
    });
    resizeObserver.observe(this.viewportElement);
    this._resizeObserver = resizeObserver;
  }
  firstUpdated() {
    const { page, selection } = this;
    const scope = hotkey.newScope(HOTKEY_SCOPE_TYPE.AFFINE_PAGE);
    if (activeEditorManager.isActive(this)) {
      hotkey.setScope(scope);
    }
    this._disposables.add(activeEditorManager.activeSlot.on(() => {
      if (activeEditorManager.isActive(this)) {
        hotkey.setScope(scope);
      }
    }));
    this._disposables.add(() => hotkey.deleteScope(scope));
    hotkey.withScope(scope, () => {
      bindHotkeys(page, selection);
    });
    hotkey.enableHotkey();
    this._initDragHandle();
    this._initSlotEffects();
    this._initFrameSizeEffect();
    this._initResizeEffect();
    this.mouseRoot.addEventListener("wheel", this._onWheel);
    this.viewportElement.addEventListener("scroll", this._onScroll);
    this.setAttribute(BLOCK_ID_ATTR, this.model.id);
  }
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:page", PageBlockService);
    this.clipboard.init(this.page);
    this.mouseRoot = this.parentElement;
    this.selection = new DefaultSelectionManager({
      page: this.page,
      mouseRoot: this.mouseRoot,
      slots: this.slots,
      container: this,
      dispatcher: this.root.uiEventDispatcher
    });
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    this.clipboard.dispose();
    this._disposables.dispose();
    (_a3 = this.components.dragHandle) == null ? void 0 : _a3.remove();
    removeHotkeys();
    this.selection.clear();
    this.selection.dispose();
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    this.mouseRoot.removeEventListener("wheel", this._onWheel);
    this.viewportElement.removeEventListener("scroll", this._onScroll);
  }
  render() {
    requestAnimationFrame(() => {
      this.selection.refreshRemoteSelection();
    });
    const { page, selection } = this;
    const { viewportOffset } = selection.state;
    const draggingArea = DraggingArea(this._draggingArea);
    const selectedEmbedContainer = EmbedSelectedRectsContainer(this._selectedEmbedRects, viewportOffset);
    const embedEditingContainer = EmbedEditingContainer(page.readonly ? null : this._embedEditingState, this.slots, viewportOffset);
    const isEmpty2 = (!this.model.title || !this.model.title.length) && !this._isComposing;
    return html`
      <div class="affine-default-viewport">
        <div class="affine-default-page-block-container">
          <div class="affine-default-page-block-title-container">
            <div
              data-block-is-title="true"
              class="affine-default-page-block-title ${isEmpty2 ? "affine-default-page-block-title-empty" : ""}"
            ></div>
            <backlink-button
              .host="${this}"
              .page="${this.page}"
            ></backlink-button>
          </div>
          ${this.content}
        </div>
        <affine-selected-blocks
          .mouseRoot="${this.mouseRoot}"
          .state="${{
      rects: this._selectedRects,
      grab: !draggingArea
    }}"
          .offset="${viewportOffset}"
        ></affine-selected-blocks>
        ${draggingArea} ${selectedEmbedContainer} ${embedEditingContainer}
      </div>
    `;
  }
};
DefaultPageBlockComponent.styles = css`
    .affine-default-viewport {
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
      height: 100%;
    }

    .affine-default-page-block-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      font-family: var(--affine-font-family);
      font-size: var(--affine-font-base);
      line-height: var(--affine-line-height);
      color: var(--affine-text-primary-color);
      font-weight: 400;
      max-width: var(--affine-editor-width);
      margin: 0 auto;
      /* cursor: crosshair; */
      cursor: default;
      padding-bottom: ${PAGE_BLOCK_PADDING_BOTTOM}px;

      /* Leave a place for drag-handle */
      padding-left: ${PAGE_BLOCK_CHILD_PADDING}px;
      padding-right: ${PAGE_BLOCK_CHILD_PADDING}px;
    }

    .affine-default-page-block-title {
      width: 100%;
      font-size: 40px;
      line-height: 50px;
      font-weight: 700;
      outline: none;
      resize: none;
      border: 0;
      font-family: inherit;
      color: inherit;
      cursor: text;
    }

    .affine-default-page-block-title-empty::before {
      content: 'Title';
      color: var(--affine-placeholder-color);
      position: absolute;
      opacity: 0.5;
    }

    .affine-default-page-block-title:disabled {
      background-color: transparent;
    }

    /*
    .affine-default-page-block-title-container {
    }
    */

    .affine-block-element {
      display: block;
    }
  `;
__decorate26([
  state()
], DefaultPageBlockComponent.prototype, "_draggingArea", void 0);
__decorate26([
  state()
], DefaultPageBlockComponent.prototype, "_selectedRects", void 0);
__decorate26([
  state()
], DefaultPageBlockComponent.prototype, "_selectedEmbedRects", void 0);
__decorate26([
  state()
], DefaultPageBlockComponent.prototype, "_embedEditingState", void 0);
__decorate26([
  state()
], DefaultPageBlockComponent.prototype, "_isComposing", void 0);
__decorate26([
  query(".affine-default-viewport")
], DefaultPageBlockComponent.prototype, "viewportElement", void 0);
__decorate26([
  query(".affine-default-page-block-container")
], DefaultPageBlockComponent.prototype, "pageBlockContainer", void 0);
__decorate26([
  query(".affine-default-page-block-title")
], DefaultPageBlockComponent.prototype, "_titleContainer", void 0);
DefaultPageBlockComponent = __decorate26([
  customElement("affine-default-page")
], DefaultPageBlockComponent);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/tool-icon-button.js
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessToolIconButton = class EdgelessToolIconButton2 extends LitElement {
  constructor() {
    super();
    this.disabled = false;
    this.coming = false;
    this.tipPosition = "top";
    this.active = false;
    this.activeMode = "color";
    this.addEventListener("click", (event) => {
      if (this.disabled) {
        event.stopPropagation();
        event.preventDefault();
      }
    }, { capture: true });
  }
  render() {
    const tooltip = this.coming ? "(Coming soon)" : this.tooltip;
    const classnames = `icon-container has-tool-tip active-mode-${this.activeMode}`;
    return html`
      <div
        class=${classnames}
        role="button"
        ?disabled=${this.disabled}
        ?active=${this.active}
      >
        <slot></slot>
        ${tooltip ? html`<tool-tip
              inert
              role="tooltip"
              tip-position=${this.tipPosition}
              arrow
              >${tooltip}</tool-tip
            >` : nothing}
      </div>
    `;
  }
};
EdgelessToolIconButton.styles = css`
    .icon-container {
      position: relative;
      display: flex;
      align-items: center;
      padding: 4px;
      color: var(--affine-icon-color);
      margin: 8px;
      border-radius: 5px;
      cursor: pointer;
    }

    .icon-container:hover {
      background: var(--affine-hover-color);
    }

    .icon-container.active-mode-color[active] {
      color: var(--affine-primary-color);
    }

    .icon-container.active-mode-background[active] {
      background: var(--affine-hover-color);
    }

    .icon-container[disabled] {
      pointer-events: none;
      cursor: not-allowed;
    }

    .icon-container[coming] {
      cursor: not-allowed;
      color: var(--affine-text-disable-color);
    }

    ${tooltipStyle}

    tool-tip {
      z-index: 12;
    }
  `;
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "disabled", void 0);
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "coming", void 0);
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "tooltip", void 0);
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "tipPosition", void 0);
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "active", void 0);
__decorate27([
  property()
], EdgelessToolIconButton.prototype, "activeMode", void 0);
EdgelessToolIconButton = __decorate27([
  customElement("edgeless-tool-icon-button")
], EdgelessToolIconButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/shape-tool/shape-menu-config.js
var ShapeComponentConfig = [
  {
    name: "rect",
    icon: SquareIcon,
    tooltip: "Square",
    disabled: false
  },
  {
    name: "ellipse",
    icon: EllipseIcon,
    tooltip: "Ellipse",
    disabled: false
  },
  {
    name: "diamond",
    icon: DiamondIcon,
    tooltip: "Diamond",
    disabled: false
  },
  {
    name: "triangle",
    icon: TriangleIcon,
    tooltip: "Triangle",
    disabled: false
  },
  {
    name: "roundedRect",
    icon: RoundedRectangleIcon,
    tooltip: "Rounded rectangle",
    disabled: false
  }
];
var ShapeComponentConfigMap = ShapeComponentConfig.reduce((acc, config2) => {
  acc[config2.name] = config2;
  return acc;
}, {});

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/shape-tool/shape-menu.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessShapeMenu = class EdgelessShapeMenu2 extends LitElement {
  constructor() {
    super(...arguments);
    this.slots = {
      select: new Slot()
    };
  }
  _onSelect(value) {
    this.selectedShape = value;
    this.slots.select.emit(value);
  }
  disconnectedCallback() {
    this.slots.select.dispose();
    super.disconnectedCallback();
  }
  render() {
    return html`
      <div class="shape-menu-container">
        ${ShapeComponentConfig.map(({ name, icon, tooltip, disabled }) => {
      return html`
            <edgeless-tool-icon-button
              .disabled=${disabled}
              .tooltip=${tooltip}
              .active=${this.selectedShape === name}
              @click=${() => {
        if (disabled)
          return;
        this._onSelect(name);
      }}
            >
              ${icon}
            </edgeless-tool-icon-button>
          `;
    })}
      </div>
    `;
  }
};
EdgelessShapeMenu.styles = css`
    :host {
      display: block;
      z-index: 2;
    }
    .shape-menu-container {
      display: flex;
      align-items: center;
      width: 240px;
      height: 48px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
      fill: none;
      stroke: currentColor;
    }
  `;
__decorate28([
  property()
], EdgelessShapeMenu.prototype, "selectedShape", void 0);
EdgelessShapeMenu = __decorate28([
  customElement("edgeless-shape-menu")
], EdgelessShapeMenu);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/line-size-button.js
var lineSizeButtonStyles = [
  css`
    .edgeless-component-line-size-button {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 16px;
      height: 16px;
    }

    .edgeless-component-line-size-button div {
      border-radius: 50%;
      background-color: var(--affine-icon-color);
    }

    .edgeless-component-line-size-button.size-s div {
      width: 4px;
      height: 4px;
    }
    .edgeless-component-line-size-button.size-l div {
      width: 10px;
      height: 10px;
    }
  `
];
function getTooltip(size) {
  return {
    s: "Thin",
    l: "Thick"
  }[size];
}
function LineSizeButton({ className, size, active, tooltip: tooltipFromProps, onClick }) {
  const classnames = `edgeless-component-line-size-button size-${size} ${active ? "active" : ""}`;
  const tooltip = tooltipFromProps !== void 0 ? tooltipFromProps : getTooltip(size);
  return html`<edgeless-tool-icon-button
    class=${className}
    .active=${active}
    .activeMode=${"background"}
    .tooltip=${tooltip}
    @click=${onClick}
  >
    <div class=${classnames}>
      <div></div>
    </div>
  </edgeless-tool-icon-button>`;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/line-style-button.js
var lineStyleButtonStyles = [
  css`
    .edgeless-component-line-style-button {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 16px;
      height: 16px;
      color: var(--affine-icon-color);
    }
  `
];
function getModeIcon(mode) {
  switch (mode) {
    case "solid": {
      return ConnectorLIcon;
    }
    case "dash": {
      return DashLineIcon;
    }
    case "none": {
      return BanIcon;
    }
  }
}
function getModeTooltip(mode) {
  return {
    solid: "Solid",
    dash: "Dash",
    none: "None"
  }[mode];
}
function LineStyleButton({ className, mode, active, tooltip: tooltipFromProps, onClick }) {
  const classnames = `edgeless-component-line-style-button mode-${mode} ${active ? "active" : ""}`;
  const icon = getModeIcon(mode);
  const tooltip = tooltipFromProps !== void 0 ? tooltipFromProps : getModeTooltip(mode);
  return html`<edgeless-tool-icon-button
    class=${className}
    .active=${active}
    .activeMode=${"background"}
    .tooltip=${tooltip}
    @click=${onClick}
  >
    <div class=${classnames}>${icon}</div>
  </edgeless-tool-icon-button>`;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/panel-wrapper.js
var panelWrapperStyle = [
  css`
    .edgeless-component-panel-wrapper {
      display: flex;
      padding: 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }
  `
];
function PanelWrapper({ children, className }) {
  const name = `edgeless-component-panel-wrapper ${className ? className : ""}`;
  return html`<div class=${name}>${children}</div>`;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/line-styles-panel.js
var lineStylesPanelStyles = [
  panelWrapperStyle,
  lineSizeButtonStyles,
  lineStyleButtonStyles
];
function LineStylesPanel({ onClick, selectedLineSize, selectedLineStyle, lineStyle = ["solid", "dash", "none"] } = {}) {
  const lineSizeButtons = repeat(["s", "l"], (size) => size, (size) => {
    return LineSizeButton({
      size,
      active: size === selectedLineSize,
      onClick: () => {
        onClick == null ? void 0 : onClick({
          type: "size",
          value: size
        });
      }
    });
  });
  const lineStyleButtons = repeat(lineStyle, (mode) => mode, (mode) => {
    return LineStyleButton({
      mode,
      active: mode === selectedLineStyle,
      onClick: () => {
        onClick == null ? void 0 : onClick({
          type: "lineStyle",
          value: mode
        });
      }
    });
  });
  return PanelWrapper({
    className: "line-style-panel",
    children: html`
      ${lineSizeButtons}
      <menu-divider .vertical=${true}></menu-divider>
      ${lineStyleButtons}
    `
  });
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/change-shape-button.js
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMostCommonShape(elements) {
  const shapeTypes = countBy(elements, (ele) => {
    return ele.shapeType === "rect" && ele.radius ? "roundedRect" : ele.shapeType;
  });
  const max2 = maxBy(Object.entries(shapeTypes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonFillColor(elements) {
  const colors = countBy(elements, (ele) => {
    return ele.filled ? ele.fillColor : "--affine-palette-transparent";
  });
  const max2 = maxBy(Object.entries(colors), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonStrokeColor(elements) {
  const colors = countBy(elements, (ele) => {
    return ele.strokeColor;
  });
  const max2 = maxBy(Object.entries(colors), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonLineSize(elements) {
  const sizes = countBy(elements, (ele) => {
    return ele.strokeWidth === 4 ? "s" : "l";
  });
  const max2 = maxBy(Object.entries(sizes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonLineStyle(elements) {
  const sizes = countBy(elements, (ele) => {
    switch (ele.strokeStyle) {
      case StrokeStyle.Solid: {
        return "solid";
      }
      case StrokeStyle.Dashed: {
        return "dash";
      }
      case StrokeStyle.None: {
        return "none";
      }
    }
  });
  const max2 = maxBy(Object.entries(sizes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
var FILL_COLORS = [
  "--affine-palette-shape-yellow",
  "--affine-palette-shape-orange",
  "--affine-palette-shape-tangerine",
  "--affine-palette-shape-red",
  "--affine-palette-shape-magenta",
  "--affine-palette-shape-purple",
  "--affine-palette-shape-green",
  "--affine-palette-shape-blue",
  "--affine-palette-shape-navy",
  "--affine-palette-shape-black",
  "--affine-palette-shape-white",
  "--affine-palette-transparent"
];
var DEFAULT_SHAPE_FILL_COLOR = FILL_COLORS[11];
var STROKE_COLORS = [
  "--affine-palette-line-yellow",
  "--affine-palette-line-orange",
  "--affine-palette-line-tangerine",
  "--affine-palette-line-red",
  "--affine-palette-line-magenta",
  "--affine-palette-line-purple",
  "--affine-palette-line-green",
  "--affine-palette-line-blue",
  "--affine-palette-line-navy",
  "--affine-palette-line-black",
  "--affine-palette-line-white",
  "--affine-palette-transparent"
];
var DEFAULT_SHAPE_STROKE_COLOR = STROKE_COLORS[9];
var EdgelessChangeShapeButton = class EdgelessChangeShapeButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.elements = [];
    this._popperShow = false;
    this._shapeMenuPopper = null;
    this._fillColorMenuPopper = null;
    this._strokeColorMenuPopper = null;
    this._lineStylesPanelPopper = null;
  }
  _forceUpdateSelection() {
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  _setShapeFillColor(color) {
    const filled = !isTransparent(color);
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        filled,
        fillColor: color
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStrokeColor(color) {
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        strokeColor: color
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStrokeWidth(strokeWidth) {
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        strokeWidth
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStrokeStyle(strokeStyle) {
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        strokeStyle
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStyles({ type, value }) {
    if (type === "size") {
      const strokeWidth = value === "s" ? 4 : 10;
      this._setShapeStrokeWidth(strokeWidth);
    } else if (type === "lineStyle") {
      switch (value) {
        case "solid": {
          this._setShapeStrokeStyle(StrokeStyle.Solid);
          break;
        }
        case "dash": {
          this._setShapeStrokeStyle(StrokeStyle.Dashed);
          break;
        }
        case "none": {
          this._setShapeStrokeStyle(StrokeStyle.None);
          break;
        }
      }
    }
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._shapeMenuPopper = createButtonPopper(this._changeShapeButton, this._shapeMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._shapeMenuPopper);
    _disposables.add(this._shapeMenu.slots.select.on((shapeType) => {
      const updatedProps = shapeType === "roundedRect" ? { shapeType: "rect", radius: 0.1 } : { shapeType, radius: 0 };
      this.page.captureSync();
      this.elements.forEach((element) => {
        this.surface.updateElement(element.id, updatedProps);
      });
      this._forceUpdateSelection();
    }));
    this._fillColorMenuPopper = createButtonPopper(this._fillColorButton, this._fillColorMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._fillColorMenuPopper);
    this._strokeColorMenuPopper = createButtonPopper(this._strokeColorButton, this._strokeColorMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._strokeColorMenuPopper);
    this._lineStylesPanelPopper = createButtonPopper(this._lineStylesButton, this._lineStylesPanel, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._lineStylesPanelPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const selectedShape = getMostCommonShape(this.elements);
    const icon = selectedShape ? ShapeComponentConfigMap[selectedShape].icon : null;
    const selectedFillColor = getMostCommonFillColor(this.elements) ?? FILL_COLORS[0];
    const selectedStrokeColor = getMostCommonStrokeColor(this.elements) ?? STROKE_COLORS[0];
    const selectedLineSize = getMostCommonLineSize(this.elements) ?? "s";
    const selectedLineStyle = getMostCommonLineStyle(this.elements) ?? "solid";
    return html`
      <edgeless-tool-icon-button
        class="change-shape-button"
        .tooltip=${this._popperShow ? "" : "Switch type"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._shapeMenuPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${icon}
      </edgeless-tool-icon-button>
      <edgeless-shape-menu .selectedShape=${selectedShape}>
      </edgeless-shape-menu>

      <menu-divider .vertical=${true}></menu-divider>

      <edgeless-tool-icon-button
        class="fill-color-button"
        .tooltip=${this._popperShow ? "" : "Shape color"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._fillColorMenuPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${ColorUnit(selectedFillColor)}
      </edgeless-tool-icon-button>
      <div class="color-panel-container fill-color">
        <edgeless-color-panel
          .value=${selectedFillColor}
          .options=${FILL_COLORS}
          @select=${(e) => this._setShapeFillColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <edgeless-tool-icon-button
        class="stroke-color-button"
        .tooltip=${this._popperShow ? "" : "Border color"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._strokeColorMenuPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${ColorUnit(selectedStrokeColor, { hollowCircle: true })}
      </edgeless-tool-icon-button>
      <div class="color-panel-container stroke-color">
        <edgeless-color-panel
          .value=${selectedStrokeColor}
          .options=${STROKE_COLORS}
          .hollowCircle=${true}
          @select=${(e) => this._setShapeStrokeColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <menu-divider .vertical=${true}></menu-divider>

      <edgeless-tool-icon-button
        class="line-styles-button"
        .tooltip=${this._popperShow ? "" : "Border style"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._lineStylesPanelPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${LineStyleIcon}
      </edgeless-tool-icon-button>
      ${LineStylesPanel({
      selectedLineSize,
      selectedLineStyle,
      onClick: (event) => {
        this._setShapeStyles(event);
      }
    })}
    `;
  }
};
EdgelessChangeShapeButton.styles = [
  lineSizeButtonStyles,
  lineStylesPanelStyles,
  css`
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        color: var(--affine-text-primary-color);
        stroke: none;
        fill: currentColor;
      }

      menu-divider {
        height: 24px;
      }

      edgeless-shape-menu {
        display: none;
      }

      edgeless-shape-menu[data-show] {
        display: block;
      }

      .change-shape-button {
        fill: none;
        stroke: currentColor;
      }

      .color-panel-container {
        display: none;
        padding: 4px;
        justify-content: center;
        align-items: center;
        background: var(--affine-background-overlay-panel-color);
        box-shadow: var(--affine-shadow-2);
        border-radius: 8px;
      }

      .color-panel-container[data-show] {
        display: block;
      }

      .shape-color-button-indicator {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        border-radius: 4px;
        cursor: pointer;
      }

      .shape-color-button-indicator div {
        border-radius: 50%;
        width: 16px;
        height: 16px;
      }

      .line-style-panel {
        display: none;
      }
      .line-style-panel[data-show] {
        display: flex;
      }
    `
];
__decorate29([
  property()
], EdgelessChangeShapeButton.prototype, "elements", void 0);
__decorate29([
  property()
], EdgelessChangeShapeButton.prototype, "page", void 0);
__decorate29([
  property()
], EdgelessChangeShapeButton.prototype, "surface", void 0);
__decorate29([
  property()
], EdgelessChangeShapeButton.prototype, "selectionState", void 0);
__decorate29([
  property()
], EdgelessChangeShapeButton.prototype, "slots", void 0);
__decorate29([
  state()
], EdgelessChangeShapeButton.prototype, "_popperShow", void 0);
__decorate29([
  query(".change-shape-button")
], EdgelessChangeShapeButton.prototype, "_changeShapeButton", void 0);
__decorate29([
  query("edgeless-shape-menu")
], EdgelessChangeShapeButton.prototype, "_shapeMenu", void 0);
__decorate29([
  query(".fill-color-button")
], EdgelessChangeShapeButton.prototype, "_fillColorButton", void 0);
__decorate29([
  query(".color-panel-container.fill-color")
], EdgelessChangeShapeButton.prototype, "_fillColorMenu", void 0);
__decorate29([
  query(".stroke-color-button")
], EdgelessChangeShapeButton.prototype, "_strokeColorButton", void 0);
__decorate29([
  query(".color-panel-container.stroke-color")
], EdgelessChangeShapeButton.prototype, "_strokeColorMenu", void 0);
__decorate29([
  query(".line-styles-button")
], EdgelessChangeShapeButton.prototype, "_lineStylesButton", void 0);
__decorate29([
  query(".line-style-panel")
], EdgelessChangeShapeButton.prototype, "_lineStylesPanel", void 0);
EdgelessChangeShapeButton = __decorate29([
  customElement("edgeless-change-shape-button")
], EdgelessChangeShapeButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/change-brush-button.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMostCommonColor2(elements) {
  const shapeTypes = countBy(elements, (ele) => ele.color);
  const max2 = maxBy(Object.entries(shapeTypes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonSize(elements) {
  const shapeTypes = countBy(elements, (ele) => ele.lineWidth);
  const max2 = maxBy(Object.entries(shapeTypes), ([k, count]) => count);
  return max2 ? Number(max2[0]) : null;
}
var EdgelessChangeBrushButton = class EdgelessChangeBrushButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.elements = [];
    this._popperShow = false;
    this._colorPanelPopper = null;
  }
  _setBrushSize(size) {
    this.page.captureSync();
    this.elements.forEach((element) => {
      if (element.lineWidth !== size) {
        this.surface.updateElement(element.id, { lineWidth: size });
      }
    });
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  _setBrushColor(color) {
    this.page.captureSync();
    this.elements.forEach((element) => {
      if (element.color !== color) {
        this.surface.updateElement(element.id, { color });
      }
    });
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._colorPanelPopper = createButtonPopper(this, this._colorPanel, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._colorPanelPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const selectedColor = getMostCommonColor2(this.elements) ?? DEFAULT_SELECTED_COLOR;
    const style = {
      backgroundColor: `var(${selectedColor})`
    };
    const selectedSize = getMostCommonSize(this.elements);
    return html`
      <edgeless-tool-icon-button
        .tooltip=${"Thin"}
        @click=${() => this._setBrushSize(BrushSize.Thin)}
      >
        <div
          class="brush-size-button"
          ?active=${selectedSize === BrushSize.Thin}
        >
          <div class="thin"></div>
        </div>
      </edgeless-tool-icon-button>
      <edgeless-tool-icon-button
        .tooltip=${"Thick"}
        @click=${() => this._setBrushSize(BrushSize.Thick)}
      >
        <div
          class="brush-size-button"
          ?active=${selectedSize === BrushSize.Thick}
        >
          <div class="thick"></div>
        </div>
      </edgeless-tool-icon-button>
      <menu-divider .vertical=${true}></menu-divider>
      <edgeless-tool-icon-button
        .tooltip=${this._popperShow ? "" : "Color"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._colorPanelPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        <div class="brush-size-button">
          <div class="thick" style=${styleMap(style)}></div>
        </div>
      </edgeless-tool-icon-button>
      <div class="color-panel-container">
        <edgeless-color-panel
          .value=${selectedColor}
          @select=${(e) => this._setBrushColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>
    `;
  }
};
EdgelessChangeBrushButton.styles = css`
    :host {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      color: var(--affine-text-primary-color);
      fill: currentColor;
    }

    menu-divider {
      height: 24px;
    }

    .color-panel-container {
      display: none;
      padding: 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    .color-panel-container[data-show] {
      display: block;
    }

    .brush-size-button {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 24px;
      height: 24px;
      box-sizing: border-box;
      border-radius: 4px;
      cursor: pointer;
    }

    .brush-size-button div {
      border-radius: 50%;
      background-color: var(--affine-icon-color);
    }

    .brush-size-button[active] div {
      background-color: var(--affine-blue);
    }

    .brush-size-button .thin {
      width: 4px;
      height: 4px;
    }

    .brush-size-button .thick {
      width: 10px;
      height: 10px;
    }
  `;
__decorate30([
  property()
], EdgelessChangeBrushButton.prototype, "elements", void 0);
__decorate30([
  property({ type: Object })
], EdgelessChangeBrushButton.prototype, "selectionState", void 0);
__decorate30([
  property()
], EdgelessChangeBrushButton.prototype, "page", void 0);
__decorate30([
  property()
], EdgelessChangeBrushButton.prototype, "surface", void 0);
__decorate30([
  property()
], EdgelessChangeBrushButton.prototype, "slots", void 0);
__decorate30([
  state()
], EdgelessChangeBrushButton.prototype, "_popperShow", void 0);
__decorate30([
  query(".color-panel-container")
], EdgelessChangeBrushButton.prototype, "_colorPanel", void 0);
EdgelessChangeBrushButton = __decorate30([
  customElement("edgeless-change-brush-button")
], EdgelessChangeBrushButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/change-connector-button.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMostCommonColor3(elements) {
  const colors = countBy(elements, (ele) => ele.color);
  const max2 = maxBy(Object.entries(colors), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonMode(elements) {
  const modes = countBy(elements, (ele) => ele.mode);
  const max2 = maxBy(Object.entries(modes), ([k, count]) => count);
  return max2 ? Number(max2[0]) : null;
}
function getMostCommonLineWidth(elements) {
  const sizes = countBy(elements, (ele) => {
    return ele.lineWidth === 4 ? "s" : "l";
  });
  const max2 = maxBy(Object.entries(sizes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
function getMostCommonLineStyle2(elements) {
  const sizes = countBy(elements, (ele) => {
    switch (ele.strokeStyle) {
      case StrokeStyle.Solid: {
        return "solid";
      }
      case StrokeStyle.Dashed: {
        return "dash";
      }
      case StrokeStyle.None: {
        return "none";
      }
    }
  });
  const max2 = maxBy(Object.entries(sizes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
var EdgelessChangeConnectorButton = class EdgelessChangeConnectorButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.elements = [];
    this._colorPanelPopper = null;
    this._disposables = new DisposableGroup();
    this._lineStylesPanelPopper = null;
    this._popperShow = false;
  }
  _forceUpdateSelection() {
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  _setConnectorMode(mode) {
    this.page.captureSync();
    this.elements.forEach((element) => {
      if (element.mode !== mode) {
        if (element.mode === ConnectorMode.Orthogonal) {
          const controllers = [
            element.controllers[0],
            element.controllers[element.controllers.length - 1]
          ].map((c) => {
            return {
              ...c,
              x: c.x + element.x,
              y: c.y + element.y
            };
          });
          this.surface.updateElement(element.id, {
            controllers,
            mode
          });
        } else {
          const { start: start2, end: end2 } = getConnectorAttachedInfo(element, this.surface, this.page);
          const route2 = generateConnectorPath(start2.rect, end2.rect, start2.point, end2.point, []);
          this.surface.updateElement(element.id, {
            controllers: route2,
            mode
          });
        }
      }
    });
    this._forceUpdateSelection();
  }
  _setConnectorColor(color) {
    this.page.captureSync();
    this.elements.forEach((element) => {
      if (element.color !== color) {
        this.surface.updateElement(element.id, { color });
      }
    });
  }
  _setShapeStrokeWidth(lineWidth) {
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        lineWidth
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStrokeStyle(strokeStyle) {
    this.elements.forEach((ele) => {
      this.surface.updateElement(ele.id, {
        strokeStyle
      });
    });
    this._forceUpdateSelection();
  }
  _setShapeStyles({ type, value }) {
    if (type === "size") {
      const strokeWidth = value === "s" ? 4 : 10;
      this._setShapeStrokeWidth(strokeWidth);
    } else if (type === "lineStyle") {
      switch (value) {
        case "solid": {
          this._setShapeStrokeStyle(StrokeStyle.Solid);
          break;
        }
        case "dash": {
          this._setShapeStrokeStyle(StrokeStyle.Dashed);
          break;
        }
        case "none": {
          this._setShapeStrokeStyle(StrokeStyle.None);
          break;
        }
      }
    }
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._colorPanelPopper = createButtonPopper(this._colorButton, this._colorPanel);
    _disposables.add(this._colorPanelPopper);
    this._lineStylesPanelPopper = createButtonPopper(this._lineStylesButton, this._lineStylesPanel, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._lineStylesPanelPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const selectedColor = getMostCommonColor3(this.elements) ?? DEFAULT_SELECTED_COLOR;
    const style = {
      backgroundColor: `var(${selectedColor})`
    };
    const selectedMode = getMostCommonMode(this.elements);
    const selectedLineSize = getMostCommonLineWidth(this.elements) ?? "s";
    const selectedLineStyle = getMostCommonLineStyle2(this.elements) ?? "solid";
    return html`
      <edgeless-tool-icon-button
        .tooltip=${"Straight line"}
        .tipPosition=${"bottom"}
        @click=${() => this._setConnectorMode(ConnectorMode.Straight)}
      >
        <div
          class="connector-mode-button"
          ?active=${selectedMode === ConnectorMode.Straight}
        >
          ${ConnectorLIcon}
        </div>
      </edgeless-tool-icon-button>
      <edgeless-tool-icon-button
        .tooltip=${"Connector"}
        .tipPosition=${"bottom"}
        @click=${() => this._setConnectorMode(ConnectorMode.Orthogonal)}
      >
        <div
          class="connector-mode-button"
          ?active=${selectedMode === ConnectorMode.Orthogonal}
        >
          ${ConnectorXIcon}
        </div>
      </edgeless-tool-icon-button>
      <menu-divider .vertical=${true}></menu-divider>
      <edgeless-tool-icon-button
        class="connector-color-button"
        .tooltip=${"Color"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._colorPanelPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        <div>
          <div class="color" style=${styleMap(style)}></div>
        </div>
      </edgeless-tool-icon-button>
      <div class="color-panel-container">
        <edgeless-color-panel
          .value=${selectedColor}
          @select=${(e) => this._setConnectorColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <edgeless-tool-icon-button
        class="line-styles-button"
        .tooltip=${this._popperShow ? "" : "Border style"}
        .tipPosition=${"bottom"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._lineStylesPanelPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${LineStyleIcon}
      </edgeless-tool-icon-button>
      ${LineStylesPanel({
      selectedLineSize,
      selectedLineStyle,
      lineStyle: ["solid", "dash"],
      onClick: (event) => {
        this._setShapeStyles(event);
      }
    })}
    `;
  }
};
EdgelessChangeConnectorButton.styles = [
  lineSizeButtonStyles,
  lineStylesPanelStyles,
  css`
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        color: var(--affine-text-primary-color);
        fill: currentColor;
      }

      menu-divider {
        height: 24px;
      }

      .color-panel-container {
        display: none;
        padding: 4px;
        justify-content: center;
        align-items: center;
        background: var(--affine-background-overlay-panel-color);
        box-shadow: var(--affine-shadow-2);
        border-radius: 8px;
      }

      .color-panel-container[data-show] {
        display: block;
      }

      .connector-mode-button {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        border-radius: 4px;
        cursor: pointer;
      }

      .connector-mode-button[active] {
        background-color: var(--affine-hover-color);
      }

      .connector-color-button .color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
      }

      .line-style-panel {
        display: none;
      }
      .line-style-panel[data-show] {
        display: flex;
      }
    `
];
__decorate31([
  property()
], EdgelessChangeConnectorButton.prototype, "elements", void 0);
__decorate31([
  property({ type: Object })
], EdgelessChangeConnectorButton.prototype, "selectionState", void 0);
__decorate31([
  property()
], EdgelessChangeConnectorButton.prototype, "page", void 0);
__decorate31([
  property()
], EdgelessChangeConnectorButton.prototype, "surface", void 0);
__decorate31([
  property()
], EdgelessChangeConnectorButton.prototype, "slots", void 0);
__decorate31([
  query(".connector-color-button")
], EdgelessChangeConnectorButton.prototype, "_colorButton", void 0);
__decorate31([
  query(".color-panel-container")
], EdgelessChangeConnectorButton.prototype, "_colorPanel", void 0);
__decorate31([
  query(".line-styles-button")
], EdgelessChangeConnectorButton.prototype, "_lineStylesButton", void 0);
__decorate31([
  query(".line-style-panel")
], EdgelessChangeConnectorButton.prototype, "_lineStylesPanel", void 0);
EdgelessChangeConnectorButton = __decorate31([
  customElement("edgeless-change-connector-button")
], EdgelessChangeConnectorButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/change-frame-button.js
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMostCommonBackground(frames) {
  const shapeTypes = countBy(frames, (frame) => {
    return frame.background;
  });
  const max2 = maxBy(Object.entries(shapeTypes), ([k, count]) => count);
  return max2 ? max2[0] : null;
}
var EdgelessChangeFrameButton = class EdgelessChangeFrameButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.frames = [];
    this._popperShow = false;
    this._colorSelectorPopper = null;
  }
  _renderSelectedColor(color) {
    const style = { backgroundColor: `var(${color})` };
    return html`<div class="selected-background" style=${styleMap(style)}>
      A
    </div>`;
  }
  _setBlockBackground(color) {
    this.frames.forEach((frame) => {
      this.page.updateBlock(frame, { background: color });
    });
    this.slots.selectionUpdated.emit({ ...this.selectionState });
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._colorSelectorPopper = createButtonPopper(this, this._colorSelector, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._colorSelectorPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const selectedBackground = getMostCommonBackground(this.frames) || FRAME_BACKGROUND_COLORS[0];
    return html`
      <edgeless-tool-icon-button
        .tooltip=${this._popperShow ? "" : "Color"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._colorSelectorPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${this._renderSelectedColor(selectedBackground)}
      </edgeless-tool-icon-button>
      <edgeless-color-panel
        .value=${selectedBackground}
        .options=${FRAME_BACKGROUND_COLORS}
        .showLetterMark=${true}
        @select=${(event) => {
      this._setBlockBackground(event.detail);
    }}
      ></edgeless-color-panel>
    `;
  }
};
EdgelessChangeFrameButton.styles = css`
    :host {
      display: block;
      color: var(--affine-text-primary-color);
      fill: currentColor;
    }

    edgeless-color-panel {
      display: none;
      width: 108px;
      height: 68px;
      padding: 8px 12px;
      flex-wrap: wrap;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    edgeless-color-panel[data-show] {
      display: flex;
    }

    .selected-background {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      width: 16px;
      height: 16px;
      box-sizing: border-box;
      border-radius: 50%;
      color: var(--affine-text-primary-color);
      font-size: 12px;
    }
  `;
__decorate32([
  property()
], EdgelessChangeFrameButton.prototype, "frames", void 0);
__decorate32([
  property()
], EdgelessChangeFrameButton.prototype, "page", void 0);
__decorate32([
  property()
], EdgelessChangeFrameButton.prototype, "selectionState", void 0);
__decorate32([
  property()
], EdgelessChangeFrameButton.prototype, "slots", void 0);
__decorate32([
  state()
], EdgelessChangeFrameButton.prototype, "_popperShow", void 0);
__decorate32([
  query("edgeless-color-panel")
], EdgelessChangeFrameButton.prototype, "_colorSelector", void 0);
EdgelessChangeFrameButton = __decorate32([
  customElement("edgeless-change-frame-button")
], EdgelessChangeFrameButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/more-button.js
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ACTIONS = [
  // FIXME: should implement these function
  // { name: 'Copy', type: 'copy', disabled: true },
  // { name: 'Paste', type: 'paste', disabled: true },
  // { name: 'Duplicate', type: 'duplicate', disabled: true },
  { name: "Bring to front", type: "front" },
  { name: "Bring forward", type: "forward" },
  { name: "Send backward", type: "backward" },
  { name: "Send to back", type: "back" },
  // { name: 'Copy as PNG', type: 'copy as PNG', disabled: true },
  { name: "Delete", type: "delete" }
];
function Actions(onClick) {
  return repeat(ACTIONS, (action) => action.type, (action) => html`<div
        class="action-item"
        @click=${() => onClick(action)}
        ?data-disabled=${action.disabled}
      >
        ${action.name}
      </div>`);
}
var EdgelessMoreButton = class EdgelessMoreButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.elements = [];
    this._popperShow = false;
    this._actionsMenuPopper = null;
    this._runAction = ({ type }) => {
      var _a3;
      switch (type) {
        case "delete":
          this._delete();
          break;
        case "front":
        case "forward":
        case "backward":
        case "back": {
          const { frames, shapes } = this._splitElements();
          if (frames.length) {
            this.slots.reorderingFramesUpdated.emit({
              elements: frames,
              type
            });
          }
          if (shapes.length) {
            this.slots.reorderingShapesUpdated.emit({
              elements: shapes,
              type
            });
          }
          break;
        }
      }
      (_a3 = this._actionsMenuPopper) == null ? void 0 : _a3.hide();
    };
  }
  _splitElements() {
    const frames = [];
    const shapes = [];
    this.elements.forEach((element) => {
      if (isTopLevelBlock(element)) {
        frames.push(element);
      } else {
        shapes.push(element);
      }
    });
    return {
      frames,
      shapes
    };
  }
  _delete() {
    this.page.captureSync();
    this.elements.forEach((element) => {
      var _a3;
      if (isTopLevelBlock(element)) {
        const children = ((_a3 = this.page.root) == null ? void 0 : _a3.children) ?? [];
        if (children.length > 1) {
          this.page.deleteBlock(element);
        }
      } else {
        this.surface.removeElement(element.id);
      }
    });
    this.slots.selectionUpdated.emit({ selected: [], active: false });
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._actionsMenuPopper = createButtonPopper(this, this._actionsMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._actionsMenuPopper);
    super.firstUpdated(changedProperties);
  }
  render() {
    const actions = Actions(this._runAction);
    return html`
      <edgeless-tool-icon-button
        .tooltip=${this._popperShow ? "" : "More"}
        .active=${false}
        @click=${() => {
      var _a3;
      return (_a3 = this._actionsMenuPopper) == null ? void 0 : _a3.toggle();
    }}
      >
        ${MoreHorizontalIcon}
      </edgeless-tool-icon-button>
      <div class="more-actions-container">${actions}</div>
    `;
  }
};
EdgelessMoreButton.styles = css`
    :host {
      display: block;
      color: var(--affine-text-primary-color);
      fill: currentColor;
    }

    .more-actions-container {
      display: none;
      width: 158px;
      padding: 8px 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
      font-size: 16px;
      line-height: 22px;
    }

    .more-actions-container[data-show] {
      display: block;
    }

    .action-item {
      width: 100%;
      height: 32px;
      box-sizing: border-box;
      padding: 5px 12px;
      border-radius: 5px;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .action-item:hover {
      background-color: var(--affine-hover-color);
    }

    .action-item[data-disabled] {
      cursor: not-allowed;
    }
  `;
__decorate33([
  property()
], EdgelessMoreButton.prototype, "elements", void 0);
__decorate33([
  property()
], EdgelessMoreButton.prototype, "page", void 0);
__decorate33([
  property()
], EdgelessMoreButton.prototype, "surface", void 0);
__decorate33([
  property()
], EdgelessMoreButton.prototype, "slots", void 0);
__decorate33([
  state()
], EdgelessMoreButton.prototype, "_popperShow", void 0);
__decorate33([
  query(".more-actions-container")
], EdgelessMoreButton.prototype, "_actionsMenu", void 0);
EdgelessMoreButton = __decorate33([
  customElement("edgeless-more-button")
], EdgelessMoreButton);

// node_modules/lit-html/development/directives/join.js
function* join3(items, joiner) {
  const isFunction = typeof joiner === "function";
  if (items !== void 0) {
    let i = -1;
    for (const value of items) {
      if (i > -1) {
        yield isFunction ? joiner(i) : joiner;
      }
      i++;
      yield value;
    }
  }
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/component-toolbar/component-toolbar.js
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessComponentToolbar = class EdgelessComponentToolbar2 extends LitElement {
  constructor() {
    super(...arguments);
    this.selected = [];
  }
  _groupSelected() {
    const result = groupBy(this.selected, (s) => {
      if (isTopLevelBlock(s)) {
        return "frame";
      }
      return s.type;
    });
    return result;
  }
  _getShapeButton(shapeElements) {
    const shapeButton = (shapeElements == null ? void 0 : shapeElements.length) ? html`<edgeless-change-shape-button
          .elements=${shapeElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-shape-button>` : null;
    return shapeButton;
  }
  _getBrushButton(brushElements) {
    return (brushElements == null ? void 0 : brushElements.length) ? html`<edgeless-change-brush-button
          .elements=${brushElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-brush-button>` : null;
  }
  _getConnectorButton(connectorElements) {
    return (connectorElements == null ? void 0 : connectorElements.length) ? html` <edgeless-change-connector-button
          .elements=${connectorElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-connector-button>` : null;
  }
  _getFrameButton(blocks) {
    return (blocks == null ? void 0 : blocks.length) ? html`<edgeless-change-frame-button
          .frames=${blocks}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-frame-button>` : null;
  }
  _getTextButton(textElements) {
    return (textElements == null ? void 0 : textElements.length) ? html`<edgeless-change-text-button
          .texts=${textElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-text-button>` : null;
  }
  render() {
    const groupedSelected = this._groupSelected();
    const { shape, brush, connector, frame, text } = groupedSelected;
    const selectedAtLeastTwoTypes = atLeastNMatches(Object.values(groupedSelected), (e) => !!e.length, 2);
    const buttons = selectedAtLeastTwoTypes ? [] : [
      this._getShapeButton(shape),
      this._getBrushButton(brush),
      this._getConnectorButton(connector),
      this._getFrameButton(frame),
      this._getTextButton(text)
    ].filter((b) => !!b);
    const divider = !buttons.length ? nothing : html`<menu-divider .vertical=${true}></menu-divider>`;
    return html`<div class="container" @pointerdown=${stopPropagation}>
      ${join3(buttons, () => "")} ${divider}
      <edgeless-more-button
        .elements=${this.selected}
        .page=${this.page}
        .surface=${this.surface}
        .slots=${this.slots}
      >
      </edgeless-more-button>
    </div>`;
  }
};
EdgelessComponentToolbar.styles = css`
    :host {
      display: block;
      user-select: none;
    }

    .container {
      display: flex;
      align-items: center;
      height: 48px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    menu-divider {
      height: 24px;
    }
  `;
__decorate34([
  property()
], EdgelessComponentToolbar.prototype, "selected", void 0);
__decorate34([
  property({ type: Object })
], EdgelessComponentToolbar.prototype, "selectionState", void 0);
__decorate34([
  property()
], EdgelessComponentToolbar.prototype, "page", void 0);
__decorate34([
  property()
], EdgelessComponentToolbar.prototype, "surface", void 0);
__decorate34([
  property()
], EdgelessComponentToolbar.prototype, "slots", void 0);
EdgelessComponentToolbar = __decorate34([
  customElement("edgeless-component-toolbar")
], EdgelessComponentToolbar);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/resize-handles.js
var HandleDirection;
(function(HandleDirection2) {
  HandleDirection2["Left"] = "left";
  HandleDirection2["Right"] = "right";
  HandleDirection2["TopLeft"] = "top-left";
  HandleDirection2["BottomLeft"] = "bottom-left";
  HandleDirection2["TopRight"] = "top-right";
  HandleDirection2["BottomRight"] = "bottom-right";
})(HandleDirection || (HandleDirection = {}));
function ResizeHandle(handleDirection, onPointerDown) {
  const handlerPointerDown = (e) => {
    e.stopPropagation();
    onPointerDown && onPointerDown(e, handleDirection);
  };
  return html`<div
    aria-label=${`handle-${handleDirection}`}
    @pointerdown=${handlerPointerDown}
  ></div>`;
}
function ResizeHandles(resizeMode, onPointerDown) {
  switch (resizeMode) {
    case "corner": {
      const handleTopLeft = ResizeHandle(HandleDirection.TopLeft, onPointerDown);
      const handleTopRight = ResizeHandle(HandleDirection.TopRight, onPointerDown);
      const handleBottomLeft = ResizeHandle(HandleDirection.BottomLeft, onPointerDown);
      const handleBottomRight = ResizeHandle(HandleDirection.BottomRight, onPointerDown);
      return html`
        ${handleTopLeft}
        ${handleTopRight}
        ${handleBottomLeft}
        ${handleBottomRight}
      `;
    }
    case "edge": {
      const handleLeft = ResizeHandle(HandleDirection.Left, onPointerDown);
      const handleRight = ResizeHandle(HandleDirection.Right, onPointerDown);
      return html`${handleLeft} ${handleRight}`;
    }
    case "none": {
      return nothing;
    }
  }
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/resize-manager.js
var HandleResizeManager = class {
  constructor(onResizeMove, onResizeEnd) {
    this._dragDirection = HandleDirection.Left;
    this._dragPos = {
      start: { x: 0, y: 0 },
      end: { x: 0, y: 0 }
    };
    this._bounds = /* @__PURE__ */ new Map();
    this._commonBound = [0, 0, 0, 0];
    this._aspectRatio = 1;
    this._resizeMode = "none";
    this._zoom = 1;
    this._shiftKey = false;
    this.onPointerDown = (e, direction, bounds, resizeMode, zoom) => {
      e.stopPropagation();
      this._bounds = bounds;
      const { x, y, w, h } = getCommonBound([...bounds.values()]);
      this._commonBound = [x, y, x + w, y + h];
      this._dragDirection = direction;
      this._dragPos.start = { x: e.x, y: e.y };
      this._dragPos.end = { x: e.x, y: e.y };
      this._aspectRatio = w / h;
      this._resizeMode = resizeMode;
      this._zoom = zoom;
      const _onPointerMove = (e2) => {
        if (resizeMode === "none")
          return;
        this._shiftKey || (this._shiftKey = e2.shiftKey);
        this._dragPos.end = { x: e2.x, y: e2.y };
        this._resize(this._shiftKey);
      };
      const _onPointerUp = (_) => {
        this._onResizeEnd();
        this._bounds.clear();
        this._dragPos = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
        this._commonBound = [0, 0, 0, 0];
        document.removeEventListener("pointermove", _onPointerMove);
        document.removeEventListener("pointerup", _onPointerUp);
      };
      document.addEventListener("pointermove", _onPointerMove);
      document.addEventListener("pointerup", _onPointerUp);
    };
    this._onResizeMove = onResizeMove;
    this._onResizeEnd = onResizeEnd;
  }
  // TODO: move to vec2
  _resize(shift = false) {
    const { _aspectRatio: aspectRatio, _dragDirection: direction, _dragPos: dragPos, _resizeMode: resizeMode, _zoom: zoom, _commonBound } = this;
    const isCorner = resizeMode === "corner";
    const { x: startX, y: startY } = dragPos.start;
    const { x: endX, y: endY } = dragPos.end;
    const deltaX = (endX - startX) / zoom;
    const [oldMinX, oldMinY, oldMaxX, oldMaxY] = _commonBound;
    const oldCommonW = oldMaxX - oldMinX;
    const oldCommonH = oldMaxY - oldMinY;
    let [minX, minY, maxX, maxY] = _commonBound;
    let width = 0;
    let height = 0;
    let flipX = false;
    let flipY = false;
    if (isCorner) {
      const deltaY = (endY - startY) / zoom;
      switch (direction) {
        case HandleDirection.TopLeft: {
          minX += deltaX;
          minY += deltaY;
          break;
        }
        case HandleDirection.BottomRight: {
          maxX += deltaX;
          maxY += deltaY;
          break;
        }
        case HandleDirection.TopRight:
          maxX += deltaX;
          minY += deltaY;
          break;
        case HandleDirection.BottomLeft: {
          minX += deltaX;
          maxY += deltaY;
          break;
        }
      }
      const dw = maxX - minX;
      const dh = maxY - minY;
      const scaleX = dw / oldCommonW;
      const scaleY = dh / oldCommonH;
      flipX = scaleX < 0;
      flipY = scaleY < 0;
      if (shift && isCorner) {
        const bw = Math.abs(dw);
        const bh = Math.abs(dh);
        const isTall = aspectRatio < bw / bh;
        const th = bw / aspectRatio * (flipY ? 1 : -1);
        const tw = bh * aspectRatio * (flipX ? 1 : -1);
        switch (direction) {
          case HandleDirection.TopLeft: {
            if (isTall)
              minY = maxY + th;
            else
              minX = maxX + tw;
            break;
          }
          case HandleDirection.BottomRight: {
            if (isTall)
              maxY = minY - th;
            else
              maxX = minX - tw;
            break;
          }
          case HandleDirection.TopRight:
            if (isTall)
              minY = maxY + th;
            else
              maxX = minX - tw;
            break;
          case HandleDirection.BottomLeft: {
            if (isTall)
              maxY = minY - th;
            else
              minX = maxX + tw;
            break;
          }
        }
      }
    } else {
      switch (direction) {
        case HandleDirection.Left:
          minX += deltaX;
          break;
        case HandleDirection.Right:
          maxX += deltaX;
          break;
      }
      flipX = maxX < minX;
    }
    if (flipX) {
      const t = maxX;
      maxX = minX;
      minX = t;
    }
    if (flipY) {
      const t = maxY;
      maxY = minY;
      minY = t;
    }
    width = Math.abs(maxX - minX);
    height = Math.abs(maxY - minY);
    const newCommonBound = {
      x: minX,
      y: minY,
      w: width,
      h: height
    };
    const newBounds = /* @__PURE__ */ new Map();
    this._bounds.forEach((bound, id) => {
      const { x: oldX, y: oldY, w: oldW, h: oldH } = bound;
      const nx = (flipX ? oldMaxX - oldX - oldW : oldX - oldMinX) / oldCommonW;
      const ny = (flipY ? oldMaxY - oldY - oldH : oldY - oldMinY) / oldCommonH;
      const shapeX = newCommonBound.w * nx + newCommonBound.x;
      const shapeY = newCommonBound.h * ny + newCommonBound.y;
      const shapeW = newCommonBound.w * (oldW / oldCommonW);
      const shapeH = newCommonBound.h * (oldH / oldCommonH);
      newBounds.set(id, new Bound(shapeX, shapeY, shapeW, shapeH));
    });
    this._onResizeMove(newBounds);
  }
  onPressShiftKey(pressed) {
    if (this._shiftKey === pressed)
      return;
    this._shiftKey = pressed;
    this._resize(pressed);
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/single-connector-handles.js
function capPointerdown(event, surface, page, element, position, connectorMode, requestUpdate) {
  const startX = event.clientX;
  const startY = event.clientY;
  const originControllers = element.controllers.map((c) => ({
    ...c,
    x: c.x + element.x,
    y: c.y + element.y
  }));
  const anchorPoint = position === "start" ? originControllers[0] : originControllers[originControllers.length - 1];
  const elementX = anchorPoint.x;
  const elementY = anchorPoint.y;
  const pointermove = (mousePointerEvent) => {
    const { clientX, clientY } = mousePointerEvent;
    const deltaX = clientX - startX;
    const deltaY = clientY - startY;
    const { zoom } = surface.viewport;
    const modelX = elementX + deltaX / zoom;
    const modelY = elementY + deltaY / zoom;
    const [x, y] = surface.toViewCoord(modelX, modelY);
    const { start: start2, end: end2 } = getConnectorAttachedInfo(element, surface, page);
    const picked = pickBy(surface, page, x, y, (ele) => ele.id !== element.id && ele.type !== "connector");
    const newRect = picked ? new Rectangle(...deserializeXYWH(getXYWH(picked))) : null;
    const { point: newPoint, position: attachedPointPosition } = getAttachedPoint(modelX, modelY, newRect);
    let routes;
    if (position === "start") {
      routes = generateConnectorPath(newRect, end2.rect, newPoint, end2.point, originControllers, connectorMode, "end");
    } else {
      routes = generateConnectorPath(start2.rect, newRect, start2.point, newPoint, originControllers, connectorMode, "start");
    }
    if (position === "start") {
      surface.updateElement(element.id, {
        controllers: routes,
        startElement: picked && attachedPointPosition ? { id: picked.id, position: attachedPointPosition } : void 0
      });
    } else {
      surface.updateElement(element.id, {
        controllers: routes,
        endElement: picked && attachedPointPosition ? { id: picked.id, position: attachedPointPosition } : void 0
      });
    }
    requestUpdate();
  };
  const pointerup = () => {
    document.removeEventListener("pointermove", pointermove);
    document.removeEventListener("pointerup", pointerup);
  };
  document.addEventListener("pointermove", pointermove);
  document.addEventListener("pointerup", pointerup);
}
function getControllerHandles(controllers) {
  const handles = [];
  for (let i = 0; i < controllers.length - 1; i++) {
    const current = controllers[i];
    const next2 = controllers[i + 1];
    const isVertical = current.x === next2.x;
    const handle = isVertical ? {
      x: current.x,
      y: (current.y + next2.y) / 2,
      position: i,
      isVertical
    } : {
      x: (current.x + next2.x) / 2,
      y: current.y,
      position: i,
      isVertical
    };
    handles.push(handle);
  }
  return handles;
}
function centerControllerPointerdown(event, surface, page, element, handle, requestUpdate) {
  const startX = event.clientX;
  const startY = event.clientY;
  const { controllers, x, y } = element;
  const pointermove = (pointerMoveEvent) => {
    const { isVertical, position } = handle;
    const { zoom } = surface.viewport;
    const absoluteControllers = controllers.map((c) => ({
      ...c,
      x: c.x + x,
      y: c.y + y
    }));
    const deltaX = isVertical ? pointerMoveEvent.clientX - startX : 0;
    const deltaY = isVertical ? 0 : pointerMoveEvent.clientY - startY;
    const point0 = absoluteControllers[position];
    const newPoint0 = {
      x: point0.x + deltaX / zoom,
      y: point0.y + deltaY / zoom,
      customized: true
    };
    const point12 = absoluteControllers[position + 1];
    const newPoint1 = {
      x: point12.x + deltaX / zoom,
      y: point12.y + deltaY / zoom,
      customized: true
    };
    if (position === 0) {
      absoluteControllers.splice(position + 1, 0, newPoint0);
      absoluteControllers[position + 2] = newPoint1;
    } else if (position === absoluteControllers.length - 2) {
      absoluteControllers[position] = newPoint0;
      absoluteControllers.splice(position + 1, 0, newPoint1);
    } else {
      absoluteControllers[position] = newPoint0;
      absoluteControllers[position + 1] = newPoint1;
    }
    surface.updateElement(element.id, {
      controllers: simplifyPath(absoluteControllers)
    });
    requestUpdate();
  };
  const pointerup = (pointerUpEvent) => {
    document.removeEventListener("pointermove", pointermove);
    document.removeEventListener("pointerup", pointerup);
  };
  document.addEventListener("pointermove", pointermove);
  document.addEventListener("pointerup", pointerup);
}
function SingleConnectorHandles(element, surface, page, requestUpdate) {
  const { controllers, mode } = element;
  const controllerHandles = mode === ConnectorMode.Orthogonal ? getControllerHandles(controllers) : [];
  const zoom = surface.viewport.zoom;
  const start2 = {
    position: "absolute",
    left: `${controllers[0].x * zoom}px`,
    top: `${controllers[0].y * zoom}px`
  };
  const end2 = {
    position: "absolute",
    left: `${controllers[controllers.length - 1].x * zoom}px`,
    top: `${controllers[controllers.length - 1].y * zoom}px`
  };
  return html`
    <style>
      .line-controller {
        position: absolute;
        width: 9px;
        height: 9px;
        box-sizing: border-box;
        border-radius: 50%;
        border: 2px solid var(--affine-text-emphasis-color);
        background-color: var(--affine-background-primary-color);
        transform: translate(-50%, -50%);
        cursor: pointer;
        z-index: 10;
        pointer-events: all;
        /**
         * Fix: pointerEvent stops firing after a short time.
         * When a gesture is started, the browser intersects the touch-action values of the touched element and its ancestors,
         * up to the one that implements the gesture (in other words, the first containing scrolling element)
         * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
         */
        touch-action: none;
      }
    </style>
    <div
      class="line-controller line-start"
      style=${styleMap(start2)}
      @pointerdown=${(e) => {
    e.stopPropagation();
    capPointerdown(e, surface, page, element, "start", mode, requestUpdate);
  }}
    ></div>
    <div
      class="line-controller line-end"
      style=${styleMap(end2)}
      @pointerdown=${(e) => {
    e.stopPropagation();
    capPointerdown(e, surface, page, element, "end", mode, requestUpdate);
  }}
    ></div>
    ${repeat(controllerHandles, (c) => Math.random(), (c) => {
    const style = {
      left: `${c.x * zoom}px`,
      top: `${c.y * zoom}px`,
      cursor: c.isVertical ? "col-resize" : "row-resize"
    };
    return html`<div
          class="line-controller"
          style=${styleMap(style)}
          @pointerdown=${(e) => {
      e.stopPropagation();
      centerControllerPointerdown(e, surface, page, element, c, requestUpdate);
    }}
        ></div>`;
  })}
  `;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/edgeless-selected-rect.js
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessSelectedRect = class EdgelessSelectedRect2 extends WithDisposable(LitElement) {
  constructor() {
    super();
    this._componentToolbarPopper = null;
    this._lock = false;
    this._onDragMove = (newBounds) => {
      const { page, state: state2, surface } = this;
      const selectedMap = new Map(state2.selected.map((element) => [element.id, element]));
      newBounds.forEach((bound, id) => {
        const element = selectedMap.get(id);
        if (!element)
          return;
        if (isTopLevelBlock(element)) {
          let frameX = bound.x;
          let frameY = bound.y;
          let frameW = bound.w;
          let frameH = deserializeXYWH(element.xywh)[3];
          if (frameW < FRAME_MIN_WIDTH) {
            frameW = FRAME_MIN_WIDTH;
            frameX = bound.x;
          }
          if (frameH < FRAME_MIN_HEIGHT) {
            frameH = FRAME_MIN_HEIGHT;
            frameY = bound.y;
          }
          page.updateBlock(element, {
            xywh: JSON.stringify([frameX, frameY, frameW, frameH])
          });
        } else {
          if (element instanceof TextElement) {
            const p = bound.h / element.h;
            bound.w = element.w * p;
            surface.updateElement(id, {
              xywh: serializeXYWH(bound.x, bound.y, bound.w, bound.h),
              fontSize: element.fontSize * p
            });
          } else {
            surface.setElementBound(element.id, bound);
          }
        }
        handleElementChangedEffectForConnector(element, [element], surface, page);
      });
      this.requestUpdate();
    };
    this._onDragEnd = () => {
      if (this._lock) {
        this.page.captureSync();
      }
      this._lock = false;
    };
    this._resizeManager = new HandleResizeManager(this._onDragMove, this._onDragEnd);
    this.addEventListener("pointerdown", stopPropagation);
  }
  get zoom() {
    return this.surface.viewport.zoom;
  }
  get resizeMode() {
    if (this.state.selected.length === 1 && this.state.selected[0].type === "connector") {
      return "none";
    }
    const hasBlockElement = this.state.selected.find((elem) => isTopLevelBlock(elem));
    return hasBlockElement ? "edge" : "corner";
  }
  firstUpdated() {
    const { _disposables, slots } = this;
    _disposables.add(slots.viewportUpdated.on(() => this.requestUpdate()));
    _disposables.add(slots.pressShiftKeyUpdated.on((pressed) => this._resizeManager.onPressShiftKey(pressed)));
    this._componentToolbarPopper = this._componentToolbar ? createPopper3(this._selectedRect, this._componentToolbar, {
      placement: "top",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 12]
          }
        },
        {
          name: "flip",
          options: {
            fallbackPlacements: ["bottom"]
          }
        }
      ]
    }) : null;
    _disposables.add(() => {
      var _a3;
      return (_a3 = this._componentToolbarPopper) == null ? void 0 : _a3.destroy();
    });
    if (this._componentToolbar) {
      const resizeObserver = new ResizeObserver(() => {
        var _a3;
        return (_a3 = this._componentToolbarPopper) == null ? void 0 : _a3.update();
      });
      resizeObserver.observe(this._componentToolbar);
      _disposables.add(() => resizeObserver.disconnect());
    }
  }
  updated(changedProperties) {
    var _a3;
    (_a3 = this._componentToolbarPopper) == null ? void 0 : _a3.update();
    super.updated(changedProperties);
  }
  render() {
    const { state: state2 } = this;
    const { active, selected } = state2;
    if (selected.length === 0 || active && selected[0] instanceof TextElement) {
      return nothing;
    }
    const { page, surface, resizeMode, _resizeManager } = this;
    const selectedRect = getSelectedRect(selected, surface.viewport);
    const style = getCommonRectStyle(selectedRect, active, true);
    const hasResizeHandles = !active && !page.readonly;
    const resizeHandles = hasResizeHandles ? ResizeHandles(resizeMode, (e, direction) => {
      const bounds = getSelectableBounds(selected);
      _resizeManager.onPointerDown(e, direction, bounds, resizeMode, this.zoom);
    }) : nothing;
    const connectorHandles = selected.length === 1 && selected[0].type === "connector" ? SingleConnectorHandles(selected[0], this.surface, this.page, () => {
      this.slots.selectionUpdated.emit({ ...state2 });
    }) : nothing;
    const componentToolbar = active ? nothing : html`<edgeless-component-toolbar
          .selected=${selected}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${state2}
        >
        </edgeless-component-toolbar>`;
    return html`
      <div class="affine-edgeless-selected-rect" style=${styleMap(style)}>
        ${resizeHandles} ${connectorHandles}
      </div>
      ${componentToolbar}
    `;
  }
};
EdgelessSelectedRect.styles = css`
    :host {
      display: block;
      user-select: none;
    }

    .affine-edgeless-selected-rect {
      position: absolute;
      border-radius: 0;
      pointer-events: none;
      box-sizing: border-box;
      z-index: 1;
      border: var(--affine-border-width) solid var(--affine-blue);
    }

    .affine-edgeless-selected-rect > [aria-label^='handle'] {
      position: absolute;
      width: 12px;
      height: 12px;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 10;
      border: 2px var(--affine-blue) solid;
      background: white;
      pointer-events: auto;
      user-select: none;
      outline: none;

      /**
       * Fix: pointerEvent stops firing after a short time.
       * When a gesture is started, the browser intersects the touch-action values of the touched element and its ancestors,
       * up to the one that implements the gesture (in other words, the first containing scrolling element)
       * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
       */
      touchaction: none;
    }

    :host([disabled='true'])
      .affine-edgeless-selected-rect
      > [aria-label^='handle'] {
      pointer-events: none;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-top-left'] {
      cursor: nwse-resize;
      left: -6px;
      top: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-top-right'] {
      cursor: nesw-resize;
      top: -6px;
      right: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-bottom-right'] {
      cursor: nwse-resize;
      right: -6px;
      bottom: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-bottom-left'] {
      cursor: nesw-resize;
      bottom: -6px;
      left: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left'],
    .affine-edgeless-selected-rect > [aria-label='handle-right'] {
      cursor: ew-resize;
      top: 0;
      bottom: 0;
      height: 100%;
      width: 6px;
      border: 0;
      background: transparent;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left'] {
      left: -3.5px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-right'] {
      right: -3.5px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left']:after,
    .affine-edgeless-selected-rect > [aria-label='handle-right']:after {
      position: absolute;
      width: 12px;
      height: 12px;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 10;
      border: 2px var(--affine-blue) solid;
      content: '';
      top: calc(50% - 6px);
      background: white;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left']:after {
      left: -3px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-right']:after {
      right: -3px;
    }

    edgeless-component-toolbar {
      /* greater than handle */
      z-index: 11;
    }
  `;
__decorate35([
  property({ type: Page })
], EdgelessSelectedRect.prototype, "page", void 0);
__decorate35([
  property({ type: SurfaceManager })
], EdgelessSelectedRect.prototype, "surface", void 0);
__decorate35([
  property({ type: Object })
], EdgelessSelectedRect.prototype, "state", void 0);
__decorate35([
  property()
], EdgelessSelectedRect.prototype, "slots", void 0);
__decorate35([
  query(".affine-edgeless-selected-rect")
], EdgelessSelectedRect.prototype, "_selectedRect", void 0);
__decorate35([
  query("edgeless-component-toolbar")
], EdgelessSelectedRect.prototype, "_componentToolbar", void 0);
EdgelessSelectedRect = __decorate35([
  customElement("edgeless-selected-rect")
], EdgelessSelectedRect);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/shape-tool/shape-tool-button.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessShapeToolButton = class EdgelessShapeToolButton2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._popperShow = false;
    this._shapeMenuPopper = null;
  }
  _toggleShapeMenu() {
    var _a3;
    (_a3 = this._shapeMenuPopper) == null ? void 0 : _a3.toggle();
  }
  firstUpdated(changedProperties) {
    const _disposables = this._disposables;
    this._shapeMenuPopper = createButtonPopper(this, this._shapeMenu, ({ display }) => {
      this._popperShow = display === "show";
    });
    _disposables.add(this._shapeMenuPopper);
    _disposables.add(this._shapeMenu.slots.select.on((shape) => {
      this.setMouseMode({
        type: "shape",
        shape,
        fillColor: DEFAULT_SHAPE_FILL_COLOR,
        strokeColor: DEFAULT_SHAPE_STROKE_COLOR
      });
    }));
    super.firstUpdated(changedProperties);
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this._disposables) == null ? void 0 : _a3.dispose();
    super.disconnectedCallback();
  }
  render() {
    var _a3;
    const type = (_a3 = this.mouseMode) == null ? void 0 : _a3.type;
    const selectedShape = type === "shape" ? this.mouseMode.shape : void 0;
    return html`
      <edgeless-tool-icon-button
        .tooltip=${this._popperShow ? "" : getTooltipWithShortcut("Shape", "S")}
        .active=${type === "shape"}
        @click=${() => {
      this.setMouseMode({
        type: "shape",
        shape: "rect",
        fillColor: DEFAULT_SHAPE_FILL_COLOR,
        strokeColor: DEFAULT_SHAPE_STROKE_COLOR
      });
      this._toggleShapeMenu();
    }}
      >
        ${ShapeIcon}
      </edgeless-tool-icon-button>
      <edgeless-shape-menu .selectedShape=${selectedShape}>
      </edgeless-shape-menu>
    `;
  }
};
EdgelessShapeToolButton.styles = css`
    :host {
      display: flex;
    }

    edgeless-shape-menu {
      display: none;
    }

    edgeless-shape-menu[data-show] {
      display: block;
    }
  `;
__decorate36([
  property()
], EdgelessShapeToolButton.prototype, "mouseMode", void 0);
__decorate36([
  property()
], EdgelessShapeToolButton.prototype, "edgeless", void 0);
__decorate36([
  property()
], EdgelessShapeToolButton.prototype, "setMouseMode", void 0);
__decorate36([
  state()
], EdgelessShapeToolButton.prototype, "_popperShow", void 0);
__decorate36([
  query("edgeless-shape-menu")
], EdgelessShapeToolButton.prototype, "_shapeMenu", void 0);
EdgelessShapeToolButton = __decorate36([
  customElement("edgeless-shape-tool-button")
], EdgelessShapeToolButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/brush-tool/brush-menu.js
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function BrushSizeButtonGroup(mouseMode, setBrushWidth) {
  if (mouseMode.type !== "brush")
    return nothing;
  const { lineWidth } = mouseMode;
  return html`
    <div class="brush-size-button-group has-tool-tip">
      <!-- This tooltip is for the last button(Thick) -->
      <tool-tip inert role="tooltip" tip-position="top" arrow>Thick</tool-tip>

      <div
        class="brush-size-button has-tool-tip"
        ?active=${lineWidth === BrushSize.Thin}
        @click=${() => setBrushWidth(BrushSize.Thin)}
      >
        <div class="thin"></div>
        <tool-tip inert role="tooltip" tip-position="top" arrow>
          Thin
        </tool-tip>
      </div>

      <div
        class="brush-size-button"
        ?active=${lineWidth === BrushSize.Thick}
        @click=${() => setBrushWidth(BrushSize.Thick)}
      >
        <div class="thick"></div>
      </div>
    </div>
  `;
}
var EdgelessBrushMenu = class EdgelessBrushMenu2 extends LitElement {
  constructor() {
    super(...arguments);
    this._setBrushColor = (color) => {
      if (this.mouseMode.type !== "brush")
        return;
      const { lineWidth } = this.mouseMode;
      this.edgeless.slots.mouseModeUpdated.emit({
        type: "brush",
        color,
        lineWidth
      });
    };
    this._setBrushWidth = (lineWidth) => {
      if (this.mouseMode.type !== "brush")
        return;
      const { color } = this.mouseMode;
      this.edgeless.slots.mouseModeUpdated.emit({
        type: "brush",
        color,
        lineWidth
      });
    };
  }
  render() {
    if (this.mouseMode.type !== "brush")
      return nothing;
    const { color } = this.mouseMode;
    const brushSizeButtonGroup = BrushSizeButtonGroup(this.mouseMode, this._setBrushWidth);
    return html`
      <div class="container">
        ${brushSizeButtonGroup}
        <menu-divider .vertical=${true}></menu-divider>
        <edgeless-color-panel
          .value=${color}
          @select=${(e) => this._setBrushColor(e.detail)}
        ></edgeless-color-panel>
      </div>
    `;
  }
};
EdgelessBrushMenu.styles = css`
    :host {
      width: 260px;
      z-index: 1;
    }
    .container {
      display: flex;
      padding: 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    .brush-size-button-group {
      display: flex;
      flex-direction: column;
    }

    .brush-size-button {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 32px;
      height: 32px;
      box-sizing: border-box;
      border-radius: 4px;
      cursor: pointer;
    }

    .brush-size-button[active],
    .brush-size-button:hover {
      background-color: var(--affine-hover-color);
    }

    .brush-size-button div {
      border-radius: 50%;
      background-color: var(--affine-icon-color);
    }

    .brush-size-button .thin {
      width: 4px;
      height: 4px;
    }

    .brush-size-button .thick {
      width: 10px;
      height: 10px;
    }

    menu-divider {
      height: 62px;
    }

    ${tooltipStyle}
  `;
__decorate37([
  property()
], EdgelessBrushMenu.prototype, "mouseMode", void 0);
__decorate37([
  property()
], EdgelessBrushMenu.prototype, "edgeless", void 0);
EdgelessBrushMenu = __decorate37([
  customElement("edgeless-brush-menu")
], EdgelessBrushMenu);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/brush-tool/brush-tool-button.js
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function createBrushMenuPopper(reference2) {
  const brushMenu = document.createElement("edgeless-brush-menu");
  assertExists(reference2.shadowRoot);
  reference2.shadowRoot.appendChild(brushMenu);
  const popper2 = createPopper3(reference2, brushMenu, {
    placement: "top",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 12]
        }
      }
    ]
  });
  return {
    element: brushMenu,
    dispose: () => {
      brushMenu.remove();
      popper2.destroy();
    }
  };
}
var EdgelessBrushToolButton = class EdgelessBrushToolButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this._popperShow = false;
    this._brushMenu = null;
  }
  _toggleBrushMenu() {
    if (this._brushMenu) {
      this._brushMenu.dispose();
      this._brushMenu = null;
      this._popperShow = false;
    } else {
      this._brushMenu = createBrushMenuPopper(this);
      this._brushMenu.element.mouseMode = this.mouseMode;
      this._brushMenu.element.edgeless = this.edgeless;
      this._popperShow = true;
    }
  }
  updated(changedProperties) {
    var _a3;
    if (changedProperties.has("mouseMode")) {
      if (this.mouseMode.type !== "brush") {
        (_a3 = this._brushMenu) == null ? void 0 : _a3.dispose();
        this._brushMenu = null;
      }
      if (this._brushMenu) {
        this._brushMenu.element.mouseMode = this.mouseMode;
        this._brushMenu.element.edgeless = this.edgeless;
      }
    }
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this._brushMenu) == null ? void 0 : _a3.dispose();
    this._brushMenu = null;
    super.disconnectedCallback();
  }
  render() {
    var _a3;
    const type = (_a3 = this.mouseMode) == null ? void 0 : _a3.type;
    return html`
      <edgeless-tool-icon-button
        .tooltip=${this._popperShow ? "" : getTooltipWithShortcut("Pen", "P")}
        .active=${type === "brush"}
        @click=${() => {
      this.setMouseMode({
        type: "brush",
        lineWidth: 4,
        color: DEFAULT_SELECTED_COLOR
      });
      this._toggleBrushMenu();
    }}
      >
        ${PenIcon}
      </edgeless-tool-icon-button>
    `;
  }
};
EdgelessBrushToolButton.styles = css`
    :host {
      display: flex;
    }
  `;
__decorate38([
  property()
], EdgelessBrushToolButton.prototype, "mouseMode", void 0);
__decorate38([
  property()
], EdgelessBrushToolButton.prototype, "edgeless", void 0);
__decorate38([
  property()
], EdgelessBrushToolButton.prototype, "setMouseMode", void 0);
__decorate38([
  state()
], EdgelessBrushToolButton.prototype, "_popperShow", void 0);
EdgelessBrushToolButton = __decorate38([
  customElement("edgeless-brush-tool-button")
], EdgelessBrushToolButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/connector-tool/connector-menu.js
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function ConnectorModeButtonGroup(mouseMode, setConnectorMode) {
  if (mouseMode.type !== "connector")
    return nothing;
  const { mode } = mouseMode;
  const straightLineTooltip = getTooltipWithShortcut("Straight line", "L");
  const orthogonalTooltip = getTooltipWithShortcut("Connector", "X");
  return html`
    <div class="connector-mode-button-group has-tool-tip">
      <!-- This tooltip is for the last button(Thick) -->
      <tool-tip inert role="tooltip" tip-position="top" arrow>
        ${orthogonalTooltip}
      </tool-tip>

      <div
        class="connector-mode-button has-tool-tip"
        ?active=${mode === ConnectorMode.Straight}
        @click=${() => setConnectorMode(ConnectorMode.Straight)}
      >
        ${ConnectorLIcon}
        <tool-tip inert role="tooltip" tip-position="top" arrow>
          ${straightLineTooltip}
        </tool-tip>
      </div>

      <div
        class="connector-mode-button"
        ?active=${mode === ConnectorMode.Orthogonal}
        @click=${() => setConnectorMode(ConnectorMode.Orthogonal)}
      >
        ${ConnectorXIcon}
      </div>
    </div>
  `;
}
var EdgelessConnectorMenu = class EdgelessConnectorMenu2 extends LitElement {
  constructor() {
    super(...arguments);
    this._setConnectorColor = (color) => {
      if (this.mouseMode.type !== "connector")
        return;
      const { mode } = this.mouseMode;
      this.edgeless.slots.mouseModeUpdated.emit({
        type: "connector",
        color,
        mode
      });
    };
    this._setConnectorMode = (mode) => {
      if (this.mouseMode.type !== "connector")
        return;
      const { color } = this.mouseMode;
      this.edgeless.slots.mouseModeUpdated.emit({
        type: "connector",
        color,
        mode
      });
    };
  }
  render() {
    if (this.mouseMode.type !== "connector")
      return nothing;
    const { color } = this.mouseMode;
    const brushSizeButtonGroup = ConnectorModeButtonGroup(this.mouseMode, this._setConnectorMode);
    return html`
      <div class="container">
        ${brushSizeButtonGroup}
        <menu-divider .vertical=${true}></menu-divider>
        <edgeless-color-panel
          .value=${color}
          @select=${(e) => this._setConnectorColor(e.detail)}
        ></edgeless-color-panel>
      </div>
    `;
  }
};
EdgelessConnectorMenu.styles = css`
    :host {
      width: 260px;
      z-index: 1;
    }
    .container {
      display: flex;
      padding: 4px;
      justify-content: center;
      align-items: center;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    .connector-mode-button-group {
      display: flex;
      flex-direction: column;
    }

    .connector-mode-button {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 32px;
      height: 32px;
      box-sizing: border-box;
      border-radius: 4px;
      cursor: pointer;
    }

    .connector-mode-button[active],
    .connector-mode-button:hover {
      background-color: var(--affine-hover-color);
    }

    .connector-mode-button div {
      border-radius: 50%;
      background-color: var(--affine-icon-color);
    }

    menu-divider {
      height: 62px;
    }

    ${tooltipStyle}
  `;
__decorate39([
  property()
], EdgelessConnectorMenu.prototype, "mouseMode", void 0);
__decorate39([
  property()
], EdgelessConnectorMenu.prototype, "edgeless", void 0);
EdgelessConnectorMenu = __decorate39([
  customElement("edgeless-connector-menu")
], EdgelessConnectorMenu);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/connector-tool/connector-tool-button.js
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function createConnectorMenuPopper(reference2) {
  const menu = document.createElement("edgeless-connector-menu");
  assertExists(reference2.shadowRoot);
  reference2.shadowRoot.appendChild(menu);
  const popper2 = createPopper3(reference2, menu, {
    placement: "top",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 12]
        }
      }
    ]
  });
  return {
    element: menu,
    dispose: () => {
      menu.remove();
      popper2.destroy();
    }
  };
}
var EdgelessConnectorToolButton = class EdgelessConnectorToolButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this._menu = null;
  }
  _toggleMenu() {
    if (this._menu) {
      this._menu.dispose();
      this._menu = null;
    } else {
      this._menu = createConnectorMenuPopper(this);
      this._menu.element.mouseMode = this.mouseMode;
      this._menu.element.edgeless = this.edgeless;
    }
  }
  updated(changedProperties) {
    var _a3;
    if (changedProperties.has("mouseMode")) {
      if (this.mouseMode.type !== "connector") {
        (_a3 = this._menu) == null ? void 0 : _a3.dispose();
        this._menu = null;
      }
      if (this._menu) {
        this._menu.element.mouseMode = this.mouseMode;
        this._menu.element.edgeless = this.edgeless;
      }
    }
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this._menu) == null ? void 0 : _a3.dispose();
    this._menu = null;
    super.disconnectedCallback();
  }
  render() {
    var _a3;
    const type = (_a3 = this.mouseMode) == null ? void 0 : _a3.type;
    return html`
      <edgeless-tool-icon-button
        .tooltip=${"Connector"}
        .active=${type === "connector"}
        @click=${() => {
      this.setMouseMode({
        type: "connector",
        mode: ConnectorMode.Orthogonal,
        color: DEFAULT_SELECTED_COLOR
      });
      this._toggleMenu();
    }}
      >
        ${ConnectorIcon}
      </edgeless-tool-icon-button>
    `;
  }
};
EdgelessConnectorToolButton.styles = css`
    :host {
      display: flex;
    }
  `;
__decorate40([
  property()
], EdgelessConnectorToolButton.prototype, "mouseMode", void 0);
__decorate40([
  property()
], EdgelessConnectorToolButton.prototype, "edgeless", void 0);
__decorate40([
  property()
], EdgelessConnectorToolButton.prototype, "setMouseMode", void 0);
EdgelessConnectorToolButton = __decorate40([
  customElement("edgeless-connector-tool-button")
], EdgelessConnectorToolButton);

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/toolbar/edgeless-toolbar.js
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FIT_TO_SCREEN_PADDING = 200;
var EdgelessToolbar = class EdgelessToolbar2 extends WithDisposable(LitElement) {
  constructor(edgeless) {
    super();
    this._imageLoading = false;
    this._rafId = null;
    this.setMouseMode = (mouseMode) => {
      this.edgeless.selection.setMouseMode(mouseMode);
    };
    this.edgeless = edgeless;
  }
  get mouseMode() {
    return this.edgeless.mouseMode;
  }
  get zoom() {
    return this.edgeless.surface.viewport.zoom;
  }
  _setCenter(x, y) {
    this.edgeless.surface.viewport.setCenter(x, y);
    this.edgeless.slots.viewportUpdated.emit();
  }
  _setZoom(zoom, focusPoint) {
    this.edgeless.surface.viewport.setZoom(zoom, focusPoint);
    this.edgeless.slots.viewportUpdated.emit();
  }
  _setZoomByStep(step) {
    this._smoothZoom(clamp(this.zoom + step, ZOOM_MIN, ZOOM_MAX));
  }
  _smoothZoom(zoom, focusPoint) {
    const delta = zoom - this.zoom;
    const innerSmoothZoom = () => {
      if (this._rafId)
        cancelAnimationFrame(this._rafId);
      this._rafId = requestAnimationFrame(() => {
        const sign = delta > 0 ? 1 : -1;
        const total = 10;
        const step = delta / total;
        const nextZoom = this._cutoff(this.zoom + step, zoom, sign);
        this._setZoom(nextZoom, focusPoint);
        if (nextZoom != zoom)
          innerSmoothZoom();
      });
    };
    innerSmoothZoom();
  }
  _cutoff(value, ref, sign) {
    if (sign > 0 && value > ref)
      return ref;
    if (sign < 0 && value < ref)
      return ref;
    return value;
  }
  _zoomToFit() {
    const bounds = [];
    const frame = this.edgeless.frames[0];
    if (frame) {
      const frameXYWH = deserializeXYWH(frame.xywh);
      const frameBound = new Bound(...frameXYWH);
      bounds.push(frameBound);
    }
    const surfaceElementsBound = this.edgeless.surface.getElementsBound();
    if (surfaceElementsBound) {
      bounds.push(surfaceElementsBound);
    }
    const { viewport: viewport2 } = this.edgeless.surface;
    let { centerX, centerY, zoom } = viewport2;
    if (bounds.length) {
      const { width, height } = viewport2;
      const bound = getCommonBound(bounds);
      assertExists(bound);
      zoom = Math.min((width - FIT_TO_SCREEN_PADDING) / bound.w, (height - FIT_TO_SCREEN_PADDING) / bound.h);
      centerX = bound.x + bound.w / 2;
      centerY = bound.y + bound.h / 2;
    } else {
      zoom = 1;
    }
    const preZoom = this.zoom;
    const newZoom = zoom;
    const cofficient = preZoom / newZoom;
    if (cofficient === 1) {
      this._smoothTranslate(centerX, centerY);
    } else {
      const center = viewport2.center;
      const newCenter = new Point(centerX, centerY);
      const focusPoint = newCenter.subtract(center.scale(cofficient)).scale(1 / (1 - cofficient));
      this._smoothZoom(zoom, focusPoint);
    }
  }
  _smoothTranslate(x, y) {
    const { viewport: viewport2 } = this.edgeless.surface;
    const delta = { x: x - viewport2.centerX, y: y - viewport2.centerY };
    const innerSmoothTranslate = () => {
      if (this._rafId)
        cancelAnimationFrame(this._rafId);
      this._rafId = requestAnimationFrame(() => {
        const rate = 10;
        const step = { x: delta.x / rate, y: delta.y / rate };
        const nextCenter = {
          x: viewport2.centerX + step.x,
          y: viewport2.centerY + step.y
        };
        const signX = delta.x > 0 ? 1 : -1;
        const signY = delta.y > 0 ? 1 : -1;
        nextCenter.x = this._cutoff(nextCenter.x, x, signX);
        nextCenter.y = this._cutoff(nextCenter.y, y, signY);
        this._setCenter(nextCenter.x, nextCenter.y);
        if (nextCenter.x != x || nextCenter.y != y)
          innerSmoothTranslate();
      });
    };
    innerSmoothTranslate();
  }
  async _addImage() {
    this._imageLoading = true;
    const options2 = {
      width: 0,
      height: 0,
      offsetX: 0,
      offsetY: 0
    };
    const models = await uploadImageFromLocal(this.edgeless.page, (realSize) => Object.assign(options2, realSize));
    const { left: left2, width, top: top2, height } = this.edgeless.pageBlockContainer.getBoundingClientRect();
    if (options2.width && options2.height) {
      const s = width / height;
      const sh = height > 100 ? height - 100 : height;
      const p = options2.width / options2.height;
      if (s >= 1) {
        options2.height = options2.height > sh ? sh : Math.min(options2.height, sh);
        options2.width = p * options2.height;
      } else {
        const sw = sh * s;
        options2.width = options2.width > sw ? sw : Math.min(options2.width, sw);
        options2.height = options2.width / p;
      }
    }
    const { zoom } = this.edgeless.surface.viewport;
    const centerX = left2 + width / 2;
    const centerY = top2 + height / 2;
    let x = 0;
    let y = 0;
    if (zoom > 1) {
      x = centerX - options2.width / 2;
      y = centerY - options2.height / 2;
      options2.width /= zoom;
      options2.height /= zoom;
    } else {
      x = centerX - options2.width * zoom / 2;
      y = centerY - options2.height * zoom / 2;
    }
    const { frameId } = this.edgeless.addNewFrame(models, new Point(x, y), options2);
    const frame = this.edgeless.frames.find((frame2) => frame2.id === frameId);
    assertExists(frame);
    this.edgeless.selection.switchToDefaultMode({
      selected: [frame],
      active: false
    });
    this._imageLoading = false;
  }
  setZoomByAction(action) {
    switch (action) {
      case "fit":
        this._zoomToFit();
        break;
      case "reset":
        this._smoothZoom(1);
        break;
      case "in":
      case "out":
        this._setZoomByStep(ZOOM_STEP * (action === "in" ? 1 : -1));
    }
  }
  firstUpdated() {
    const { _disposables, edgeless: { slots } } = this;
    _disposables.add(slots.mouseModeUpdated.on(() => this.requestUpdate()));
    _disposables.add(slots.viewportUpdated.on(() => this.requestUpdate()));
  }
  render() {
    const { type } = this.mouseMode;
    const formattedZoom = `${Math.round(this.zoom * 100)}%`;
    return html`
      <div
        class="edgeless-toolbar-container"
        @dblclick=${stopPropagation}
        @mousedown=${stopPropagation}
        @mouseup=${stopPropagation}
        @pointerdown=${stopPropagation}
      >
        <edgeless-tool-icon-button
          .tooltip=${getTooltipWithShortcut("Select", "V")}
          .active=${type === "default"}
          @click=${() => this.setMouseMode({ type: "default" })}
        >
          ${SelectIcon}
        </edgeless-tool-icon-button>
        <edgeless-tool-icon-button
          .tooltip=${getTooltipWithShortcut("Text", "T")}
          .active=${type === "text"}
          @click=${() => this.setMouseMode({ type: "text" })}
        >
          ${TextIconLarge}
        </edgeless-tool-icon-button>
        <edgeless-shape-tool-button
          .mouseMode=${this.mouseMode}
          .edgeless=${this.edgeless}
          .setMouseMode=${this.setMouseMode}
        ></edgeless-shape-tool-button>
        <edgeless-tool-icon-button
          .disabled=${this._imageLoading}
          .tooltip=${"Image"}
          @click=${() => this._addImage()}
        >
          ${ImageIcon}
        </edgeless-tool-icon-button>
        <edgeless-connector-tool-button
          .mouseMode=${this.mouseMode}
          .edgeless=${this.edgeless}
          .setMouseMode=${this.setMouseMode}
        ></edgeless-connector-tool-button>
        <edgeless-brush-tool-button
          .mouseMode=${this.mouseMode}
          .edgeless=${this.edgeless}
          .setMouseMode=${this.setMouseMode}
        ></edgeless-brush-tool-button>
        <edgeless-tool-icon-button
          .tooltip=${getTooltipWithShortcut("Hand", "H")}
          .active=${type === "pan"}
          @click=${() => this.setMouseMode({ type: "pan", panning: false })}
        >
          ${HandIcon}
        </edgeless-tool-icon-button>
        <edgeless-tool-icon-button
          .tooltip=${getTooltipWithShortcut("Note", "N")}
          .active=${type === "note"}
          @click=${() => this.setMouseMode({
      type: "note",
      background: FRAME_BACKGROUND_COLORS[0]
    })}
        >
          ${NoteIcon}
        </edgeless-tool-icon-button>
        <div class="divider"></div>
        <edgeless-tool-icon-button
          .tooltip=${"Fit to screen"}
          @click=${() => this._zoomToFit()}
        >
          ${ViewBarIcon}
        </edgeless-tool-icon-button>
        <edgeless-tool-icon-button
          .tooltip=${"Zoom out"}
          @click=${() => this._setZoomByStep(-ZOOM_STEP)}
        >
          ${MinusIcon}
        </edgeless-tool-icon-button>
        <span class="zoom-percent" @click=${() => this._smoothZoom(1)}>
          ${formattedZoom}
        </span>
        <edgeless-tool-icon-button
          .tooltip=${"Zoom in"}
          @click=${() => this._setZoomByStep(ZOOM_STEP)}
        >
          ${PlusIcon}
        </edgeless-tool-icon-button>
      </div>
    `;
  }
};
EdgelessToolbar.styles = css`
    :host {
      position: absolute;
      z-index: 2;
      bottom: 28px;
      left: calc(50%);
      display: flex;
      justify-content: center;
      transform: translateX(-50%);
      user-select: none;
    }

    .edgeless-toolbar-container {
      display: flex;
      align-items: center;
      height: 48px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
      fill: currentcolor;
    }

    .edgeless-toolbar-container[level='second'] {
      position: absolute;
      bottom: 8px;
      transform: translateY(-100%);
    }

    .edgeless-toolbar-container[hidden] {
      display: none;
    }

    .divider {
      width: 1px;
      height: 24px;
      margin: 0 7px;
      background-color: var(--affine-border-color);
    }

    .zoom-percent {
      display: block;
      box-sizing: border-box;
      width: 48px;
      height: 32px;
      line-height: 22px;
      padding: 5px;
      border-radius: 5px;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      cursor: pointer;
      color: var(--affine-icon-color);
    }

    .zoom-percent:hover {
      color: var(--affine-primary-color);
      background-color: var(--affine-hover-color);
    }
  `;
EdgelessToolbar = __decorate41([
  customElement("edgeless-toolbar")
], EdgelessToolbar);

// node_modules/@blocksuite/blocks/dist/__internal__/theme/utils.js
function getClosestEditorContainer(element) {
  const container = element.closest("editor-container");
  assertExists(container);
  return container;
}
function listenToThemeChange(currentELement, callback) {
  const container = getClosestEditorContainer(currentELement);
  return container.themeObserver.on(callback);
}
function getThemePropertyValue(currentELement, name) {
  var _a3;
  const container = getClosestEditorContainer(currentELement);
  return (_a3 = container.themeObserver.cssVariables) == null ? void 0 : _a3[name];
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/block-children-container.js
function EdgelessMask() {
  const style = {
    position: "absolute",
    top: "0",
    left: "0",
    bottom: "0",
    right: "0",
    zIndex: "1"
  };
  return html`
    <div class="affine-edgeless-mask" style=${styleMap(style)}></div>
  `;
}
function EdgelessBlockChild(index, model, active, renderer) {
  const { xywh, background } = model;
  const [modelX, modelY, modelW, modelH] = deserializeXYWH(xywh);
  const style = {
    position: "absolute",
    transform: `translate(${modelX}px, ${modelY}px)`,
    transformOrigin: "0 0",
    width: modelW + "px",
    height: modelH + "px",
    padding: `${EDGELESS_BLOCK_CHILD_PADDING}px`,
    background: `var(${background || FRAME_BACKGROUND_COLORS[0]})`,
    pointerEvents: "all",
    zIndex: `${index}`,
    boxSizing: "border-box",
    borderRadius: "8px",
    border: "2px solid var(--affine-white-10)",
    boxShadow: "var(--affine-shadow-3)"
  };
  const mask = active ? nothing : EdgelessMask();
  return html`
    <div class="affine-edgeless-block-child" style=${styleMap(style)}>
      ${renderer(model)} ${mask}
    </div>
  `;
}
function EdgelessBlockChildrenContainer(frames, active, renderer) {
  return html`
    ${repeat(frames, (child) => child.id, (child, index) => EdgelessBlockChild(index, child, active, renderer))}
  `;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/dragging-area.js
function EdgelessDraggingArea(rect) {
  if (rect === null)
    return html``;
  const style = {
    left: rect.left + "px",
    top: rect.top + "px",
    width: rect.width + "px",
    height: rect.height + "px"
  };
  return html`
    <style>
      .affine-edgeless-dragging-area {
        position: absolute;
        background: var(--affine-hover-color);
        z-index: 1;
        pointer-events: none;
      }
    </style>
    <div class="affine-edgeless-dragging-area" style=${styleMap(style)}></div>
  `;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/components/hover-rect.js
function EdgelessHoverRect(hoverState, zoom) {
  if (!hoverState)
    return null;
  const rect = hoverState.rect;
  const style = getCommonRectStyle(rect);
  return html`
    <div class="affine-edgeless-hover-rect" style=${styleMap(style)}></div>
  `;
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/index.js
var MouseModeController = class {
  constructor(edgeless) {
    this._draggingArea = null;
    this.enableHover = false;
    this._edgeless = edgeless;
  }
  get draggingArea() {
    return this._draggingArea;
  }
  get _surface() {
    return this._edgeless.surface;
  }
  get _page() {
    return this._edgeless.page;
  }
  get _blocks() {
    return this._edgeless.sortedFrames;
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/default-mode.js
var DefaultModeDragType;
(function(DefaultModeDragType2) {
  DefaultModeDragType2["ContentMoving"] = "content-moving";
  DefaultModeDragType2["Selecting"] = "selecting";
  DefaultModeDragType2["NativeEditing"] = "native-editing";
  DefaultModeDragType2["None"] = "none";
  DefaultModeDragType2["PreviewDragging"] = "preview-dragging";
  DefaultModeDragType2["AltCloning"] = "alt-cloning";
})(DefaultModeDragType || (DefaultModeDragType = {}));
var DefaultModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "default"
    };
    this.enableHover = true;
    this.dragType = DefaultModeDragType.None;
    this._startRange = null;
    this._dragStartPos = { x: 0, y: 0 };
    this._dragLastPos = { x: 0, y: 0 };
    this._lock = false;
    this._isDoubleClickedOnMask = false;
  }
  get draggingArea() {
    if (this.dragType === DefaultModeDragType.Selecting) {
      return {
        start: new DOMPoint(this._dragStartPos.x, this._dragStartPos.y),
        end: new DOMPoint(this._dragLastPos.x, this._dragLastPos.y)
      };
    }
    return null;
  }
  get selectedBlocks() {
    return this._edgeless.selection.selectedBlocks;
  }
  get state() {
    return this._edgeless.selection.state;
  }
  get isActive() {
    return this._edgeless.selection.state.active;
  }
  _pick(x, y) {
    const { surface } = this._edgeless;
    const [modelX, modelY] = surface.viewport.toModelCoord(x, y);
    const selectedShape = surface.pickTop(modelX, modelY);
    return selectedShape ? selectedShape : pickTopBlock(this._blocks, modelX, modelY);
  }
  _setNoneSelectionState() {
    this._edgeless.slots.selectionUpdated.emit({ selected: [], active: false });
    resetNativeSelection(null);
  }
  _setSelectionState(selected, active) {
    this._edgeless.slots.selectionUpdated.emit({
      selected,
      active
    });
  }
  _handleClickOnSelected(element, e) {
    const { selected, active } = this.state;
    this._edgeless.clearSelectedBlocks();
    if (active && selected.length === 1 && selected[0] === element) {
      handleNativeRangeAtPoint(e.raw.clientX, e.raw.clientY);
      return;
    }
    if (!e.keys.shift && selected.length === 1 && isTopLevelBlock(element)) {
      if (selected[0] === element && !active || active && selected[0] !== element) {
        this._setSelectionState([element], true);
        this._edgeless.slots.selectedBlocksUpdated.emit([]);
        return;
      }
    }
    if (e.keys.shift) {
      const selections = [...selected];
      if (selected.includes(element)) {
        this._setSelectionState(selections.filter((item) => item !== element), false);
      } else {
        this._setSelectionState([...selections, element], false);
      }
    } else {
      this._setSelectionState([element], false);
    }
  }
  _handleDragMoveEffect(element) {
    handleElementChangedEffectForConnector(element, this.state.selected, this._edgeless.surface, this._page);
  }
  _handleSurfaceDragMove(selected, e) {
    if (!this._lock) {
      this._lock = true;
      this._page.captureSync();
    }
    const { surface } = this._edgeless;
    const { zoom } = surface.viewport;
    const deltaX = this._dragLastPos.x - e.x;
    const deltaY = this._dragLastPos.y - e.y;
    const boundX = selected.x - deltaX / zoom;
    const boundY = selected.y - deltaY / zoom;
    const boundW = selected.w;
    const boundH = selected.h;
    if (selected.type !== "connector" || selected instanceof ConnectorElement && isConnectorAndBindingsAllSelected(selected, this.state.selected)) {
      surface.setElementBound(selected.id, {
        x: boundX,
        y: boundY,
        w: boundW,
        h: boundH
      });
    }
    this._handleDragMoveEffect(selected);
  }
  _handleBlockDragMove(block2, e) {
    const [modelX, modelY, modelW, modelH] = JSON.parse(block2.xywh);
    const { zoom } = this._edgeless.surface.viewport;
    const xywh = JSON.stringify([
      modelX + e.delta.x / zoom,
      modelY + e.delta.y / zoom,
      modelW,
      modelH
    ]);
    this._page.updateBlock(block2, { xywh });
    this._handleDragMoveEffect(block2);
    if (this.selectedBlocks.length) {
      this._edgeless.slots.selectedBlocksUpdated.emit(this.selectedBlocks);
    }
  }
  _isInSelectedRect(viewX, viewY) {
    const { selected } = this.state;
    if (!selected.length)
      return false;
    const commonBound = getCommonBound(selected.map((element) => {
      if (isTopLevelBlock(element)) {
        const [x, y, w, h] = deserializeXYWH(getXYWH(element));
        return {
          x,
          y,
          w,
          h
        };
      }
      return element;
    }));
    const [modelX, modelY] = this._surface.toModelCoord(viewX, viewY);
    if (commonBound && isPointIn(commonBound, modelX, modelY)) {
      return true;
    }
    return false;
  }
  _forceUpdateSelection() {
    this._edgeless.slots.selectionUpdated.emit({
      ...this.state
    });
  }
  _tryDeleteEmptyBlocks() {
    const emptyBlocks = this._blocks.filter((b) => isEmpty(b));
    if (emptyBlocks.length === this._blocks.length) {
      emptyBlocks.shift();
    }
    if (emptyBlocks.length) {
      this._page.captureSync();
      emptyBlocks.forEach((b) => this._page.deleteBlock(b));
    }
  }
  /** Update drag handle by closest block elements */
  _updateDragHandle(e) {
    var _a3;
    const block2 = this.state.selected[0];
    if (!block2 || !isTopLevelBlock(block2))
      return;
    const frameBlockElement = getBlockElementByModel(block2);
    assertExists(frameBlockElement);
    const { raw: { clientX, clientY } } = e;
    const point = new Point(clientX, clientY);
    const element = getClosestBlockElementByPoint(point, {
      container: frameBlockElement,
      rect: Rect.fromDOM(frameBlockElement)
    }, this._edgeless.surface.viewport.zoom);
    let hoverEditingState = null;
    if (element) {
      hoverEditingState = {
        element,
        model: getModelByBlockElement(element),
        rect: getRectByBlockElement(element)
      };
      (_a3 = this._edgeless.components.dragHandle) == null ? void 0 : _a3.onContainerMouseMove(e, hoverEditingState);
    }
  }
  onContainerClick(e) {
    this._tryDeleteEmptyBlocks();
    const selected = this._pick(e.x, e.y);
    if (selected) {
      this._handleClickOnSelected(selected, e);
    } else {
      this._setNoneSelectionState();
    }
    this._isDoubleClickedOnMask = false;
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    const selected = this._pick(e.x, e.y);
    if (!selected) {
      addText(this._edgeless, e);
      return;
    } else {
      if (selected instanceof TextElement) {
        mountTextEditor(selected, this._edgeless);
        return;
      }
    }
    if (e.raw.target && e.raw.target instanceof HTMLElement && e.raw.target.classList.contains("affine-edgeless-mask")) {
      this.onContainerClick(e);
      this._isDoubleClickedOnMask = true;
      return;
    }
    showFormatQuickBarByClicks("double", e, this._page, this._edgeless);
  }
  onContainerTripleClick(e) {
    if (this._isDoubleClickedOnMask)
      return;
    showFormatQuickBarByClicks("triple", e, this._page, this._edgeless);
  }
  _determineDragType(e) {
    if (this._isInSelectedRect(e.x, e.y)) {
      return this.state.active ? DefaultModeDragType.NativeEditing : DefaultModeDragType.ContentMoving;
    } else {
      const selected = this._pick(e.x, e.y);
      if (selected) {
        this._setSelectionState([selected], false);
        return DefaultModeDragType.ContentMoving;
      } else {
        return DefaultModeDragType.Selecting;
      }
    }
  }
  async _cloneContent(e) {
    this._lock = true;
    const { surface } = this._edgeless;
    const elements = await Promise.all(this.state.selected.map(async (selected) => {
      return await this._cloneSelected(selected, surface);
    }));
    this._setSelectionState(elements, false);
  }
  async _cloneSelected(selected, surface) {
    var _a3;
    if (isTopLevelBlock(selected)) {
      const frameService = this._edgeless.getService("affine:frame");
      const id = this._page.addBlock("affine:frame", { xywh: selected.xywh }, (_a3 = this._page.root) == null ? void 0 : _a3.id);
      const frame = this._page.getBlockById(id);
      assertExists(frame);
      await frameService.json2Block(frame, frameService.block2Json(selected).children);
      return this._page.getBlockById(id);
    } else {
      const id = surface.addElement(selected.type, selected.serialize());
      return surface.pickById(id);
    }
  }
  async onContainerDragStart(e) {
    let dragType = this._determineDragType(e);
    if (e.keys.alt && dragType === DefaultModeDragType.ContentMoving) {
      dragType = DefaultModeDragType.AltCloning;
      await this._cloneContent(e);
    }
    this.initializeDragState(e, dragType);
  }
  initializeDragState(e, dragType) {
    this.dragType = dragType;
    this._startRange = caretRangeFromPoint(e.x, e.y);
    this._dragStartPos = { x: e.x, y: e.y };
    this._dragLastPos = { x: e.x, y: e.y };
  }
  onContainerDragMove(e) {
    switch (this.dragType) {
      case DefaultModeDragType.Selecting: {
        const startX = this._dragStartPos.x;
        const startY = this._dragStartPos.y;
        const viewX = Math.min(startX, e.x);
        const viewY = Math.min(startY, e.y);
        const [x, y] = this._surface.toModelCoord(viewX, viewY);
        const w = Math.abs(startX - e.x);
        const h = Math.abs(startY - e.y);
        const { zoom } = this._surface.viewport;
        const bound = new Bound(x, y, w / zoom, h / zoom);
        const blocks = pickBlocksByBound(this._blocks, bound);
        const elements = this._surface.pickByBound(bound);
        this._setSelectionState([...blocks, ...elements], false);
        break;
      }
      case DefaultModeDragType.AltCloning:
      case DefaultModeDragType.ContentMoving: {
        this.state.selected.forEach((element) => {
          if (isPhasorElement(element)) {
            this._handleSurfaceDragMove(element, e);
          } else {
            this._handleBlockDragMove(element, e);
          }
        });
        this._forceUpdateSelection();
        break;
      }
      case DefaultModeDragType.NativeEditing: {
        handleNativeRangeDragMove(this._startRange, e);
        break;
      }
    }
    this._dragLastPos = {
      x: e.x,
      y: e.y
    };
  }
  onContainerDragEnd(e) {
    if (this._lock) {
      this._page.captureSync();
      this._lock = false;
    }
    if (this.isActive) {
      const { direction, selectedType } = getNativeSelectionMouseDragInfo(e);
      if (selectedType === "Caret") {
        return;
      }
      showFormatQuickBar({
        page: this._page,
        container: this._edgeless,
        direction,
        anchorEl: {
          getBoundingClientRect: () => {
            return calcCurrentSelectionPosition(direction);
          }
        }
      });
    }
    this.dragType = DefaultModeDragType.None;
    this._dragStartPos = { x: 0, y: 0 };
    this._dragLastPos = { x: 0, y: 0 };
    this._forceUpdateSelection();
  }
  onContainerMouseMove(e) {
    if (this.dragType === DefaultModeDragType.PreviewDragging)
      return;
    this._updateDragHandle(e);
  }
  onContainerMouseOut(_) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/create-drag-handle.js
function createDragHandle2(pageBlock) {
  return new DragHandle({
    // Drag handle should be at the same level with EditorContainer
    container: pageBlock.mouseRoot,
    onDropCallback(point, blockElements2, editingState, type) {
      const blockElementsExcludeSubtrees = getBlockElementsExcludeSubtrees(blockElements2);
      if (!blockElementsExcludeSubtrees.length)
        return;
      const models = blockElementsExcludeSubtrees.map(getModelByBlockElement);
      if (!models.length)
        return;
      const page = pageBlock.page;
      if (editingState && type !== "none") {
        const { model } = editingState;
        if (models.length === 1 && isInSamePath(page, model, models[0]))
          return;
        const focusId = models[0].id;
        const targetFrameBlock = getClosestFrameBlockElementById(model.id, pageBlock);
        assertExists(targetFrameBlock);
        const frameBlock = getClosestFrameBlockElementById(focusId, pageBlock);
        assertExists(frameBlock);
        page.captureSync();
        if (type === "database") {
          page.moveBlocks(models, model);
        } else {
          const parent2 = page.getParent(model);
          assertExists(parent2);
          page.moveBlocks(models, parent2, model, type === "before");
        }
        pageBlock.setSelection(targetFrameBlock.model.id, true, focusId, point);
        return;
      }
      page.captureSync();
      const parent = page.getParent(models[0]);
      assertExists(parent);
      const firstModelIndex = parent.children.findIndex((m) => m.id === models[0].id);
      const lastModelIndex = parent.children.findIndex((m) => m.id === models[models.length - 1].id);
      pageBlock.moveBlocksWithNewFrame(models, point, {
        rect: getRectByBlockElement(blockElementsExcludeSubtrees[0]),
        focus: true,
        frameIndex: firstModelIndex === 0 ? 0 : void 0
      });
      if (firstModelIndex !== 0 && lastModelIndex !== parent.children.length - 1) {
        const nextFirstBlockElement = getBlockElementByModel(parent == null ? void 0 : parent.children[lastModelIndex]);
        assertExists(nextFirstBlockElement);
        const nextFirstBlockRect = getRectByBlockElement(nextFirstBlockElement);
        pageBlock.moveBlocksWithNewFrame(parent == null ? void 0 : parent.children.slice(lastModelIndex), new Point(nextFirstBlockRect.x, nextFirstBlockRect.y), { rect: nextFirstBlockRect });
      }
    },
    setDragType(dragging) {
      const { selection } = pageBlock;
      if (selection.mouseMode.type === "default") {
        const currentController = selection.currentController;
        currentController.dragType = dragging ? DefaultModeDragType.PreviewDragging : DefaultModeDragType.None;
      }
    },
    setSelectedBlock(modelState) {
      const selectedBlocks = [];
      if (modelState) {
        selectedBlocks.push(modelState.element);
      }
      pageBlock.slots.selectedBlocksUpdated.emit(selectedBlocks);
    },
    getSelectedBlocks() {
      return pageBlock.selection.selectedBlocks;
    },
    getClosestBlockElement(point) {
      if (pageBlock.mouseMode.type !== "default")
        return null;
      const hoveringFrame = getHoveringFrame(point);
      if (!hoveringFrame)
        return null;
      return getClosestBlockElementByPoint(point, { container: hoveringFrame, rect: Rect.fromDOM(hoveringFrame) }, pageBlock.surface.viewport.zoom);
    }
  });
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/frame-resize-observer.js
var FrameResizeObserver = class {
  constructor() {
    this._cachedElements = /* @__PURE__ */ new Map();
    this._lastRects = /* @__PURE__ */ new Map();
    this.slots = {
      resize: new Slot()
    };
    this._onResize = (entries) => {
      const resizedFrames = /* @__PURE__ */ new Map();
      entries.forEach((entry) => {
        const blockElement = entry.target.closest(`[${BLOCK_ID_ATTR}]`);
        const id = blockElement == null ? void 0 : blockElement.getAttribute(BLOCK_ID_ATTR);
        if (!id)
          return;
        if (this._lastRects.has(id)) {
          const rect = this._lastRects.get(id);
          if (rect && almostEqual(rect.x, entry.contentRect.x) && almostEqual(rect.y, entry.contentRect.y) && almostEqual(rect.width, entry.contentRect.width) && almostEqual(rect.height, entry.contentRect.height)) {
            return;
          }
        }
        this._lastRects.set(id, entry.contentRect);
        resizedFrames.set(id, entry.contentRect);
      });
      if (resizedFrames.size) {
        this.slots.resize.emit(resizedFrames);
      }
    };
    this._observer = new ResizeObserver(throttle(this._onResize, 1e3 / 60));
  }
  resetListener(page) {
    var _a3;
    const unCachedKeys = new Set(this._cachedElements.keys());
    (_a3 = page.root) == null ? void 0 : _a3.children.forEach((model) => {
      const blockId = model.id;
      unCachedKeys.delete(blockId);
      const blockElement = getBlockElementByModel(model);
      const container = blockElement == null ? void 0 : blockElement.querySelector(".affine-frame-block-container");
      const cachedElement = this._cachedElements.get(blockId);
      if (cachedElement) {
        if (container === cachedElement) {
          return;
        }
        this._observer.unobserve(cachedElement);
        this._cachedElements.delete(blockId);
      }
      if (!container)
        return;
      this._observer.observe(container);
      this._cachedElements.set(blockId, container);
    });
    unCachedKeys.forEach((k) => {
      const element = this._cachedElements.get(k);
      if (!element)
        return;
      this._observer.unobserve(element);
    });
  }
  dispose() {
    this._observer.disconnect();
    this.slots.resize.dispose();
    this._cachedElements.clear();
    this._lastRects.clear();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/hotkey.js
function setMouseMode(edgeless, mouseMode, ignoreActiveState = false) {
  if (!ignoreActiveState && edgeless.selection.isActive) {
    return;
  }
  edgeless.selection.setMouseMode(mouseMode);
}
function bindSpace(edgeless) {
  let shouldRevertMode = false;
  let lastMode = null;
  hotkey.addListener(HOTKEYS.SPACE, (event) => {
    const { mouseMode, state: state2 } = edgeless.selection;
    if (event.type === "keydown") {
      if (mouseMode.type === "pan") {
        return;
      }
      if (mouseMode.type === "default" && state2.active) {
        return;
      }
      shouldRevertMode = true;
      lastMode = mouseMode;
      setMouseMode(edgeless, { type: "pan", panning: false });
      return;
    }
    if (event.type === "keyup") {
      if (mouseMode.type === "pan" && shouldRevertMode && lastMode) {
        setMouseMode(edgeless, lastMode);
      }
      shouldRevertMode = false;
    }
  }, {
    keydown: true,
    keyup: true
  });
}
function bindDelete(edgeless) {
  function backspace(e) {
    deleteModelsByRange(edgeless.page);
    const { selected } = edgeless.selection.state;
    selected.forEach((element) => {
      var _a3;
      if (isTopLevelBlock(element)) {
        const children = ((_a3 = edgeless.page.root) == null ? void 0 : _a3.children) ?? [];
        if (children.length > 1) {
          edgeless.page.deleteBlock(element);
        }
      } else {
        edgeless.surface.removeElement(element.id);
      }
    });
    edgeless.selection.clear();
    edgeless.slots.selectionUpdated.emit(edgeless.selection.state);
  }
  hotkey.addListener(HOTKEYS.BACKSPACE, backspace);
  hotkey.addListener(HOTKEYS.DELETE, backspace);
}
function bindShift(edgeless, key = "shift", pressed = false) {
  hotkey.addListener(HOTKEYS.ANY_KEY, (e) => {
    if (e.key.toLowerCase() === key && pressed !== e.shiftKey) {
      pressed = e.shiftKey;
      edgeless.slots.pressShiftKeyUpdated.emit(pressed);
    }
  }, {
    keydown: true,
    keyup: true
  });
}
function bindEdgelessHotkeys(edgeless) {
  const scope = hotkey.newScope(HOTKEY_SCOPE_TYPE.AFFINE_EDGELESS);
  if (activeEditorManager.isActive(edgeless)) {
    hotkey.setScope(scope);
  }
  const activeDispose = activeEditorManager.activeSlot.on(() => {
    if (activeEditorManager.isActive(edgeless)) {
      hotkey.setScope(scope);
    }
  });
  hotkey.withScope(scope, () => {
    hotkey.addListener(HOTKEYS.UP, (e) => handleUp(e, edgeless.page, { zoom: edgeless.surface.viewport.zoom }));
    hotkey.addListener(HOTKEYS.DOWN, (e) => handleDown(e, edgeless.page, { zoom: edgeless.surface.viewport.zoom }));
    hotkey.addListener("v", () => setMouseMode(edgeless, { type: "default" }));
    hotkey.addListener("t", () => setMouseMode(edgeless, { type: "text" }));
    hotkey.addListener("h", () => setMouseMode(edgeless, { type: "pan", panning: false }));
    hotkey.addListener("n", () => setMouseMode(edgeless, {
      type: "note",
      background: FRAME_BACKGROUND_COLORS[0]
    }));
    hotkey.addListener("p", () => setMouseMode(edgeless, {
      type: "brush",
      color: DEFAULT_SELECTED_COLOR,
      lineWidth: BrushSize.Thin
    }));
    hotkey.addListener("s", () => setMouseMode(edgeless, {
      type: "shape",
      shape: "rect",
      fillColor: DEFAULT_SHAPE_FILL_COLOR,
      strokeColor: DEFAULT_SHAPE_STROKE_COLOR
    }));
    hotkey.addListener(HOTKEYS.ESC, () => {
      edgeless.slots.selectionUpdated.emit({ selected: [], active: false });
      setMouseMode(edgeless, { type: "default" }, true);
    });
    hotkey.addListener(HOTKEYS.SELECT_ALL, (keyboardEvent) => {
      keyboardEvent.preventDefault();
      edgeless.slots.selectionUpdated.emit({
        selected: [...edgeless.frames, ...edgeless.surface.getElements()],
        active: false
      });
    });
    hotkey.addListener(`${SHORT_KEY}+1`, (e) => {
      e.preventDefault();
      edgeless.slots.zoomUpdated.emit("fit");
    });
    hotkey.addListener(`${SHORT_KEY}+-`, (e) => {
      e.preventDefault();
      edgeless.slots.zoomUpdated.emit("out");
    });
    hotkey.addListener(`${SHORT_KEY}+0`, (e) => {
      e.preventDefault();
      edgeless.slots.zoomUpdated.emit("reset");
    });
    hotkey.addListener(`${SHORT_KEY}+=`, (e) => {
      e.preventDefault();
      edgeless.slots.zoomUpdated.emit("in");
    });
    bindSpace(edgeless);
    bindDelete(edgeless);
    bindShift(edgeless);
    bindCommonHotkey(edgeless.page);
  });
  return () => {
    hotkey.deleteScope(scope);
    activeDispose.dispose();
  };
}

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/brush-mode.js
var BrushModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "brush",
      color: DEFAULT_SELECTED_COLOR,
      lineWidth: 4
    };
    this._draggingElementId = null;
    this._draggingPathPoints = null;
  }
  onContainerClick(e) {
    noop();
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    this._page.captureSync();
    const { viewport: viewport2 } = this._edgeless.surface;
    const [modelX, modelY] = viewport2.toModelCoord(e.point.x, e.point.y);
    const { color, lineWidth } = this.mouseMode;
    const points2 = [[modelX, modelY]];
    const id = this._surface.addElement("brush", {
      points: points2,
      color,
      lineWidth
    });
    this._draggingElementId = id;
    this._draggingPathPoints = points2;
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerDragMove(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    if (!this._draggingElementId)
      return;
    assertExists(this._draggingElementId);
    assertExists(this._draggingPathPoints);
    const { lineWidth } = this.mouseMode;
    const [modelX, modelY] = this._edgeless.surface.toModelCoord(e.point.x, e.point.y);
    const points2 = [...this._draggingPathPoints, [modelX, modelY]];
    this._draggingPathPoints = points2;
    this._surface.updateElement(this._draggingElementId, {
      points: points2,
      lineWidth
    });
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerDragEnd(e) {
    this._draggingElementId = null;
    this._draggingPathPoints = null;
    this._page.captureSync();
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/connector-mode.js
var ConnectorModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "connector"
    };
    this._draggingElementId = null;
    this._draggingArea = null;
    this._draggingStartElement = null;
    this._draggingStartRect = null;
  }
  _pickBy(x, y, filter2) {
    const { surface } = this._edgeless;
    return pickBy(surface, this._page, x, y, filter2);
  }
  onContainerClick(e) {
    noop();
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    this._page.captureSync();
    const { viewport: viewport2 } = this._edgeless.surface;
    const { mode, color } = this.mouseMode;
    const [modelX, modelY] = viewport2.toModelCoord(e.x, e.y);
    this._draggingStartElement = this._pickBy(e.x, e.y, (ele) => ele.type !== "connector");
    this._draggingStartRect = this._draggingStartElement ? new Rectangle(...deserializeXYWH(getXYWH(this._draggingStartElement))) : null;
    const { point: startPoint, position: startPosition } = getAttachedPoint(modelX, modelY, this._draggingStartRect);
    this._draggingStartPoint = startPoint;
    const id = this._surface.addElement("connector", {
      color,
      mode,
      controllers: [
        { x: modelX, y: modelY },
        { x: modelX + 1, y: modelY + 1 }
      ],
      lineWidth: 4,
      strokeStyle: StrokeStyle.Solid,
      startElement: this._draggingStartElement && startPosition ? {
        id: this._draggingStartElement.id,
        position: startPosition
      } : void 0
    });
    this._draggingElementId = id;
    this._draggingArea = {
      start: new DOMPoint(e.x, e.y),
      end: new DOMPoint(e.x, e.y)
    };
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerDragMove(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    assertExists(this._draggingElementId);
    assertExists(this._draggingArea);
    const { viewport: viewport2 } = this._edgeless.surface;
    const { mode } = this.mouseMode;
    this._draggingArea.end = new DOMPoint(e.x, e.y);
    const id = this._draggingElementId;
    const startX = this._draggingStartPoint.x;
    const startY = this._draggingStartPoint.y;
    const [endModelX, endModelY] = viewport2.toModelCoord(e.x, e.y);
    const end2 = this._pickBy(e.x, e.y, (ele) => ele.id !== id && ele.type !== "connector");
    const endRect = end2 && end2.id !== id ? new Rectangle(...deserializeXYWH(getXYWH(end2))) : null;
    const { point: { x: endX, y: endY }, position: endPosition } = getAttachedPoint(endModelX, endModelY, endRect);
    const routes = generateConnectorPath(this._draggingStartRect, endRect, { x: startX, y: startY }, { x: endX, y: endY }, [], mode);
    this._surface.updateElement(id, {
      controllers: routes,
      endElement: end2 && endPosition ? { id: end2.id, position: endPosition } : void 0
    });
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerDragEnd(e) {
    const id = this._draggingElementId;
    assertExists(id);
    this._draggingElementId = null;
    this._draggingArea = null;
    this._page.captureSync();
    const element = this._surface.pickById(id);
    assertExists(element);
    this._edgeless.selection.switchToDefaultMode({
      selected: [element],
      active: false
    });
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/note-mode.js
var NoteModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "note"
    };
    this._dragStartEvent = null;
  }
  _addNote(e, width = DEFAULT_FRAME_WIDTH) {
    addNote(this._edgeless, this._page, e, width);
  }
  onContainerClick(e) {
    this._addNote(e);
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    this._dragStartEvent = e;
    this._draggingArea = {
      start: new DOMPoint(e.x, e.y),
      end: new DOMPoint(e.x, e.y)
    };
  }
  onContainerDragMove(e) {
    if (this._draggingArea) {
      this._draggingArea.end = new DOMPoint(e.x, e.y);
      this._edgeless.slots.hoverUpdated.emit();
    }
  }
  onContainerDragEnd(e) {
    if (this._dragStartEvent) {
      const startEvent = e.x > this._dragStartEvent.x ? this._dragStartEvent : e;
      const width = Math.max(Math.abs(e.x - this._dragStartEvent.x), DEFAULT_FRAME_WIDTH);
      this._addNote(startEvent, width);
    }
    this._dragStartEvent = null;
    this._draggingArea = null;
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/pan-mode.js
var PanModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "pan"
    };
    this._lastPoint = null;
  }
  onContainerClick(e) {
    noop();
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    this._lastPoint = [e.x, e.y];
    this._edgeless.slots.mouseModeUpdated.emit({ type: "pan", panning: true });
  }
  onContainerDragMove(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    if (!this._lastPoint)
      return;
    const { viewport: viewport2 } = this._edgeless.surface;
    const { zoom } = viewport2;
    const [lastX, lastY] = this._lastPoint;
    const deltaX = lastX - e.x;
    const deltaY = lastY - e.y;
    this._lastPoint = [e.x, e.y];
    viewport2.applyDeltaCenter(deltaX / zoom, deltaY / zoom);
    this._edgeless.slots.viewportUpdated.emit();
  }
  onContainerDragEnd() {
    this._lastPoint = null;
    this._edgeless.slots.mouseModeUpdated.emit({ type: "pan", panning: false });
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/shape-mode.js
var ShapeModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "shape",
      shape: "rect",
      fillColor: DEFAULT_SHAPE_FILL_COLOR,
      strokeColor: DEFAULT_SHAPE_STROKE_COLOR
    };
    this._draggingElementId = null;
    this._draggingArea = null;
  }
  onContainerClick(e) {
    noop();
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    this._page.captureSync();
    const { viewport: viewport2 } = this._edgeless.surface;
    const [modelX, modelY] = viewport2.toModelCoord(e.point.x, e.point.y);
    const bound = new Bound(modelX, modelY, 0, 0);
    const { shape, fillColor, strokeColor } = this.mouseMode;
    const shapeType = shape === "roundedRect" ? "rect" : shape;
    const id = this._surface.addElement("shape", {
      shapeType,
      xywh: bound.serialize(),
      strokeColor,
      fillColor,
      filled: !isTransparent(fillColor),
      radius: shape === "roundedRect" ? 0.1 : 0,
      strokeWidth: 4,
      strokeStyle: StrokeStyle.Solid
    });
    this._draggingElementId = id;
    this._draggingArea = {
      start: new DOMPoint(e.x, e.y),
      end: new DOMPoint(e.x, e.y)
    };
    this._edgeless.slots.surfaceUpdated.emit();
  }
  onContainerDragMove(e) {
    if (!this._page.awarenessStore.getFlag("enable_surface"))
      return;
    assertExists(this._draggingElementId);
    assertExists(this._draggingArea);
    this._draggingArea.end = new DOMPoint(e.x, e.y);
    this._resize(e.keys.shift || this._edgeless.selection.shiftKey);
  }
  onContainerDragEnd(e) {
    const id = this._draggingElementId;
    assertExists(id);
    this._draggingElementId = null;
    this._draggingArea = null;
    this._page.captureSync();
    const element = this._surface.pickById(id);
    assertExists(element);
    this._edgeless.selection.switchToDefaultMode({
      selected: [element],
      active: false
    });
  }
  onPressShiftKey(pressed) {
    const id = this._draggingElementId;
    if (!id)
      return;
    this._resize(pressed);
  }
  _resize(shift = false) {
    const { _draggingElementId: id, _draggingArea, _edgeless } = this;
    assertExists(id);
    assertExists(_draggingArea);
    const { slots, surface } = _edgeless;
    const { viewport: viewport2 } = surface;
    const { zoom } = viewport2;
    const { start: { x: startX, y: startY }, end: end2 } = _draggingArea;
    let { x: endX, y: endY } = end2;
    if (shift) {
      const w2 = Math.abs(endX - startX);
      const h2 = Math.abs(endY - startY);
      const m = Math.max(w2, h2);
      endX = startX + (endX > startX ? m : -m);
      endY = startY + (endY > startY ? m : -m);
    }
    const [x, y] = viewport2.toModelCoord(Math.min(startX, endX), Math.min(startY, endY));
    const w = Math.abs(startX - endX) / zoom;
    const h = Math.abs(startY - endY) / zoom;
    const bound = new Bound(x, y, w, h);
    surface.setElementBound(id, bound);
    slots.surfaceUpdated.emit();
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/mode-controllers/text-mode.js
var TextModeController = class extends MouseModeController {
  constructor() {
    super(...arguments);
    this.mouseMode = {
      type: "text"
    };
  }
  onContainerClick(e) {
    addText(this._edgeless, e);
  }
  onContainerContextMenu(e) {
    noop();
  }
  onContainerDblClick(e) {
    noop();
  }
  onContainerTripleClick(e) {
    noop();
  }
  onContainerDragStart(e) {
    noop();
  }
  onContainerDragMove(e) {
    noop();
  }
  onContainerDragEnd(e) {
    noop();
  }
  onContainerMouseMove(e) {
    noop();
  }
  onContainerMouseOut(e) {
    noop();
  }
  onPressShiftKey(_) {
    noop();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/selection-manager.js
function shouldFilterMouseEvent2(event) {
  const target = event.target;
  if (!target || !(target instanceof HTMLElement)) {
    return false;
  }
  if (target.tagName === "INPUT") {
    return true;
  }
  if (target.tagName === "FORMAT-QUICK-BAR") {
    return true;
  }
  if (target.tagName === "AFFINE-DRAG-HANDLE") {
    return true;
  }
  return false;
}
var EdgelessSelectionManager = class extends AbstractSelectionManager {
  get isActive() {
    return this.state.active;
  }
  get lastMousePos() {
    return this._lastMousePos;
  }
  get mouseMode() {
    return this._mouseMode;
  }
  set mouseMode(mode) {
    this._mouseMode = mode;
    this._controllers[this._mouseMode.type].mouseMode = this._mouseMode;
  }
  get currentController() {
    return this._controllers[this.mouseMode.type];
  }
  get draggingArea() {
    if (!this.currentController.draggingArea)
      return null;
    const { start: start2, end: end2 } = this.currentController.draggingArea;
    const minX = Math.min(start2.x, end2.x);
    const minY = Math.min(start2.y, end2.y);
    const maxX = Math.max(start2.x, end2.x);
    const maxY = Math.max(start2.y, end2.y);
    return new DOMRect(minX, minY, maxX - minX, maxY - minY);
  }
  get shiftKey() {
    return this._shiftKey;
  }
  set shiftKey(pressed) {
    this._shiftKey = pressed;
    this.currentController.onPressShiftKey(pressed);
  }
  constructor(container, dispacher) {
    super(container, dispacher);
    this._mouseMode = {
      type: "default"
    };
    this._lastMousePos = { x: 0, y: 0 };
    this._rightClickTimer = null;
    this._shiftKey = false;
    this.selectedBlocks = [];
    this.lastState = null;
    this.state = {
      selected: [],
      active: false
    };
    this._add = (name, fn2) => {
      this._disposables.add(this._dispatcher.add(name, fn2));
    };
    this._onContainerDragStart = (e) => {
      if (this.page.readonly)
        return;
      if (e.button === 2 && this.mouseMode.type !== "pan")
        return;
      return this.currentController.onContainerDragStart(e);
    };
    this._onContainerDragMove = (e) => {
      if (this.page.readonly)
        return;
      if (e.button === 2 && this.mouseMode.type !== "pan")
        return;
      return this.currentController.onContainerDragMove(e);
    };
    this._onContainerDragEnd = (e) => {
      if (this.page.readonly)
        return;
      if (e.button === 2 && this.mouseMode.type !== "pan")
        return;
      return this.currentController.onContainerDragEnd(e);
    };
    this._onContainerClick = (e) => {
      const container2 = getEditorContainerByElement(this.container);
      activeEditorManager.setActive(container2);
      return this.currentController.onContainerClick(e);
    };
    this._onContainerDblClick = (e) => {
      return this.currentController.onContainerDblClick(e);
    };
    this._onContainerTripleClick = (e) => {
      return this.currentController.onContainerTripleClick(e);
    };
    this._onContainerPointerMove = (e) => {
      this._updateLastMousePos(e);
      this.container.slots.hoverUpdated.emit();
      return this._controllers[this.mouseMode.type].onContainerMouseMove(e);
    };
    this._onContainerPointerOut = (e) => {
      return this._controllers[this.mouseMode.type].onContainerMouseOut(e);
    };
    this._onContainerContextMenu = (e) => {
      e.raw.preventDefault();
      const mouseMode = this.mouseMode;
      if (mouseMode.type !== "pan" && !this._rightClickTimer) {
        this._rightClickTimer = {
          mouseMode,
          timeStamp: e.raw.timeStamp,
          timer: window.setTimeout(() => {
            this._controllers["pan"].onContainerDragStart(e);
          }, 233)
        };
      }
    };
    this._onContainerPointerUp = (e) => {
      if (e.button === 2 && this._rightClickTimer) {
        const { timer, timeStamp, mouseMode } = this._rightClickTimer;
        if (e.raw.timeStamp - timeStamp > 233) {
          this.container.slots.mouseModeUpdated.emit(mouseMode);
        } else {
          clearTimeout(timer);
        }
        this._rightClickTimer = null;
      }
    };
    this._onSelectionChangeWithoutDebounce = () => {
      updateLocalSelectionRange(this.page);
    };
    this.setMouseMode = (mouseMode, state2 = {
      selected: [],
      active: false
    }) => {
      if (this.mouseMode === mouseMode)
        return;
      if (mouseMode.type === "default") {
        if (!state2.selected.length && this.lastState) {
          state2 = this.lastState;
          this.lastState = null;
        } else {
          this.lastState = state2;
        }
      } else if (this.state.selected.length) {
        this.lastState = this.state;
      }
      this.container.slots.mouseModeUpdated.emit(mouseMode);
      this.container.slots.selectionUpdated.emit(state2);
    };
    this._controllers = {
      default: new DefaultModeController(this.container),
      text: new TextModeController(this.container),
      shape: new ShapeModeController(this.container),
      brush: new BrushModeController(this.container),
      pan: new PanModeController(this.container),
      note: new NoteModeController(this.container),
      connector: new ConnectorModeController(this.container)
    };
    this._initMouseAndWheelEvents();
  }
  _updateLastMousePos(e) {
    this._lastMousePos = {
      x: e.x,
      y: e.y
    };
  }
  async _initMouseAndWheelEvents() {
    if (!this.container.surface) {
      await new Promise((resolve) => requestAnimationFrame(resolve));
    }
    this._add("dragStart", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent2(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target) && !isInsideEdgelessTextEditor(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerDragStart(event);
    });
    this._add("dragMove", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent2(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target) && !isInsideEdgelessTextEditor(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerDragMove(event);
    });
    this._add("dragEnd", (ctx) => {
      const event = ctx.get("pointerState");
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target) && !isInsideEdgelessTextEditor(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerDragEnd(event);
    });
    this._add("click", (ctx) => {
      const event = ctx.get("pointerState");
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target) && !isInsideEdgelessTextEditor(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerClick(event);
    });
    this._add("doubleClick", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent2(event.raw))
        return;
      this._onContainerDblClick(event);
    });
    this._add("tripleClick", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent2(event.raw))
        return;
      this._onContainerTripleClick(event);
    });
    this._add("pointerMove", (ctx) => {
      const event = ctx.get("pointerState");
      if (shouldFilterMouseEvent2(event.raw))
        return;
      if (!isInsidePageTitle(event.raw.target) && !isDatabaseInput(event.raw.target) && !isInsideEdgelessTextEditor(event.raw.target)) {
        event.raw.preventDefault();
      }
      this._onContainerPointerMove(event);
    });
    this._add("pointerUp", (ctx) => {
      const event = ctx.get("pointerState");
      this._onContainerPointerUp(event);
    });
    this._add("pointerOut", (ctx) => {
      const event = ctx.get("pointerState");
      this._onContainerPointerOut(event);
    });
    this._add("contextMenu", (ctx) => {
      const event = ctx.get("pointerState");
      this._onContainerContextMenu(event);
    });
    this._add("selectionChange", () => {
      this._onSelectionChangeWithoutDebounce();
    });
    this._add("wheel", (ctx) => {
      const state2 = ctx.get("defaultState");
      const e = state2.event;
      if (!(e instanceof WheelEvent))
        return;
      e.preventDefault();
      const container = this.container;
      const { viewport: viewport2 } = container.surface;
      if (!isPinchEvent(e)) {
        const dx = e.deltaX / viewport2.zoom;
        const dy = e.deltaY / viewport2.zoom;
        viewport2.applyDeltaCenter(dx, dy);
        container.slots.viewportUpdated.emit();
      } else {
        const rect = container.getBoundingClientRect();
        const [baseX, baseY] = container.surface.toModelCoord(e.clientX - rect.x, e.clientY - rect.y);
        const zoom = normalizeWheelDeltaY(e.deltaY, viewport2.zoom);
        viewport2.setZoom(zoom, new Point(baseX, baseY));
        container.slots.viewportUpdated.emit();
      }
    });
  }
  refreshRemoteSelection() {
    const element = document.querySelector("remote-selection");
    if (element) {
      element.requestUpdate();
    }
  }
  getHoverState() {
    var _a3, _b;
    if (!this.currentController.enableHover) {
      return null;
    }
    const { surface } = this.container;
    const frames = (((_a3 = this.page.root) == null ? void 0 : _a3.children) ?? []).filter((child) => child.flavour === "affine:frame");
    const { x, y } = this._lastMousePos;
    const [modelX, modelY] = surface.toModelCoord(x, y);
    const hovered = surface.pickTop(modelX, modelY) || pickTopBlock(frames, modelX, modelY);
    if (
      // if not frame block
      !isTopLevelBlock(hovered) || // if in other mouse mode
      this.mouseMode.type !== "default" || // if current selection is not active
      !this.state.active || // if current selected block is not the hovered block
      this.state.selected[0].id !== hovered.id
    ) {
      (_b = this.container.components.dragHandle) == null ? void 0 : _b.hide();
    }
    if (!hovered || this.state.active) {
      return null;
    }
    const xywh = getXYWH(hovered);
    return {
      rect: getSelectionBoxBound(surface.viewport, xywh),
      content: hovered
    };
  }
  switchToDefaultMode(state2) {
    this.setMouseMode({ type: "default" }, state2);
  }
  clear() {
    this.selectedBlocks = [];
    this.lastState = null;
    this.state = {
      selected: [],
      active: false
    };
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/edgeless/edgeless-page-block.js
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EdgelessPageBlockComponent = class EdgelessPageBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this.flavour = "edgeless";
    this.components = {
      dragHandle: null,
      toolbar: null
    };
    this.showGrid = true;
    this.mouseMode = {
      type: "default"
    };
    this._rectsOfSelectedBlocks = [];
    this.clipboard = new EdgelessClipboard(this.page, this);
    this.slots = {
      viewportUpdated: new Slot(),
      selectedBlocksUpdated: new Slot(),
      selectionUpdated: new Slot(),
      hoverUpdated: new Slot(),
      surfaceUpdated: new Slot(),
      mouseModeUpdated: new Slot(),
      reorderingFramesUpdated: new Slot(),
      reorderingShapesUpdated: new Slot(),
      zoomUpdated: new Slot(),
      pressShiftKeyUpdated: new Slot(),
      subpageLinked: new Slot(),
      subpageUnlinked: new Slot(),
      pageLinkClicked: new Slot()
    };
    this.indexes = { max: "a0", min: "a0" };
    this.getService = getService;
    this._resizeObserver = null;
    this._frameResizeObserver = new FrameResizeObserver();
    this._initDragHandle = () => {
      const createHandle = () => {
        this.components.dragHandle = createDragHandle2(this);
      };
      if (this.page.awarenessStore.getFlag("enable_drag_handle") && !this.components.dragHandle) {
        createHandle();
      }
      this._disposables.add(this.page.awarenessStore.slots.update.subscribe((msg) => {
        var _a3;
        return (_a3 = msg.state) == null ? void 0 : _a3.flags.enable_drag_handle;
      }, (enable) => {
        var _a3;
        if (enable) {
          if (this.components.dragHandle)
            return;
          createHandle();
          return;
        }
        (_a3 = this.components.dragHandle) == null ? void 0 : _a3.remove();
        this.components.dragHandle = null;
      }, {
        filter: (msg) => msg.id === this.page.doc.clientID
      }));
    };
    this.reorderFrames = ({ elements, type }) => {
      const updateIndexes = (keys, elements2) => {
        this.updateIndexes(keys, elements2, (keys2) => {
          const min3 = keys2[0];
          if (min3 < this.indexes.min) {
            this.indexes.min = min3;
          }
          const max2 = keys2[keys2.length - 1];
          if (max2 > this.indexes.max) {
            this.indexes.max = max2;
          }
        });
      };
      switch (type) {
        case "front":
          this._reorderTo(elements, () => ({
            start: this.indexes.max,
            end: null
          }), updateIndexes);
          break;
        case "forward":
          this._reorder(elements, (pickedElements) => ({
            start: generateKeyBetween(null, pickedElements[0].index),
            end: null
          }), () => this.getSortedElementsWithViewportBounds(elements), bringForward, updateIndexes);
          break;
        case "backward":
          this._reorder(elements, (pickedElements) => ({
            start: null,
            end: pickedElements[pickedElements.length - 1].index
          }), () => this.getSortedElementsWithViewportBounds(elements), sendBackward, updateIndexes);
          break;
        case "back":
          this._reorderTo(elements, () => ({
            start: null,
            end: this.indexes.min
          }), updateIndexes);
          break;
      }
    };
    this.reorderShapes = ({ elements, type }) => {
      const updateIndexes = (keys, elements2) => {
        this.surface.updateIndexes(keys, elements2, (keys2) => {
          const min3 = keys2[0];
          if (min3 < this.surface.indexes.min) {
            this.surface.indexes.min = min3;
          }
          const max2 = keys2[keys2.length - 1];
          if (max2 > this.surface.indexes.max) {
            this.surface.indexes.max = max2;
          }
        });
      };
      switch (type) {
        case "front":
          this._reorderTo(elements, () => ({
            start: this.surface.indexes.max,
            end: null
          }), updateIndexes);
          break;
        case "forward":
          this._reorder(elements, (pickedElements) => ({
            start: generateKeyBetween(null, pickedElements[0].index),
            end: null
          }), () => this.surface.getSortedElementsWithViewportBounds(), bringForward, updateIndexes);
          break;
        case "backward":
          this._reorder(elements, (pickedElements) => ({
            start: null,
            end: pickedElements[pickedElements.length - 1].index
          }), () => this.surface.getSortedElementsWithViewportBounds(), sendBackward, updateIndexes);
          break;
        case "back":
          this._reorderTo(elements, () => ({
            start: null,
            end: this.surface.indexes.min
          }), updateIndexes);
          break;
      }
    };
  }
  // Gets the top level frames.
  get frames() {
    return this.model.children.filter((child) => child.flavour === "affine:frame");
  }
  // Gets the sorted frames.
  get sortedFrames() {
    return this.frames.sort(compare);
  }
  _clearSelection() {
    requestAnimationFrame(() => {
      if (!this.selection.isActive) {
        resetNativeSelection(null);
      }
    });
  }
  // just init surface, attach to dom later
  _initSurface() {
    const { page, parentElement } = this;
    const surfaceBlock = this.model.children.find((child) => child.flavour === "affine:surface");
    assertExists(parentElement);
    assertExists(surfaceBlock);
    const yBlock = page.getYBlockById(surfaceBlock.id);
    assertExists(yBlock);
    let yContainer = yBlock.get("elements");
    if (!yContainer) {
      yContainer = new page.YMap();
      yBlock.set("elements", yContainer);
    }
    this.surface = new SurfaceManager(yContainer, (value) => {
      if (isCssVariable(value)) {
        const cssValue = getThemePropertyValue(parentElement, value);
        if (cssValue === void 0) {
          console.error(new Error(`All variables should have a value. Please check for any dirty data or variable renaming.Variable: ${value}`));
        }
        return cssValue ?? value;
      }
      return value;
    });
    this._disposables.add(listenToThemeChange(this, () => {
      this.surface.refresh();
    }));
  }
  _handleToolbarFlag() {
    const createToolbar = () => {
      const toolbar = new EdgelessToolbar(this);
      this.appendChild(toolbar);
      this.components.toolbar = toolbar;
    };
    if (this.page.awarenessStore.getFlag("enable_edgeless_toolbar") && !this.components.toolbar) {
      createToolbar();
    }
    this._disposables.add(this.page.awarenessStore.slots.update.subscribe((msg) => {
      var _a3;
      return (_a3 = msg.state) == null ? void 0 : _a3.flags.enable_edgeless_toolbar;
    }, (enable) => {
      var _a3;
      if (enable) {
        if (this.components.toolbar)
          return;
        createToolbar();
        return;
      }
      (_a3 = this.components.toolbar) == null ? void 0 : _a3.remove();
      this.components.toolbar = null;
    }, {
      filter: (msg) => msg.id === this.page.doc.clientID
    }));
  }
  _initSlotEffects() {
    const { _disposables, slots } = this;
    _disposables.add(slots.viewportUpdated.on(() => {
      var _a3, _b;
      const prevZoom = this.style.getPropertyValue("--affine-zoom");
      const newZoom = this.surface.viewport.zoom;
      if (!prevZoom || +prevZoom !== newZoom) {
        this.style.setProperty("--affine-zoom", `${newZoom}`);
        (_a3 = this.components.dragHandle) == null ? void 0 : _a3.setScale(newZoom);
      }
      (_b = this.components.dragHandle) == null ? void 0 : _b.hide();
      if (this.selection.selectedBlocks.length) {
        slots.selectedBlocksUpdated.emit([...this.selection.selectedBlocks]);
      }
      this.requestUpdate();
    }));
    _disposables.add(slots.selectedBlocksUpdated.on((selectedBlocks) => {
      this.selection.selectedBlocks = selectedBlocks;
      requestAnimationFrame(() => {
        this._rectsOfSelectedBlocks = selectedBlocks.map(getRectByBlockElement);
      });
    }));
    _disposables.add(slots.hoverUpdated.on(() => this.requestUpdate()));
    _disposables.add(slots.selectionUpdated.on((state2) => {
      this.selection.state = state2;
      this._clearSelection();
      this.requestUpdate();
    }));
    _disposables.add(slots.surfaceUpdated.on(() => this.requestUpdate()));
    _disposables.add(slots.mouseModeUpdated.on((mouseMode) => {
      var _a3;
      if (mouseMode.type !== "default") {
        (_a3 = this.components.dragHandle) == null ? void 0 : _a3.hide();
      }
      this.mouseMode = mouseMode;
    }));
    _disposables.add(this.page.slots.historyUpdated.on(() => {
      this._clearSelection();
      this.requestUpdate();
    }));
    _disposables.add(this.selection);
    _disposables.add(this.surface);
    _disposables.add(bindEdgelessHotkeys(this));
    _disposables.add(this._frameResizeObserver);
    _disposables.add(this._frameResizeObserver.slots.resize.on((resizedFrames) => {
      const page = this.page;
      resizedFrames.forEach((domRect, id) => {
        const model = page.getBlockById(id);
        const { index, xywh } = model;
        const [x, y, w, h] = deserializeXYWH(xywh);
        if (index < this.indexes.min) {
          this.indexes.min = index;
        } else if (index > this.indexes.max) {
          this.indexes.max = index;
        }
        const newModelHeight = domRect.height + EDGELESS_BLOCK_CHILD_PADDING * 2;
        if (!almostEqual(newModelHeight, h)) {
          page.updateBlock(model, {
            xywh: JSON.stringify([x, y, w, Math.round(newModelHeight)])
          });
        }
      });
      slots.selectionUpdated.emit({ ...this.selection.state });
    }));
    _disposables.add(slots.reorderingFramesUpdated.on(this.reorderFrames));
    _disposables.add(slots.reorderingShapesUpdated.on(this.reorderShapes));
    _disposables.add(slots.zoomUpdated.on((action) => {
      var _a3;
      return (_a3 = this.components.toolbar) == null ? void 0 : _a3.setZoomByAction(action);
    }));
    _disposables.add(slots.pressShiftKeyUpdated.on((pressed) => {
      this.selection.shiftKey = pressed;
      this.requestUpdate();
    }));
  }
  /**
   * Brings to front or sends to back.
   */
  _reorderTo(elements, getIndexes, updateIndexes) {
    reorderTo(elements, compare, getIndexes, (start2, end2, len3) => generateNKeysBetween(start2, end2, len3), updateIndexes);
  }
  /**
   * Brings forward or sends backward layer by layer.
   */
  _reorder(elements, getIndexes, pick, order2, updateIndexes) {
    reorder(elements, compare, pick, getIndexes, order2, (start2, end2, len3) => generateNKeysBetween(start2, end2, len3), updateIndexes);
  }
  updateIndexes(keys, elements, callback) {
    let index;
    let i = 0;
    let element;
    const len3 = elements.length;
    for (; i < len3; i++) {
      index = keys[i];
      element = elements[i];
      if (element.index === index)
        continue;
      this.page.updateBlock(element, {
        index
      });
    }
    callback(keys);
  }
  getSortedElementsWithViewportBounds(elements) {
    const bounds = this.surface.viewport.viewportBounds;
    return this.sortedFrames.filter((element) => {
      if (elements.includes(element))
        return true;
      return intersects(bounds, xywhArrayToObject(element));
    });
  }
  /**
   * Adds a new frame with the given point on the editor-container.
   *
   * @param: point Point
   * @returns: The id of new frame
   */
  addFrameWithPoint(point, options2 = {}) {
    var _a3;
    const { width = DEFAULT_FRAME_WIDTH, height = DEFAULT_FRAME_HEIGHT, offsetX = DEFAULT_FRAME_OFFSET_X, offsetY = DEFAULT_FRAME_OFFSET_Y, parentId = (_a3 = this.page.root) == null ? void 0 : _a3.id, frameIndex } = options2;
    const [x, y] = this.surface.toModelCoord(point.x, point.y);
    return this.page.addBlock("affine:frame", {
      xywh: serializeXYWH(x - offsetX, y - offsetY, width, height),
      index: this.indexes.max
    }, parentId, frameIndex);
  }
  /**
   * Adds a new frame with the given blocks and point.
   * @param blocks Array<Partial<BaseBlockModel>>
   * @param point Point
   */
  addNewFrame(blocks, point, options2) {
    this.page.captureSync();
    const { left: left2, top: top2 } = this.surface.viewport;
    point.x -= left2;
    point.y -= top2;
    const frameId = this.addFrameWithPoint(point, options2);
    const ids = this.page.addBlocks(blocks.map(({ flavour, ...blockProps }) => {
      assertExists(flavour);
      return {
        flavour,
        blockProps
      };
    }), frameId);
    return {
      frameId,
      ids
    };
  }
  /** Moves selected blocks into a new frame at the given point. */
  moveBlocksWithNewFrame(blocks, point, { rect, focus, parentId, frameIndex } = {}) {
    const { left: left2, top: top2, zoom } = this.surface.viewport;
    const width = (rect == null ? void 0 : rect.width) ? rect.width / zoom + EDGELESS_BLOCK_CHILD_PADDING * 2 : DEFAULT_FRAME_WIDTH;
    point.x -= left2;
    point.y -= top2;
    const frameId = this.addFrameWithPoint(point, {
      width,
      parentId,
      frameIndex
    });
    const frameModel = this.page.getBlockById(frameId);
    this.page.moveBlocks(blocks, frameModel);
    focus && this.setSelection(frameId, true, blocks[0].id, point);
  }
  /*
   * Set selection state by giving frameId & blockId.
   * Not supports surface elements.
   */
  setSelection(frameId, active = true, blockId, point) {
    const frameBlock = this.frames.find((b) => b.id === frameId);
    assertExists(frameBlock);
    requestAnimationFrame(() => {
      this.slots.selectedBlocksUpdated.emit([]);
      this.slots.selectionUpdated.emit({
        selected: [frameBlock],
        active
      });
      this.updateComplete.then(() => {
        if (blockId) {
          asyncFocusRichText(this.page, blockId);
        } else if (point) {
          handleNativeRangeAtPoint(point.x, point.y);
        }
      });
    });
  }
  /**
   * Clear selected blocks.
   */
  clearSelectedBlocks() {
    if (this.selection.selectedBlocks.length) {
      this.slots.selectedBlocksUpdated.emit([]);
    }
  }
  update(changedProperties) {
    if (changedProperties.has("page")) {
      this._initSurface();
      this.selection = new EdgelessSelectionManager(this, this.root.uiEventDispatcher);
    }
    if (changedProperties.has("mouseMode")) {
      this.selection.mouseMode = this.mouseMode;
    }
    super.update(changedProperties);
  }
  _initResizeEffect() {
    const resizeObserver = new ResizeObserver((_) => {
      this.surface.onResize();
      this.slots.selectedBlocksUpdated.emit([...this.selection.selectedBlocks]);
      this.slots.selectionUpdated.emit({ ...this.selection.state });
    });
    resizeObserver.observe(this.pageBlockContainer);
    this._resizeObserver = resizeObserver;
  }
  firstUpdated() {
    var _a3;
    this._initSlotEffects();
    this._initDragHandle();
    this._initResizeEffect();
    this.clipboard.init(this.page);
    tryUpdateFrameSize(this.page, this.surface.viewport.zoom);
    requestAnimationFrame(() => {
      this.surface.attach(this._surfaceContainer);
      const frame = this.frames.find((child) => child.flavour === "affine:frame");
      if (frame) {
        const [modelX, modelY, modelW, modelH] = deserializeXYWH(frame.xywh);
        this.surface.viewport.setCenter(modelX + modelW / 2, modelY + modelH / 2);
      }
      this._handleToolbarFlag();
      this._frameResizeObserver.resetListener(this.page);
      this.requestUpdate();
    });
    this._clearSelection();
    (_a3 = this.page.root) == null ? void 0 : _a3.childrenUpdated.on(() => {
      requestAnimationFrame(() => {
        this._frameResizeObserver.resetListener(this.page);
      });
    });
  }
  updated(changedProperties) {
    super.updated(changedProperties);
  }
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:page", PageBlockService);
    this.mouseRoot = this.parentElement;
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    this.clipboard.dispose();
    (_a3 = this.components.dragHandle) == null ? void 0 : _a3.remove();
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  }
  render() {
    requestAnimationFrame(() => {
      this.selection.refreshRemoteSelection();
    });
    this.setAttribute(BLOCK_ID_ATTR, this.model.id);
    const { mouseMode, page, selection, surface, _rectsOfSelectedBlocks } = this;
    const { state: state2, draggingArea } = selection;
    const { viewport: viewport2 } = surface;
    const childrenContainer = EdgelessBlockChildrenContainer(this.sortedFrames, state2.active, this.root.renderModel);
    const { zoom, viewportX, viewportY, left: left2, top: top2 } = viewport2;
    const draggingAreaTpl = EdgelessDraggingArea(draggingArea);
    const hoverState = selection.getHoverState();
    const hoverRectTpl = EdgelessHoverRect(hoverState, zoom);
    const { grid, gap, translateX, translateY } = getBackgroundGrid(viewportX, viewportY, zoom, this.showGrid);
    const blockContainerStyle = {
      cursor: getCursorMode(mouseMode),
      "--affine-edgeless-gap": `${gap}px`,
      "--affine-edgeless-grid": grid,
      "--affine-edgeless-x": `${translateX}px`,
      "--affine-edgeless-y": `${translateY}px`
    };
    return html`
      <div class="affine-edgeless-surface-block-container">
        <!-- attach canvas later in Phasor -->
      </div>
      <div
        class="affine-edgeless-page-block-container"
        style=${styleMap(blockContainerStyle)}
      >
        <div class="affine-block-children-container edgeless">
          <div class="affine-edgeless-layer">${childrenContainer}</div>
        </div>
        <affine-selected-blocks
          .mouseRoot=${this.mouseRoot}
          .state=${{
      rects: _rectsOfSelectedBlocks,
      grab: false
    }}
          .offset=${{
      x: -left2,
      y: -top2
    }}
        ></affine-selected-blocks>
        ${hoverRectTpl} ${draggingAreaTpl}
        ${state2.selected.length ? html`
              <edgeless-selected-rect
                disabled=${mouseMode.type === "pan"}
                .page=${page}
                .state=${state2}
                .slots=${this.slots}
                .surface=${surface}
              ></edgeless-selected-rect>
            ` : nothing}
      </div>
    `;
  }
};
EdgelessPageBlockComponent.styles = css`
    .affine-edgeless-page-block-container {
      position: relative;
      box-sizing: border-box;
      overflow: hidden;
      height: 100%;
      font-family: var(--affine-font-family);
      font-size: var(--affine-font-base);
      line-height: var(--affine-line-height);
      color: var(--affine-text-primary-color);
      font-weight: 400;
    }

    .affine-edgeless-surface-block-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    .affine-edgeless-surface-block-container canvas {
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 1;
      pointer-events: none;
    }

    .affine-block-children-container.edgeless {
      padding-left: 0;
      position: relative;
      overflow: hidden;
      height: 100%;
      /**
       * Fix: pointerEvent stops firing after a short time.
       * When a gesture is started, the browser intersects the touch-action values of the touched element and its ancestors,
       * up to the one that implements the gesture (in other words, the first containing scrolling element)
       * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
       */
      touch-action: none;

      background-size: var(--affine-edgeless-gap) var(--affine-edgeless-gap);
      background-position: var(--affine-edgeless-x) var(--affine-edgeless-y);
      background-color: var(--affine-background-primary-color);
      background-image: var(--affine-edgeless-grid);
      z-index: 0;
    }

    .affine-edgeless-layer {
      position: absolute;
      contain: layout style size;
      transform: translate(var(--affine-edgeless-x), var(--affine-edgeless-y))
        scale(var(--affine-zoom));
    }

    .affine-edgeless-hover-rect {
      position: absolute;
      border-radius: 0;
      pointer-events: none;
      box-sizing: border-box;
      z-index: 1;
      border: var(--affine-border-width) solid var(--affine-blue);
    }
  `;
__decorate42([
  state()
], EdgelessPageBlockComponent.prototype, "mouseMode", void 0);
__decorate42([
  state()
], EdgelessPageBlockComponent.prototype, "_rectsOfSelectedBlocks", void 0);
__decorate42([
  query(".affine-edgeless-surface-block-container")
], EdgelessPageBlockComponent.prototype, "_surfaceContainer", void 0);
__decorate42([
  query(".affine-edgeless-page-block-container")
], EdgelessPageBlockComponent.prototype, "pageBlockContainer", void 0);
EdgelessPageBlockComponent = __decorate42([
  customElement("affine-edgeless-page")
], EdgelessPageBlockComponent);

// node_modules/@blocksuite/blocks/dist/page-block/page-model.js
var PageBlockModel = class extends BaseBlockModel {
  onCreated() {
    super.onCreated();
    this.page.slots.blockUpdated.on(({ type }) => {
      if (type === "add") {
        this.page.workspace.setPageMeta(this.page.id, {
          title: this.title.toString()
        });
      }
    });
  }
};
var PageBlockSchema = defineBlockSchema({
  flavour: "affine:page",
  props: (internal) => ({
    title: internal.Text()
  }),
  metadata: {
    version: 2,
    role: "root",
    tag: literal`affine-page`
  },
  toModel: () => new PageBlockModel()
});

// node_modules/@blocksuite/blocks/dist/__internal__/service/json2block.js
async function json2block(focusedBlockModel, pastedBlocks, options2) {
  var _a3, _b, _c, _d, _e, _f, _g;
  const { convertToPastedIfEmpty = false, range } = options2 ?? {};
  assertExists(range);
  const { page } = focusedBlockModel;
  const firstBlock = pastedBlocks[0];
  const lastBlock = pastedBlocks[pastedBlocks.length - 1];
  const isFocusedBlockEmpty = !((_a3 = focusedBlockModel.text) == null ? void 0 : _a3.length) && !convertToPastedIfEmpty;
  const shouldMergeFirstBlock = !isFocusedBlockEmpty && firstBlock.text && focusedBlockModel.text;
  const shouldMergeLastBlock = focusedBlockModel.text && lastBlock.text;
  const parent = page.getParent(focusedBlockModel);
  assertExists(parent);
  if (pastedBlocks.length === 1) {
    const textLength = ((_b = firstBlock == null ? void 0 : firstBlock.text) == null ? void 0 : _b.reduce((sum, data) => {
      var _a4;
      return sum + (((_a4 = data.insert) == null ? void 0 : _a4.length) || 0);
    }, 0)) ?? 0;
    const shouldSplitBlock = ((_c = focusedBlockModel.text) == null ? void 0 : _c.length) !== range.endOffset;
    shouldSplitBlock && await handleBlockSplit(page, focusedBlockModel, range.startOffset, 0);
    if (shouldMergeFirstBlock) {
      (_d = focusedBlockModel.text) == null ? void 0 : _d.insertList(firstBlock.text || [], (range == null ? void 0 : range.startOffset) || 0);
      await addSerializedBlocks(page, firstBlock.children || [], focusedBlockModel, 0);
      await setRange(focusedBlockModel, {
        index: ((range == null ? void 0 : range.startOffset) ?? 0) + textLength,
        length: 0
      });
    } else {
      const [id] = await addSerializedBlocks(page, pastedBlocks, parent, parent.children.indexOf(focusedBlockModel) + 1);
      const model = page.getBlockById(id);
      assertExists(model);
      if (model.text) {
        await setRange(model, {
          index: textLength,
          length: 0
        });
      } else {
      }
    }
    isFocusedBlockEmpty && page.deleteBlock(focusedBlockModel);
    return;
  }
  await handleBlockSplit(page, focusedBlockModel, range.startOffset, 0);
  if (shouldMergeFirstBlock) {
    (_e = focusedBlockModel.text) == null ? void 0 : _e.insertList(firstBlock.text || [], (range == null ? void 0 : range.startOffset) || 0);
    await addSerializedBlocks(page, firstBlock.children || [], focusedBlockModel, 0);
  }
  const insertPosition = parent.children.indexOf(focusedBlockModel) + (shouldMergeFirstBlock ? 1 : 0);
  const ids = await addSerializedBlocks(page, pastedBlocks.slice(shouldMergeFirstBlock ? 1 : 0), parent, insertPosition);
  isFocusedBlockEmpty && page.deleteBlock(focusedBlockModel);
  const lastModel = page.getBlockById(ids[ids.length - 1]);
  if (shouldMergeLastBlock) {
    assertExists(lastModel);
    const rangeOffset = ((_f = lastModel.text) == null ? void 0 : _f.length) || 0;
    const nextSiblingModel = page.getNextSibling(lastModel);
    (_g = lastModel.text) == null ? void 0 : _g.join(nextSiblingModel == null ? void 0 : nextSiblingModel.text);
    assertExists(nextSiblingModel);
    page.deleteBlock(nextSiblingModel);
    requestAnimationFrame(() => {
      setRange(lastModel, {
        index: rangeOffset,
        length: 0
      });
    });
  } else {
    if (lastModel == null ? void 0 : lastModel.text) {
      setRange(lastModel, {
        index: lastModel.text.length,
        length: 0
      });
    } else {
    }
  }
}
async function setRange(model, vRange) {
  const vEditor = await asyncGetVirgoByModel(model);
  assertExists(vEditor);
  vEditor.setVRange(vRange);
}
async function addSerializedBlocks(page, serializedBlocks, parent, index) {
  var _a3, _b, _c, _d, _e, _f, _g;
  const addedBlockIds = [];
  const pendingModels = [];
  for (let i = 0; i < serializedBlocks.length; i++) {
    const json = serializedBlocks[i];
    const flavour = json.flavour;
    const blockProps = {
      flavour,
      type: json.type,
      checked: json.checked,
      sourceId: json.sourceId,
      caption: json.caption,
      width: json.width,
      height: json.height,
      language: json.language,
      title: ((_a3 = json.databaseProps) == null ? void 0 : _a3.title) || json.title,
      titleColumnName: (_b = json.databaseProps) == null ? void 0 : _b.titleColumnName,
      titleColumnWidth: (_c = json.databaseProps) == null ? void 0 : _c.titleColumnWidth,
      // bookmark
      url: json.url,
      description: json.description,
      icon: json.icon,
      image: json.image,
      crawled: json.crawled
    };
    const id = page.addBlock(flavour, blockProps, parent, index + i);
    addedBlockIds.push(id);
    const model = page.getBlockById(id);
    assertExists(model);
    const initialProps = (model == null ? void 0 : model.flavour) && page.getInitialPropsByFlavour(model == null ? void 0 : model.flavour);
    if (initialProps && initialProps.text instanceof Text2) {
      json.text && ((_d = model == null ? void 0 : model.text) == null ? void 0 : _d.applyDelta(json.text));
    }
    if (model && json.children.length) {
      await addSerializedBlocks(page, json.children, model, 0);
      pendingModels.push({ model, json });
    }
  }
  for (const { model, json } of pendingModels) {
    const flavour = model.flavour;
    const service = await getServiceOrRegister(flavour);
    service.onBlockPasted(model, {
      rowIds: (_e = json.databaseProps) == null ? void 0 : _e.rowIds,
      cells: (_f = json.databaseProps) == null ? void 0 : _f.cells,
      columns: (_g = json.databaseProps) == null ? void 0 : _g.columns
    });
  }
  return addedBlockIds;
}

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/markdown-convert.js
var matches2 = [
  {
    name: "bolditalic",
    pattern: /(?:\*){3}(.+?)(?:\*){3}$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        bold: true,
        italic: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length - 3,
        length: 3
      });
      vEditor.deleteText({
        index: startIndex,
        length: 3
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 6,
        length: 0
      });
      return true;
    }
  },
  {
    name: "bold",
    pattern: /(?:\*){2}(.+?)(?:\*){2}$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        bold: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length - 2,
        length: 2
      });
      vEditor.deleteText({
        index: startIndex,
        length: 2
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 4,
        length: 0
      });
      return true;
    }
  },
  {
    name: "italic",
    pattern: /(?:\*){1}(.+?)(?:\*){1}$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        italic: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length - 1,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex,
        length: 1
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 2,
        length: 0
      });
      return true;
    }
  },
  {
    name: "strikethrough",
    pattern: /(?:~~)(.+?)(?:~~)$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        strike: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length - 2,
        length: 2
      });
      vEditor.deleteText({
        index: startIndex,
        length: 2
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 4,
        length: 0
      });
      return true;
    }
  },
  {
    name: "underthrough",
    pattern: /(?:~)(.+?)(?:~)$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        underline: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: selection.index - 1,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex,
        length: 1
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 2,
        length: 0
      });
      return true;
    }
  },
  {
    name: "code",
    pattern: /(?:`)(`{2,}?|[^`]+)(?:`)$/g,
    action: (model, vEditor, text, selection, pattern) => {
      const match = pattern.exec(text);
      if (!match) {
        return false;
      }
      const annotatedText = match[0];
      const startIndex = selection.index - annotatedText.length;
      if (text.match(/^([* \n]+)$/g)) {
        return false;
      }
      vEditor.insertText({
        index: startIndex + annotatedText.length,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: startIndex,
        length: annotatedText.length
      }, {
        code: true
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex + annotatedText.length - 1,
        length: 1
      });
      vEditor.deleteText({
        index: startIndex,
        length: 1
      });
      vEditor.setVRange({
        index: startIndex + annotatedText.length - 2,
        length: 0
      });
      return true;
    }
  },
  {
    name: "codeblock",
    pattern: /^```([a-zA-Z0-9]*)$/g,
    action: (model, vEditor, text, selection, pattern) => {
      var _a3;
      if (model.flavour === "affine:paragraph" && model.type === "quote") {
        return false;
      }
      const match = pattern.exec(text);
      const page = model.page;
      page.captureSync();
      const parent = page.getParent(model);
      assertExists(parent);
      const index = parent.children.indexOf(model);
      page.deleteBlock(model);
      const codeId = page.addBlock("affine:code", {
        language: ((_a3 = getStandardLanguage((match == null ? void 0 : match[1]) || "")) == null ? void 0 : _a3.id) ?? FALLBACK_LANG
      }, parent, index);
      const codeBlock = page.getBlockById(codeId);
      assertExists(codeBlock);
      asyncSetVRange(codeBlock, { index: 0, length: 0 });
      return true;
    }
  },
  {
    name: "link",
    pattern: /(?:\[(.+?)\])(?:\((.+?)\))$/g,
    action: (model, vEditor, text, selection, pattern) => {
      var _a3, _b, _c;
      const startIndex = text.search(pattern);
      const matchedText = (_a3 = text.match(pattern)) == null ? void 0 : _a3[0];
      const hrefText = (_b = text.match(/(?:\[(.*?)\])/g)) == null ? void 0 : _b[0];
      const hrefLink = (_c = text.match(/(?:\((.*?)\))/g)) == null ? void 0 : _c[0];
      if (startIndex === -1 || !matchedText || !hrefText || !hrefLink) {
        return false;
      }
      const start2 = selection.index - matchedText.length;
      vEditor.insertText({
        index: selection.index,
        length: 0
      }, " ");
      model.page.captureSync();
      vEditor.formatText({
        index: start2,
        length: hrefText.length
      }, {
        link: hrefLink.slice(1, hrefLink.length - 1)
      });
      vEditor.deleteText({
        index: selection.index + matchedText.length,
        length: 1
      });
      vEditor.deleteText({
        index: selection.index - hrefLink.length - 1,
        length: hrefLink.length + 1
      });
      vEditor.deleteText({
        index: start2,
        length: 1
      });
      vEditor.setVRange({
        index: start2 + hrefText.length - 1,
        length: 0
      });
      return true;
    }
  }
];
function markdownConvert(vEditor, model, prefix) {
  const vRange = vEditor.getVRange();
  if (!vRange) {
    return false;
  }
  for (const match of matches2) {
    const matchedText = prefix.match(match.pattern);
    if (matchedText) {
      return match.action(model, vEditor, prefix, vRange, match.pattern);
    }
  }
  return false;
}
function tryMatchSpaceHotkey(page, model, vEditor, prefix, range) {
  const [, offset2] = vEditor.getLine(range.index);
  if (offset2 > prefix.length) {
    return ALLOW_DEFAULT;
  }
  const isParagraphQuoteBlock = isEqual(model.type, "quote");
  const isCodeBlock = matchFlavours(model, ["affine:code"]);
  if (isParagraphQuoteBlock || isCodeBlock) {
    return ALLOW_DEFAULT;
  }
  let isConverted = false;
  switch (prefix.trim()) {
    case "[]":
    case "[ ]":
      isConverted = convertToList(page, model, "todo", prefix, {
        checked: false
      });
      break;
    case "[x]":
      isConverted = convertToList(page, model, "todo", prefix, {
        checked: true
      });
      break;
    case "-":
    case "*":
      isConverted = convertToList(page, model, "bulleted", prefix);
      break;
    case "***":
    case "---":
      isConverted = convertToDivider(page, model, prefix);
      break;
    case "#":
      isConverted = convertToParagraph(page, model, "h1", prefix);
      break;
    case "##":
      isConverted = convertToParagraph(page, model, "h2", prefix);
      break;
    case "###":
      isConverted = convertToParagraph(page, model, "h3", prefix);
      break;
    case "####":
      isConverted = convertToParagraph(page, model, "h4", prefix);
      break;
    case "#####":
      isConverted = convertToParagraph(page, model, "h5", prefix);
      break;
    case "######":
      isConverted = convertToParagraph(page, model, "h6", prefix);
      break;
    case ">":
      isConverted = convertToParagraph(page, model, "quote", prefix);
      break;
    default:
      isConverted = convertToList(page, model, "numbered", prefix);
  }
  return isConverted ? PREVENT_DEFAULT : ALLOW_DEFAULT;
}

// node_modules/@blocksuite/blocks/dist/__internal__/service/keymap.js
function onSoftEnter(model, range, vEditor) {
  handleSoftEnter(model.page, model, range.index, range.length);
  vEditor.setVRange({
    index: range.index + 1,
    length: 0
  });
  return PREVENT_DEFAULT;
}
function hardEnter(model, range, vEditor, e, shortKey = false) {
  const page = model.page;
  e.stopPropagation();
  const parent = page.getParent(model);
  const isLastChild = (parent == null ? void 0 : parent.lastChild()) === model;
  const isEmptyList = matchFlavours(model, ["affine:list"]) && model.text.length === 0;
  assertExists(model.text, "Failed to hardEnter! model.text not exists!");
  if (isEmptyList && parent && matchFlavours(parent, ["affine:frame", "affine:database"]) && model.children.length === 0) {
    handleLineStartBackspace(page, model);
    return PREVENT_DEFAULT;
  }
  if (isEmptyList && isLastChild) {
    handleUnindent(page, model, range.index);
    return PREVENT_DEFAULT;
  }
  const isEnd = model.text.length === range.index;
  if (isEnd || shortKey) {
    const softEnterable = isSoftEnterable(model);
    const textStr = model.text.toString();
    const endWithTwoBlankLines = textStr === "\n" || textStr.endsWith("\n");
    const shouldSoftEnter = softEnterable && !endWithTwoBlankLines;
    if (shouldSoftEnter) {
      onSoftEnter(model, range, vEditor);
      return PREVENT_DEFAULT;
    }
    if (softEnterable) {
      model.text.delete(range.index - 1, 1);
    }
    handleBlockEndEnter(page, model);
    return PREVENT_DEFAULT;
  }
  const isSoftEnterBlock = isSoftEnterable(model);
  if (isSoftEnterBlock) {
    onSoftEnter(model, range, vEditor);
    return PREVENT_DEFAULT;
  }
  handleBlockSplit(page, model, range.index, range.length);
  return PREVENT_DEFAULT;
}
function isSoftEnterable(model) {
  if (matchFlavours(model, ["affine:code"]))
    return true;
  if (matchFlavours(model, ["affine:paragraph"])) {
    return model.type === "quote";
  }
  return false;
}
function enterMarkdownMatch(model, virgo, range, context) {
  const { prefix } = context;
  markdownConvert(virgo, model, prefix);
  return ALLOW_DEFAULT;
}
function spaceMarkdownMatch(model, virgo, range, context) {
  const { prefix } = context;
  return markdownConvert(virgo, model, prefix) ? PREVENT_DEFAULT : ALLOW_DEFAULT;
}
function onSpace(model, virgo, range, context) {
  const { prefix } = context;
  return tryMatchSpaceHotkey(model.page, model, virgo, prefix, range);
}
function onBackspace(model, e, vEditor) {
  e.stopPropagation();
  if (isCollapsedAtBlockStart(vEditor)) {
    handleLineStartBackspace(model.page, model);
    return PREVENT_DEFAULT;
  }
  return ALLOW_DEFAULT;
}
function onKeyLeft(e, range) {
  if (range.length !== 0) {
    e.stopPropagation();
    return ALLOW_DEFAULT;
  }
  const lineStart = range.index === 0;
  if (!lineStart) {
    e.stopPropagation();
    return ALLOW_DEFAULT;
  }
  return PREVENT_DEFAULT;
}
function onKeyRight(model, e, range) {
  if (range.length !== 0) {
    e.stopPropagation();
    return ALLOW_DEFAULT;
  }
  assertExists(model.text, "Failed to onKeyRight! model.text not exists!");
  const textLength = model.text.length;
  const lineEnd = textLength === range.index;
  if (!lineEnd) {
    e.stopPropagation();
    return ALLOW_DEFAULT;
  }
  return PREVENT_DEFAULT;
}

// node_modules/@blocksuite/blocks/dist/__internal__/service/index.js
var BaseService = class _BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    var _a3;
    const delta = ((_a3 = block2.text) == null ? void 0 : _a3.sliceToDelta(begin || 0, end2)) || [];
    const text = delta.reduce((html3, item) => {
      return html3 + _BaseService.deltaLeaf2Html(block2, item);
    }, "");
    return `${text}${childText}`;
  }
  block2Text(block2, { childText = "", begin = 0, end: end2 } = {}) {
    var _a3;
    const text = (((_a3 = block2.text) == null ? void 0 : _a3.toString()) || "").slice(begin, end2);
    return `${text}${childText}`;
  }
  block2Json(block2, begin, end2) {
    var _a3, _b;
    const delta = ((_a3 = block2.text) == null ? void 0 : _a3.sliceToDelta(begin || 0, end2)) || [];
    return {
      flavour: block2.flavour,
      type: block2.type,
      text: delta,
      children: (_b = block2.children) == null ? void 0 : _b.map((child, index) => {
        if (index === block2.children.length - 1) {
          return getService(child.flavour).block2Json(child, 0, end2);
        }
        return getService(child.flavour).block2Json(child);
      })
    };
  }
  // json2block is triggered when paste behavior occurs(now),
  // at this time cursor is focus on one block, and is must a caret in this block(since selection has been handled in paste callback)
  // this is the common handler for most block, but like code block, it should be overridden this
  async json2Block(focusedBlockModel, pastedBlocks, range) {
    return json2block(focusedBlockModel, pastedBlocks, { range });
  }
  async onBlockPasted(model, clipboardData) {
  }
  static deltaLeaf2Html(block2, deltaLeaf) {
    let text = deltaLeaf.insert ?? "";
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    const attributes = deltaLeaf.attributes;
    if (!attributes) {
      return text;
    }
    if (attributes.code) {
      text = `<code>${text}</code>`;
    }
    if (attributes.bold) {
      text = `<strong>${text}</strong>`;
    }
    if (attributes.italic) {
      text = `<em>${text}</em>`;
    }
    if (attributes.underline) {
      text = `<u>${text}</u>`;
    }
    if (attributes.strikethrough) {
      text = `<s>${text}</s>`;
    }
    if (attributes.link) {
      text = `<a href="${attributes.link}">${text}</a>`;
    }
    if (attributes.reference) {
      const refPageId = attributes.reference.pageId;
      const workspace = block2.page.workspace;
      const pageMeta = workspace.meta.pageMetas.find((page) => page.id === refPageId);
      const host = window.location.origin;
      const referenceLink = `${host}/workspace/${workspace.id}/${refPageId}`;
      const referenceTitle = pageMeta ? pageMeta.title : "Deleted page";
      text = `<a href="${referenceLink}">${referenceTitle}</a>`;
    }
    return text;
  }
  /**
   * side effect when update block
   */
  async updateEffect(block2) {
    const handleUnindent2 = (await import("./rich-text-operations-DLQ4ZCMI.js")).handleUnindent;
    if (supportsChildren(block2)) {
      return;
    }
    if (!block2.children.length) {
      return;
    }
    handleUnindent2(block2.page, block2.children[0], 0, false);
  }
  defineKeymap(block2, virgo) {
    return {
      enterMarkdownMatch: {
        key: "Enter",
        handler: (range, context) => {
          assertExists(virgo);
          return enterMarkdownMatch(block2, virgo, range, context);
        }
      },
      spaceMarkdownMatch: {
        key: " ",
        handler(range, context) {
          assertExists(virgo);
          return spaceMarkdownMatch(block2, virgo, range, context);
        }
      },
      hardEnter: {
        key: "Enter",
        handler(range, context) {
          assertExists(virgo);
          return hardEnter(block2, range, virgo, context.event);
        }
      },
      softEnter: {
        key: "Enter",
        shiftKey: true,
        handler(range, context) {
          assertExists(virgo);
          return onSoftEnter(block2, range, virgo);
        }
      },
      // shortKey+enter
      insertLineAfter: {
        key: "Enter",
        shortKey: true,
        handler(range, context) {
          assertExists(virgo);
          return hardEnter(block2, range, virgo, context.event, true);
        }
      },
      tab: {
        key: "Tab",
        handler(range, context) {
          const index = range.index;
          handleIndent(block2.page, block2, index);
          context.event.stopPropagation();
          return PREVENT_DEFAULT;
        }
      },
      shiftTab: {
        key: "Tab",
        shiftKey: true,
        handler(range, context) {
          const index = range.index;
          handleUnindent(block2.page, block2, index);
          context.event.stopPropagation();
          return PREVENT_DEFAULT;
        }
      },
      backspace: {
        key: "Backspace",
        handler(range, context) {
          return onBackspace(block2, context.event, this.vEditor);
        }
      },
      up: {
        key: "ArrowUp",
        shiftKey: false,
        handler(range, context) {
          return handleKeyUp(context.event, this.vEditor.rootElement);
        }
      },
      down: {
        key: "ArrowDown",
        shiftKey: false,
        handler(range, context) {
          return handleKeyDown(block2, context.event, this.vEditor.rootElement);
        }
      },
      left: {
        key: "ArrowLeft",
        shiftKey: false,
        handler(range, context) {
          return onKeyLeft(context.event, range);
        }
      },
      right: {
        key: "ArrowRight",
        shiftKey: false,
        handler(range, context) {
          return onKeyRight(block2, context.event, range);
        }
      },
      inputRule: {
        key: " ",
        shiftKey: null,
        prefix: /^(\d+\.|-|\*|\[ ?\]|\[x\]|(#){1,6}|(-){3}|(\*){3}|>)$/,
        handler(range, context) {
          return onSpace(block2, virgo, range, context);
        }
      }
    };
  }
};

// node_modules/@blocksuite/blocks/dist/page-block/page-service.js
var PageBlockService = class extends BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    return `<div>${block2.title.toString()}${childText}</div>`;
  }
  block2Text(block2, { childText = "", begin, end: end2 } = {}) {
    const text = (block2.title.toString() || "").slice(begin || 0, end2);
    return `${text}${childText}`;
  }
  // todo we don't support link and database in page block title
  _getAllSubTexts(block2) {
    if (block2.flavour === "affine:database") {
      return [];
    }
    const texts = (block2.text || []).filter((text) => {
      var _a3;
      return !((_a3 = text.attributes) == null ? void 0 : _a3.link);
    });
    if (block2.children) {
      block2.children.forEach((child) => {
        texts.push(...this._getAllSubTexts(child));
      });
    }
    return texts;
  }
  async json2Block(focusedBlockModel, pastedBlocks) {
    if (pastedBlocks.length > 0 && (pastedBlocks[0].children.length === 0 || pastedBlocks[0].flavour === "affine:page")) {
      const titles = this._getAllSubTexts(pastedBlocks[0]);
      focusedBlockModel.title.applyDelta(titles);
      pastedBlocks = pastedBlocks.slice(1);
    }
    const frameId = focusedBlockModel.page.addBlock("affine:frame", {}, focusedBlockModel.id);
    const frameModel = focusedBlockModel.page.getBlockById(frameId);
    assertExists(frameModel);
    const service = getService("affine:frame");
    return service.json2Block(frameModel, pastedBlocks);
  }
};

// node_modules/@blocksuite/blocks/dist/counter-block/counter-block.js
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CounterBlock = class CounterBlock2 extends LitElement {
  constructor() {
    super();
    this.count = 0;
  }
  async _notify() {
    this.count++;
    await this.updateComplete;
    const options2 = {
      detail: this.count,
      bubbles: true,
      composed: true
    };
    this.dispatchEvent(new CustomEvent("block-count-update", options2));
  }
  render() {
    return html` <div @click=${this._notify}>${this.count}</div> `;
  }
};
__decorate43([
  property()
], CounterBlock.prototype, "count", void 0);
CounterBlock = __decorate43([
  customElement("counter-block")
], CounterBlock);

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/inline-suggestion.js
var InlineSuggestionController = class {
  constructor(host) {
    this._abortController = new AbortController();
    this._disposables = new DisposableGroup();
    this._suggestionState = {
      show: false,
      position: { x: 0, y: 0 },
      loading: false,
      text: ""
    };
    this.onFocusIn = (e) => {
      const inlineSuggestProvider = this.provider;
      if (!inlineSuggestProvider)
        return;
      assertExists(this.model);
      const editor = this.vEditor;
      assertExists(editor);
      this._disposables.add(editor.slots.vRangeUpdated.on(async ([vRange, type]) => {
        this._updateSuggestions(vRange);
      }));
    };
    this.onFocusOut = (e) => {
      this._abortController.abort();
      this._disposables.dispose();
      this._disposables = new DisposableGroup();
    };
    this._updateSuggestions = debounce(async (vRange) => {
      this._abortController.abort();
      this._abortController = new AbortController();
      assertExists(this.model);
      const editor = this.vEditor;
      assertExists(editor);
      const len3 = editor.yText.length;
      if (!len3 || vRange.length !== 0 || vRange.index !== len3) {
        return;
      }
      const pageBlock = this.model.page.root;
      assertExists(pageBlock);
      if (!matchFlavours(pageBlock, ["affine:page"])) {
        throw new Error("Invalid page root");
      }
      this._setSuggestionState({
        show: true,
        loading: true,
        position: this._updatePosition()
      });
      const text = this.model.text;
      assertExists(text);
      const textStr = text.toString();
      const title = pageBlock.title.toString();
      const abortController = this._abortController;
      abortController.signal.addEventListener("abort", () => {
        this._setSuggestionState({
          show: false,
          loading: false
        });
      });
      try {
        assertExists(this.provider);
        const suggestion = await this.provider({
          title,
          text: textStr,
          abortSignal: abortController.signal
        });
        if (abortController.signal.aborted) {
          this._setSuggestionState({
            show: false,
            loading: false
          });
          return;
        }
        requestAnimationFrame(() => {
          this._setSuggestionState({
            show: true,
            loading: false,
            text: suggestion,
            position: this._updatePosition()
          });
        });
      } catch (error) {
        console.error("Failed to get inline suggest", error);
        this._setSuggestionState({
          show: false,
          loading: false
        });
      }
    }, 300, { leading: false });
    this.onKeyDown = (e) => {
      if (!this._suggestionState.show || this._suggestionState.loading)
        return;
      if (e.isComposing || e.key !== "Tab") {
        requestAnimationFrame(() => {
          const position = this._updatePosition();
          this._setSuggestionState({
            position
          });
        });
        return;
      }
      const editor = this.vEditor;
      assertExists(editor);
      const vRange = editor.getVRange();
      if (!vRange)
        return;
      const suggestion = this._suggestionState.text;
      editor.insertText(vRange, suggestion);
      editor.setVRange({
        index: vRange.index + suggestion.length,
        length: 0
      });
      this._setSuggestionState({ text: "" });
      e.stopPropagation();
      e.preventDefault();
    };
    host.addController(this);
    this.host = host;
  }
  hostConnected() {
    this._disposables = new DisposableGroup();
  }
  hostDisconnected() {
    this._disposables.dispose();
  }
  init({ model, vEditor, provider }) {
    this.provider = provider;
    this.model = model;
    this.vEditor = vEditor;
  }
  _setSuggestionState(newState) {
    const previousState = this._suggestionState;
    this._suggestionState = { ...previousState, ...newState };
    this.host.requestUpdate();
  }
  _updatePosition() {
    const richTextRect = this.host.getBoundingClientRect();
    if (!hasNativeSelection())
      return;
    const range = getCurrentNativeRange();
    const rangeRect = range.getBoundingClientRect();
    return {
      x: rangeRect.x - richTextRect.x,
      y: -rangeRect.height
    };
  }
  render() {
    if (!this._suggestionState.show)
      return nothing;
    const text = this._suggestionState.loading ? "..." : this._suggestionState.text;
    const position = this._suggestionState.position;
    if (!text)
      return nothing;
    return html`<div
      class="inline-suggestion"
      style="text-indent: ${position.x + 2}px;"
    >
      ${text}
    </div>`;
  }
};
InlineSuggestionController.styles = css`
    .inline-suggestion {
      display: flex;
      align-items: center;
      gap: 4px;
      left: 0;
      top: 0;
      color: var(--affine-placeholder-color);
      fill: var(--affine-placeholder-color);
      margin-bottom: calc(-1 * var(--affine-line-height));
      transform: translateY(calc(-1 * var(--affine-line-height)));
      pointer-events: none;
    }
  `;

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/bracket-complete.js
var bracketPairs = [
  {
    name: "parenthesis",
    left: "(",
    right: ")"
  },
  {
    name: "square bracket",
    left: "[",
    right: "]"
  },
  {
    name: "curly bracket",
    left: "{",
    right: "}"
  },
  {
    name: "single quote",
    left: "'",
    right: "'"
  },
  {
    name: "double quote",
    left: '"',
    right: '"'
  },
  // {
  //   name: 'backtick',
  //   left: '`',
  //   right: '`',
  // },
  {
    name: "angle bracket",
    left: "<",
    right: ">"
  },
  {
    name: "fullwidth single quote",
    left: "‘",
    right: "’"
  },
  {
    name: "fullwidth double quote",
    left: "“",
    right: "”"
  },
  {
    name: "fullwidth parenthesis",
    left: "（",
    right: "）"
  },
  {
    name: "fullwidth square bracket",
    left: "【",
    right: "】"
  },
  {
    name: "fullwidth angle bracket",
    left: "《",
    right: "》"
  },
  {
    name: "corner bracket",
    left: "「",
    right: "」"
  },
  {
    name: "white corner bracket",
    left: "『",
    right: "』"
  }
];
function createBracketAutoCompleteBindings(model) {
  const bindings = {};
  bracketPairs.forEach((pair) => {
    bindings[pair.name] = {
      key: pair.left,
      // Input some brackets need to press shift key
      shiftKey: null,
      collapsed: false,
      handler(range) {
        if (!model.text)
          return ALLOW_DEFAULT;
        model.text.insert(pair.left, range.index);
        model.text.insert(pair.right, range.index + range.length + 1);
        this.vEditor.setVRange({
          index: range.index + 1,
          length: range.length
        });
        return PREVENT_DEFAULT;
      }
    };
  });
  bindings["backtick"] = {
    key: "`",
    collapsed: false,
    handler(range, context) {
      if (!model.text)
        return ALLOW_DEFAULT;
      model.text.format(range.index, range.length, { code: true });
      this.vEditor.setVRange({
        index: range.index,
        length: range.length
      });
      return PREVENT_DEFAULT;
    }
  };
  return bindings;
}

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/keyboard.js
function createKeyboardBindings(model, vEditor) {
  const page = model.page;
  const service = getService(model.flavour);
  const blockKeyBinding = service.defineKeymap(model, vEditor);
  const keyboardBindings = {
    ...blockKeyBinding,
    linkedPage: {
      key: ["[", "【", "@"],
      altKey: null,
      shiftKey: null,
      handler(range, { event, prefix }) {
        if (range.length > 0) {
          return ALLOW_DEFAULT;
        }
        if ((event.key === "[" || event.key === "【") && !prefix.endsWith(event.key)) {
          return ALLOW_DEFAULT;
        }
        const flag = page.awarenessStore.getFlag("enable_linked_page");
        if (!flag)
          return ALLOW_DEFAULT;
        if (matchFlavours(model, ["affine:code"])) {
          return ALLOW_DEFAULT;
        }
        this.vEditor.slots.rangeUpdated.once(() => {
          if (event.key === "[" || event.key === "【") {
            this.vEditor.deleteText({ index: range.index - 1, length: 2 });
            this.vEditor.insertText({ index: range.index - 1, length: 0 }, "@");
            this.vEditor.setVRange({ index: range.index, length: 0 });
            this.vEditor.slots.rangeUpdated.once(() => {
              const curRange2 = getCurrentNativeRange();
              showLinkedPagePopover({ model, range: curRange2 });
            });
            return;
          }
          const curRange = getCurrentNativeRange();
          showLinkedPagePopover({ model, range: curRange });
        });
        return ALLOW_DEFAULT;
      }
    },
    slash: {
      key: [
        "/",
        // Compatible with CJK IME
        "、"
      ],
      shiftKey: null,
      // prefix non digit or empty string
      // see https://stackoverflow.com/questions/19127384/what-is-a-regex-to-match-only-an-empty-string
      // prefix: /[^\d]$|^(?![\s\S])/,
      handler(range, context) {
        const flag = page.awarenessStore.getFlag("enable_slash_menu");
        if (!flag) {
          return ALLOW_DEFAULT;
        }
        if (matchFlavours(model, ["affine:code"])) {
          return ALLOW_DEFAULT;
        }
        this.vEditor.slots.rangeUpdated.once(() => {
          const curRange = getCurrentNativeRange();
          showSlashMenu({ model, range: curRange });
        });
        return ALLOW_DEFAULT;
      }
    },
    ...createBracketAutoCompleteBindings(model)
  };
  return keyboardBindings;
}
var SHORT_KEY_PROPERTY = IS_IOS || IS_MAC ? "metaKey" : "ctrlKey";
function createKeyDownHandler(vEditor, bindings, model) {
  const bindingStore = {};
  function normalize2(binding) {
    if (binding.shortKey) {
      binding[SHORT_KEY_PROPERTY] = binding.shortKey;
      delete binding.shortKey;
    }
    return binding;
  }
  function match(evt, binding) {
    if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some((key) => {
      return !!binding[key] !== evt[key] && binding[key] !== null;
    })) {
      return false;
    }
    return binding.key === evt.key || binding.key === evt.which;
  }
  function addBinding(keyBinding) {
    const binding = normalize2(keyBinding);
    const keys = Array.isArray(binding.key) ? binding.key : [binding.key];
    keys.forEach((key) => {
      const singleBinding = {
        ...binding,
        key
      };
      bindingStore[key] = bindingStore[key] ?? [];
      bindingStore[key].push(singleBinding);
    });
  }
  Object.values(bindings).forEach((binding) => {
    addBinding(binding);
  });
  function keyDownHandler(evt) {
    const parentModel = model.page.getParent(model);
    const previousModel = model.page.getPreviousSibling(model);
    if (parentModel && matchFlavours(parentModel, ["affine:database"]) || previousModel && matchFlavours(previousModel, ["affine:database"])) {
      if (evt.key === "Tab") {
        evt.preventDefault();
        evt.stopPropagation();
        return;
      }
    }
    if (evt.defaultPrevented || evt.isComposing)
      return;
    const keyBindings = (bindingStore[evt.key] || []).concat(bindingStore[evt.which] || []);
    const matches3 = keyBindings.filter((binding) => match(evt, binding));
    if (matches3.length === 0)
      return;
    const vRange = vEditor.getVRange();
    if (!vRange)
      return;
    if (!hasNativeSelection())
      return;
    const range = getCurrentNativeRange();
    if (!range)
      return;
    if (!vEditor.rootElement.contains(range.startContainer) || !vEditor.rootElement.contains(range.endContainer)) {
      return;
    }
    const [line2, offset2] = vEditor.getLine(vRange.index);
    const [leafStart, offsetStart] = vEditor.getTextPoint(vRange.index);
    const [leafEnd, offsetEnd] = vRange.length === 0 ? [leafStart, offsetStart] : vEditor.getTextPoint(vRange.index + vRange.length);
    const prefixText = leafStart.textContent ? leafStart.textContent.slice(0, offsetStart) : "";
    const suffixText = leafEnd.textContent ? leafEnd.textContent.slice(offsetEnd) : "";
    const curContext = {
      collapsed: vRange.length === 0,
      empty: vRange.length === 0 && line2.textLength <= 1,
      format: vEditor.getFormat(vRange),
      line: line2,
      offset: offset2,
      prefix: prefixText,
      suffix: suffixText,
      event: evt
    };
    const prevented = matches3.some((binding) => {
      if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {
        return false;
      }
      if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {
        return false;
      }
      if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {
        return false;
      }
      return !binding.handler.call({
        vEditor,
        options: {
          bindings
        }
      }, vRange, curContext);
    });
    if (prevented) {
      evt.preventDefault();
    }
  }
  return keyDownHandler;
}

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/virgo/types.js
var affineTextAttributes = baseTextAttributes.extend({
  reference: z.object({
    type: z.enum(["Subpage", "LinkedPage"]),
    pageId: z.string()
  }).optional()
});

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/rich-text.js
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IGNORED_ATTRIBUTES = ["code", "reference"];
var autoIdentifyLink = (editor, context) => {
  var _a3, _b, _c;
  const vRange = editor.getVRange();
  if (!vRange)
    return;
  if (((_a3 = context.attributes) == null ? void 0 : _a3.link) && context.data === " ") {
    delete context.attributes["link"];
    return;
  }
  const linkPattern = /.*\.(com|cn|org|edu|net|gov|mil|info|biz|io|me)(\/\S*)?$/i;
  if ((_b = context.attributes) == null ? void 0 : _b.link) {
    const linkDeltaInfo = editor.deltaService.getDeltasByVRange(vRange).filter(([delta2]) => {
      var _a4;
      return (_a4 = delta2.attributes) == null ? void 0 : _a4.link;
    })[0];
    const [delta, { index, length: length2 }] = linkDeltaInfo;
    const rangePositionInDelta = vRange.index - index;
    if (((_c = delta.attributes) == null ? void 0 : _c.link) !== delta.insert) {
      if (rangePositionInDelta === length2) {
        delete context.attributes["link"];
        return;
      }
      return;
    }
    const newText = delta.insert.slice(0, rangePositionInDelta) + context.data + delta.insert.slice(rangePositionInDelta);
    const match2 = linkPattern.exec(newText);
    if (!match2) {
      editor.resetText({ index, length: length2 });
      delete context.attributes["link"];
      return;
    }
    editor.formatText({
      index,
      length: length2
    }, {
      link: newText
    });
    context.attributes = {
      ...context.attributes,
      link: newText
    };
    return;
  }
  const [line2] = editor.getLine(vRange.index);
  const prefixText = line2.textContent.slice(0, vRange.index);
  const match = linkPattern.exec(prefixText + context.data);
  if (!match) {
    return;
  }
  const linkText = match[0];
  const startIndex = vRange.index - linkText.length;
  editor.formatText({
    index: startIndex,
    length: linkText.length
  }, {
    link: linkText
  });
  context.attributes = {
    ...context.attributes,
    link: linkText
  };
};
var RichText = class RichText2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this._vEditor = null;
    this._inlineSuggestController = new InlineSuggestionController(this);
  }
  get virgoContainer() {
    return this._virgoContainer;
  }
  get vEditor() {
    return this._vEditor;
  }
  firstUpdated() {
    assertExists(this.model.text, "rich-text need text to init.");
    this._vEditor = new VEditor(this.model.text.yText, {
      active: () => activeEditorManager.isActive(this)
    });
    setupVirgoScroll(this.model.page, this._vEditor);
    const textSchema = this.textSchema;
    assertExists(textSchema, "Failed to render rich-text! textSchema not found");
    this._vEditor.setAttributeSchema(textSchema.attributesSchema);
    this._vEditor.setAttributeRenderer(textSchema.textRenderer());
    const keyboardBindings = createKeyboardBindings(this.model, this._vEditor);
    const keyDownHandler = createKeyDownHandler(this._vEditor, keyboardBindings, this.model);
    let ifPrefixSpace = false;
    this._vEditor.mount(this._virgoContainer);
    this._vEditor.bindHandlers({
      keydown: keyDownHandler,
      virgoInput: (ctx) => {
        const vEditor = this._vEditor;
        assertExists(vEditor);
        const vRange = vEditor.getVRange();
        if (!vRange || vRange.length !== 0) {
          return ctx;
        }
        const { data, event } = ctx;
        const deltas = vEditor.getDeltasByVRange(vRange);
        if (event.inputType === "insertText" && data === " ") {
          ifPrefixSpace = true;
        } else if (data !== ". " && data !== "。 ") {
          ifPrefixSpace = false;
        }
        if (ifPrefixSpace && (data === ". " || data === "。 ")) {
          ctx.data = " ";
        }
        if (data && data.length > 0 && data !== "\n") {
          if (deltas.length > 1 || deltas.length === 1 && vRange.index !== 0) {
            const { attributes } = deltas[0][0];
            if (deltas.length !== 1 || vRange.index === vEditor.yText.length) {
              IGNORED_ATTRIBUTES.forEach((attr) => {
                attributes == null ? true : delete attributes[attr];
              });
            }
            ctx.attributes = attributes ?? null;
          }
        }
        autoIdentifyLink(vEditor, ctx);
        return ctx;
      },
      virgoCompositionEnd: (ctx) => {
        const vEditor = this._vEditor;
        assertExists(vEditor);
        const vRange = vEditor.getVRange();
        if (!vRange || vRange.length !== 0) {
          return ctx;
        }
        const { data } = ctx;
        const deltas = vEditor.getDeltasByVRange(vRange);
        if (data && data.length > 0 && data !== "\n") {
          if (deltas.length > 1 || deltas.length === 1 && vRange.index !== 0) {
            const attributes = deltas[0][0].attributes;
            if (deltas.length !== 1 || vRange.index === vEditor.yText.length) {
              IGNORED_ATTRIBUTES.forEach((attr) => {
                attributes == null ? true : delete attributes[attr];
              });
            }
            ctx.attributes = attributes ?? null;
          }
        }
        autoIdentifyLink(vEditor, ctx);
        return ctx;
      }
    });
    this._vEditor.setReadonly(this.model.page.readonly);
    const inlineSuggestionProvider = this.model.page.workspace.inlineSuggestionProvider;
    if (inlineSuggestionProvider) {
      this._inlineSuggestController.init({
        provider: inlineSuggestionProvider,
        model: this.model,
        vEditor: this._vEditor
      });
    }
  }
  updated() {
    if (this._vEditor) {
      this._vEditor.setReadonly(this.model.page.readonly);
    }
  }
  render() {
    return html`<div
        class="affine-rich-text virgo-editor"
        @keydown=${this._inlineSuggestController.onKeyDown}
        @focusin=${this._inlineSuggestController.onFocusIn}
        @focusout=${this._inlineSuggestController.onFocusOut}
      ></div>
      ${this._inlineSuggestController.render()}`;
  }
};
RichText.styles = css`
    .affine-rich-text {
      height: 100%;
      width: 100%;
      outline: none;
      cursor: text;
    }

    v-line {
      scroll-margin-top: 50px;
      scroll-margin-bottom: 30px;
    }

    ${InlineSuggestionController.styles}
  `;
__decorate44([
  query(".affine-rich-text")
], RichText.prototype, "_virgoContainer", void 0);
__decorate44([
  property()
], RichText.prototype, "model", void 0);
__decorate44([
  property()
], RichText.prototype, "textSchema", void 0);
RichText = __decorate44([
  customElement("rich-text")
], RichText);

// node_modules/@blocksuite/blocks/dist/__internal__/rich-text/virgo/attribute-renderer.js
var attributeRenderer = () => (delta) => {
  const defaultTemplate = html`<affine-text .delta=${delta}></affine-text>`;
  if (!delta.attributes) {
    return defaultTemplate;
  }
  const attributes = delta.attributes;
  if (attributes.link) {
    if (attributes.reference) {
      console.error("Invalid attributes: link and reference cannot be used together", delta);
    }
    return html`<affine-link .delta=${delta}></affine-link>`;
  }
  if (attributes.reference) {
    return html`${repeat(Array.from(delta.insert).map((_, index) => ({
      delta: {
        insert: REFERENCE_NODE,
        attributes
      },
      index
    })), (item) => item.index, (item) => html`<affine-reference .delta=${item.delta}></affine-reference>`)}`;
  }
  return defaultTemplate;
};

// node_modules/@blocksuite/blocks/dist/paragraph-block/paragraph-service.js
var ParagraphBlockService = class extends BaseService {
  block2html(model, { childText = "", begin, end: end2 } = {}) {
    const text = super.block2html(model, {
      childText,
      begin,
      end: end2
    });
    switch (model.type) {
      case "text":
        return `<p>${text}</p>`;
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        return `<${model.type}>${text}</${model.type}>`;
      case "quote":
        return `<blockquote>${text}</blockquote>`;
      default:
        return text;
    }
  }
  async json2Block(focusedBlockModel, pastedBlocks, range) {
    const convertToPastedIfEmpty = focusedBlockModel.type !== "text";
    return json2block(focusedBlockModel, pastedBlocks, {
      range,
      convertToPastedIfEmpty
    });
  }
};
var paragraph_service_default = ParagraphBlockService;

// node_modules/@blocksuite/blocks/dist/paragraph-block/paragraph-block.js
var __decorate45 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function tipsPlaceholderPreventDefault(event) {
  event.preventDefault();
}
function TipsPlaceholder(model, tipsPos) {
  if (!matchFlavours(model, ["affine:paragraph"])) {
    throw new Error("TipsPlaceholder can't be used for this model");
  }
  if (model.type === "text") {
    if (!isPageMode(model.page)) {
      return html`<div class="tips-placeholder" style=${styleMap(tipsPos)}>
        Type '/' for commands
      </div> `;
    }
    const blockHub = document.querySelector("affine-block-hub");
    if (!blockHub) {
      return html`<div class="tips-placeholder" style=${styleMap(tipsPos)}>
        Type '/' for commands
      </div>`;
    }
    const onClick = () => {
      if (!blockHub) {
        throw new Error("Failed to find blockHub!");
      }
      blockHub.toggleMenu();
    };
    return html`
      <div
        class="tips-placeholder"
        @click=${onClick}
        @pointerdown=${tipsPlaceholderPreventDefault}
        style=${styleMap(tipsPos)}
      >
        Click ${BlockHubIcon20} to insert blocks, type '/' for commands
      </div>
    `;
  }
  const placeholders = {
    h1: "Heading 1",
    h2: "Heading 2",
    h3: "Heading 3",
    h4: "Heading 4",
    h5: "Heading 5",
    h6: "Heading 6",
    quote: ""
  };
  return html`<div class="tips-placeholder">${placeholders[model.type]}</div> `;
}
var ParagraphBlockComponent = class ParagraphBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this.tipsPos = { top: "50%", transform: "translateY(-50%)", left: "2px" };
    this._tipsPlaceholderTemplate = html``;
    this._isComposing = false;
    this._isFocus = false;
    this.textSchema = {
      attributesSchema: affineTextAttributes,
      textRenderer: attributeRenderer
    };
    this._placeholderDisposables = new DisposableGroup();
    this._updatePlaceholder = () => {
      var _a3;
      if (this.model.text.length !== 0 || this._isComposing) {
        this._tipsPlaceholderTemplate = html``;
        return;
      }
      if (this.model.type === "text" && !this._isFocus) {
        this._tipsPlaceholderTemplate = html``;
        return;
      }
      if (this._richTextElement) {
        const parentRect = (_a3 = this._richTextElement.parentElement) == null ? void 0 : _a3.getBoundingClientRect();
        const rect = this._richTextElement.getBoundingClientRect();
        const relativeTop = rect.top - parentRect.top;
        const relativeLeft = rect.left - parentRect.left;
        this.tipsPos = {
          top: `${relativeTop}px`,
          transform: "",
          left: `${relativeLeft + 2}px`
        };
      }
      this._tipsPlaceholderTemplate = TipsPlaceholder(this.model, this.tipsPos);
    };
    this._onFocusIn = (e) => {
      this._isFocus = true;
      this._updatePlaceholder();
      this.model.text.yText.observe(this._updatePlaceholder);
      this._placeholderDisposables.add(() => this.model.text.yText.unobserve(this._updatePlaceholder));
      this._placeholderDisposables.addFromEvent(this, "compositionstart", () => {
        this._isComposing = true;
        this._updatePlaceholder();
      });
      this._placeholderDisposables.addFromEvent(this, "compositionend", () => {
        this._isComposing = false;
        this._updatePlaceholder();
      });
    };
    this._onFocusOut = (e) => {
      this._isFocus = false;
      this._updatePlaceholder();
      this._placeholderDisposables.dispose();
      this._placeholderDisposables = new DisposableGroup();
    };
    this.isInDatabase = () => {
      let parent = this.parentElement;
      while (parent && parent !== document.body) {
        if (parent.tagName.toLowerCase() === "affine-database") {
          return true;
        }
        parent = parent.parentElement;
      }
      return false;
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this._updatePlaceholder();
    registerService("affine:paragraph", paragraph_service_default);
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => {
      this._updatePlaceholder();
      this.requestUpdate();
    });
    this.model.childrenUpdated.on(() => this.requestUpdate());
  }
  render() {
    const { type } = this.model;
    const tipsPlaceholderTemplate = this.isInDatabase() ? "" : this._tipsPlaceholderTemplate;
    const children = html`<div
      class="affine-block-children-container"
      style="padding-left: ${BLOCK_CHILDREN_CONTAINER_PADDING_LEFT}px"
    >
      ${this.content}
    </div>`;
    return html`
      <div class="affine-paragraph-block-container ${type}">
        ${tipsPlaceholderTemplate}
        <rich-text
          .model=${this.model}
          .textSchema=${this.textSchema}
          @focusin=${this._onFocusIn}
          @focusout=${this._onFocusOut}
          style=${styleMap({
      fontWeight: /^h[1-6]$/.test(type) ? "600" : void 0
    })}
        ></rich-text>
        ${children}
      </div>
    `;
  }
};
ParagraphBlockComponent.styles = css`
    .affine-paragraph-block-container {
      position: relative;
      border-radius: 5px;
    }
    .affine-paragraph-block-container.selected {
      background-color: var(--affine-hover-color);
    }
    .h1 {
      font-size: var(--affine-font-h-1);
      line-height: calc(1em + 12px);
      margin-top: calc(var(--affine-paragraph-space) + 24px);
    }
    .h1 code {
      font-size: calc(var(--affine-font-base) + 8px);
    }
    .h2 {
      font-size: var(--affine-font-h-2);
      line-height: calc(1em + 10px);
      margin-top: calc(var(--affine-paragraph-space) + 20px);
    }
    .h2 code {
      font-size: calc(var(--affine-font-base) + 6px);
    }
    .h3 {
      font-size: var(--affine-font-h-3);
      line-height: calc(1em + 8px);
      margin-top: calc(var(--affine-paragraph-space) + 16px);
    }
    .h3 code {
      font-size: calc(var(--affine-font-base) + 4px);
    }
    .h4 {
      font-size: var(--affine-font-h-4);
      line-height: calc(1em + 10px);
      margin-top: calc(var(--affine-paragraph-space) + 12px);
    }
    .h4 code {
      font-size: calc(var(--affine-font-base) + 2px);
    }
    .h5 {
      font-size: var(--affine-font-h-5);
      line-height: calc(1em + 8px);
      margin-top: calc(var(--affine-paragraph-space) + 8px);
    }
    .h5 code {
      font-size: calc(var(--affine-font-base));
    }
    .h6 {
      font-size: var(--affine-font-h-6);
      line-height: calc(1em + 8px);
      margin-top: calc(var(--affine-paragraph-space) + 4px);
    }
    .h6 code {
      font-size: calc(var(--affine-font-base) - 2px);
    }
    .quote {
      line-height: 26px;
      padding-left: 12px;
      margin-top: var(--affine-paragraph-space);
      position: relative;
    }
    .quote::after {
      content: '';
      width: 4px;
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
      background: var(--affine-quote-color);
      border-radius: 4px;
    }
    .text {
      margin-top: var(--affine-paragraph-space);
      font-size: var(--affine-font-base);
    }

    .tips-placeholder {
      position: absolute;
      display: flex;
      align-items: center;
      gap: 4px;
      pointer-events: none;
      color: var(--affine-placeholder-color);
      fill: var(--affine-placeholder-color);
    }

    .tips-placeholder > svg {
      cursor: pointer;
      pointer-events: all;
    }
    .tips-placeholder > svg:hover {
      fill: var(--affine-primary-color);
    }
  `;
__decorate45([
  state()
], ParagraphBlockComponent.prototype, "tipsPos", void 0);
__decorate45([
  state()
], ParagraphBlockComponent.prototype, "_tipsPlaceholderTemplate", void 0);
__decorate45([
  state()
], ParagraphBlockComponent.prototype, "_isComposing", void 0);
__decorate45([
  state()
], ParagraphBlockComponent.prototype, "_isFocus", void 0);
__decorate45([
  query("rich-text")
], ParagraphBlockComponent.prototype, "_richTextElement", void 0);
ParagraphBlockComponent = __decorate45([
  customElement("affine-paragraph")
], ParagraphBlockComponent);

// node_modules/@blocksuite/blocks/dist/paragraph-block/paragraph-model.js
var ParagraphBlockSchema = defineBlockSchema({
  flavour: "affine:paragraph",
  props: (internal) => ({
    type: "text",
    text: internal.Text()
  }),
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-paragraph`,
    parent: [
      "affine:frame",
      "affine:database",
      "affine:paragraph",
      "affine:list"
    ]
  }
});

// node_modules/@blocksuite/blocks/dist/list-block/list-service.js
var ListBlockService = class extends BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    let text = super.block2html(block2, {
      childText,
      begin,
      end: end2
    });
    const previousSiblingBlock = block2.page.getPreviousSibling(block2);
    const nextSiblingBlock = block2.page.getNextSibling(block2);
    switch (block2.type) {
      case "bulleted":
      case "toggle":
        text = `<li>${text}</li>`;
        break;
      case "numbered":
        text = `<li>${text}</li>`;
        break;
      case "todo":
        text = `<li><input disabled type="checkbox" ${block2.checked ? "checked" : ""}>${text}</li>`;
        break;
      default:
        break;
    }
    if ((previousSiblingBlock == null ? void 0 : previousSiblingBlock.flavour) !== block2.flavour || previousSiblingBlock.type !== block2.type) {
      switch (block2.type) {
        case "bulleted":
        case "toggle":
        case "todo":
          text = `<ul>${text}`;
          break;
        case "numbered":
          text = `<ol>${text}`;
          break;
        default:
          break;
      }
    }
    if ((nextSiblingBlock == null ? void 0 : nextSiblingBlock.flavour) !== block2.flavour || nextSiblingBlock.type !== block2.type) {
      switch (block2.type) {
        case "bulleted":
        case "toggle":
        case "todo":
          text = `${text}</ul>`;
          break;
        case "numbered":
          text = `${text}</ol>`;
          break;
        default:
          break;
      }
    }
    return text;
  }
  async json2Block(focusedBlockModel, pastedBlocks, range) {
    const convertToPastedIfEmpty = pastedBlocks[0].flavour !== "affine:list";
    return json2block(focusedBlockModel, pastedBlocks, {
      range,
      convertToPastedIfEmpty
    });
  }
};

// node_modules/@blocksuite/blocks/dist/list-block/utils/get-number-prefix.js
function number2letter(n) {
  const ordA = "a".charCodeAt(0);
  const ordZ = "z".charCodeAt(0);
  const len3 = ordZ - ordA + 1;
  let s = "";
  while (n >= 0) {
    s = String.fromCharCode(n % len3 + ordA) + s;
    n = Math.floor(n / len3) - 1;
  }
  return s;
}
function number2roman(num) {
  const lookup = {
    M: 1e3,
    CM: 900,
    D: 500,
    CD: 400,
    C: 100,
    XC: 90,
    L: 50,
    XL: 40,
    X: 10,
    IX: 9,
    V: 5,
    IV: 4,
    I: 1
  };
  let romanStr = "";
  for (const i in lookup) {
    while (num >= lookup[i]) {
      romanStr += i;
      num -= lookup[i];
    }
  }
  return romanStr;
}
function getPrefix(depth, index) {
  const map = [() => index + 1, number2letter, () => number2roman(index + 1)];
  return map[depth % map.length](index);
}
function getNumberPrefix(index, depth) {
  const prefix = getPrefix(depth, index);
  return `${prefix} .`;
}

// node_modules/@blocksuite/blocks/dist/list-block/utils/icons.js
var point1 = () => {
  return html`
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
      <circle cx="12" cy="12" r="2" />
    </svg>
  `;
};
var point2 = () => {
  return html`
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M12 13.5C12.8284 13.5 13.5 12.8284 13.5 12C13.5 11.1716 12.8284 10.5 12 10.5C11.1716 10.5 10.5 11.1716 10.5 12C10.5 12.8284 11.1716 13.5 12 13.5ZM12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14Z"
      />
    </svg>
  `;
};
var point3 = () => {
  return html`
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
      <path
        d="M11.6056 10.1634C11.8234 9.94555 12.1766 9.94555 12.3944 10.1634L13.8366 11.6056C14.0545 11.8234 14.0545 12.1766 13.8366 12.3944L12.3944 13.8366C12.1766 14.0545 11.8234 14.0545 11.6056 13.8366L10.1634 12.3944C9.94555 12.1766 9.94555 11.8234 10.1634 11.6056L11.6056 10.1634Z"
      />
    </svg>
  `;
};
var point4 = () => {
  return html`
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M13.4422 12L12 10.5578L10.5578 12L12 13.4422L13.4422 12ZM12.3944 10.1634C12.1766 9.94555 11.8234 9.94555 11.6056 10.1634L10.1634 11.6056C9.94555 11.8234 9.94555 12.1766 10.1634 12.3944L11.6056 13.8366C11.8234 14.0545 12.1766 14.0545 12.3944 13.8366L13.8366 12.3944C14.0545 12.1766 14.0545 11.8234 13.8366 11.6056L12.3944 10.1634Z"
        fill="#7389FD"
      />
    </svg>
  `;
};
var toggleRight = (enabled = true) => {
  return html`
    <svg
      xmlns="http://www.w3.org/2000/svg"
      data-is-toggle-icon="true"
      width="1em"
      height="1em"
      viewBox="0 0 20 20"
    >
      <path
        data-is-toggle-icon="true"
        fill="currentColor"
        opacity="${!enabled ? "0.6" : "1"}"
        d="m15.795 11.272l-8 5A1.5 1.5 0 0 1 5.5 15V5a1.5 1.5 0 0 1 2.295-1.272l8 5a1.5 1.5 0 0 1 0 2.544Z"
      />
    </svg>
  `;
};
var toggleDown = () => {
  return html`
    <svg
      xmlns="http://www.w3.org/2000/svg"
      data-is-toggle-icon="true"
      width="1em"
      height="1em"
      viewBox="0 0 20 20"
      @mousedown="${(e) => {
  }}"
    >
      <path
        data-is-toggle-icon="true"
        fill="currentColor"
        d="m8.728 15.795l-5-8A1.5 1.5 0 0 1 5 5.5h10a1.5 1.5 0 0 1 1.272 2.295l-5 8a1.5 1.5 0 0 1-2.544 0Z"
      />
    </svg>
  `;
};
var checkboxChecked = () => {
  return html`
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7 4C5.34315 4 4 5.34315 4 7V17C4 18.6569 5.34315 20 7 20H17C18.6569 20 20 18.6569 20 17V7C20 5.34315 18.6569 4 17 4H7ZM17.5665 9.56473C17.8785 9.25181 17.8776 8.74528 17.5647 8.43336C17.2518 8.12144 16.7453 8.12225 16.4334 8.43517L10.3547 14.5333L7.56666 11.7352C7.2548 11.4222 6.74827 11.4213 6.43529 11.7331C6.1223 12.045 6.12139 12.5515 6.43325 12.8645L9.64626 16.0891C10.037 16.4813 10.672 16.4814 11.0629 16.0893L17.5665 9.56473Z"
        fill="#A6ABB7"
      />
    </svg>
  `;
};
var checkboxUnchecked = () => {
  return html`
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M17 5.6H7C6.2268 5.6 5.6 6.2268 5.6 7V17C5.6 17.7732 6.2268 18.4 7 18.4H17C17.7732 18.4 18.4 17.7732 18.4 17V7C18.4 6.2268 17.7732 5.6 17 5.6ZM7 4C5.34315 4 4 5.34315 4 7V17C4 18.6569 5.34315 20 7 20H17C18.6569 20 20 18.6569 20 17V7C20 5.34315 18.6569 4 17 4H7Z"
        fill="#A6ABB7"
      />
    </svg>
  `;
};
var points = [point1(), point2(), point3(), point4()];

// node_modules/@blocksuite/blocks/dist/list-block/utils/get-list-icon.js
function ListIcon(model, index, depth, showChildren, onClick) {
  const icon = (() => {
    switch (model.type) {
      case "bulleted":
        return points[depth % points.length];
      case "numbered":
        return getNumberPrefix(index, depth);
      case "todo":
        return model.checked ? checkboxChecked() : checkboxUnchecked();
      case "toggle":
        return showChildren ? toggleDown() : toggleRight(model.children.length > 0);
      default:
        return "";
    }
  })();
  return html`
    <div
      class="affine-list-block__prefix ${model.type === "todo" ? "affine-list-block__todo-prefix" : ""}"
      @click="${(e) => onClick(e)}"
    >
      ${icon}
    </div>
  `;
}

// node_modules/@blocksuite/blocks/dist/list-block/utils/get-list-info.js
var getIndex = (model) => {
  var _a3;
  const siblings = ((_a3 = model.page.getParent(model)) == null ? void 0 : _a3.children) || [];
  const fakeIndex = siblings.findIndex((v) => v === model);
  let index = 0;
  for (let i = 0; i < fakeIndex; i++) {
    if (siblings[i].flavour === model.flavour && siblings[i].type === model.type) {
      index += 1;
    } else {
      index = 0;
    }
  }
  return index;
};
var getListDeep = (model) => {
  let deep = 0;
  let parent = model.page.getParent(model);
  while ((parent == null ? void 0 : parent.flavour) === model.flavour) {
    deep++;
    parent = model.page.getParent(parent);
  }
  return deep;
};
var getListInfo = (model) => {
  const deep = getListDeep(model);
  const index = getIndex(model);
  return { deep, index };
};

// node_modules/@blocksuite/blocks/dist/list-block/list-block.js
var __decorate46 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ListBlockComponent = class ListBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this.showChildren = true;
    this.textSchema = {
      attributesSchema: affineTextAttributes,
      textRenderer: attributeRenderer
    };
    this._onClickIcon = (e) => {
      e.stopPropagation();
      if (this.model.type === "toggle") {
        this.showChildren = !this.showChildren;
        return;
      } else if (this.model.type === "todo") {
        this.model.page.captureSync();
        const checkedPropObj = { checked: !this.model.checked };
        this.model.page.updateBlock(this.model, checkedPropObj);
        return;
      }
      this._select();
    };
  }
  _select() {
    const pageBlock = getPageBlock(this.model);
    assertExists(pageBlock);
    if (pageBlock instanceof DefaultPageBlockComponent) {
      pageBlock.selection.selectOneBlock(this);
    }
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => this.requestUpdate());
    this.model.childrenUpdated.on(() => this.requestUpdate());
  }
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:list", ListBlockService);
  }
  render() {
    const { deep, index } = getListInfo(this.model);
    const { model, showChildren, _onClickIcon } = this;
    const listIcon = ListIcon(model, index, deep, showChildren, _onClickIcon);
    const shouldAddMarginTop = index === 0 && deep === 0;
    const children = html`<div
      class="affine-block-children-container"
      style="padding-left: ${BLOCK_CHILDREN_CONTAINER_PADDING_LEFT}px"
    >
      ${this.content}
    </div>`;
    return html`
      <div
        class=${`affine-list-block-container ${shouldAddMarginTop ? "affine-list-block-container--first" : ""}`}
      >
        <div
          class=${`affine-list-rich-text-wrapper ${this.model.checked ? "affine-list--checked" : ""}`}
        >
          ${listIcon}
          <rich-text
            .model=${this.model}
            .textSchema=${this.textSchema}
          ></rich-text>
        </div>
        ${this.showChildren ? children : nothing}
      </div>
    `;
  }
};
ListBlockComponent.styles = css`
    .affine-list-block-container {
      box-sizing: border-box;
      border-radius: 5px;
      margin-top: 2px;
    }
    .affine-list-block-container--first {
      margin-top: var(--affine-paragraph-space);
    }
    .affine-list-block-container .affine-list-block-container {
      margin-top: 0;
    }
    .affine-list-block-container.selected {
      background-color: var(--affine-hover-color);
    }
    .affine-list-rich-text-wrapper {
      display: flex;
      align-items: center;
    }
    .affine-list-rich-text-wrapper rich-text {
      flex: 1;
    }

    .affine-list-block__prefix {
      flex-shrink: 0;
      min-width: 26px;
      height: 26px;
      margin-right: 4px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      align-self: flex-start;
      color: var(--affine-list-color);
      font-size: 14px;
      line-height: var(--affine-line-height);
      user-select: none;
    }
    .affine-list-block__todo-prefix {
      cursor: pointer;
    }
    .affine-list-block__todo {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid var(--affine-icon-color);
    }
    .affine-list-block__todo.affine-list-block__todo--active {
      background: var(--affine-icon-color);
    }

    .affine-list--checked {
      color: var(--affine-icon-color);
    }
  `;
__decorate46([
  state()
], ListBlockComponent.prototype, "showChildren", void 0);
ListBlockComponent = __decorate46([
  customElement("affine-list")
], ListBlockComponent);

// node_modules/@blocksuite/blocks/dist/list-block/list-model.js
var ListBlockSchema = defineBlockSchema({
  flavour: "affine:list",
  props: (internal) => ({
    type: "bulleted",
    text: internal.Text(),
    checked: false
  }),
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-list`,
    parent: [
      "affine:frame",
      "affine:database",
      "affine:list",
      "affine:paragraph"
    ]
  }
});

// node_modules/@blocksuite/blocks/dist/frame-block/frame-service.js
var FrameBlockService = class extends BaseService {
  async json2Block(focusedBlockModel, pastedBlocks) {
    await addSerializedBlocks(focusedBlockModel.page, pastedBlocks, focusedBlockModel, 0);
  }
  block2Json(block2, begin, end2) {
    var _a3, _b;
    const delta = ((_a3 = block2.text) == null ? void 0 : _a3.sliceToDelta(begin || 0, end2)) || [];
    return {
      flavour: block2.flavour,
      type: block2.type,
      text: delta,
      xywh: block2.xywh,
      background: block2.background,
      children: (_b = block2.children) == null ? void 0 : _b.map((child, index) => {
        if (index === block2.children.length - 1) {
          return getService(child.flavour).block2Json(child, 0, end2);
        }
        return getService(child.flavour).block2Json(child);
      })
    };
  }
};

// node_modules/@blocksuite/blocks/dist/frame-block/frame-block.js
var __decorate47 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FrameBlockComponent = class FrameBlockComponent2 extends BlockElement {
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:frame", FrameBlockService);
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => this.requestUpdate());
    this.model.childrenUpdated.on(() => this.requestUpdate());
  }
  render() {
    return html`
      <div class="affine-frame-block-container">
        <div class="affine-block-children-container">${this.content}</div>
      </div>
    `;
  }
};
FrameBlockComponent.styles = css`
    .affine-frame-block-container {
      display: flow-root;
    }
    .affine-frame-block-container.selected {
      background-color: var(--affine-hover-color);
    }
  `;
FrameBlockComponent = __decorate47([
  customElement("affine-frame")
], FrameBlockComponent);

// node_modules/@blocksuite/blocks/dist/frame-block/frame-model.js
var FrameBlockSchema = defineBlockSchema({
  flavour: "affine:frame",
  props: () => ({
    xywh: `[0,0,${EDITOR_WIDTH},480]`,
    background: FRAME_BACKGROUND_COLORS[0],
    index: "a0"
  }),
  metadata: {
    version: 1,
    role: "hub",
    tag: literal`affine-frame`,
    parent: ["affine:page"],
    children: [
      "affine:paragraph",
      "affine:list",
      "affine:code",
      "affine:divider",
      "affine:database",
      "affine:embed",
      "affine:frame-block-*",
      "affine:bookmark"
    ]
  }
});

// node_modules/@blocksuite/blocks/dist/divider-block/divider-service.js
var DividerBlockService = class extends BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    return `<hr/>`;
  }
};

// node_modules/@blocksuite/blocks/dist/divider-block/divider-block.js
var __decorate48 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DividerBlockComponent = class DividerBlockComponent2 extends BlockElement {
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:divider", DividerBlockService);
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => this.requestUpdate());
    this.model.childrenUpdated.on(() => this.requestUpdate());
  }
  render() {
    const children = html`<div
      class="affine-block-children-container"
      style="padding-left: ${BLOCK_CHILDREN_CONTAINER_PADDING_LEFT}px"
    >
      ${this.content}
    </div>`;
    return html`
      <div class=${`affine-divider-block-container`}>
        <hr />
        ${children}
      </div>
    `;
  }
};
DividerBlockComponent.styles = css`
    .affine-divider-block-container {
      width: 100%;
      height: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-top: calc(var(--affine-paragraph-space) + 8px);
      margin-bottom: calc(var(--affine-paragraph-space) + 8px);
    }
    hr {
      width: 100%;
    }
  `;
DividerBlockComponent = __decorate48([
  customElement("affine-divider")
], DividerBlockComponent);

// node_modules/@blocksuite/blocks/dist/divider-block/divider-model.js
var DividerBlockSchema = defineBlockSchema({
  flavour: "affine:divider",
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-divider`,
    children: []
  }
});

// node_modules/@blocksuite/blocks/dist/code-block/utils/highlight-cache.js
var LRUCache = class {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.cache.get(key);
    if (value === void 0) {
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }
  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
};
var highlightCache = new LRUCache(100);

// node_modules/@blocksuite/blocks/dist/code-block/affine-code-line.js
var __decorate49 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AffineCodeLine = class AffineCodeLine2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.delta = {
      insert: ZERO_WIDTH_SPACE
    };
    this.highlightOptionsGetter = null;
  }
  render() {
    assertExists(this.highlightOptionsGetter, "highlightOptionsGetter is not set");
    const { lang, highlighter } = this.highlightOptionsGetter();
    if (!highlighter || !highlighter.getLoadedLanguages().includes(lang)) {
      const vText = new VText();
      vText.str = this.delta.insert;
      vText.styles = styleMap({});
      return html`<span>${vText}</span>`;
    }
    const mode = queryCurrentMode();
    const cacheKey = `${this.delta.insert}-${lang}-${mode}`;
    const cache2 = highlightCache.get(cacheKey);
    let tokens = [
      {
        content: this.delta.insert
      }
    ];
    if (cache2) {
      tokens = cache2;
    } else {
      tokens = highlighter.codeToThemedTokens(this.delta.insert, lang, mode === "dark" ? DARK_THEME : LIGHT_THEME)[0];
      highlightCache.set(cacheKey, tokens);
    }
    const vTexts = tokens.map((token) => {
      const vText = new VText();
      vText.str = token.content;
      vText.styles = styleMap({
        color: token.color
      });
      return vText;
    });
    return html`<span>${vTexts}</span>`;
  }
};
__decorate49([
  property({ type: Object })
], AffineCodeLine.prototype, "delta", void 0);
__decorate49([
  property()
], AffineCodeLine.prototype, "highlightOptionsGetter", void 0);
AffineCodeLine = __decorate49([
  customElement("affine-code-line")
], AffineCodeLine);

// node_modules/@blocksuite/blocks/dist/embed-block/embed-service.js
var EmbedBlockService = class extends BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    return `<figure><img src="${block2.sourceId}" alt="${block2.caption}"><figcaption>${block2.caption}</figcaption></figure>`;
  }
  block2Text(block2, { childText = "", begin, end: end2 } = {}) {
    return block2.caption;
  }
  block2Json(block2, begin, end2) {
    return {
      type: block2.type,
      sourceId: block2.sourceId,
      width: block2.width,
      height: block2.height,
      caption: block2.caption,
      flavour: block2.flavour,
      children: []
    };
  }
};

// node_modules/@blocksuite/blocks/dist/embed-block/embed-block.js
var __decorate50 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EmbedBlockComponent = class EmbedBlockComponent2 extends BlockElement {
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:embed", EmbedBlockService);
  }
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this.updateComplete.then(() => {
      var _a3;
      this._caption = ((_a3 = this.model) == null ? void 0 : _a3.caption) ?? "";
      if (this._caption.length > 0) {
        this._input.classList.add("caption-show");
      }
    });
    this.addEventListener("click", () => {
      if (document.activeElement && document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
    });
  }
  _onInputChange() {
    this._caption = this._input.value;
    this.model.page.updateBlock(this.model, { caption: this._caption });
  }
  _onInputBlur() {
    if (!this._caption) {
      this._input.classList.remove("caption-show");
    }
  }
  render() {
    const slot = this.model.type === "image" ? html`<affine-image .model=${this.model}></affine-image>` : nothing;
    return html`
      ${slot}
      <div class="affine-embed-block-container">
        <div class="affine-embed-wrapper">
          <input
            .disabled=${this.model.page.readonly}
            placeholder="Write a caption"
            class="affine-embed-wrapper-caption"
            value=${this._caption}
            @input=${this._onInputChange}
            @blur=${this._onInputBlur}
            @click=${(e) => {
      e.stopPropagation();
    }}
          />
        </div>
      </div>
    `;
  }
};
EmbedBlockComponent.styles = css`
    affine-embed {
      display: block;
    }
    .affine-embed-wrapper {
      text-align: center;
      margin-bottom: calc(var(--affine-paragraph-space) + 8px);
    }
    .affine-embed-wrapper-caption {
      width: 100%;
      font-size: var(--affine-font-sm);
      outline: none;
      border: 0;
      font-family: inherit;
      text-align: center;
      color: var(--affine-icon-color);
      display: none;
      background: var(--affine-background-primary-color);
    }
    .affine-embed-wrapper-caption::placeholder {
      color: var(--affine-placeholder-color);
    }

    .affine-embed-wrapper .caption-show {
      display: inline-block;
    }
  `;
__decorate50([
  query("input")
], EmbedBlockComponent.prototype, "_input", void 0);
__decorate50([
  state()
], EmbedBlockComponent.prototype, "_caption", void 0);
EmbedBlockComponent = __decorate50([
  customElement("affine-embed")
], EmbedBlockComponent);

// node_modules/@blocksuite/blocks/dist/embed-block/embed-model.js
var EmbedBlockSchema = defineBlockSchema({
  flavour: "affine:embed",
  props: () => ({
    type: "image",
    caption: "",
    sourceId: "",
    width: 0,
    height: 0
  }),
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-embed`
  }
});

// node_modules/@blocksuite/blocks/dist/embed-block/image/placeholder/circle-loading.js
var __decorate51 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ELEMENT_TAG = "affine-image-block-circle-loading";
var AffineImageBlockCircleLoading = class AffineImageBlockCircleLoading2 extends ShadowlessElement {
  render() {
    return html`<div class="affine-image-block-container">
      <div class="affine-image-block-loading"></div>
    </div>`;
  }
};
AffineImageBlockCircleLoading.styles = css`
    @keyframes affine-image-block-rotate {
      from {
        rotate: 0deg;
      }
      to {
        rotate: 360deg;
      }
    }

    .affine-image-block-container {
      width: 24px;
      height: 24px;
      overflow: hidden;
    }

    .affine-image-block-loading {
      display: inline-block;
      width: 24px;
      height: 24px;
      position: relative;
      background: conic-gradient(rgba(255, 255, 255, 0.31), #6880ff);
      border-radius: 50%;
      animation: affine-image-block-rotate 1s infinite ease-in;
    }

    .affine-image-block-loading::before {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: white;
      position: absolute;
      top: 2px;
      left: 2px;
    }
  `;
AffineImageBlockCircleLoading = __decorate51([
  customElement(ELEMENT_TAG)
], AffineImageBlockCircleLoading);

// node_modules/@blocksuite/blocks/dist/embed-block/image/placeholder/loading-card.js
var __decorate52 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ELEMENT_TAG2 = "affine-image-block-loading-card";
var AffineImageBlockLoadingCard = class AffineImageBlockLoadingCard2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.content = "Loading content...";
  }
  render() {
    return html`
      <div class="affine-image-block-loading-card">
        <affine-image-block-circle-loading></affine-image-block-circle-loading>
        <div class="affine-image-block-content">${this.content}</div>
      </div>
    `;
  }
};
AffineImageBlockLoadingCard.styles = css`
    .affine-image-block-loading-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      margin: 0 auto;
      border: 1px solid #ebeeff;
      border-radius: 10px;
      background: #fbfbff;
    }

    .affine-image-block-content {
      height: 30px;
      line-height: 22px;
      padding-top: 8px;
      color: var(--affine-primary-color);
      font-size: 16px;
      font-weight: 400;
    }
  `;
__decorate52([
  property()
], AffineImageBlockLoadingCard.prototype, "content", void 0);
AffineImageBlockLoadingCard = __decorate52([
  customElement(ELEMENT_TAG2)
], AffineImageBlockLoadingCard);

// node_modules/@blocksuite/blocks/dist/embed-block/image/placeholder/image-not-found.js
var __decorate53 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var notFoundIcon = html`<svg
  width="25"
  height="24"
  viewBox="0 0 25 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.5 3H8.3C6.61984 3 5.77976 3 5.13803 3.32698C4.57354 3.6146 4.1146 4.07354 3.82698 4.63803C3.5 5.27976 3.5 6.11984 3.5 7.8V16.2C3.5 17.8802 3.5 18.7202 3.82698 19.362C4.1146 19.9265 4.57354 20.3854 5.13803 20.673C5.77976 21 6.61984 21 8.3 21H12.5L15.5 18L11.5 14L12.8418 12.6582C12.8197 12.6391 12.7979 12.6205 12.7762 12.6022C12.4696 12.3444 12.1366 12.1162 11.7278 11.987C11.1185 11.7945 10.4637 11.8016 9.85866 12.0072C9.45274 12.1452 9.12474 12.3806 8.82383 12.645C8.82383 12.645 6.60291 14.8415 5.5 15.9308V6.6C5.5 6.03995 5.5 5.75992 5.60899 5.54601C5.70487 5.35785 5.85785 5.20487 6.04601 5.10899C6.25992 5 6.53995 5 7.1 5H12.5L14.5 3ZM13.304 7.80408C13.1102 8.15931 13 8.56677 13 9C13 9.94759 13.5271 10.7719 14.3041 11.1959L15.5 10L13.304 7.80408ZM15.4156 11.4986L16.9142 10L13.9514 7.03724C14.3773 6.7008 14.9152 6.5 15.5 6.5C16.8806 6.5 18 7.61914 18 9C18 10.3809 16.8806 11.5 15.5 11.5C15.4718 11.5 15.4437 11.4995 15.4156 11.4986ZM13.5691 13.3451C13.6352 13.4103 13.7029 13.4775 13.7724 13.5464L14.7645 14.5302C15.0059 14.2937 15.2246 14.0861 15.4261 13.9167C15.7329 13.6587 16.0663 13.4302 16.4756 13.3011C17.0855 13.1087 17.7409 13.1162 18.3463 13.3226C18.7524 13.4611 19.0805 13.6971 19.3813 13.9622C19.4202 13.9965 19.4598 14.0322 19.5 14.0694V6.6C19.5 6.03995 19.5 5.75992 19.391 5.54601C19.2951 5.35785 19.1422 5.20487 18.954 5.10899C18.7401 5 18.4601 5 17.9 5H13.9143L15.9143 3H16.7C18.3802 3 19.2202 3 19.862 3.32698C20.4265 3.6146 20.8854 4.07354 21.173 4.63803C21.5 5.27976 21.5 6.11984 21.5 7.8V16.2C21.5 17.8802 21.5 18.7202 21.173 19.362C20.8854 19.9265 20.4265 20.3854 19.862 20.673C19.2202 21 18.3802 21 16.7 21H13.9143L16.9142 18L12.9142 14L13.5691 13.3451Z"
    fill="#6880FF"
  />
</svg>`;
var ELEMENT_TAG3 = "affine-image-block-not-found-card";
var AffineImageBlockNotFoundCard = class AffineImageBlockNotFoundCard2 extends ShadowlessElement {
  render() {
    return html`
      <div class="affine-image-block-not-found-card">${notFoundIcon}</div>
    `;
  }
};
AffineImageBlockNotFoundCard.styles = css`
    .affine-image-block-not-found-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      margin: 0 auto;
      border: 1px solid var(--affine-border-color);
      border-radius: 10px;
      background: var(--affine-background-primary-color);
    }
  `;
AffineImageBlockNotFoundCard = __decorate53([
  customElement(ELEMENT_TAG3)
], AffineImageBlockNotFoundCard);

// node_modules/@blocksuite/blocks/dist/embed-block/image/image-block.js
var __decorate54 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ImageBlockComponent_1;
var ImageBlockComponent = ImageBlockComponent_1 = class ImageBlockComponent2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._imageReady = {
      dispose: () => {
        return;
      }
    };
    this._imageState = "loading";
    this._retryCount = 0;
    this._fetchError = (e) => {
      this._imageState = "waitUploaded";
      this._retryCount++;
      console.warn("Cannot find blob, retrying", this._retryCount);
      if (this._retryCount < ImageBlockComponent_1.maxRetryCount) {
        setTimeout(() => {
          this._fetchImage();
        }, 1e3 * this._retryCount);
      } else {
        console.error(e);
        this._imageState = "failed";
      }
    };
    this._fetchImage = () => {
      if (this._imageState === "ready") {
        return;
      }
      const storage = this.model.page.blobs;
      storage.get(this.model.sourceId).then((blob) => {
        if (blob) {
          this._source = URL.createObjectURL(blob);
          this._imageState = "ready";
        } else {
          this._fetchError(new Error("Cannot find blob"));
        }
      }).catch(this._fetchError);
    };
  }
  async firstUpdated() {
    this.model.propsUpdated.on(() => this.requestUpdate());
    this.model.childrenUpdated.on(() => this.requestUpdate());
    const { width, height } = this.model;
    if (width && height) {
      this.resizeImg.style.width = width + "px";
      this.resizeImg.style.height = height + "px";
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this._imageState = "loading";
    this._fetchImage();
    this._disposables.add(this.model.page.workspace.slots.blobUpdate.on(this._fetchImage));
  }
  disconnectedCallback() {
    this._imageReady.dispose();
    if (this._source) {
      URL.revokeObjectURL(this._source);
    }
    super.disconnectedCallback();
  }
  render() {
    const resizeImgStyle = {
      width: "unset",
      height: "unset"
    };
    const { width, height } = this.model;
    if (width && height) {
      resizeImgStyle.width = `${width}px`;
      resizeImgStyle.height = `${height}px`;
    }
    const img = {
      waitUploaded: html`<affine-image-block-loading-card
        content="Delivering content..."
      ></affine-image-block-loading-card>`,
      loading: html`<affine-image-block-loading-card
        content="Loading content..."
      ></affine-image-block-loading-card>`,
      ready: html`<img src=${this._source} />`,
      failed: html`<affine-image-block-not-found-card></affine-image-block-not-found-card>`
    }[this._imageState];
    return html`
      <div class="affine-image-wrapper">
        <div class="resizable-img" style=${styleMap(resizeImgStyle)}>
          ${img}
        </div>
      </div>
    `;
  }
};
ImageBlockComponent.styles = css`
    .affine-image-wrapper {
      padding: 8px;
      width: 100%;
      text-align: center;
      line-height: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin-top: calc(var(--affine-paragraph-space) + 8px);
      overflow: hidden;
    }
    .affine-image-wrapper img {
      max-width: 100%;
      margin: auto;
      width: 100%;
    }

    .resizable {
      max-width: 100%;
    }

    .active .resizable {
      border: 1px solid var(--affine-primary-color) !important;
    }
    .resizable .image-option-container {
      display: none;
      position: absolute;
      top: 4px;
      right: -52px;
      margin: 0;
      padding-left: 12px;
    }

    .embed-editing-state {
      box-shadow: var(--affine-shadow-2);
      border-radius: 10px;
      list-style: none;
      padding: 4px;
      width: 40px;
      background-color: var(--affine-background-overlay-panel-color);
      margin: 0;
    }

    .resizable .resizes {
      /* width: 100%; */
      height: 100%;
      box-sizing: border-box;
      line-height: 0;
    }

    .resizable .resizes .resize {
      /* display: none; */
      width: 10px;
      height: 10px;
      border-radius: 50%; /*magic to turn square into circle*/
      background: white;
      border: 2px solid var(--affine-primary-color);
      position: absolute;
    }

    .resizable:hover .resize {
      display: block;
    }
    .active .resize {
      display: block !important;
    }
    .resizable .resizes .resize.top-left {
      left: -5px;
      top: -5px;
      cursor: nwse-resize; /*resizer cursor*/
    }
    .resizable .resizes .resize.top-right {
      right: -5px;
      top: -5px;
      cursor: nesw-resize;
    }
    .resizable .resizes .resize.bottom-left {
      left: -5px;
      bottom: -5px;
      cursor: nesw-resize;
    }
    .resizable .resizes .resize.bottom-right {
      right: -5px;
      bottom: -5px;
      cursor: nwse-resize;
    }

    .resizable-img {
      border: 1px solid var(--affine-white-90);
    }
    .resizable-img:hover {
      border: 1px solid var(--affine-primary-color);
    }

    .resizable-img img {
      width: 100%;
    }
  `;
ImageBlockComponent.maxRetryCount = 3;
__decorate54([
  property()
], ImageBlockComponent.prototype, "model", void 0);
__decorate54([
  query(".resizable-img")
], ImageBlockComponent.prototype, "resizeImg", void 0);
__decorate54([
  state()
], ImageBlockComponent.prototype, "_source", void 0);
__decorate54([
  state()
], ImageBlockComponent.prototype, "_imageState", void 0);
ImageBlockComponent = ImageBlockComponent_1 = __decorate54([
  customElement("affine-image")
], ImageBlockComponent);

// node_modules/@blocksuite/blocks/dist/surface-block/surface-model.js
var SurfaceBlockSchema = defineBlockSchema({
  flavour: "affine:surface",
  metadata: {
    version: 3,
    role: "hub",
    tag: literal`affine-surface`,
    parent: ["affine:page"],
    children: []
  }
});

// node_modules/@blocksuite/blocks/dist/database-block/utils.js
function isVisible(elem) {
  return !!elem && !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
}
function onClickOutside(element, callback, event = "click", reusable = false) {
  const outsideClickListener = (event2) => {
    const path = event2.composedPath && event2.composedPath();
    const isOutside = path ? path.indexOf(element) < 0 : !element.contains(event2.target) && isVisible(element);
    if (!isOutside)
      return;
    callback(element, event2.target);
    if (!reusable)
      removeClickListener();
  };
  document.addEventListener(event, outsideClickListener);
  const removeClickListener = () => {
    document.removeEventListener(event, outsideClickListener);
  };
  return removeClickListener;
}
var tagColorPoll = [
  "var(--affine-tag-blue)",
  "var(--affine-tag-green)",
  "var(--affine-tag-teal)",
  "var(--affine-tag-white)",
  "var(--affine-tag-purple)",
  "var(--affine-tag-red)",
  "var(--affine-tag-pink)",
  "var(--affine-tag-yellow)",
  "var(--affine-tag-orange)",
  "var(--affine-tag-gray)"
];
function tagColorHelper() {
  let colors = [...tagColorPoll];
  return () => {
    if (colors.length === 0) {
      colors = [...tagColorPoll];
    }
    const index = Math.floor(Math.random() * colors.length);
    const color = colors.splice(index, 1)[0];
    return color;
  };
}
var getTagColor = tagColorHelper();
function isDivider(action) {
  return action.type === "divider";
}

// node_modules/@blocksuite/blocks/dist/database-block/table/consts.js
var DEFAULT_COLUMN_WIDTH = 200;
var DEFAULT_COLUMN_MIN_WIDTH = 100;
var DEFAULT_COLUMN_TITLE_HEIGHT = 40;
var DEFAULT_ADD_BUTTON_WIDTH = 40;
var DATABASE_TITLE_LENGTH = 50;
var SELECT_TAG_NAME_MAX_LENGTH = 50;
var SELECT_EDIT_POPUP_WIDTH = 345;
var DEFAULT_TITLE = "Database";

// node_modules/@blocksuite/blocks/dist/database-block/table/types.js
var ColumnInsertPosition;
(function(ColumnInsertPosition2) {
  ColumnInsertPosition2["Left"] = "left";
  ColumnInsertPosition2["Right"] = "right";
})(ColumnInsertPosition || (ColumnInsertPosition = {}));
var SearchState;
(function(SearchState2) {
  SearchState2["SearchInput"] = "input";
  SearchState2["SearchIcon"] = "icon";
  SearchState2["Searching"] = "searching";
  SearchState2["Action"] = "action";
})(SearchState || (SearchState = {}));
var SelectMode;
(function(SelectMode2) {
  SelectMode2["Multi"] = "multi";
  SelectMode2["Single"] = "single";
})(SelectMode || (SelectMode = {}));

// node_modules/@blocksuite/blocks/dist/database-block/table/components/edit-column-popup/styles.js
var actionStyles = css`
  .action {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 32px;
    padding: 4px 8px;
    border-radius: 5px;
    cursor: pointer;
  }
  .action:hover {
    background: var(--affine-hover-color);
  }
  .action-content {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .action-content > svg {
    width: 20px;
    height: 20px;
    color: var(--affine-icon-color);
    fill: var(--affine-icon-color);
  }
  .action-divider {
    height: 0.5px;
    background: var(--affine-divider-color);
    margin: 8px 0;
  }
`;
var styles7 = css`
  :host {
    background: var(--affine-background-primary-color);
    box-shadow: var(--affine-menu-shadow);
    padding: 8px;
    border: 1px solid var(--affine-border-color);
    border-radius: 8px;
    z-index: 1;
    font-family: var(--affine-font-family);
  }

  .affine-database-edit-column-popup {
    display: flex;
    flex-direction: column;
    color: var(--affine-text-primary-color);
  }
  .affine-database-edit-column-popup * {
    box-sizing: border-box;
  }
  .rename,
  .delete,
  .column-type {
    fill: var(--affine-icon-color);
  }
  .column-type > svg {
    transform: rotate(-90deg);
  }
  ${actionStyles}
`;

// node_modules/@blocksuite/blocks/dist/database-block/table/components/edit-column-popup/column-type-popup.js
var __decorate55 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var columnTypes = [
  {
    type: "rich-text",
    text: "Text",
    icon: TextIcon
  },
  {
    type: "select",
    text: "Select",
    icon: DatabaseSelect
  },
  {
    type: "multi-select",
    text: "Multi-select",
    icon: DatabaseMultiSelect
  },
  {
    type: "number",
    text: "Number",
    icon: DatabaseNumber
  },
  {
    type: "checkbox",
    text: "Checkbox",
    icon: TodoIcon
  },
  {
    type: "progress",
    text: "Progress",
    icon: DatabaseProgress
  }
];
var styles8 = css`
  :host {
    z-index: 1;
    width: 200px;
    padding: 8px;
    border: 1px solid var(--affine-border-color);
    border-radius: 8px;
    background: var(--affine-background-primary-color);
    box-shadow: var(--affine-menu-shadow);
    font-family: var(--affine-font-family);
  }
  ${actionStyles}
  .action > svg {
    width: 16px;
    height: 16px;
  }

  .rich-text {
    fill: var(--affine-icon-color);
  }
  .column-type {
    padding: 0;
    color: var(--affine-text-secondary-color);
    font-size: 14px;
    cursor: unset;
  }
  .column-type:hover {
    background: none;
  }
  .selected {
    color: var(--affine-text-emphasis-color);
    background: rgba(0, 0, 0, 0.02);
  }
  .selected svg {
    color: var(--affine-text-emphasis-color);
  }
  .selected.rich-text svg {
    fill: var(--affine-text-emphasis-color);
  }
  /* .action.disabled {
    cursor: not-allowed;
  }
  .action.disabled:hover {
    background: unset;
  } */
`;
var ColumnTypePopup = class ColumnTypePopup2 extends LitElement {
  render() {
    return html`
      <div class="affine-database-column-type-popup">
        <div class="action column-type">
          <div class="action-content"><span>Column type</span></div>
        </div>
        <div class="action-divider"></div>
        ${columnTypes.map((column) => {
      const selected = column.type === this.columnType;
      const onChangeColumnType = () => {
        if (!selected) {
          this.changeColumnType(this.columnId, column.type);
        }
      };
      return html`
            <div
              class="action ${column.type} ${selected ? "selected" : ""}"
              @click=${onChangeColumnType}
            >
              <div class="action-content">
                ${column.icon}<span>${column.text}</span>
              </div>
              ${selected ? DatabaseDone : null}
            </div>
          `;
    })}
      </div>
    `;
  }
};
ColumnTypePopup.styles = styles8;
__decorate55([
  property()
], ColumnTypePopup.prototype, "columnType", void 0);
__decorate55([
  property()
], ColumnTypePopup.prototype, "columnId", void 0);
__decorate55([
  property()
], ColumnTypePopup.prototype, "changeColumnType", void 0);
ColumnTypePopup = __decorate55([
  customElement("affine-database-column-type-popup")
], ColumnTypePopup);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/edit-column-popup/utils.js
function changeColumnType(columnId, targetType, targetColumn, targetModel, columnRenderer) {
  if (isTitleColumn(targetColumn))
    return;
  const currentType = targetColumn.type;
  targetModel.page.captureSync();
  if (currentType === "select" && targetType === "multi-select") {
    updateColumn(columnId, { type: targetType }, targetModel);
  } else if (currentType === "multi-select" && targetType === "select") {
    updateColumn(columnId, { type: targetType }, targetModel);
    targetModel.convertCellsByColumn(columnId, "select");
  } else if (currentType === "number" && targetType === "rich-text") {
    updateColumn(columnId, { type: targetType }, targetModel);
    targetModel.convertCellsByColumn(columnId, "rich-text");
  } else {
    const renderer = columnRenderer.get(targetType);
    updateColumn(columnId, {
      ...renderer.propertyCreator(),
      type: targetType
    }, targetModel);
    targetModel.deleteCellsByColumn(columnId);
  }
}
function onActionClick(actionType, columnId, targetModel, columnIndex, setTitleColumnEditId, insertColumn) {
  if (actionType === "rename") {
    setTitleColumnEditId(columnId);
    return;
  }
  if (actionType === "insert-right" || actionType === "insert-left") {
    if (actionType === "insert-right") {
      insertColumn(ColumnInsertPosition.Right);
    } else {
      insertColumn(ColumnInsertPosition.Left);
    }
    return;
  }
  if (actionType === "delete") {
    targetModel.page.captureSync();
    targetModel.deleteColumn(columnId);
    targetModel.deleteCellsByColumn(columnId);
    targetModel.applyColumnUpdate();
    return;
  }
  if (actionType === "move-left" || actionType === "move-right") {
    const targetIndex = actionType === "move-left" ? columnIndex - 1 : columnIndex + 1;
    targetModel.page.captureSync();
    targetModel.moveColumn(columnIndex, targetIndex);
    targetModel.applyColumnUpdate();
    return;
  }
  if (actionType === "duplicate") {
    targetModel.page.captureSync();
    const currentSchema = targetModel.getColumn(columnId);
    assertExists(currentSchema);
    const { id: copyId, ...nonIdProps } = currentSchema;
    const schema = { ...nonIdProps };
    const id = targetModel.addColumn(schema, columnIndex + 1);
    targetModel.applyColumnUpdate();
    targetModel.copyCellsByColumn(copyId, id);
    return;
  }
}
function updateColumn(columnId, schemaProperties, targetModel) {
  const currentSchema = targetModel.getColumn(columnId);
  assertExists(currentSchema);
  const schema = { ...currentSchema, ...schemaProperties };
  targetModel.updateColumn(schema);
}
function isTitleColumn(column) {
  return typeof column === "string";
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/edit-column-popup/edit-column-popup.js
var __decorate56 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var columnActions = [
  {
    type: "rename",
    text: "Rename",
    icon: PenIcon
  },
  {
    type: "divider"
  },
  {
    type: "column-type",
    text: "Column type",
    icon: TextIcon
  },
  {
    type: "duplicate",
    text: "Duplicate column",
    icon: DatabaseDuplicate
  },
  {
    type: "insert-left",
    text: "Insert left column",
    icon: DatabaseInsertLeft
  },
  {
    type: "insert-right",
    text: "Insert right column",
    icon: DatabaseInsertRight
  },
  {
    type: "move-left",
    text: "Move left",
    icon: DatabaseMoveLeft
  },
  {
    type: "move-right",
    text: "Move Right",
    icon: DatabaseMoveRight
  },
  {
    type: "divider"
  },
  {
    type: "delete",
    text: "Delete column",
    icon: DeleteIcon
  }
];
var titleColumnActions = [
  {
    type: "rename",
    text: "Rename",
    icon: PenIcon
  },
  {
    type: "insert-right",
    text: "Insert right column",
    icon: DatabaseInsertRight
  }
];
var EditColumnPopup = class EditColumnPopup2 extends LitElement {
  constructor() {
    super(...arguments);
    this._onShowColumnType = (columnId) => {
      if (this._columnTypePopup)
        return;
      this._columnTypePopup = new ColumnTypePopup();
      this._columnTypePopup.changeColumnType = this._changeColumnType;
      this._columnTypePopup.columnId = columnId;
      if (!isTitleColumn(this.targetColumn)) {
        this._columnTypePopup.columnType = this.targetColumn.type;
      }
      this._container.appendChild(this._columnTypePopup);
      createPopper3(this._container, this._columnTypePopup, {
        placement: "right-start",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [-9, 12]
            }
          }
        ]
      });
    };
    this._onHideColumnType = () => {
      var _a3;
      if (this._columnTypePopup) {
        (_a3 = this._columnTypePopup) == null ? void 0 : _a3.remove();
        this._columnTypePopup = null;
      }
    };
    this._changeColumnType = (columnId, targetType) => {
      changeColumnType(columnId, targetType, this.targetColumn, this.targetModel, this.columnRenderer);
      this.closePopup();
    };
    this._onActionClick = (actionType, columnId) => {
      onActionClick(actionType, columnId, this.targetModel, this.columnIndex, this.setTitleColumnEditId, this.insertColumn);
      this.closePopup();
    };
    this._renderActions = () => {
      const actions = isTitleColumn(this.targetColumn) ? titleColumnActions : columnActions;
      return html`
      ${actions.map((action) => {
        if (isDivider(action)) {
          return html`<div class="action-divider"></div>`;
        }
        if (this.columnIndex === 0 && action.type === "move-left" || this.columnIndex === this.targetModel.columns.length - 1 && action.type === "move-right") {
          return null;
        }
        const columnId = isTitleColumn(this.targetColumn) ? "-1" : this.targetColumn.id;
        const onMouseOver = isTitleColumn(this.targetColumn) ? void 0 : action.type === "column-type" ? () => this._onShowColumnType(columnId) : this._onHideColumnType;
        return html`
          <div
            class="action ${action.type}"
            @mouseover=${onMouseOver}
            @click=${() => this._onActionClick(action.type, columnId)}
          >
            <div class="action-content">
              ${action.icon}<span>${action.text}</span>
            </div>
            ${action.type === "column-type" ? ArrowDownIcon : html``}
          </div>
        `;
      })}
    `;
    };
  }
  render() {
    return html`
      <div class="affine-database-edit-column-popup">
        ${this._renderActions()}
      </div>
    `;
  }
};
EditColumnPopup.styles = styles7;
__decorate56([
  property()
], EditColumnPopup.prototype, "targetModel", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "columnRenderer", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "targetColumn", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "columnIndex", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "closePopup", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "setTitleColumnEditId", void 0);
__decorate56([
  property()
], EditColumnPopup.prototype, "insertColumn", void 0);
__decorate56([
  query("input")
], EditColumnPopup.prototype, "titleInput", void 0);
__decorate56([
  query(".affine-database-edit-column-popup")
], EditColumnPopup.prototype, "_container", void 0);
EditColumnPopup = __decorate56([
  customElement("affine-database-edit-column-popup")
], EditColumnPopup);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/column-move/column-drag-indicator.js
var __decorate57 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnDragIndicator = class ColumnDragIndicator2 extends LitElement {
  constructor() {
    super(...arguments);
    this.targetRect = null;
    this.scale = 1;
  }
  render() {
    if (!this.targetRect) {
      return null;
    }
    const rect = this.targetRect;
    const style = styleMap({
      width: `${3 * this.scale}px`,
      height: `${rect.height}px`,
      transform: `translate(${rect.left}px, ${rect.top}px)`
    });
    return html`
      <div class="affine-database-column-drag-indicator" style=${style}></div>
    `;
  }
};
ColumnDragIndicator.styles = css`
    .affine-database-column-drag-indicator {
      position: fixed;
      z-index: 10;
      top: 0;
      left: 0;
      background: var(--affine-primary-color);
      transition-property: width, transform;
      transition-duration: 100ms;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-delay: 0s;
      pointer-events: none;
    }
  `;
__decorate57([
  property()
], ColumnDragIndicator.prototype, "targetRect", void 0);
__decorate57([
  property()
], ColumnDragIndicator.prototype, "scale", void 0);
ColumnDragIndicator = __decorate57([
  customElement("affine-database-column-drag-indicator")
], ColumnDragIndicator);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/column-move/column-drag-preview.js
var __decorate58 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnDragPreview = class ColumnDragPreview2 extends ShadowlessElement {
  render() {
    return html`
      <style>
        affine-database-column-drag-preview {
          display: flex;
          flex-direction: column;
          position: fixed;
          top: 0;
          left: 0;
          height: 220px;
          width: fit-content;
          border: 1px solid var(--affine-border-color);
          border-radius: 4px;
          overflow: hidden;
          cursor: none;
          user-select: none;
          pointer-events: none;
          caret-color: transparent;
          z-index: 100;
        }

        .preview-column-header {
          opacity: 0.8;
          border-bottom: 1px solid var(--affine-border-color);
          background: var(--affine-tertiary-color);
        }
        .preview-column-header .affine-database-column-move svg {
          cursor: grabbing;
          opacity: 1;
        }
        .preview-column-header .affine-database-column-move circle {
          fill: var(--affine-text-emphasis-color);
        }

        .preview-column-content {
          flex: 1;
          opacity: 0.8;
          background: var(--affine-white);
        }
      </style>
    `;
  }
};
ColumnDragPreview = __decorate58([
  customElement("affine-database-column-drag-preview")
], ColumnDragPreview);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/column-move/index.js
function initMoveColumnHandlers(headerContainer, tableContainer, targetModel) {
  let dragPreview = null;
  let dragColumnConfig = null;
  let indicator = document.querySelector("affine-database-column-drag-indicator");
  if (!indicator) {
    indicator = new ColumnDragIndicator();
    document.body.appendChild(indicator);
  }
  let rafId = -1;
  const onColumnDragStart = (event) => {
    event.stopPropagation();
    assertExists(event.dataTransfer);
    event.dataTransfer.effectAllowed = "move";
    const headerColumns = Array.from(headerContainer.querySelectorAll(".affine-database-column")).filter((column) => !column.classList.contains("add-column-button"));
    const dragIcon = event.target;
    const dragHeaderColumn = dragIcon.closest(".affine-database-column");
    assertExists(dragHeaderColumn);
    const dragIndex = headerColumns.indexOf(dragHeaderColumn) - 1;
    const database = tableContainer.closest("affine-database");
    assertExists(database);
    const { x, y } = dragHeaderColumn.getBoundingClientRect();
    const tableBody = tableContainer.closest(".affine-database-block-table");
    assertExists(tableBody);
    const { left: left2, right: right2 } = tableBody.getBoundingClientRect();
    dragColumnConfig = {
      dragIndex,
      tableBody,
      headerColumns,
      targetIndex: -1,
      indicatorHeight: tableContainer.clientHeight,
      previewBoundaries: {
        left: left2,
        right: right2
      },
      offset: {
        x: event.clientX - x,
        y: event.clientY - y
      }
    };
    dragPreview = createDragPreview(event);
    tableContainer.appendChild(dragPreview);
  };
  const onColumnDrag = (event) => {
    if (!dragColumnConfig)
      return;
    assertExists(dragPreview);
    if (dragPreview.style.opacity !== "1") {
      dragPreview.style.opacity = "1";
    }
    const x = event.clientX;
    const y = event.clientY;
    const { dragIndex, tableBody, previewBoundaries, indicatorHeight, headerColumns, offset: { x: offsetX, y: offsetY } } = dragColumnConfig;
    dragPreview.style.transform = `translate(${x - offsetX}px, ${y - offsetY}px)`;
    const point = new Point(x, y);
    const { element, index: targetIndex } = getClosestElement(point, headerColumns);
    const elementRect = element.getBoundingClientRect();
    const outOfBoundaries = elementRect.right < previewBoundaries.left || elementRect.right > previewBoundaries.right;
    const rect = dragIndex === targetIndex || dragIndex === targetIndex - 1 || outOfBoundaries ? null : new DOMRect(elementRect.right, elementRect.top, 1, indicatorHeight);
    assertExists(indicator);
    indicator.targetRect = rect;
    dragColumnConfig.targetIndex = targetIndex - 1;
    const autoLeft = x <= previewBoundaries.left + 50;
    const autoRight = x >= previewBoundaries.right - 50;
    const auto2 = autoLeft || autoRight;
    const autoScroll2 = () => {
      if (!auto2) {
        cancelAnimationFrame(rafId);
        return;
      } else {
        rafId = requestAnimationFrame(autoScroll2);
      }
      if (autoRight) {
        tableBody.scrollLeft += 10;
      }
      if (autoLeft) {
        tableBody.scrollLeft -= 10;
      }
    };
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(autoScroll2);
  };
  const onColumnDragEnd = (event) => {
    if (!dragColumnConfig)
      return;
    const { dragIndex: fromIndex, targetIndex } = dragColumnConfig;
    dragColumnConfig = null;
    if (indicator)
      indicator.targetRect = null;
    if (dragPreview) {
      dragPreview.remove();
      dragPreview = null;
    }
    const toIndex = targetIndex + 1;
    if (
      // self
      fromIndex === toIndex - 1 || // same position
      fromIndex === toIndex
    ) {
      return;
    }
    targetModel.page.captureSync();
    targetModel.moveColumn(fromIndex, toIndex);
    targetModel.applyColumnUpdate();
  };
  const disposables = new DisposableGroup();
  const stopPropagation2 = (e) => e.stopPropagation();
  const columnMoveElements = headerContainer.querySelectorAll(".affine-database-column-move");
  columnMoveElements.forEach((moveElement) => {
    disposables.addFromEvent(moveElement, "pointerdown", stopPropagation2);
    disposables.addFromEvent(moveElement, "pointermove", stopPropagation2);
    disposables.addFromEvent(moveElement, "pointerup", stopPropagation2);
    disposables.addFromEvent(moveElement, "click", stopPropagation2);
    disposables.addFromEvent(moveElement, "dragstart", onColumnDragStart);
    disposables.addFromEvent(moveElement, "drag", onColumnDrag);
    disposables.addFromEvent(moveElement, "dragend", onColumnDragEnd);
  });
  return disposables;
}
function createDragPreview(event) {
  var _a3;
  const dragPreview = new ColumnDragPreview();
  dragPreview.style.opacity = "0";
  const previewFragment = document.createDocumentFragment();
  const dragIcon = event.target;
  const headerColumn = dragIcon.closest(".affine-database-column");
  assertExists(headerColumn);
  const headerColumnClone = headerColumn.cloneNode(true);
  headerColumnClone.classList.add("preview-column-header");
  previewFragment.appendChild(headerColumnClone);
  const previewContent = document.createElement("div");
  previewContent.classList.add("preview-column-content");
  previewFragment.appendChild(previewContent);
  dragPreview.appendChild(previewFragment);
  (_a3 = event.dataTransfer) == null ? void 0 : _a3.setDragImage(dragPreview, 0, 0);
  return dragPreview;
}
function getClosestElement(point, headerColumns) {
  let element = null;
  let index = -1;
  const length2 = headerColumns.length;
  for (let i = 0; i < length2; i++) {
    const column = headerColumns[i];
    const rect = column.getBoundingClientRect();
    if (point.x >= rect.left && point.x <= rect.right) {
      element = column;
      index = i;
      break;
    }
  }
  if (!element) {
    const firstColumnRect = headerColumns[0].getBoundingClientRect();
    if (point.x <= firstColumnRect.left) {
      element = headerColumns[0];
      index = 0;
    } else {
      element = headerColumns[length2 - 1];
      index = length2 - 1;
    }
  }
  return {
    element,
    index
  };
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/column-width/index.js
function initChangeColumnWidthHandlers(headerContainer, tableContainer, targetModel, changeActiveColumnIndex) {
  let changeColumnWidthConfig = null;
  const onColumnWidthPointerdown = (event, index) => {
    event.stopPropagation();
    const currentColumnCells = Array.from(tableContainer.querySelectorAll(`.database-cell:nth-child(${index + 1})`));
    const dragHandleCell = headerContainer.querySelector(`.database-cell:nth-child(${index + 1})`);
    assertExists(dragHandleCell);
    const parentElement = tableContainer.parentElement;
    assertExists(parentElement);
    changeColumnWidthConfig = {
      index,
      rowCells: currentColumnCells,
      scrollLeft: parentElement.scrollLeft,
      lastClientX: event.clientX,
      startClientX: event.clientX,
      rawWidth: currentColumnCells[0].clientWidth,
      currentCell: dragHandleCell,
      rafId: void 0
    };
    changeActiveColumnIndex(index);
  };
  const onColumnWidthPointermove = (event) => {
    event.stopPropagation();
    if (!changeColumnWidthConfig)
      return;
    const { rafId, rowCells, rawWidth, lastClientX, startClientX, scrollLeft: startScrollLeft } = changeColumnWidthConfig;
    if (event.clientX - lastClientX === 0)
      return;
    const direction = event.clientX - lastClientX > 0 ? "right" : "left";
    changeColumnWidthConfig.lastClientX = event.clientX;
    const onUpdateDOM = () => {
      const columnWidth = rawWidth + event.clientX - startClientX <= DEFAULT_COLUMN_MIN_WIDTH ? DEFAULT_COLUMN_MIN_WIDTH : rawWidth + event.clientX - startClientX;
      rowCells.forEach((cell) => {
        cell.style.width = `${columnWidth}px`;
        const titleText = cell.querySelector(".affine-database-column-text-input");
        if (titleText) {
          titleText.style.width = `${columnWidth - 54}px`;
        }
      });
      const parentElement = tableContainer.parentElement;
      assertExists(parentElement);
      const { right: boundaryRight, left: boundaryLeft } = parentElement.getBoundingClientRect();
      const dragHandleRight = event.clientX - boundaryRight + DEFAULT_ADD_BUTTON_WIDTH;
      if (dragHandleRight >= 0) {
        if (direction === "right") {
          parentElement.scrollLeft = Math.max(parentElement.scrollLeft, startScrollLeft + dragHandleRight);
        } else {
          let scrollLeft = parentElement.scrollLeft;
          if (dragHandleRight <= DEFAULT_ADD_BUTTON_WIDTH) {
            scrollLeft += dragHandleRight;
          }
          parentElement.scrollLeft = Math.min(scrollLeft, startScrollLeft + dragHandleRight);
        }
        return;
      }
      const dragHandleLeft = event.clientX - boundaryLeft - DEFAULT_ADD_BUTTON_WIDTH;
      if (dragHandleLeft <= 0 && parentElement.scrollLeft > 0) {
        parentElement.scrollLeft = startScrollLeft + dragHandleLeft;
      }
    };
    if (rafId)
      cancelAnimationFrame(rafId);
    changeColumnWidthConfig.rafId = requestAnimationFrame(onUpdateDOM);
  };
  const onColumnWidthPointerup = (event) => {
    event.stopPropagation();
    changeActiveColumnIndex(-1);
    if (!changeColumnWidthConfig)
      return;
    const { rafId, index, rowCells } = changeColumnWidthConfig;
    if (rafId)
      cancelAnimationFrame(rafId);
    changeColumnWidthConfig = null;
    const columnWidth = rowCells[0].offsetWidth;
    targetModel.page.captureSync();
    if (index === 0) {
      targetModel.page.updateBlock(targetModel, {
        titleColumnWidth: columnWidth
      });
    } else {
      const columnId = targetModel.columns[index - 1].id;
      const columnProps = targetModel.getColumn(columnId);
      targetModel.updateColumn({
        ...columnProps,
        width: columnWidth
      });
      targetModel.applyColumnUpdate();
    }
  };
  const disposables = new DisposableGroup();
  const dragHandles = headerContainer.querySelectorAll(".affine-database-column-drag-handle");
  dragHandles.forEach((dragHandle, index) => {
    disposables.addFromEvent(dragHandle, "pointerdown", (event) => onColumnWidthPointerdown(event, index));
  });
  disposables.addFromEvent(document, "pointermove", onColumnWidthPointermove);
  disposables.addFromEvent(document, "pointerup", onColumnWidthPointerup);
  return disposables;
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/styles.js
var styles9 = css`
  .affine-database-column-header {
    position: relative;
    display: flex;
    flex-direction: row;
    height: 40px;
    border-bottom: 1px solid var(--affine-border-color);
  }
  .affine-database-column-header > .affine-database-column:first-child {
    background: var(--affine-hover-color);
  }

  .affine-database-column {
    position: relative;
    z-index: 1;
    cursor: pointer;
    background: var(--affine-white);
    transform: translateX(0);
  }
  .database-cell {
    min-width: ${DEFAULT_COLUMN_MIN_WIDTH}px;
  }
  .database-cell.add-column-button {
    flex: 1;
    min-width: ${DEFAULT_ADD_BUTTON_WIDTH}px;
    min-height: 100%;
    display: flex;
    align-items: center;
  }
  .affine-database-column-content {
    display: flex;
    align-items: center;
    gap: 6px;
    width: 100%;
    height: 100%;
    padding: 8px;
    border-right: 1px solid var(--affine-border-color);
  }
  .affine-database-column:last-child .affine-database-column-content {
    border-right: none;
  }
  .affine-database-column-drag-handle {
    position: absolute;
    z-index: 1;
    top: 0;
    left: -8px;
    width: 16px;
    height: 100%;
    cursor: col-resize;
  }
  .affine-database-column-drag-handle::before {
    content: ' ';
    display: none;
    position: absolute;
    width: 2px;
    height: 100%;
    left: 7px;
    background: var(--affine-text-emphasis-color);
    box-shadow: 0px 0px 8px rgba(84, 56, 255, 0.35);
  }
  .affine-database-column-drag-handle:hover::before,
  .affine-database-column-drag-handle.dragging::before {
    display: block;
  }
  .affine-database-column-content:hover,
  .affine-database-column-content.edit {
    background: linear-gradient(
        0deg,
        var(--affine-hover-color),
        var(--affine-hover-color)
      ),
      var(--affine-white);
  }
  .affine-database-column-content.edit .affine-database-column-text-icon {
    opacity: 1;
  }
  .affine-database-column-text {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 4px;
    /* https://stackoverflow.com/a/36247448/15443637 */
    overflow: hidden;
    color: var(--affine-text-secondary-color);
    font-size: 14px;
    font-weight: 600;
  }
  .affine-database-column-type-icon {
    display: flex;
    align-items: center;
    border: 1px solid transparent;
    border-radius: 4px;
  }
  .affine-database-column-type-icon.edit {
    background: linear-gradient(
        0deg,
        var(--affine-hover-color),
        var(--affine-hover-color)
      ),
      var(--affine-white);
    border-color: var(--affine-border-color);
  }
  .affine-database-column-type-icon.edit:hover {
    background: var(--affine-white);
  }
  .affine-database-column-type-icon svg {
    width: 16px;
    height: 16px;
    fill: var(--affine-icon-color);
  }
  .affine-database-column-text-content {
    flex: 1;
    display: flex;
    align-items: center;
    overflow: hidden;
  }
  .affine-database-column-content:hover .affine-database-column-text-icon {
    opacity: 1;
  }
  .affine-database-column-text-input {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .affine-database-column-text-icon {
    display: flex;
    align-items: center;
    width: 16px;
    height: 16px;
    background: var(--affine-white);
    border: 1px solid var(--affine-border-color);
    border-radius: 4px;
    opacity: 0;
  }
  .affine-database-column-text-save-icon {
    display: flex;
    align-items: center;
    width: 16px;
    height: 16px;
    border: 1px solid transparent;
    border-radius: 4px;
    fill: var(--affine-icon-color);
  }
  .affine-database-column-text-save-icon:hover {
    background: var(--affine-white);
    border-color: var(--affine-border-color);
  }
  .affine-database-column-text-icon svg {
    fill: var(--affine-icon-color);
  }
  .affine-database-column-input {
    width: 100%;
    height: 24px;
    padding: 0;
    border: none;
    color: inherit;
    font-weight: 600;
    font-size: 14px;
    font-family: var(--affine-font-family);
    background: transparent;
  }
  .affine-database-column-input:focus {
    outline: none;
  }
  .affine-database-column-move {
    display: flex;
    align-items: center;
  }
  .affine-database-column-move svg {
    width: 10px;
    height: 14px;
    color: var(--affine-black-10);
    cursor: grab;
    opacity: 0;
  }
  .affine-database-column-content:hover svg {
    opacity: 1;
  }

  .affine-database-add-column-button {
    visibility: hidden;
    position: fixed;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 38px;
    cursor: pointer;
  }
  .header-add-column-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 100%;
    cursor: pointer;
  }

  .affine-database-column-move-preview {
    position: fixed;
    z-index: 100;
    width: 100px;
    height: 100px;
    background: var(--affine-text-emphasis-color);
  }
`;

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-header/column-header.js
var __decorate59 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var columnTypeIconMap = {
  select: DatabaseSelect,
  number: DatabaseNumber,
  checkbox: TodoIcon,
  progress: DatabaseProgress,
  "rich-text": TextIcon,
  "multi-select": DatabaseMultiSelect
};
var DatabaseColumnHeader = class DatabaseColumnHeader2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._editingColumnId = "";
    this._changingColumnTypeId = "";
    this._widthChangingIndex = -1;
    this._columnWidthDisposables = new DisposableGroup();
    this._columnMoveDisposables = new DisposableGroup();
    this._isHeaderHover = false;
    this._indicator = null;
    this._editingColumnPopupIndex = -1;
    this.setEditingColumnId = (id) => {
      this._editingColumnId = id;
    };
    this.showAddColumnButton = (event) => {
      const databaseElement = this.closest("affine-database");
      assertExists(databaseElement);
      const { right: boundaryRight } = databaseElement.getBoundingClientRect();
      const { left: headerAddColumnButtonLeft } = this._headerAddColumnButton.getBoundingClientRect();
      let isInHeader = true;
      if (event) {
        isInHeader = event.offsetY <= DEFAULT_COLUMN_TITLE_HEIGHT && event.offsetY >= 0;
      }
      const needShow = boundaryRight <= headerAddColumnButtonLeft;
      if (needShow && this._isHeaderHover && isInHeader) {
        this._addColumnButton.style.visibility = "visible";
      } else {
        this._addColumnButton.style.visibility = "hidden";
      }
    };
    this._setChangingColumnIndex = (index) => {
      if (this._widthChangingIndex !== index) {
        this._widthChangingIndex = index;
      }
    };
    this._onShowEditColumnPopup = (target, column, index) => {
      if (this._editingColumnId || this.readonly)
        return;
      if (this._editingColumnPopupIndex === index) {
        this._editingColumnPopupIndex = -1;
        return;
      }
      this._editingColumnPopupIndex = index;
      const currentEl = target;
      const reference2 = currentEl.closest(".affine-database-column");
      assertExists(reference2);
      const editColumn = new EditColumnPopup();
      editColumn.setTitleColumnEditId = this.setEditingColumnId;
      editColumn.targetModel = this.targetModel;
      editColumn.targetColumn = column;
      editColumn.columnIndex = index - 1;
      editColumn.columnRenderer = this.columnRenderer;
      editColumn.closePopup = () => {
        this._editingColumnPopupIndex = -1;
        editColumn.remove();
      };
      editColumn.insertColumn = (position) => {
        const insertIdex = position === ColumnInsertPosition.Right ? index : index - 1;
        this.addColumn(insertIdex);
      };
      document.body.appendChild(editColumn);
      createPopper3(reference2, editColumn, { placement: "bottom-start" });
      onClickOutside(editColumn, (ele, target2) => {
        if (!target2.closest(".affine-database-column-content")) {
          this._editingColumnPopupIndex = -1;
        }
        ele.remove();
      }, "mousedown");
    };
    this._onShowColumnTypePopup = (event, columnId, column) => {
      if (this._editingColumnId === "" || this.readonly)
        return;
      if (this._changingColumnTypeId === columnId) {
        this._changingColumnTypeId = "";
        return;
      }
      event.stopPropagation();
      this._changingColumnTypeId = columnId;
      const popup = new ColumnTypePopup();
      popup.columnId = columnId;
      popup.columnType = column.type;
      popup.changeColumnType = (columnId2, type) => {
        changeColumnType(columnId2, type, column, this.targetModel, this.columnRenderer);
        this._changingColumnTypeId = "";
        popup.remove();
      };
      document.body.appendChild(popup);
      const target = event.target;
      const reference2 = target.closest(".affine-database-column-content");
      assertExists(reference2);
      createPopper3(reference2, popup, {
        placement: "bottom-start"
      });
      onClickOutside(popup, (ele, target2) => {
        if (!target2.closest(".affine-database-column-type-icon")) {
          this._changingColumnTypeId = "";
        }
        ele.remove();
      }, "mousedown");
    };
    this._onKeydown = (event, type, column) => {
      if (event.key === "Enter") {
        this.targetModel.page.captureSync();
        this._saveColumnTitle(type, column);
        return;
      }
      if (event.key === "Escape") {
        this.setEditingColumnId("");
        return;
      }
    };
    this._saveColumnTitle = (type, column) => {
      if (this._editingColumnId === "")
        return;
      const name = this._titleColumnInput.value;
      if (type === "title") {
        this._onUpdateTitleColumn(name);
      } else {
        assertExists(column);
        this._onUpdateNormalColumn(name, column);
      }
      if (this._editingColumnId === (column == null ? void 0 : column.id)) {
        this.setEditingColumnId("");
      }
    };
    this._onUpdateTitleColumn = (titleColumnName) => {
      this.targetModel.page.captureSync();
      this.targetModel.page.updateBlock(this.targetModel, {
        titleColumnName
      });
      this.setEditingColumnId("");
    };
    this._onUpdateNormalColumn = (name, column) => {
      this.targetModel.page.captureSync();
      this.targetModel.updateColumn({
        ...column,
        name
      });
      this.targetModel.applyColumnUpdate();
      this.setEditingColumnId("");
    };
    this._onEditColumnTitle = (event, columnId) => {
      event.stopPropagation();
      this.setEditingColumnId(columnId);
    };
    this._onAddColumn = () => {
      if (this.readonly)
        return;
      this.addColumn(this.targetModel.columns.length);
    };
  }
  get tableContainer() {
    return this.parentElement;
  }
  get readonly() {
    return this.targetModel.page.readonly;
  }
  firstUpdated() {
    if (this.readonly)
      return;
    this._initChangeColumnWidthHandlers();
    this._initSetDragHandleHeightEffect();
    this._initHeaderMousemoveHandlers();
    this._initMoveColumnHandlers();
    const databaseElement = this.closest("affine-database");
    if (databaseElement) {
      this._initResizeEffect(databaseElement);
    }
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (this.readonly)
      return;
    if (changedProperties.has("_editingColumnId") && !!this._editingColumnId) {
      this._titleColumnInput.focus();
      const length2 = this._titleColumnInput.value.length;
      this._titleColumnInput.setSelectionRange(0, length2);
    }
    if (changedProperties.has("columns")) {
      this._initMoveColumnHandlers();
      this._initChangeColumnWidthHandlers();
    }
    if (changedProperties.size === 0 || changedProperties.has("columns")) {
      this._setDragHandleHeight();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._columnWidthDisposables.dispose();
    if (this._indicator) {
      this._indicator.targetRect = null;
    }
  }
  _initResizeEffect(element) {
    const pageBlock = getDefaultPage(this.targetModel.page);
    const viewportElement = pageBlock == null ? void 0 : pageBlock.viewportElement;
    if (viewportElement) {
      const resizeObserver = new ResizeObserver((entries) => {
        for (const { target } of entries) {
          if (target === viewportElement) {
            const { right: containerRight } = element.getBoundingClientRect();
            this._addColumnButton.style.left = `${containerRight}px`;
            break;
          }
        }
      });
      resizeObserver.observe(viewportElement);
    }
  }
  _initSetDragHandleHeightEffect() {
    const mutationObserver = new MutationObserver(() => {
      this._setDragHandleHeight();
    });
    const tableContainer = this.closest(".affine-database-table-container");
    assertExists(tableContainer);
    mutationObserver.observe(tableContainer, {
      childList: true,
      subtree: true
    });
    this._disposables.add(() => mutationObserver.disconnect());
  }
  _setDragHandleHeight() {
    const databaseElement = this.closest("affine-database");
    if (!databaseElement)
      return;
    const databaseBody = databaseElement.querySelector(".affine-database-block-rows");
    assertExists(databaseBody);
    const dragHandleHeight = databaseBody.clientHeight + DEFAULT_COLUMN_TITLE_HEIGHT - 1;
    const allDragHandle = databaseElement.querySelectorAll(".affine-database-column-drag-handle");
    allDragHandle.forEach((handle) => {
      handle.style.height = `${dragHandleHeight}px`;
    });
  }
  _initHeaderMousemoveHandlers() {
    this._disposables.addFromEvent(this._headerContainer, "mouseover", (event) => {
      this._isHeaderHover = true;
      this.showAddColumnButton(event);
    });
    this._disposables.addFromEvent(this._headerContainer, "mouseleave", (event) => {
      this._isHeaderHover = false;
      this.showAddColumnButton(event);
    });
  }
  _initChangeColumnWidthHandlers() {
    const isChangingWidth = this._widthChangingIndex !== -1;
    if (isChangingWidth)
      return;
    this._columnWidthDisposables.dispose();
    const disposables = initChangeColumnWidthHandlers(this._headerContainer, this.tableContainer, this.targetModel, this._setChangingColumnIndex);
    this._columnWidthDisposables = disposables;
  }
  _initMoveColumnHandlers() {
    this._columnMoveDisposables.dispose();
    const disposables = initMoveColumnHandlers(this._headerContainer, this.tableContainer, this.targetModel);
    this._columnMoveDisposables = disposables;
  }
  render() {
    const style = styleMap({
      width: `${this.targetModel.titleColumnWidth}px`
    });
    const isTitleEditing = this._editingColumnId === "-1" && !this.readonly;
    return html2`
      <div class="affine-database-column-header database-row">
        <div class="affine-database-column database-cell" style=${style}>
          <div
            class="affine-database-column-content ${this._editingColumnId === "-1" ? "edit" : ""}"
            data-column-id="-1"
            @click=${(event) => this._onShowEditColumnPopup(event.target, this.targetModel.titleColumnName, 0)}
          >
            <div class="affine-database-column-text">
              <div class="affine-database-column-type-icon">${TextIcon}</div>
              ${isTitleEditing ? html2`<div class="affine-database-column-text-content">
                    <input
                      class="affine-database-column-input"
                      value=${this.targetModel.titleColumnName}
                      @keydown=${(event) => this._onKeydown(event, "title")}
                      @pointerdown=${(event) => event.stopPropagation()}
                    />
                    <div
                      class="affine-database-column-text-save-icon"
                      @click=${(event) => {
      event.stopPropagation();
      this._saveColumnTitle("title");
    }}
                    >
                      ${DatabaseDone}
                    </div>
                  </div>` : html2`<div class="affine-database-column-text-content">
                    <div class="affine-database-column-text-input">
                      ${this.targetModel.titleColumnName}
                    </div>
                    ${this.readonly ? null : html2`<div
                          class="affine-database-column-text-icon"
                          @click=${(e) => this._onEditColumnTitle(e, "-1")}
                        >
                          ${PenIcon}
                        </div>`}
                  </div>`}
            </div>
          </div>
        </div>
        ${repeat(this.columns, (column) => column.id, (column, index) => {
      const style2 = styleMap({
        width: `${column.width}px`
      });
      const isEditing = this._editingColumnId === column.id && !this.readonly;
      const isChangingColumnType = this._changingColumnTypeId === column.id;
      return html2`
              <div class="affine-database-column database-cell" style=${style2}>
                <div
                  class="affine-database-column-content ${isEditing ? "edit" : ""}"
                  data-column-id="${column.id}"
                  @click=${(event) => this._onShowEditColumnPopup(event.target, column, index + 1)}
                >
                  <div class="affine-database-column-text ${column.type}">
                    <div
                      class="affine-database-column-type-icon ${isEditing ? "edit" : ""} ${isChangingColumnType ? "active" : ""}"
                      @click=${(e) => this._onShowColumnTypePopup(e, column.id, column)}
                    >
                      ${columnTypeIconMap[column.type]}
                    </div>
                    ${isEditing ? html2`<div class="affine-database-column-text-content">
                          <input
                            class="affine-database-column-input"
                            value=${column.name}
                            @keydown=${(event) => this._onKeydown(event, "normal", column)}
                            @pointerdown=${(event) => event.stopPropagation()}
                          />
                          <div
                            class="affine-database-column-text-save-icon"
                            @click=${(event) => {
        event.stopPropagation();
        this._saveColumnTitle("normal", column);
      }}
                          >
                            ${DatabaseDone}
                          </div>
                        </div>` : html2`<div class="affine-database-column-text-content">
                          <div class="affine-database-column-text-input">
                            ${column.name}
                          </div>
                          ${this.readonly ? null : html2`<div
                                class="affine-database-column-text-icon"
                                @click=${(e) => this._onEditColumnTitle(e, column.id)}
                              >
                                ${PenIcon}
                              </div>`}
                        </div>`}
                  </div>
                  ${this.readonly ? null : html2`<div
                        draggable="true"
                        class="affine-database-column-move"
                      >
                        ${DatabaseDragIcon}
                      </div>`}
                </div>
                ${this.readonly ? null : html2`<div
                      class="affine-database-column-drag-handle ${this._widthChangingIndex === index ? "dragging" : ""}"
                    ></div>`}
              </div>
            `;
    })}
        <div class="affine-database-column database-cell add-column-button">
          ${this.readonly ? null : html2`<div
                  class="affine-database-column-drag-handle  ${this._widthChangingIndex === this.columns.length ? "dragging" : ""}"
                ></div>
                <div
                  class="header-add-column-button"
                  @click=${this._onAddColumn}
                >
                  ${DatabaseAddColumn}
                </div>`}
        </div>
        ${this.readonly ? null : html2`<div
              class="affine-database-add-column-button"
              data-test-id="affine-database-add-column-button"
              @click=${this._onAddColumn}
            >
              ${DatabaseAddColumn}
            </div>`}
      </div>
    `;
  }
};
DatabaseColumnHeader.styles = styles9;
__decorate59([
  property()
], DatabaseColumnHeader.prototype, "targetModel", void 0);
__decorate59([
  property()
], DatabaseColumnHeader.prototype, "columns", void 0);
__decorate59([
  property()
], DatabaseColumnHeader.prototype, "addColumn", void 0);
__decorate59([
  property()
], DatabaseColumnHeader.prototype, "columnRenderer", void 0);
__decorate59([
  state()
], DatabaseColumnHeader.prototype, "_editingColumnId", void 0);
__decorate59([
  state()
], DatabaseColumnHeader.prototype, "_changingColumnTypeId", void 0);
__decorate59([
  query(".affine-database-column-input")
], DatabaseColumnHeader.prototype, "_titleColumnInput", void 0);
__decorate59([
  query(".affine-database-column-header")
], DatabaseColumnHeader.prototype, "_headerContainer", void 0);
__decorate59([
  query(".affine-database-add-column-button")
], DatabaseColumnHeader.prototype, "_addColumnButton", void 0);
__decorate59([
  query(".header-add-column-button")
], DatabaseColumnHeader.prototype, "_headerAddColumnButton", void 0);
__decorate59([
  state()
], DatabaseColumnHeader.prototype, "_widthChangingIndex", void 0);
DatabaseColumnHeader = __decorate59([
  customElement("affine-database-column-header")
], DatabaseColumnHeader);

// node_modules/@blocksuite/blocks/dist/database-block/table/register.js
var __decorate60 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DatabaseCellElement = class extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this.cell = null;
  }
};
__decorate60([
  property()
], DatabaseCellElement.prototype, "rowHost", void 0);
__decorate60([
  property()
], DatabaseCellElement.prototype, "databaseModel", void 0);
__decorate60([
  property()
], DatabaseCellElement.prototype, "rowModel", void 0);
__decorate60([
  property()
], DatabaseCellElement.prototype, "column", void 0);
__decorate60([
  property()
], DatabaseCellElement.prototype, "cell", void 0);
function defineColumnRenderer(type, propertyCreator, defaultValue, components, config2) {
  return {
    displayName: config2.displayName,
    type,
    propertyCreator,
    components,
    defaultValue
  };
}
var ColumnRendererHelper = class {
  constructor() {
    this._columns = /* @__PURE__ */ new Map();
  }
  register(renderer) {
    const columns = this._columns;
    if (columns.has(renderer.type)) {
      throw new Error("cannot register twice for " + renderer.type);
    }
    columns.set(renderer.type, renderer);
  }
  get(type) {
    const renderer = this._columns.get(type);
    if (!renderer) {
      throw new Error("cannot find renderer");
    }
    return renderer;
  }
  list() {
    return [...this._columns.values()];
  }
};

// node_modules/@blocksuite/blocks/dist/database-block/table/components/cell-container.js
var __decorate61 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CELL_PADDING = 8;
var DatabaseCellContainer = class DatabaseCellContainer2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this._isEditing = false;
    this._onClick = (event) => {
      if (this.readonly)
        return;
      this._isEditing = true;
      this.removeEventListener("click", this._onClick);
      setTimeout(() => {
        onClickOutside(this, () => {
          this.addEventListener("click", this._onClick);
          this._isEditing = false;
        }, "mousedown");
      });
    };
    this.setEditing = (isEditing) => {
      this._isEditing = isEditing;
      if (!this._isEditing) {
        setTimeout(() => {
          this.addEventListener("click", this._onClick);
        });
      }
    };
    this.setHeight = (height) => {
      this.style.height = `${height + CELL_PADDING * 2}px`;
    };
  }
  get readonly() {
    return this.databaseModel.page.readonly;
  }
  connectedCallback() {
    super.connectedCallback();
    const disposables = this._disposables;
    disposables.addFromEvent(this, "click", this._onClick);
  }
  firstUpdated() {
    this.setAttribute("data-block-is-database-input", "true");
    this.setAttribute("data-row-id", this.rowModel.id);
    this.setAttribute("data-column-id", this.column.id);
  }
  setValue(value, option = { captureSync: true }) {
    queueMicrotask(() => {
      if (option.captureSync) {
        this.databaseModel.page.captureSync();
      }
      this.databaseModel.updateCell(this.rowModel.id, {
        columnId: this.column.id,
        value
      });
      this.databaseModel.applyColumnUpdate();
      this.requestUpdate();
    });
  }
  updateColumnProperty(apply) {
    const newProperty = apply(this.column);
    this.databaseModel.page.captureSync();
    this.databaseModel.updateColumn({
      ...this.column,
      ...newProperty
    });
  }
  /* eslint-disable lit/binding-positions, lit/no-invalid-html */
  render() {
    const renderer = this.columnRenderer.get(this.column.type);
    const cell = this.databaseModel.getCell(this.rowModel.id, this.column.id);
    if (!this.readonly && this._isEditing && renderer.components.CellEditing !== null) {
      const editingTag = renderer.components.CellEditing.tag;
      return html2`
        <${editingTag}
          data-is-editing-cell="true"
          .rowHost=${this}
          .databaseModel=${this.databaseModel}
          .rowModel=${this.rowModel}
          .column=${this.column}
          .cell=${cell}
        ></${editingTag}>
      `;
    }
    const previewTag = renderer.components.Cell.tag;
    return html2`
      <${previewTag}
        .rowHost=${this}
        .databaseModel=${this.databaseModel}
        .rowModel=${this.rowModel}
        .column=${this.column}
        .cell=${cell}
      ></${previewTag}>
    `;
  }
};
DatabaseCellContainer.styles = css`
    affine-database-cell-container {
      display: flex;
      align-items: center;
      width: 100%;
      height: 100%;
      padding: 0 ${CELL_PADDING}px;
      border-right: 1px solid var(--affine-border-color);
    }

    affine-database-cell-container * {
      box-sizing: border-box;
    }
  `;
__decorate61([
  state()
], DatabaseCellContainer.prototype, "_isEditing", void 0);
__decorate61([
  property()
], DatabaseCellContainer.prototype, "columnRenderer", void 0);
DatabaseCellContainer = __decorate61([
  customElement("affine-database-cell-container")
], DatabaseCellContainer);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/toolbar/toolbar-action-popup.js
var __decorate62 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var toolbarActions = [
  {
    type: "database-type",
    text: "Database type",
    icon: DatabaseTableViewIcon
  },
  {
    type: "copy",
    text: "Copy",
    icon: CopyIcon
  },
  {
    type: "divider"
  },
  {
    type: "delete-database",
    text: "Delete database",
    icon: DeleteIcon
  }
];
var databaseTypes = [
  {
    type: "table",
    text: "Table view",
    icon: DatabaseTableViewIcon
  },
  {
    type: "kanban",
    text: "Kanban view",
    icon: DatabaseKanbanViewIcon
  }
];
var DatabaseTypePopup = class DatabaseTypePopup2 extends LitElement {
  render() {
    return html`
      <div class="affine-database-type-popup">
        <div class="action database-type">
          <div class="action-content"><span>Database type</span></div>
        </div>
        <div class="action-divider"></div>
        ${databaseTypes.map((column) => {
      const isKanban = column.type === "kanban";
      const selected = column.type === this.dbType && !isKanban;
      return html`
            <div
              class="action ${column.type} ${selected ? "selected" : ""} ${isKanban ? "disabled" : ""}"
            >
              <div class="action-content">
                ${column.icon}<span>${column.text}</span>
              </div>
            </div>
          `;
    })}
      </div>
    `;
  }
};
DatabaseTypePopup.styles = css`
    :host {
      width: 200px;
      padding: 8px;
      border: 1px solid var(--affine-border-color);
      border-radius: 8px;
      background: var(--affine-background-primary-color);
      box-shadow: 0px 0px 12px rgba(66, 65, 73, 0.14),
        inset 0px 0px 0px 0.5px var(--affine-border-color);
    }
    :host * {
      box-sizing: border-box;
    }
    ${actionStyles}
    .action > svg {
      width: 16px;
      height: 16px;
      fill: var(--affine-icon-color);
    }
    .database-type {
      height: 30px;
      padding: 0;
      color: var(--affine-text-secondary-color);
      font-size: 14px;
      cursor: unset;
    }
    .database-type:hover {
      background: none;
    }
    .selected {
      color: var(--affine-text-emphasis-color);
      background: rgba(0, 0, 0, 0.02);
    }
    .selected svg {
      color: var(--affine-text-emphasis-color);
    }
    .selected.table-view svg {
      fill: var(--affine-text-emphasis-color);
    }
    .action.disabled {
      cursor: not-allowed;
    }
    .action.disabled:hover {
      background: unset;
    }
  `;
__decorate62([
  property()
], DatabaseTypePopup.prototype, "dbType", void 0);
DatabaseTypePopup = __decorate62([
  customElement("affine-database-type-popup")
], DatabaseTypePopup);
var ToolbarActionPopup = class ToolbarActionPopup2 extends LitElement {
  constructor() {
    super(...arguments);
    this._onActionClick = (event, actionType) => {
      event.stopPropagation();
      if (actionType === "delete-database") {
        const models = [this.targetModel, ...this.targetModel.children];
        models.forEach((model) => this.targetModel.page.deleteBlock(model));
      } else if (actionType === "copy") {
        copyBlocks({
          type: "Block",
          models: [this.targetModel],
          startOffset: 0,
          endOffset: 0
        });
        toast("Copied Database to clipboard");
      }
      this.close();
    };
    this._onShowDatabaseType = () => {
      if (this._databaseTypePopup)
        return;
      this._databaseTypePopup = new DatabaseTypePopup();
      this._databaseTypePopup.dbType = "table";
      this._container.appendChild(this._databaseTypePopup);
      createPopper3(this._container, this._databaseTypePopup, {
        placement: "right-start",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [-9, 12]
            }
          }
        ]
      });
    };
    this._onHideDatabaseType = () => {
      var _a3;
      if (this._databaseTypePopup) {
        (_a3 = this._databaseTypePopup) == null ? void 0 : _a3.remove();
        this._databaseTypePopup = null;
      }
    };
    this._renderActions = () => {
      return html`
      ${toolbarActions.map((action) => {
        if (isDivider(action)) {
          return html`<div class="action-divider"></div>`;
        }
        const onMouseOver = action.type === "database-type" ? this._onShowDatabaseType : this._onHideDatabaseType;
        return html`
          <div
            class="action ${action.type}"
            @mouseover=${onMouseOver}
            @click=${(event) => this._onActionClick(event, action.type)}
          >
            <div class="action-content">
              ${action.icon}<span>${action.text}</span>
            </div>
            ${action.type === "database-type" ? ArrowDownIcon : html``}
          </div>
        `;
      })}
    `;
    };
  }
  render() {
    return html`<div class="affine-database-toolbar-action-popup">
      ${this._renderActions()}
    </div>`;
  }
};
ToolbarActionPopup.styles = css`
    :host {
      width: 200px;
      height: 128px;
      padding: 8px;
      border: 1px solid var(--affine-border-color);
      border-radius: 8px;
      box-shadow: 0px 0px 12px rgba(66, 65, 73, 0.14),
        inset 0px 0px 0px 0.5px var(--affine-border-color);
      z-index: var(--affine-z-index-popover);
      background: var(--affine-white);
    }
    :host * {
      box-sizing: border-box;
    }
    ${actionStyles}
    .action-content > svg {
      width: 20px;
      height: 20px;
      fill: var(--affine-icon-color);
    }
    .action > svg {
      width: 16px;
      height: 16px;
      fill: var(--affine-icon-color);
    }
    .database-type > svg {
      transform: rotate(-90deg);
    }
  `;
__decorate62([
  property()
], ToolbarActionPopup.prototype, "close", void 0);
__decorate62([
  query(".affine-database-toolbar-action-popup")
], ToolbarActionPopup.prototype, "_container", void 0);
ToolbarActionPopup = __decorate62([
  customElement("affine-database-toolbar-action-popup")
], ToolbarActionPopup);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/toolbar/index.js
var __decorate63 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NewRecordPreview = class NewRecordPreview2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this.offset = { x: 0, y: 0 };
  }
  render() {
    return html`
      <style>
        affine-database-new-record-preview {
          display: flex;
          align-items: center;
          justify-content: center;
          position: fixed;
          top: 0;
          left: 0;
          height: 32px;
          width: 32px;
          border: 1px solid var(--affine-border-color);
          border-radius: 50%;
          background: linear-gradient(
              0deg,
              rgba(96, 70, 254, 0.3),
              rgba(96, 70, 254, 0.3)
            ),
            linear-gradient(
              0deg,
              var(--affine-hover-color),
              var(--affine-hover-color)
            ),
            var(--affine-white);
          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.05),
            0px 0px 0px 0.5px var(--affine-black-10);
          cursor: none;
          user-select: none;
          pointer-events: none;
          caret-color: transparent;
          z-index: 100;
        }
        affine-database-new-record-preview svg {
          width: 16px;
          height: 16px;
        }
        affine-database-new-record-preview path {
          fill: var(--affine-brand-color);
        }
      </style>
      ${PlusIcon}
    `;
  }
};
__decorate63([
  property()
], NewRecordPreview.prototype, "offset", void 0);
NewRecordPreview = __decorate63([
  customElement("affine-database-new-record-preview")
], NewRecordPreview);
function initAddNewRecordHandlers(element, container, addRow) {
  let dragConfig = null;
  let dragPreview = null;
  const database = container.closest("affine-database");
  if (!database)
    return;
  const rowContainer = database.querySelector(".affine-database-block-rows");
  assertExists(rowContainer);
  const indicator = document.querySelector("affine-drag-indicator");
  if (!indicator) {
    const indicator2 = document.createElement("affine-drag-indicator");
    document.body.appendChild(indicator2);
  }
  const onDragStart = (event) => {
    var _a3;
    event.stopPropagation();
    assertExists(event.dataTransfer);
    event.dataTransfer.effectAllowed = "move";
    dragPreview = new NewRecordPreview();
    dragPreview.style.opacity = "0";
    (_a3 = event.dataTransfer) == null ? void 0 : _a3.setDragImage(dragPreview, 0, 0);
    container.appendChild(dragPreview);
    const rows = Array.from(rowContainer.querySelectorAll(".affine-database-block-row"));
    dragConfig = {
      index: -1,
      rows
    };
  };
  const onDrag = (event) => {
    if (!dragConfig)
      return;
    if (!dragPreview)
      return;
    if (dragPreview.style.opacity !== "1") {
      dragPreview.style.opacity = "1";
    }
    const x = event.clientX;
    const y = event.clientY;
    dragPreview.style.transform = `translate(${x}px, ${y}px)`;
    const point = new Point(x, y);
    const row = getClosestRow(point, dragConfig.rows);
    assertExists(indicator);
    if (row) {
      const { top: top2, bottom: bottom2 } = row.element.getBoundingClientRect();
      const rectTop = row.isLast ? bottom2 : top2;
      const { width: databaseWidth, left: databaseLeft } = database.getBoundingClientRect();
      indicator.rect = Rect.fromLWTH(databaseLeft, databaseWidth, rectTop, 3);
      dragConfig.index = row.insertRowIndex;
    } else {
      indicator.rect = null;
      dragConfig.index = -1;
    }
  };
  const onDragEnd = () => {
    if (!dragConfig)
      return;
    const { index } = dragConfig;
    dragConfig = null;
    if (indicator)
      indicator.rect = null;
    if (dragPreview) {
      dragPreview.remove();
      dragPreview = null;
    }
    if (index !== -1) {
      addRow(index);
    }
  };
  const disposables = new DisposableGroup();
  const stopPropagation2 = (e) => {
    e.stopPropagation();
  };
  disposables.addFromEvent(element, "pointerdown", stopPropagation2);
  disposables.addFromEvent(element, "pointermove", stopPropagation2);
  disposables.addFromEvent(element, "pointerup", stopPropagation2);
  disposables.addFromEvent(element, "dragstart", onDragStart);
  disposables.addFromEvent(element, "drag", onDrag);
  disposables.addFromEvent(element, "dragend", onDragEnd);
  return disposables;
}
function getClosestRow(point, rows) {
  const length2 = rows.length;
  for (let i = 0; i < length2; i++) {
    const row = rows[i];
    const { top: top2, bottom: bottom2 } = row.getBoundingClientRect();
    if (point.y <= top2 + 20 && point.y >= top2 - 20) {
      return {
        element: row,
        insertRowIndex: i,
        isLast: false
      };
    }
    if (i === length2 - 1) {
      if (point.y >= bottom2 - 20 && point.y <= bottom2 + 20) {
        return {
          element: row,
          insertRowIndex: i + 1,
          isLast: true
        };
      }
    }
  }
  return null;
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/toolbar/toolbar.js
var __decorate64 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles10 = css`
  .affine-database-toolbar {
    display: none;
    align-items: center;
    gap: 26px;
  }
  .affine-database-toolbar-search svg,
  .affine-database-toolbar svg {
    width: 16px;
    height: 16px;
    fill: var(--affine-icon-color);
  }
  .affine-database-toolbar-item {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  .search-container.hidden {
    overflow: hidden;
  }
  .affine-database-toolbar-item.more-action {
    width: 32px;
    height: 32px;
    border-radius: 4px;
  }
  .affine-database-toolbar-item.more-action:hover,
  .more-action.active {
    background: var(--affine-hover-color);
  }
  .affine-database-search-container {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 16px;
    height: 32px;
    padding: 8px 0;
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  .affine-database-search-container > svg {
    min-width: 16px;
    min-height: 16px;
  }
  .search-container-expand {
    width: 138px;
    padding: 8px 12px;
    background-color: var(--affine-hover-color);
  }
  .search-input-container {
    display: flex;
    align-items: center;
  }
  .search-input-container > .close-icon {
    display: flex;
    align-items: center;
  }
  .close-icon .code {
    width: 31px;
    height: 18px;
    padding: 2px 6px;
    border-radius: 4px;
    background: var(--affine-white-10);
  }
  .affine-database-search-input-icon {
    display: inline-flex;
  }
  .affine-database-search-input {
    flex: 1;
    height: 16px;
    width: 80px;
    border: none;
    font-family: var(--affine-font-family);
    font-size: var(--affine-font-sm);
    box-sizing: border-box;
    color: inherit;
    background: transparent;
  }
  .affine-database-search-input:focus {
    outline: none;
  }
  .affine-database-search-input::placeholder {
    color: var(--affine-placeholder-color);
    font-size: var(--affine-font-sm);
  }

  .affine-database-toolbar-item.new-record {
    display: flex;
    align-items: center;
    gap: 4px;
    width: 120px;
    height: 32px;
    padding: 6px 8px;
    border-radius: 8px;
    font-size: 14px;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.05),
      0px 0px 0px 0.5px var(--affine-black-10);
    background: linear-gradient(
        0deg,
        var(--affine-hover-color),
        var(--affine-hover-color)
      ),
      var(--affine-white);
  }
  .new-record > tool-tip {
    max-width: 280px;
  }

  .show-toolbar {
    display: flex;
  }
`;
var DatabaseToolbar = class DatabaseToolbar2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._recordAddDisposables = new DisposableGroup();
    this._onSearch = (event) => {
      const el = event.target;
      const inputValue = el.value.trim();
      this.setSearchState(SearchState.Searching);
      if (inputValue === "") {
        this.setSearchState(SearchState.SearchInput);
      }
      const { _databaseMap } = this;
      const existingRowIds = Object.keys(_databaseMap).filter((key) => {
        return _databaseMap[key].findIndex((item) => item.toLocaleLowerCase().includes(inputValue.toLocaleLowerCase())) > -1;
      });
      const filteredRowIds = this.targetModel.children.filter((child) => existingRowIds.includes(child.id)).map((child) => child.id);
      this.setFilteredRowIds(filteredRowIds);
      requestAnimationFrame(() => el.focus());
    };
    this._onSearchKeydown = (event) => {
      if (event.key === "Escape") {
        if (this._searchInput.value) {
          this._searchInput.value = "";
          this.setSearchState(SearchState.SearchInput);
        } else {
          this._resetSearchStatus();
          this._searchContainer.classList.add("hidden");
        }
      }
    };
    this._clearSearch = (event) => {
      event.stopPropagation();
      this._searchInput.value = "";
      this.setSearchState(SearchState.SearchInput);
    };
    this._onShowSearch = () => {
      this.setSearchState(SearchState.SearchInput);
      const removeListener = onClickOutside(this._searchContainer, () => {
        if (this.searchState !== SearchState.Searching) {
          this._searchContainer.classList.add("hidden");
          this.setSearchState(SearchState.SearchIcon);
          removeListener();
        }
      }, "click", true);
    };
    this._onFocusSearchInput = () => {
      if (this.searchState === SearchState.SearchInput) {
        this._searchInput.focus();
        this._searchContainer.classList.remove("hidden");
      } else {
        this._searchInput.blur();
      }
    };
    this._onShowAction = () => {
      if (this.readonly)
        return;
      if (this._toolbarAction) {
        this._closeToolbarAction();
        return;
      }
      this.setSearchState(SearchState.Action);
      this._toolbarAction = new ToolbarActionPopup();
      this._toolbarAction.targetModel = this.targetModel;
      this._toolbarAction.close = this._closeToolbarAction;
      this._moreActionContainer.appendChild(this._toolbarAction);
      createPopper3(this._moreActionContainer, this._toolbarAction, {
        placement: "bottom"
      });
      onClickOutside(this._moreActionContainer, () => {
        this._closeToolbarAction();
      }, "mousedown");
    };
    this._closeToolbarAction = () => {
      var _a3;
      (_a3 = this._toolbarAction) == null ? void 0 : _a3.remove();
      this._toolbarAction = void 0;
    };
    this._resetSearchStatus = () => {
      this._searchInput.value = "";
      this.setFilteredRowIds([]);
      this.setSearchState(SearchState.SearchIcon);
    };
    this._onAddNewRecord = () => {
      if (this.readonly)
        return;
      this.addRow(0);
    };
  }
  get readonly() {
    return this.targetModel.page.readonly;
  }
  firstUpdated() {
    if (!this.readonly) {
      this._initAddRecordHandlers();
    }
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (!this.readonly) {
      this._initAddRecordHandlers();
    }
  }
  _initAddRecordHandlers() {
    this._recordAddDisposables.dispose();
    const disposables = initAddNewRecordHandlers(this._newRecord, this, this.addRow);
    if (disposables) {
      this._recordAddDisposables = disposables;
    }
  }
  get _databaseMap() {
    var _a3;
    const databaseMap = {};
    for (const child of this.targetModel.children) {
      databaseMap[child.id] = [((_a3 = child.text) == null ? void 0 : _a3.toString()) ?? ""];
    }
    const { cells } = this.targetModel;
    const rowIds = this.targetModel.children.map((child) => child.id);
    rowIds.forEach((rowId) => {
      const columnMap = cells[rowId];
      if (!columnMap)
        return;
      const columnValues = Object.keys(columnMap).map((key) => {
        const value = columnMap[key].value;
        if (Array.isArray(value)) {
          return value.map((item) => item.value);
        }
        return columnMap[key].value + "";
      });
      databaseMap[rowId].push(...columnValues.flat());
    });
    return databaseMap;
  }
  render() {
    const expandSearch = this.searchState === SearchState.SearchInput || this.searchState === SearchState.Searching;
    const isActiveMoreAction = this.searchState === SearchState.Action;
    const onSearchIconClick = expandSearch ? void 0 : this._onShowSearch;
    const closeIcon = this._searchInput ? this._searchInput.value === "" ? null : DatabaseSearchClose : null;
    const searchTool = html`
      <div
        class="affine-database-search-container ${expandSearch ? "search-container-expand" : ""}"
        @click=${onSearchIconClick}
        @transitionend=${this._onFocusSearchInput}
      >
        <div class="affine-database-search-input-icon">
          ${DatabaseSearchIcon}
        </div>
        <div class="search-input-container">
          <input
            placeholder="Search..."
            class="affine-database-search-input"
            @input=${this._onSearch}
            @click=${(event) => event.stopPropagation()}
            @keydown=${this._onSearchKeydown}
            @pointerdown=${stopPropagation}
          />
          <div class="has-tool-tip close-icon" @click=${this._clearSearch}>
            ${closeIcon}
            <tool-tip inert arrow tip-position="top" role="tooltip">
              <span class="code">Esc</span> to clear all
            </tool-tip>
          </div>
        </div>
      </div>
    `;
    return html`<div
      class="affine-database-toolbar ${this.hoverState ? "show-toolbar" : ""}"
    >
      <div class="affine-database-toolbar-item search-container hidden">
        ${searchTool}
      </div>
      ${this.readonly ? null : html`<div
              class="affine-database-toolbar-item more-action ${isActiveMoreAction ? "active" : ""}"
              @click=${this._onShowAction}
            >
              ${MoreHorizontalIcon}
            </div>
            <div
              class="has-tool-tip affine-database-toolbar-item new-record"
              draggable="true"
              @click=${this._onAddNewRecord}
            >
              ${PlusIcon}<span>New Record</span>
              <tool-tip inert arrow tip-position="top" role="tooltip"
                >You can drag this button to the desired location and add a
                record
              </tool-tip>
            </div>`}
    </div>`;
  }
};
DatabaseToolbar.styles = styles10;
__decorate64([
  property()
], DatabaseToolbar.prototype, "targetModel", void 0);
__decorate64([
  property()
], DatabaseToolbar.prototype, "hoverState", void 0);
__decorate64([
  property()
], DatabaseToolbar.prototype, "searchState", void 0);
__decorate64([
  property()
], DatabaseToolbar.prototype, "addRow", void 0);
__decorate64([
  property()
], DatabaseToolbar.prototype, "setSearchState", void 0);
__decorate64([
  property()
], DatabaseToolbar.prototype, "setFilteredRowIds", void 0);
__decorate64([
  query(".affine-database-search-input")
], DatabaseToolbar.prototype, "_searchInput", void 0);
__decorate64([
  query(".more-action")
], DatabaseToolbar.prototype, "_moreActionContainer", void 0);
__decorate64([
  query(".search-container")
], DatabaseToolbar.prototype, "_searchContainer", void 0);
__decorate64([
  query(".new-record")
], DatabaseToolbar.prototype, "_newRecord", void 0);
DatabaseToolbar = __decorate64([
  customElement("affine-database-toolbar")
], DatabaseToolbar);

// node_modules/@blocksuite/blocks/dist/components/virgo-input/virgo-input.js
var VirgoInput = class _VirgoInput {
  constructor(options2) {
    this.yDoc = new Doc();
    this._active = true;
    this.type = "default";
    this.maxLength = Infinity;
    const { rootElement, yText = this.yDoc.getText(_VirgoInput.YTEXT_NAME), maxLength, type } = options2;
    const text = yText.toString();
    if (maxLength) {
      this.maxLength = maxLength;
      if (text.length > maxLength) {
        throw new Error("The text exceeds the limit length.");
      }
    }
    if (type) {
      this.type = type;
    }
    if (yText instanceof YText) {
      if (yText.doc) {
        this.yText = yText;
        this.yDoc = yText.doc;
      } else {
        throw new Error("Y.Text should be binded to Y.Doc.");
      }
    } else {
      this.yText = this.yDoc.getText(_VirgoInput.YTEXT_NAME);
      this.yText.insert(0, text);
    }
    this.undoManager = new UndoManager(this.yText, {
      trackedOrigins: /* @__PURE__ */ new Set([this.yDoc.clientID])
    });
    this.undoManager.on("stack-item-added", (event) => {
      const vRange = this.vEditor.getVRange();
      event.stackItem.meta.set("v-range", vRange);
    });
    this.undoManager.on("stack-item-popped", (event) => {
      const vRange = event.stackItem.meta.get("v-range");
      if (vRange) {
        this.vEditor.setVRange(vRange);
      }
    });
    this.vEditor = new VEditor(this.yText, {
      active: () => activeEditorManager.isActive(options2.rootElement) && this.active
    });
    this.vEditor.mount(rootElement);
    this.vEditor.bindHandlers({
      paste: (event) => {
        var _a3, _b;
        event.stopPropagation();
        const data = (_b = (_a3 = event.clipboardData) == null ? void 0 : _a3.getData("text/plain")) == null ? void 0 : _b.replace(/(\r\n|\r|\n)/g, "\n");
        if (!data) {
          return;
        }
        const vRange = this.vEditor.getVRange();
        if (vRange) {
          if (vRange.length > 0) {
            this.vEditor.yText.delete(vRange.index, vRange.length);
          }
          const length2 = this.vEditor.yText.length;
          const restLength = this.maxLength - length2;
          if (restLength <= 0) {
            return;
          }
          const text2 = data.length > restLength ? data.slice(0, restLength) : data;
          this.vEditor.insertText(vRange, text2);
          this.vEditor.setVRange({
            index: vRange.index + text2.length,
            length: 0
          });
          this.undoManager.stopCapturing();
        }
      },
      virgoInput: (ctx) => {
        const vRange = this.vEditor.getVRange();
        if (!vRange) {
          return ctx;
        }
        let originalText = this.vEditor.yText.toString();
        if (vRange.length > 0) {
          originalText = `${originalText.substring(0, vRange.index)}${originalText.substring(vRange.index + vRange.length)}`;
        }
        const tmpText = `${originalText.substring(0, vRange.index)}${ctx.data ?? ""}${originalText.substring(vRange.index)}`;
        let flag = true;
        if (tmpText.length >= this.maxLength) {
          ctx.skipDefault = true;
          flag = false;
        }
        if (flag) {
          this.undoManager.stopCapturing();
        }
        return ctx;
      },
      virgoCompositionEnd: (ctx) => {
        const vRange = this.vEditor.getVRange();
        if (!vRange) {
          return ctx;
        }
        let originalText = this.vEditor.yText.toString();
        if (vRange.length > 0) {
          originalText = `${originalText.substring(0, vRange.index)}${originalText.substring(vRange.index + vRange.length)}`;
        }
        const tmpText = `${originalText.substring(0, vRange.index)}${ctx.data}${originalText.substring(vRange.index)}`;
        let flag = true;
        if (tmpText.length >= this.maxLength) {
          ctx.data = "";
          flag = false;
        }
        if (flag) {
          this.undoManager.stopCapturing();
        }
        return ctx;
      },
      keydown: (e) => {
        if (e instanceof KeyboardEvent && (e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "Z")) {
          e.preventDefault();
          if (e.shiftKey) {
            this.redo();
          } else {
            this.undo();
          }
        }
      }
    });
    rootElement.addEventListener("blur", () => {
      if (this.type === "number") {
        const text2 = this.yText.toString();
        const num = parseFloat(text2);
        const transformedText = isNaN(num) ? "" : num.toString();
        if (text2 !== transformedText) {
          this.setActive(false);
          this.setValue(transformedText);
          requestAnimationFrame(() => {
            this.setActive(true);
          });
        }
      }
    });
  }
  get value() {
    return this.yText.toString();
  }
  get active() {
    return this._active;
  }
  setActive(value) {
    this._active = value;
  }
  setValue(str) {
    if (str.length > this.maxLength) {
      throw new Error("The text exceeds the limit length.");
    }
    this.yText.delete(0, this.yText.length);
    this.yText.insert(0, str);
    this.vEditor.setVRange({
      index: str.length,
      length: 0
    });
    this.undoManager.stopCapturing();
  }
  undo() {
    this.undoManager.undo();
  }
  redo() {
    this.undoManager.redo();
  }
};
VirgoInput.YTEXT_NAME = "YTEXT_NAME";

// node_modules/@blocksuite/blocks/dist/database-block/table/components/database-title.js
var __decorate65 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DatabaseTitle = class DatabaseTitle2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._titleVInput = null;
    this._handleKeyDown = (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        this.addRow(0);
        return;
      }
    };
    this._onTitleFocus = () => {
      var _a3, _b, _c;
      this._titleContainer.classList.remove("ellipsis");
      (_a3 = this._titleVInput) == null ? void 0 : _a3.setActive(true);
      if (((_b = this._titleVInput) == null ? void 0 : _b.value) === "Database") {
        (_c = this._titleVInput) == null ? void 0 : _c.setValue("");
      }
    };
    this._onTitleBlur = () => {
      var _a3, _b, _c;
      this._titleContainer.classList.add("ellipsis");
      (_a3 = this._titleVInput) == null ? void 0 : _a3.setActive(false);
      if (((_b = this._titleVInput) == null ? void 0 : _b.value) === "") {
        (_c = this._titleVInput) == null ? void 0 : _c.setValue(DEFAULT_TITLE);
      }
    };
  }
  firstUpdated() {
    this._initTitleVEditor();
    const disposables = this._disposables;
    disposables.addFromEvent(this._titleContainer, "focus", this._onTitleFocus);
    disposables.addFromEvent(this._titleContainer, "blur", this._onTitleBlur);
    const onStopPropagation = (event) => event.stopPropagation();
    this._disposables.addFromEvent(this, "pointerdown", onStopPropagation);
    this._disposables.addFromEvent(this, "pointermove", onStopPropagation);
  }
  _initTitleVEditor() {
    this._titleVInput = new VirgoInput({
      yText: this.targetModel.title.yText,
      rootElement: this._titleContainer,
      maxLength: DATABASE_TITLE_LENGTH
    });
    setupVirgoScroll(this.targetModel.page, this._titleVInput.vEditor);
    this._titleVInput.vEditor.setReadonly(this.targetModel.page.readonly);
    this._titleContainer.addEventListener("keydown", this._handleKeyDown);
    this.targetModel.title.yText.observe(() => {
      this.requestUpdate();
    });
  }
  render() {
    const isEmpty2 = !this.targetModel.title || !this.targetModel.title.length;
    return html`<div class="affine-database-title">
      <div
        class="database-title ${isEmpty2 ? "database-title-empty" : ""}"
        data-block-is-database-title="true"
        title=${this.targetModel.title.toString()}
      ></div>
    </div>`;
  }
};
DatabaseTitle.styles = css`
    .affine-database-title {
      flex: 1;
      max-width: 300px;
      min-width: 300px;
      height: 30px;
    }

    .database-title {
      position: sticky;
      width: 300px;
      height: 30px;
      font-size: 18px;
      font-weight: 600;
      line-height: 24px;
      color: var(--affine-text-primary-color);
      font-family: inherit;
      /* overflow-x: scroll; */
      overflow: hidden;
      cursor: text;
    }

    .database-title [data-virgo-text='true'] {
      display: block;
      white-space: pre !important;
    }

    .database-title.ellipsis [data-virgo-text='true'] {
      white-space: nowrap !important;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .database-title:focus {
      outline: none;
    }

    .database-title:disabled {
      background-color: transparent;
    }

    .database-title-empty::before {
      content: 'Database';
      color: var(--affine-placeholder-color);
      position: absolute;
      opacity: 0.5;
    }
  `;
__decorate65([
  property()
], DatabaseTitle.prototype, "targetModel", void 0);
__decorate65([
  property()
], DatabaseTitle.prototype, "addRow", void 0);
__decorate65([
  query(".database-title")
], DatabaseTitle.prototype, "_titleContainer", void 0);
DatabaseTitle = __decorate65([
  customElement("affine-database-title")
], DatabaseTitle);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/checkbox.js
var __decorate66 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CheckboxCell = class CheckboxCell2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "checkbox";
  }
  firstUpdated() {
    this._disposables.addFromEvent(this, "click", this._onChange);
  }
  _onChange() {
    var _a3;
    const checked = !((_a3 = this.cell) == null ? void 0 : _a3.value);
    this.rowHost.setValue(checked);
  }
  render() {
    var _a3;
    const checked = ((_a3 = this.cell) == null ? void 0 : _a3.value) ?? false;
    const icon = checked ? checkboxChecked() : checkboxUnchecked();
    return html`<div class="affine-database-checkbox-container">
      <div class="affine-database-checkbox checkbox ${checked && "checked"}">
        ${icon}
      </div>
    </div>`;
  }
};
CheckboxCell.tag = literal`affine-database-checkbox-cell`;
CheckboxCell.styles = css`
    affine-database-checkbox-cell {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .affine-database-checkbox-container {
      height: 100%;
    }

    .affine-database-checkbox {
      display: flex;
      align-items: center;
      height: 100%;
      width: 100%;
    }
  `;
CheckboxCell = __decorate66([
  customElement("affine-database-checkbox-cell")
], CheckboxCell);
var CheckboxColumnRenderer = defineColumnRenderer("checkbox", () => ({}), () => false, {
  Cell: CheckboxCell,
  CellEditing: null
}, {
  displayName: "Checkbox"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/multi-select.js
var __decorate67 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var MultiSelectCell = class MultiSelectCell2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "multi-select";
  }
  render() {
    return html2`
      <affine-database-select-cell
        .rowHost=${this.rowHost}
        .databaseModel=${this.databaseModel}
        .rowModel=${this.rowModel}
        .column=${this.column}
        .cell=${this.cell}
      ></affine-database-select-cell>
    `;
  }
};
MultiSelectCell.styles = css`
    :host {
      width: 100%;
    }
  `;
MultiSelectCell.tag = literal`affine-database-multi-select-cell`;
MultiSelectCell = __decorate67([
  customElement("affine-database-multi-select-cell")
], MultiSelectCell);
var MultiSelectCellEditing = class MultiSelectCellEditing2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "multi-select";
  }
  render() {
    return html2`
      <affine-database-select-cell-editing
        data-is-editing-cell="true"
        .rowHost=${this.rowHost}
        .databaseModel=${this.databaseModel}
        .rowModel=${this.rowModel}
        .column=${this.column}
        .cell=${this.cell}
        .mode=${SelectMode.Multi}
      ></affine-database-select-cell-editing>
    `;
  }
};
MultiSelectCellEditing.tag = literal`affine-database-multi-select-cell-editing`;
MultiSelectCellEditing = __decorate67([
  customElement("affine-database-multi-select-cell-editing")
], MultiSelectCellEditing);
var MultiSelectColumnRenderer = defineColumnRenderer("multi-select", () => ({
  selection: []
}), () => [], {
  Cell: MultiSelectCell,
  CellEditing: MultiSelectCellEditing
}, {
  displayName: "Multi Select"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/number.js
var __decorate68 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NumberCellEditing = class NumberCellEditing2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "number";
    this._vInput = null;
    this._onClick = () => {
      this.databaseModel.page.captureSync();
    };
    this._onInitVEditor = () => {
      var _a3;
      let value;
      if (!((_a3 = this.cell) == null ? void 0 : _a3.value)) {
        const yText = new this.databaseModel.page.YText("");
        this.databaseModel.updateCell(this.rowModel.id, {
          columnId: this.column.id,
          value: yText
        });
        value = yText;
      } else {
        value = this.cell.value;
      }
      this._vInput = new VirgoInput({
        yText: value,
        rootElement: this._container,
        type: "number"
      });
      setupVirgoScroll(this.databaseModel.page, this.vEditor);
      this._container.addEventListener("keydown", (event) => {
        if (!this._vInput)
          return;
        if (event.key === "Enter") {
          if (event.shiftKey) {
          } else {
            this.rowHost.setEditing(false);
            this._container.blur();
          }
          event.preventDefault();
          return;
        }
      });
    };
  }
  get vEditor() {
    assertExists(this._vInput);
    return this._vInput.vEditor;
  }
  firstUpdated() {
    this._disposables.addFromEvent(this, "click", this._onClick);
    this._onInitVEditor();
  }
  render() {
    return html`<div class="affine-database-number number virgo-editor"></div>`;
  }
};
NumberCellEditing.styles = css`
    affine-database-number-cell-editing {
      display: block;
      width: 100%;
      height: 100%;
      cursor: text;
    }

    .affine-database-number {
      display: flex;
      align-items: center;
      height: 100%;
    }
    .affine-database-number:focus {
      outline: none;
    }
    .affine-database-number v-line {
      display: flex !important;
      align-items: center;
      height: 100%;
      width: 100%;
    }
    .affine-database-number v-line > div {
      flex-grow: 1;
    }
  `;
NumberCellEditing.tag = literal`affine-database-number-cell-editing`;
__decorate68([
  query(".affine-database-number")
], NumberCellEditing.prototype, "_container", void 0);
NumberCellEditing = __decorate68([
  customElement("affine-database-number-cell-editing")
], NumberCellEditing);
var NumberColumnRenderer = defineColumnRenderer("number", () => ({
  decimal: 0
}), (page) => new page.YText(""), {
  Cell: NumberCellEditing,
  CellEditing: null
}, {
  displayName: "Number"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/progress.js
var __decorate69 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles11 = css`
  affine-database-progress-cell-editing {
    display: block;
    width: 100%;
    height: 100%;
    padding: 0 4px;
  }

  affine-database-progress-cell-editing:hover
    .affine-database-progress-drag-handle {
    opacity: 1;
  }

  .affine-database-progress {
    display: flex;
    align-items: center;
    height: 100%;
    gap: 4px;
  }

  .affine-database-progress-bar {
    position: relative;
    width: 104px;
  }

  .affine-database-progress-bg {
    overflow: hidden;
    width: 100%;
    height: 13px;
    border-radius: 22px;
  }

  .affine-database-progress-fg {
    height: 100%;
  }

  .affine-database-progress-drag-handle {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(0px, -1px);
    width: 6px;
    height: 15px;
    border-radius: 2px;
    opacity: 0;
    cursor: ew-resize;
    background: var(--affine-primary-color);
    transition: opacity 0.2s ease-in-out;
  }

  .progress-number {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 18px;
    width: 25px;
    color: var(--affine-text-secondary-color);
    font-size: 14px;
  }
`;
var progressColors = {
  empty: "var(--affine-black-10)",
  processing: "var(--affine-processing-color)",
  success: "var(--affine-success-color)"
};
var ProgressCellEditing = class ProgressCellEditing2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "progress";
    this._dragConfig = null;
    this._progressBgWidth = 0;
    this._onDocumentMove = () => {
      if (!this._dragConfig)
        return;
      this._onPointerUp();
    };
    this._onPointerDown = (event) => {
      event.stopPropagation();
      const { left: left2, width } = this._progressBg.getBoundingClientRect();
      const visibleWidth = width - 6;
      this._dragConfig = {
        stepWidth: visibleWidth / 100,
        boundLeft: left2,
        containerWidth: visibleWidth
      };
      this.databaseModel.page.captureSync();
    };
    this._onPointerMove = (event) => {
      var _a3;
      event.stopPropagation();
      if (!this._dragConfig)
        return;
      const x = event.clientX;
      const { boundLeft, containerWidth, stepWidth } = this._dragConfig;
      let steps;
      if (x <= boundLeft) {
        steps = 0;
      } else if (x - boundLeft >= containerWidth) {
        steps = 100;
      } else {
        steps = Math.floor((x - boundLeft) / stepWidth);
      }
      if (((_a3 = this.cell) == null ? void 0 : _a3.value) !== steps) {
        this.rowHost.setValue(steps, { captureSync: false });
      }
    };
    this._onPointerUp = () => {
      this._dragConfig = null;
      this.databaseModel.page.captureSync();
    };
  }
  firstUpdated() {
    var _a3;
    const disposables = this._disposables;
    disposables.addFromEvent(this._dragHandle, "pointerdown", this._onPointerDown);
    disposables.addFromEvent(this, "pointermove", this._onPointerMove);
    disposables.addFromEvent(this, "pointerup", this._onPointerUp);
    disposables.addFromEvent(document, "pointermove", this._onDocumentMove);
    const { width } = this._progressBg.getBoundingClientRect();
    const visibleWidth = width - 6;
    this._progressBgWidth = visibleWidth;
    const value = (_a3 = this.cell) == null ? void 0 : _a3.value;
    if (value) {
      this._setDragHandlePosition(value);
    }
  }
  _setDragHandlePosition(value) {
    const x = this._progressBgWidth * (value / 100);
    this._dragHandle.style.transform = `translate(${x}px, -1px)`;
  }
  updated(_changedProperties) {
    var _a3;
    super.updated(_changedProperties);
    if (_changedProperties.has("cell")) {
      this._setDragHandlePosition(((_a3 = this.cell) == null ? void 0 : _a3.value) ?? 0);
    }
  }
  render() {
    var _a3;
    const progress = ((_a3 = this.cell) == null ? void 0 : _a3.value) ?? 0;
    let backgroundColor = progressColors.processing;
    if (progress === 100) {
      backgroundColor = progressColors.success;
    }
    const fgStyles = styleMap({
      width: `${progress}%`,
      backgroundColor
    });
    const bgStyles = styleMap({
      backgroundColor: progress === 0 ? progressColors.empty : "var(--affine-hover-color)"
    });
    return html`<div
      class="affine-database-progress"
      @mousedown=${(e) => e.preventDefault()}
    >
      <div class="affine-database-progress-bar">
        <div class="affine-database-progress-bg" style=${bgStyles}>
          <div class="affine-database-progress-fg" style=${fgStyles}></div>
          <div class="affine-database-progress-drag-handle"></div>
        </div>
      </div>
      <div class="progress-number progress">${progress}</div>
    </div>`;
  }
};
ProgressCellEditing.styles = styles11;
ProgressCellEditing.tag = literal`affine-database-progress-cell-editing`;
__decorate69([
  query(".affine-database-progress-drag-handle")
], ProgressCellEditing.prototype, "_dragHandle", void 0);
__decorate69([
  query(".affine-database-progress-bg")
], ProgressCellEditing.prototype, "_progressBg", void 0);
ProgressCellEditing = __decorate69([
  customElement("affine-database-progress-cell-editing")
], ProgressCellEditing);
var ProgressColumnRenderer = defineColumnRenderer("progress", () => ({}), () => 0, {
  Cell: ProgressCellEditing,
  CellEditing: null
}, {
  displayName: "Progress"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/rich-text.js
var __decorate70 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function toggleStyle(vEditor, attrs) {
  const vRange = vEditor.getVRange();
  if (!vRange) {
    return;
  }
  const root2 = vEditor.rootElement;
  if (!root2) {
    return;
  }
  const deltas = vEditor.getDeltasByVRange(vRange);
  let oldAttributes = {};
  for (const [delta] of deltas) {
    const attributes = delta.attributes;
    if (!attributes) {
      continue;
    }
    oldAttributes = { ...attributes };
  }
  const newAttributes = Object.fromEntries(Object.entries(attrs).map(([k, v]) => {
    if (typeof v === "boolean" && v === oldAttributes[k]) {
      return [k, !v];
    } else {
      return [k, v];
    }
  }));
  vEditor.formatText(vRange, newAttributes, {
    mode: "merge"
  });
  root2.blur();
  vEditor.syncVRange();
}
var TextCell = class TextCell2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.vEditor = null;
    this.cellType = "rich-text";
    this._initYText = (text) => {
      const yText = new this.databaseModel.page.YText(text);
      this.databaseModel.updateCell(this.rowModel.id, {
        columnId: this.column.id,
        value: yText
      });
      return yText;
    };
    this._handleKeyDown = (event) => {
      if (event.key !== "Escape") {
        if (event.key === "Tab") {
          event.preventDefault();
          return;
        }
        event.stopPropagation();
      }
      if (!this.vEditor)
        return;
      if (event.key === "Enter") {
        if (event.shiftKey) {
          this._onSoftEnter();
        } else {
          this.rowHost.setEditing(false);
          this._container.blur();
        }
        event.preventDefault();
        return;
      }
      const vEditor = this.vEditor;
      switch (event.key) {
        case "B":
        case "b":
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            toggleStyle(this.vEditor, { bold: true });
          }
          break;
        case "I":
        case "i":
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            toggleStyle(this.vEditor, { italic: true });
          }
          break;
        case "U":
        case "u":
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            toggleStyle(this.vEditor, { underline: true });
          }
          break;
        case "S":
        case "s":
          if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            event.preventDefault();
            toggleStyle(vEditor, { strike: true });
          }
          break;
        case "E":
        case "e":
          if ((event.metaKey || event.ctrlKey) && event.shiftKey) {
            event.preventDefault();
            toggleStyle(vEditor, { code: true });
          }
          break;
        default:
          break;
      }
    };
    this._onSoftEnter = () => {
      if (this.cell && this.vEditor) {
        const vRange = this.vEditor.getVRange();
        assertExists(vRange);
        const page = this.databaseModel.page;
        page.captureSync();
        const text = new Text2(this.vEditor.yText);
        text.replace(vRange.index, length, "\n");
        this.vEditor.setVRange({
          index: vRange.index + 1,
          length: 0
        });
      }
    };
  }
  get readonly() {
    return this.databaseModel.page.readonly;
  }
  firstUpdated() {
    this._onInitVEditor();
    this._disposables.addFromEvent(this, "click", this._handleClick);
  }
  _handleClick() {
    this.databaseModel.page.captureSync();
  }
  _onInitVEditor() {
    var _a3;
    let value;
    if (!((_a3 = this.cell) == null ? void 0 : _a3.value)) {
      value = this._initYText();
    } else {
      if (typeof this.cell.value === "string") {
        value = this._initYText(this.cell.value);
      } else {
        value = this.cell.value;
      }
    }
    this.vEditor = new VEditor(value, {
      active: () => activeEditorManager.isActive(this)
    });
    setupVirgoScroll(this.databaseModel.page, this.vEditor);
    this.vEditor.mount(this._container);
    this.vEditor.bindHandlers({
      keydown: this._handleKeyDown
    });
    this.vEditor.setReadonly(this.readonly);
  }
  render() {
    return html2`<div class="affine-database-rich-text virgo-editor"></div>`;
  }
};
TextCell.styles = css`
    affine-database-rich-text-cell {
      display: flex;
      align-items: center;
      width: 100%;
      height: 100%;
      cursor: text;
    }

    .affine-database-rich-text {
      display: flex;
      flex-direction: column;
      justify-content: center;
      width: 100%;
      height: 100%;
      outline: none;
    }
    .affine-database-rich-text v-line {
      display: flex !important;
      align-items: center;
      height: 100%;
      width: 100%;
    }
    .affine-database-rich-text v-line > div {
      flex-grow: 1;
    }
  `;
TextCell.tag = literal`affine-database-rich-text-cell`;
__decorate70([
  query(".affine-database-rich-text")
], TextCell.prototype, "_container", void 0);
TextCell = __decorate70([
  customElement("affine-database-rich-text-cell")
], TextCell);
var RichTextColumnRenderer = defineColumnRenderer("rich-text", () => ({}), (page) => new page.YText(""), {
  Cell: TextCell,
  CellEditing: null
}, {
  displayName: "Rich Text"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/select/select-option.js
var __decorate71 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SelectOption = class SelectOption2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this._onOptionFocus = () => {
      this._container.classList.remove("ellipsis");
    };
    this._onOptionBlur = () => {
      this._container.classList.add("ellipsis");
    };
  }
  get _vEditor() {
    return this._vInput.vEditor;
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("editing")) {
      if (this.editing) {
        this._vEditor.focusEnd();
      }
      this._vEditor.setReadonly(!this.editing);
      this._vEditor.setText(this.select.value);
    }
    if (changedProperties.has("select")) {
      this._vEditor.setText(this.select.value);
    }
  }
  getSelectionValue() {
    return this._vEditor.yText.toString();
  }
  _onInitVEditor() {
    this._vInput = new VirgoInput({
      yText: this.select.value,
      rootElement: this._container,
      maxLength: SELECT_TAG_NAME_MAX_LENGTH
    });
    setupVirgoScroll(this.databaseModel.page, this._vEditor);
    this._vEditor.setReadonly(!this.editing);
    this._container.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        if (this._vInput.value.length > 0) {
          this.saveSelectionName(this.index);
        }
      }
      if (event.key === "Escape") {
        event.stopPropagation();
        event.preventDefault();
        this.setEditingIndex(-1);
        this._container.blur();
      }
    });
  }
  firstUpdated() {
    this._disposables.addFromEvent(this._container, "focus", this._onOptionFocus);
    this._disposables.addFromEvent(this._container, "blur", this._onOptionBlur);
    this._onInitVEditor();
  }
  render() {
    const style = styleMap({
      backgroundColor: this.select.color,
      cursor: this.editing ? "text" : "pointer"
    });
    return html`<div
      class="select-option-text virgo-editor"
      style=${style}
    ></div>`;
  }
};
SelectOption.styles = css`
    affine-database-select-option {
      display: flex;
      align-items: center;
    }
    .select-option-text {
      display: inline-block;
      min-width: 22px;
      height: 100%;
      max-width: 100%;
      padding: 2px 10px;
      border-radius: 4px;
      background: var(--affine-tag-pink);
      overflow: hidden;
      cursor: text;
    }
    .select-option-text:focus {
      outline: none;
    }

    .select-option-text [data-virgo-text='true'] {
      display: block;
      white-space: nowrap !important;
      text-overflow: ellipsis;
      overflow: hidden;
    }
  `;
__decorate71([
  property()
], SelectOption.prototype, "databaseModel", void 0);
__decorate71([
  property()
], SelectOption.prototype, "select", void 0);
__decorate71([
  property()
], SelectOption.prototype, "editing", void 0);
__decorate71([
  property()
], SelectOption.prototype, "index", void 0);
__decorate71([
  property()
], SelectOption.prototype, "saveSelectionName", void 0);
__decorate71([
  property()
], SelectOption.prototype, "setEditingIndex", void 0);
__decorate71([
  query(".select-option-text")
], SelectOption.prototype, "_container", void 0);
SelectOption = __decorate71([
  customElement("affine-database-select-option")
], SelectOption);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/selection/cell-selection.js
var __decorate72 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CellLevelSelection = class CellLevelSelection2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.state = null;
    this.setSelection = (state2) => {
      this.state = state2;
    };
    this.clearSelection = () => {
      this.state = null;
    };
    this._getStyles = () => {
      if (this.state === null) {
        return styleMap({
          left: 0,
          top: 0,
          height: 0,
          width: 0,
          display: "none"
        });
      }
      const { databaseId, coords } = this.state;
      const { left: left2, top: top2, width, height } = getCellSelectionRectByCoords(coords, databaseId);
      const rowsContainer = getRowsContainer(databaseId);
      const containerRect = rowsContainer.getBoundingClientRect();
      const scale = 1 / this._zoom;
      const scaledLeft = (left2 - containerRect.left) * scale;
      const scaledTop = (top2 - containerRect.top) * scale;
      const scaledWidth = width * scale;
      const scaledHeight = height * scale;
      return styleMap({
        left: `${scaledLeft}px`,
        top: `${scaledTop}px`,
        height: `${scaledHeight}px`,
        width: `${scaledWidth}px`,
        display: "block"
      });
    };
  }
  get _zoom() {
    const edgelessPageBlock = document.querySelector("affine-edgeless-page");
    if (!edgelessPageBlock)
      return 1;
    return edgelessPageBlock.surface.viewport.zoom;
  }
  render() {
    const styles15 = this._getStyles();
    return html`<div
      class="database-cell-level-selection"
      style=${styles15}
    ></div>`;
  }
};
CellLevelSelection.styles = css`
    .database-cell-level-selection {
      position: absolute;
      width: 100%;
      z-index: 1;
      box-sizing: border-box;
      border: 2px solid var(--affine-primary-color);
      border-radius: 2px;
      background: var(--affine-primary-color-04);
    }
  `;
__decorate72([
  property()
], CellLevelSelection.prototype, "cell", void 0);
__decorate72([
  state()
], CellLevelSelection.prototype, "state", void 0);
CellLevelSelection = __decorate72([
  customElement("database-cell-level-selection")
], CellLevelSelection);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/selection/row-selection.js
var __decorate73 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowLevelSelection = class RowLevelSelection2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this.state = null;
    this.setSelection = ({ databaseId, rowIds }) => {
      this.state = {
        databaseId,
        rowIds
      };
    };
    this.clearSelection = () => {
      this.state = null;
    };
    this._getStyles = () => {
      const hideStyles = styleMap({
        left: 0,
        top: 0,
        height: 0,
        display: "none"
      });
      if (!this.state)
        return hideStyles;
      const { rowIds } = this.state;
      const { startRow, endRow } = getRowsByIds(this.container, {
        startRowId: rowIds[0],
        endRowId: rowIds[rowIds.length - 1]
      });
      if (!startRow || !endRow)
        return hideStyles;
      const containerPos = this.container.getBoundingClientRect();
      const { left: left2, top: top2 } = startRow.getBoundingClientRect();
      const scale = 1 / this._zoom;
      const scaledHeight = calcSelectionHeight(this.container, rowIds) * scale;
      const scaledLeft = (left2 - containerPos.left) * scale;
      const scaledTop = (top2 - containerPos.top) * scale;
      const styles15 = styleMap({
        left: `${scaledLeft}px`,
        top: `${scaledTop}px`,
        height: `${scaledHeight}px`
      });
      return styles15;
    };
  }
  get _zoom() {
    const edgelessPageBlock = document.querySelector("affine-edgeless-page");
    if (!edgelessPageBlock)
      return 1;
    return edgelessPageBlock.surface.viewport.zoom;
  }
  render() {
    const styles15 = this._getStyles();
    return html`<div
      class="database-row-level-selection"
      style=${styles15}
    ></div>`;
  }
};
RowLevelSelection.styles = css`
    .database-row-level-selection {
      position: absolute;
      z-index: 1;
      box-sizing: border-box;
      width: 100%;
      border: 2px solid var(--affine-primary-color);
      border-radius: 2px;
      background: var(--affine-primary-color-04);
    }
  `;
__decorate73([
  property()
], RowLevelSelection.prototype, "container", void 0);
__decorate73([
  state()
], RowLevelSelection.prototype, "state", void 0);
RowLevelSelection = __decorate73([
  customElement("database-row-level-selection")
], RowLevelSelection);
function getRowsByIds(container, { startRowId, endRowId }) {
  const startRow = container.querySelector(`.database-row[data-row-id="${startRowId}"]`);
  const endRow = container.querySelector(`.database-row[data-row-id="${endRowId}"]`);
  return {
    startRow,
    endRow
  };
}
function calcSelectionHeight(container, rowIds) {
  return rowIds.reduce((acc, rowId) => {
    const row = container.querySelector(`.database-row[data-row-id="${rowId}"]`);
    if (!row) {
      return acc;
    }
    const { height } = row.getBoundingClientRect();
    return acc + height;
  }, 0);
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/selection/utils.js
function clearAllDatabaseRowsSelection() {
  const databases = document.querySelectorAll("affine-database");
  databases.forEach((database) => {
    const rowLevelSelection = database.querySelector("database-row-level-selection");
    rowLevelSelection == null ? void 0 : rowLevelSelection.clearSelection();
  });
}
function setDatabaseRowsSelection(databaseId, rowIds) {
  const container = getRowsContainer(databaseId);
  let rowLevelSelection = container.querySelector("database-row-level-selection");
  if (!rowLevelSelection) {
    rowLevelSelection = new RowLevelSelection();
    container.appendChild(rowLevelSelection);
  }
  rowLevelSelection.container = container;
  rowLevelSelection.setSelection({
    databaseId,
    rowIds
  });
}
function setDatabaseCellSelection(databaseId, coords) {
  const container = getRowsContainer(databaseId);
  const cellLevelSelection = getCellLevelSelection(container);
  cellLevelSelection.setSelection({
    databaseId,
    coords
  });
  const currentCell = getCellElementByCoord(coords[0], databaseId);
  currentCell.scrollIntoView({ block: "nearest" });
}
function clearAllDatabaseCellSelection() {
  const databases = document.querySelectorAll("affine-database");
  databases.forEach((database) => {
    const cellLevelSelection = database.querySelector("database-cell-level-selection");
    cellLevelSelection == null ? void 0 : cellLevelSelection.clearSelection();
  });
}
function setDatabaseCellEditing(databaseId, coord) {
  var _a3, _b, _c, _d;
  const currentCell = getCellElementByCoord(coord, databaseId);
  const cell = (_a3 = currentCell.firstElementChild) == null ? void 0 : _a3.firstElementChild;
  assertExists(cell);
  let shouldClearCellSelection = true;
  const richText = cell == null ? void 0 : cell.querySelector("rich-text");
  if (richText) {
    (_b = richText.vEditor) == null ? void 0 : _b.focusEnd();
  } else if (cell.cellType === "number") {
    const richTextCell = cell;
    (_c = richTextCell.vEditor) == null ? void 0 : _c.focusEnd();
  } else if (cell.cellType === "rich-text") {
    const richTextCell = cell;
    (_d = richTextCell.vEditor) == null ? void 0 : _d.focusEnd();
  } else {
    if (cell.cellType === "checkbox") {
      shouldClearCellSelection = false;
    }
    cell.click();
  }
  if (shouldClearCellSelection) {
    clearDatabaseCellSelectionByDatabaseId(databaseId);
  }
}
function getCellCoord(target, databaseId, key) {
  const rowsContainer = getRowsContainer(databaseId);
  const cellRects = getAllCellsRect(rowsContainer);
  const rowsCount = cellRects.length;
  const cellsCount = cellRects[0].length;
  let cellCoord = null;
  if (target instanceof Element) {
    cellCoord = getCellCoordByElement(target, databaseId);
    assertExists(cellCoord);
  } else {
    cellCoord = target;
  }
  const nextCellCoord = getNextCellCoord(key, cellCoord, rowsCount, cellsCount);
  return nextCellCoord;
}
function getCellSelectionRectByCoords(coords, databaseId) {
  const rowsContainer = getRowsContainer(databaseId);
  const cellRects = getAllCellsRect(rowsContainer);
  const [start2] = coords;
  const cell = cellRects[start2.rowIndex][start2.cellIndex];
  return {
    left: cell.left,
    top: cell.top,
    width: cell.width,
    height: cell.height
  };
}
function getRowsContainer(databaseId) {
  const database = getDatabaseById(databaseId);
  const container = database.querySelector(".affine-database-table-container");
  assertExists(container);
  return container;
}
function getDatabaseById(id) {
  const database = document.querySelector(`affine-database[data-block-id="${id}"]`);
  assertExists(database);
  return database;
}
function getCellCoordByElement(cell, databaseId) {
  const rowsContainer = getRowsContainer(databaseId);
  const cellRects = getAllCellsRect(rowsContainer);
  for (let i = 0; i < cellRects.length; i++) {
    const row = cellRects[i];
    for (let j = 0; j < row.length; j++) {
      if (row[j].cell === cell) {
        return {
          rowIndex: i,
          cellIndex: j
        };
      }
    }
  }
  return null;
}
function getCellElementByCoord(coord, databaseId) {
  const rowsContainer = getRowsContainer(databaseId);
  const cellRects = getAllCellsRect(rowsContainer);
  const { rowIndex, cellIndex } = coord;
  const cell = cellRects[rowIndex][cellIndex].cell;
  return cell;
}
function getAllCellsRect(rowsContainer) {
  const cellRects = [];
  const allRows = rowsContainer.querySelectorAll(".affine-database-block-row");
  allRows.forEach((row, rowIndex) => {
    const allCells = row.querySelectorAll(".database-cell");
    allCells.forEach((cell, cellIndex) => {
      if (cell.classList.contains("add-column-button"))
        return;
      const { left: left2, top: top2, height, width } = cell.getBoundingClientRect();
      cellRects[rowIndex] = cellRects[rowIndex] ?? [];
      cellRects[rowIndex][cellIndex] = { left: left2, top: top2, height, width, cell };
    });
  });
  return cellRects;
}
function getNextCellCoord(key, currentCellCoord, rowsCount, cellsCount) {
  switch (key) {
    case "Escape":
      return getNextCellCoordByEscape(currentCellCoord);
    case "Tab":
    case "ArrowRight":
      return getNextCellCoordByTab(currentCellCoord, rowsCount, cellsCount);
    case "ArrowUp":
      return getNextCellCoordByArrowUp(currentCellCoord);
    case "ArrowDown":
      return getNextCellCoordByArrowDown(currentCellCoord, rowsCount);
    case "ArrowLeft":
      return getNextCellCoordByArrowLeft(currentCellCoord, cellsCount);
  }
  return currentCellCoord;
}
function getNextCellCoordByTab(currentCellCoord, rowsCount, cellsCount) {
  const nextCellPos = { rowIndex: 0, cellIndex: 0 };
  if (currentCellCoord.cellIndex !== cellsCount - 1) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex;
    nextCellPos.cellIndex = currentCellCoord.cellIndex + 1;
    return nextCellPos;
  }
  if (currentCellCoord.rowIndex !== rowsCount - 1) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex + 1;
    nextCellPos.cellIndex = 0;
    return nextCellPos;
  }
  return currentCellCoord;
}
function getNextCellCoordByArrowLeft(currentCellCoord, cellsCount) {
  const nextCellPos = { rowIndex: 0, cellIndex: 0 };
  if (currentCellCoord.cellIndex !== 0) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex;
    nextCellPos.cellIndex = currentCellCoord.cellIndex - 1;
    return nextCellPos;
  }
  if (currentCellCoord.rowIndex !== 0) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex - 1;
    nextCellPos.cellIndex = cellsCount - 1;
    return nextCellPos;
  }
  return currentCellCoord;
}
function getNextCellCoordByArrowUp(currentCellCoord) {
  const nextCellPos = { rowIndex: 0, cellIndex: 0 };
  if (currentCellCoord.rowIndex !== 0) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex - 1;
    nextCellPos.cellIndex = currentCellCoord.cellIndex;
    return nextCellPos;
  }
  return currentCellCoord;
}
function getNextCellCoordByArrowDown(currentCellCoord, rowsCount) {
  const nextCellPos = { rowIndex: 0, cellIndex: 0 };
  if (currentCellCoord.rowIndex + 1 !== rowsCount) {
    nextCellPos.rowIndex = currentCellCoord.rowIndex + 1;
    nextCellPos.cellIndex = currentCellCoord.cellIndex;
    return nextCellPos;
  }
  return currentCellCoord;
}
function getNextCellCoordByEscape(currentCellCoord) {
  return currentCellCoord;
}
function getCellLevelSelection(container) {
  let cellLevelSelection = container.querySelector("database-cell-level-selection");
  if (!cellLevelSelection) {
    cellLevelSelection = new CellLevelSelection();
    container.appendChild(cellLevelSelection);
  }
  return cellLevelSelection;
}
function clearDatabaseCellSelectionByDatabaseId(databaseId) {
  const container = getRowsContainer(databaseId);
  const cellLevelSelection = container.querySelector("database-cell-level-selection");
  cellLevelSelection == null ? void 0 : cellLevelSelection.clearSelection();
}

// node_modules/@blocksuite/blocks/dist/database-block/table/selection-manager/cell.js
var CELL_SELECTION_MOVE_KEYS = [
  "Tab",
  "Enter",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
];
var CELL_SELECTION_ENTER_KEYS = ["Tab", "Escape"];
var CellSelectionManager = class {
  constructor(dispatcher, model) {
    this._disposables = new DisposableGroup();
    this._service = null;
    this._onClick = (ctx) => {
      var _a3;
      (_a3 = this._service) == null ? void 0 : _a3.clearCellLevelSelection();
    };
    this._onCellSelectionMove = (ctx) => {
      const e = ctx.get("keyboardState");
      const event = e.raw;
      if (CELL_SELECTION_MOVE_KEYS.indexOf(event.key) <= -1)
        return;
      const service = getService("affine:database");
      const cellSelection = service.getLastCellSelection();
      if (!cellSelection)
        return;
      event.preventDefault();
      const { databaseId, coords } = cellSelection;
      if (event.key === "Enter") {
        service.setCellSelection({
          type: "edit",
          coords,
          databaseId
        });
      } else {
        const nextCoord = getCellCoord(coords[0], databaseId, event.key);
        service.setCellSelection({
          type: "select",
          coords: [nextCoord],
          databaseId
        });
      }
      return true;
    };
    this._add = (name, fn2) => {
      this._disposables.add(this._dispatcher.add(name, fn2));
    };
    this.onCellSelectionChange = (event) => {
      if (!isValidKey(event.key))
        return;
      event.preventDefault();
      event.stopPropagation();
      const element = event.target;
      selectCellByElement(element, this._model.id, event.key);
    };
    this._dispatcher = dispatcher;
    this._model = model;
    this._service = getService("affine:database");
    this._add("click", this._onClick);
    this._add("keyDown", this._onCellSelectionMove);
  }
  dispose() {
    this._disposables.dispose();
  }
};
function isValidKey(key) {
  return CELL_SELECTION_ENTER_KEYS.indexOf(key) > -1;
}
function selectCellByElement(element, databaseId, key) {
  const rowsContainer = element.closest(".affine-database-block-rows");
  const currentCell = element.closest(".database-cell");
  if (!rowsContainer)
    return;
  if (!currentCell)
    return;
  const editor = currentCell.querySelector(".virgo-editor");
  editor == null ? void 0 : editor.blur();
  resetNativeSelection(null);
  const nextCoord = getCellCoord(currentCell, databaseId, key);
  const service = getService("affine:database");
  const hasRowSelection = service.getLastRowSelection() !== null;
  if (hasRowSelection)
    return;
  service.setCellSelection({
    type: "select",
    coords: [nextCoord],
    databaseId
  });
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/select/select-option-popup.js
var __decorate74 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tagActions = [
  {
    type: "rename",
    text: "Rename",
    icon: PenIcon
  },
  {
    type: "divider"
  },
  {
    type: "delete",
    text: "Delete",
    icon: DeleteIcon
  }
];
var SelectActionPopup = class SelectActionPopup2 extends LitElement {
  constructor() {
    super(...arguments);
    this._onAction = (e, type) => {
      e.stopPropagation();
      this.onAction(type, this.index);
      this.onClose();
    };
  }
  render() {
    return html`
      <div class="affine-database-select-action">
        ${tagActions.map((action) => {
      if (isDivider(action))
        return html`<div class="action-divider"></div>`;
      return html`
            <div
              class="action ${action.type}"
              @mousedown=${(e) => this._onAction(e, action.type)}
            >
              <div class="action-content">
                ${action.icon}<span>${action.text}</span>
              </div>
            </div>
          `;
    })}
      </div>
    `;
  }
};
SelectActionPopup.styles = css`
    :host {
      z-index: 11;
    }
    .affine-database-select-action {
      width: 200px;
      padding: 8px;
      border: 1px solid var(--affine-border-color);
      border-radius: 8px;
      background: var(--affine-white);
      box-shadow: var(--affine-menu-shadow);
    }
    ${actionStyles}
    .action {
      color: var(--affine-text-primary-color);
    }
    .action svg {
      width: 20px;
      height: 20px;
    }
    .rename,
    .delete {
      fill: var(--affine-icon-color);
    }
  `;
__decorate74([
  property()
], SelectActionPopup.prototype, "index", void 0);
__decorate74([
  property()
], SelectActionPopup.prototype, "onAction", void 0);
__decorate74([
  property()
], SelectActionPopup.prototype, "onClose", void 0);
SelectActionPopup = __decorate74([
  customElement("affine-database-select-action-popup")
], SelectActionPopup);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/select/select-cell-editing.js
var __decorate75 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var KEYS_WHITE_LIST = ["Enter", "ArrowUp", "ArrowDown"];
var styles12 = css`
  affine-database-select-cell-editing {
    z-index: 2;
    border: 1px solid var(--affine-border-color);
    border-radius: 8px;
    background: var(--affine-background-primary-color);
    box-shadow: var(--affine-shadow-2);
  }
  .affine-database-select-cell-select {
    font-size: var(--affine-font-sm);
  }
  .select-input-container {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 6px;
    min-height: 44px;
    padding: 10px 8px;
    background: var(--affine-hover-color);
  }
  .select-input {
    flex: 1 1 0%;
    height: 24px;
    border: none;
    font-family: var(--affine-font-family);
    color: inherit;
    background: transparent;
    line-height: 24px;
  }
  .select-input:focus {
    outline: none;
  }
  .select-input::placeholder {
    color: var(--affine-placeholder-color);
  }
  .select-option-container {
    padding: 8px;
    color: var(--affine-black-90);
  }
  .select-option-container-header {
    padding: 8px 0px;
    color: var(--affine-black-60);
  }
  .select-input-container .select-selected {
    display: flex;
    align-items: center;
    padding: 2px 10px;
    gap: 10px;
    height: 28px;
    background: var(--affine-tag-white);
    border-radius: 4px;
    color: var(--affine-black-90);
    background: var(--affine-tertiary-color);
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }
  .select-selected-text {
    width: calc(100% - 16px);
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
  }
  .select-selected > .close-icon {
    display: flex;
    align-items: center;
  }
  .select-selected > .close-icon:hover {
    cursor: pointer;
  }
  .select-selected > .close-icon > svg {
    fill: var(--affine-black-90);
  }
  .select-option-new {
    display: flex;
    flex-direction: row;
    align-items: center;
    height: 36px;
    padding: 4px;
    gap: 5px;
    border-radius: 4px;
    background: var(--affine-selected-color);
  }
  .select-option-new-text {
    flex: 1;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    height: 28px;
    padding: 2px 10px;
    border-radius: 4px;
    background: var(--affine-tag-red);
  }
  .select-option-new-icon {
    display: flex;
    align-items: center;
    gap: 6px;
    height: 28px;
    color: var(--affine-text-primary-color);
  }
  .select-option-new-icon svg {
    width: 16px;
    height: 16px;
  }
  .select-option {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 36px;
    padding: 4px;
    border-radius: 4px;
    margin-bottom: 4px;
    cursor: pointer;
  }
  .select-option.selected,
  .select-option:hover {
    background: var(--affine-hover-color);
  }
  .select-option:hover .select-option-icon {
    display: flex;
  }
  .select-option-text-container {
    width: calc(100% - 28px);
    overflow: hidden;
  }
  .select-option-icon {
    display: none;
    justify-content: center;
    align-items: center;
    width: 28px;
    height: 28px;
    border-radius: 3px;
    cursor: pointer;
  }
  .select-option-icon:hover {
    background: var(--affine-hover-color);
  }
  .select-option-icon svg {
    width: 16px;
    height: 16px;
    pointer-events: none;
  }
  .editing {
    background: var(--affine-hover-color);
  }
  .editing .select-option-text [data-virgo-text='true'] {
    display: block;
    white-space: pre !important;
    overflow: unset;
    text-overflow: unset;
  }
  .editing .select-option-icon {
    display: flex;
    background: var(--affine-hover-background);
  }
`;
var SelectCellEditing = class SelectCellEditing2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.value = void 0;
    this.cellType = "select";
    this.mode = SelectMode.Single;
    this._inputValue = "";
    this._editingIndex = -1;
    this._selectedOptionIndex = -1;
    this._selectColor = void 0;
    this._onSelectOption = (event) => {
      var _a3;
      const key = event.key;
      if (KEYS_WHITE_LIST.indexOf(key) <= -1)
        return;
      event.preventDefault();
      event.stopPropagation();
      const maxIndex = this.selectionList.length - 1;
      if (this._selectedOptionIndex === maxIndex && key === "ArrowDown") {
        this._selectedOptionIndex = 0;
        return;
      }
      if (this._selectedOptionIndex <= 0 && key === "ArrowUp") {
        this._selectedOptionIndex = maxIndex;
        return;
      }
      if (key === "ArrowDown") {
        this._selectedOptionIndex++;
      } else if (key === "ArrowUp") {
        this._selectedOptionIndex--;
      } else if (key === "Enter") {
        const index = this._selectedOptionIndex;
        if (index === -1)
          return;
        if (this.isSingleMode) {
          this._selectedOptionIndex = -1;
        }
        const selected = ((_a3 = this.cell) == null ? void 0 : _a3.value) ?? [];
        const currentSelection = this.selectionList[index];
        this._onSelect(selected, currentSelection);
        const cell = this._selectOptionContainer.closest(".database-cell");
        assertExists(cell);
        this._selectCell(cell, "Escape");
      }
    };
    this._selectCell = (element, key, exitEditing = false) => {
      if (this.isSingleMode || exitEditing)
        this.rowHost.setEditing(false);
      selectCellByElement(element, this.databaseModel.id, key);
    };
    this._onDeleteSelected = (selectedValue, value) => {
      const filteredValue = selectedValue.filter((item) => item !== value);
      this.rowHost.setValue(filteredValue);
    };
    this._onSelectSearchInput = (event) => {
      const value = event.target.value;
      this._inputValue = value;
      if (!this._selectColor) {
        this._selectColor = getTagColor();
      }
    };
    this._onSelectOrAdd = (event, selectedValue) => {
      const inputValue = this._inputValue.trim();
      if (event.key === "Backspace" && inputValue === "") {
        this._onDeleteSelected(selectedValue, selectedValue[selectedValue.length - 1]);
      } else if (event.key === "Enter" && inputValue !== "") {
        if (this._selectedOptionIndex !== -1)
          return;
        const selectTag = this.selectionList.find((item) => item.value === inputValue);
        if (selectTag) {
          this._onSelect(selectedValue, selectTag);
        } else {
          this._onAddSelection(selectedValue);
        }
      } else if (event.key === "Escape") {
        this._selectCell(event.target, "Escape", true);
      } else if (event.key === "Tab") {
        event.preventDefault();
        this._selectCell(event.target, "Tab", true);
      }
    };
    this._onSelect = (selectedValue, select) => {
      if (this._editingIndex !== -1)
        return;
      const isExist = selectedValue.findIndex((item) => item.value === select.value) > -1;
      if (isExist)
        return;
      this.value = select;
      const isSelected = selectedValue.indexOf(this.value) > -1;
      if (!isSelected) {
        const newValue = this.isSingleMode ? [this.value] : [...selectedValue, this.value];
        this.rowHost.setValue(newValue);
        if (this.isSingleMode)
          this.rowHost.setEditing(false);
        if (!this.isSingleMode && newValue.length > 1) {
          this._calcRowHostHeight();
        }
      }
    };
    this._onAddSelection = (selectedValue) => {
      let value = this._inputValue.trim();
      if (value === "")
        return;
      if (value.length > SELECT_TAG_NAME_MAX_LENGTH) {
        value = value.slice(0, SELECT_TAG_NAME_MAX_LENGTH);
      }
      const tagColor = this._selectColor ?? getTagColor();
      this._selectColor = void 0;
      const newSelect = { id: nanoid2(), value, color: tagColor };
      this.rowHost.updateColumnProperty((property2) => {
        const selection = property2.selection;
        return {
          ...property2,
          selection: selection.findIndex((select) => select.value === value) === -1 ? [...selection, newSelect] : selection
        };
      });
      const newValue = this.isSingleMode ? [newSelect] : [...selectedValue, newSelect];
      this.rowHost.setValue(newValue);
      this.rowHost.setEditing(false);
      if (!this.isSingleMode && newValue.length > 1) {
        this._calcRowHostHeight();
      }
    };
    this._calcRowHostHeight = () => {
      setTimeout(() => {
        var _a3, _b;
        const shadowRoot = (_b = (_a3 = this.rowHost.shadowRoot) == null ? void 0 : _a3.children[0].shadowRoot) == null ? void 0 : _b.children[0].shadowRoot;
        const selectCell = shadowRoot == null ? void 0 : shadowRoot.querySelector(".affine-database-select-cell-container");
        if (selectCell) {
          const { height } = selectCell.getBoundingClientRect();
          this.rowHost.setHeight(height);
        }
      });
    };
    this._onSelectAction = (type, index) => {
      if (type === "rename") {
        this._setEditingIndex(index);
        return;
      }
      if (type === "delete") {
        this.databaseModel.updateColumn({
          ...this.column,
          selection: this.selectionList.filter((_, i) => i !== index)
        });
        const select = this.selectionList[index];
        this.databaseModel.deleteSelectedCellTag(this.column.id, select);
        return;
      }
    };
    this._showSelectAction = (index) => {
      const selectOption = this.querySelectorAll(".select-option").item(index);
      assertExists(selectOption);
      const action = new SelectActionPopup();
      action.onAction = this._onSelectAction;
      action.index = index;
      selectOption.appendChild(action);
      const onClose = () => action.remove();
      action.onClose = onClose;
      createPopper3({
        getBoundingClientRect: () => {
          const optionIcon = selectOption.querySelector(".select-option-icon");
          assertExists(optionIcon);
          const { height } = action.getBoundingClientRect();
          const rect = optionIcon.getBoundingClientRect();
          rect.y = rect.y + height + 36;
          rect.x = rect.x + 33;
          return rect;
        }
      }, action, {
        placement: "bottom-end"
      });
      onClickOutside(selectOption, onClose, "mousedown");
    };
    this._onSaveSelectionName = (index) => {
      const selectOption = this._selectOptionContainer.querySelectorAll("affine-database-select-option").item(index);
      const selection = [...this.selectionList];
      const value = selectOption.getSelectionValue();
      const isExist = selection.findIndex((select, i) => i !== index && select.value === value) > -1;
      if (isExist)
        return;
      const oldSelect = selection[index];
      const newSelect = { ...oldSelect, value };
      selection[index] = newSelect;
      this.databaseModel.updateColumn({
        ...this.column,
        selection
      });
      this.databaseModel.renameSelectedCellTag(this.column.id, oldSelect, newSelect);
      this._setEditingIndex(-1);
    };
    this._setEditingIndex = (index) => {
      this._editingIndex = index;
    };
  }
  get isSingleMode() {
    return this.mode === SelectMode.Single;
  }
  get selectionList() {
    return this.column.selection;
  }
  firstUpdated() {
    this.style.width = `${SELECT_EDIT_POPUP_WIDTH}px`;
    this._selectInput.focus();
  }
  connectedCallback() {
    super.connectedCallback();
    this._disposables.addFromEvent(document.body, "keydown", this._onSelectOption);
    createPopper3({
      getBoundingClientRect: () => {
        const rect = this.rowHost.getBoundingClientRect();
        rect.y = rect.y - rect.height - 2;
        rect.x = rect.x - 2;
        return rect;
      }
    }, this, {
      placement: "bottom-start",
      strategy: "fixed"
    });
  }
  updated(_changedProperties) {
    super.updated(_changedProperties);
    if (_changedProperties.has("cell")) {
      this._selectInput.focus();
    }
  }
  render() {
    var _a3;
    const filteredSelection = this.selectionList.filter((item) => {
      if (!this._inputValue) {
        return true;
      }
      return item.value.toLocaleLowerCase().indexOf(this._inputValue.toLocaleLowerCase()) > -1;
    });
    const selectedTag = ((_a3 = this.cell) == null ? void 0 : _a3.value) ?? [];
    const showCreateTip = this._inputValue && filteredSelection.findIndex((item) => item.value === this._inputValue) === -1;
    const selectCreateTip = showCreateTip ? html2`<div class="select-option-new" @click=${this._onAddSelection}>
          <div class="select-option-new-icon">Create ${PlusIcon}</div>
          <span
            class="select-option-new-text"
            style=${styleMap({ backgroundColor: this._selectColor })}
            >${this._inputValue}</span
          >
        </div>` : null;
    return html2`
      <div class="affine-database-select-cell-select">
        <div class="select-input-container">
          ${selectedTag.map((item) => {
      const style = styleMap({
        backgroundColor: item.color
      });
      return html2`<div class="select-selected" style=${style}>
              <div class="select-selected-text">${item.value}</div>
              <span
                class="close-icon"
                @click=${() => this._onDeleteSelected(selectedTag, item)}
                >${DatabaseSearchClose}</span
              >
            </div>`;
    })}
          <input
            class="select-input"
            placeholder="Type here..."
            maxlength=${SELECT_TAG_NAME_MAX_LENGTH}
            @input=${this._onSelectSearchInput}
            @keydown=${(event) => this._onSelectOrAdd(event, selectedTag)}
          />
        </div>
        <div class="select-option-container">
          <div class="select-option-container-header">
            Select tag or create one
          </div>
          ${selectCreateTip}
          ${repeat(filteredSelection, (select) => select.id, (select, index) => {
      const isEditing = index === this._editingIndex;
      const isSelected = index === this._selectedOptionIndex;
      const onOptionIconClick = isEditing ? () => this._onSaveSelectionName(index) : () => this._showSelectAction(index);
      const classes = classMap({
        "select-option": true,
        selected: isSelected,
        editing: isEditing
      });
      return html2`
                <div class="${classes}">
                  <div
                    class="select-option-text-container"
                    @click=${() => this._onSelect(selectedTag, select)}
                  >
                    <affine-database-select-option
                      style=${styleMap({
        cursor: isEditing ? "text" : "pointer"
      })}
                      .databaseModel=${this.databaseModel}
                      .select=${select}
                      .editing=${isEditing}
                      .index=${index}
                      .saveSelectionName=${this._onSaveSelectionName}
                      .setEditingIndex=${this._setEditingIndex}
                    ></affine-database-select-option>
                  </div>
                  <div class="select-option-icon" @click=${onOptionIconClick}>
                    ${isEditing ? DatabaseDone : MoreHorizontalIcon}
                  </div>
                </div>
              `;
    })}
        </div>
      </div>
    `;
  }
};
SelectCellEditing.styles = styles12;
SelectCellEditing.tag = literal`affine-database-select-cell-editing`;
__decorate75([
  property()
], SelectCellEditing.prototype, "mode", void 0);
__decorate75([
  query(".select-input")
], SelectCellEditing.prototype, "_selectInput", void 0);
__decorate75([
  state()
], SelectCellEditing.prototype, "_inputValue", void 0);
__decorate75([
  state()
], SelectCellEditing.prototype, "_editingIndex", void 0);
__decorate75([
  state()
], SelectCellEditing.prototype, "_selectedOptionIndex", void 0);
__decorate75([
  query(".select-option-container")
], SelectCellEditing.prototype, "_selectOptionContainer", void 0);
SelectCellEditing = __decorate75([
  customElement("affine-database-select-cell-editing")
], SelectCellEditing);

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/select/select.js
var __decorate76 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SelectCell = class SelectCell2 extends DatabaseCellElement {
  constructor() {
    super(...arguments);
    this.cellType = "select";
  }
  render() {
    var _a3;
    const values = ((_a3 = this.cell) == null ? void 0 : _a3.value) ?? [];
    return html2`
      <div
        class="affine-database-select-cell-container"
        style=${styleMap({
      maxWidth: `${this.column.width}px`
    })}
      >
        ${values.map((item) => {
      const style = styleMap({
        backgroundColor: item.color
      });
      return html2`<span class="select-selected" style=${style}
            >${item.value}</span
          >`;
    })}
      </div>
    `;
  }
};
SelectCell.styles = css`
    affine-database-select-cell {
      display: flex;
      align-items: center;
      width: calc(100% + 8px);
      height: 100%;
      margin: -2px -4px;
    }
    .affine-database-select-cell-container * {
      box-sizing: border-box;
    }
    .affine-database-select-cell-container {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      width: 100%;
      cursor: pointer;
      font-size: var(--affine-font-sm);
    }
    .affine-database-select-cell-container .select-selected {
      height: 28px;
      padding: 2px 10px;
      border-radius: 4px;
      white-space: nowrap;
      background: var(--affine-tag-white);
    }
  `;
SelectCell.tag = literal`affine-database-select-cell`;
SelectCell = __decorate76([
  customElement("affine-database-select-cell")
], SelectCell);
var SelectColumnRenderer = defineColumnRenderer("select", () => ({
  selection: []
}), () => [], {
  Cell: SelectCell,
  CellEditing: SelectCellEditing
}, {
  displayName: "Select"
});

// node_modules/@blocksuite/blocks/dist/database-block/table/components/column-type/index.js
function registerInternalRenderer() {
  const columnRenderer = new ColumnRendererHelper();
  columnRenderer.register(NumberColumnRenderer);
  columnRenderer.register(SelectColumnRenderer);
  columnRenderer.register(MultiSelectColumnRenderer);
  columnRenderer.register(RichTextColumnRenderer);
  columnRenderer.register(ProgressColumnRenderer);
  columnRenderer.register(CheckboxColumnRenderer);
  return columnRenderer;
}

// node_modules/@blocksuite/blocks/dist/database-block/table/components/row-container.js
function DataBaseRowContainer(databaseBlock, filteredRowIds, searchState, root2) {
  const databaseModel = databaseBlock.model;
  const columns = databaseModel.columns;
  const filteredChildren = searchState === SearchState.Searching ? databaseModel.children.filter((child) => filteredRowIds.indexOf(child.id) > -1) : databaseModel.children;
  return html`
    <style>
      .affine-database-block-rows {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: flex-start;
      }

      .affine-database-block-row {
        width: 100%;
        min-height: 44px;
        display: flex;
        flex-direction: row;
        border-bottom: 1px solid var(--affine-border-color);
      }
      .affine-database-block-row.selected > .database-cell {
        background: transparent;
      }
      .affine-database-block-row > .affine-database-block-row-cell:first-child {
        background: var(--affine-hover-color);
      }
      .affine-database-block-row > .database-cell {
        background: var(--affine-white);
      }

      .affine-database-block-row-cell-content {
        display: flex;
        align-items: center;
        height: 100%;
        min-height: 44px;
        padding: 0 8px;
        border-right: 1px solid var(--affine-border-color);
        transform: translateX(0);
      }
      .affine-database-block-row-cell-content > [data-block-id] {
        width: 100%;
      }
      .affine-database-block-row-cell-content > affine-paragraph {
        display: flex;
        align-items: center;
        width: 100%;
        height: 100%;
      }
      .affine-database-block-row-cell-content > affine-paragraph > .text {
        width: 100%;
        margin-top: unset;
      }
      .database-cell {
        min-width: ${DEFAULT_COLUMN_MIN_WIDTH}px;
      }
      .database-cell:last-child affine-database-cell-container {
        border-right: none;
      }
    </style>
    <div class="affine-database-block-rows">
      ${repeat(filteredChildren, (child) => child.id, (child, idx) => {
    const style = styleMap({
      width: `${databaseModel.titleColumnWidth}px`
    });
    return html`
            <div
              class="affine-database-block-row database-row"
              data-row-index="${idx}"
              data-row-id="${child.id}"
            >
              <div
                class="affine-database-block-row-cell database-cell"
                style=${style}
              >
                <div class="affine-database-block-row-cell-content">
                  ${root2.renderModel(child)}
                </div>
              </div>
              ${repeat(columns, (column) => {
      return html`
                  <div
                    class="database-cell"
                    style=${styleMap({
        width: `${column.width}px`
      })}
                  >
                    <affine-database-cell-container
                      .databaseModel=${databaseModel}
                      .rowModel=${child}
                      .column=${column}
                      .columnRenderer=${databaseBlock.columnRenderer}
                    >
                    </affine-database-cell-container>
                  </div>
                `;
    })}
              <div class="database-cell add-column-button"></div>
            </div>
          `;
  })}
    </div>
  `;
}

// node_modules/@blocksuite/blocks/dist/database-block/table/selection-manager/utils.js
function getClosestRowIndex(element) {
  var _a3;
  const rowIndex = (_a3 = element.closest(".database-row")) == null ? void 0 : _a3.getAttribute("data-row-index");
  if (rowIndex) {
    return Number(rowIndex);
  }
  return -1;
}
function getClosestRowId(element) {
  var _a3;
  const rowId = (_a3 = element.closest(".database-row")) == null ? void 0 : _a3.getAttribute("data-row-id");
  if (rowId) {
    return rowId;
  }
  return "";
}
function getSelectedRowIdsByIndexes(database, indexes) {
  return indexes.map((item) => getRowIdByIndex(database, item));
}
function getSelectedRowIndexes(startCell, endCell) {
  const currentRowIndex = getClosestRowIndex(startCell);
  const startRowIndex = getClosestRowIndex(endCell);
  if (currentRowIndex === -1 || startRowIndex === -1)
    return [];
  const minIndex = Math.min(currentRowIndex, startRowIndex);
  const maxIndex = Math.max(currentRowIndex, startRowIndex);
  const rowIndexes = [];
  for (let id = minIndex; id <= maxIndex; id++) {
    rowIndexes.push(id);
  }
  return rowIndexes;
}
function getClosestDatabase(element) {
  const database = element == null ? void 0 : element.closest("affine-database");
  assertExists(database);
  return database;
}
function getClosestDatabaseId(element) {
  const databaseId = getClosestDatabase(element).getAttribute("data-block-id");
  assertExists(databaseId);
  return databaseId;
}
function isInDatabase(element) {
  const database = element.closest("affine-database");
  return database !== null;
}
function getRowIdByIndex(database, index) {
  var _a3;
  const rowId = (_a3 = database.querySelector(`.database-row[data-row-index="${index}"]`)) == null ? void 0 : _a3.getAttribute("data-row-id");
  assertExists(rowId);
  return rowId;
}

// node_modules/@blocksuite/blocks/dist/database-block/table/selection-manager/row.js
var RowSelectionManager = class {
  constructor(dispatcher, model) {
    this._disposables = new DisposableGroup();
    this._service = null;
    this._startCell = null;
    this._database = null;
    this._columnWidthHandles = [];
    this._startRange = null;
    this._rowIds = [];
    this._isInDatabase = false;
    this._onDragStart = (ctx) => {
      const e = ctx.get("pointerState");
      const { clientX: x, clientY: y, target } = e.raw;
      const targetElement = target;
      this._isInDatabase = isInDatabase(targetElement);
      if (!this._isInDatabase) {
        return false;
      }
      const startRange = caretRangeFromPoint(x, y);
      this._startRange = startRange;
      if (!isBlankArea(e)) {
        const el = document.elementFromPoint(x, y);
        this._startCell = (el == null ? void 0 : el.closest(".database-cell")) ?? null;
        const database = getClosestDatabase(this._startCell);
        this._database = database;
        this._columnWidthHandles = Array.from(database.querySelectorAll(".affine-database-column-drag-handle"));
        this._setColumnWidthHandleDisplay("none");
      }
      return true;
    };
    this._onDragMove = (ctx) => {
      var _a3;
      if (!this._isInDatabase) {
        return false;
      }
      const e = ctx.get("pointerState");
      e.raw.preventDefault();
      const { clientX: x, clientY: y, target } = e.raw;
      if (!isInDatabase(target)) {
        return false;
      }
      const elements = Array.from(document.elementsFromPoint(x, y));
      const endCell = elements.find((el) => el.classList.contains("database-cell"));
      const startCell = this._startCell;
      if (!endCell || !startCell || !this._database)
        return false;
      if (endCell === startCell) {
        const editor = elements.find((el) => el.classList.contains("virgo-editor"));
        if (editor) {
          const { left: left2, right: right2 } = editor.getBoundingClientRect();
          if (x <= left2 + 1 || x >= right2 - 1) {
            return true;
          }
          handleNativeRangeDragMove(this._startRange, e);
        }
        if (this._rowIds.length > 0) {
          this._clearRowSelection();
        }
      } else {
        e.raw.preventDefault();
        resetNativeSelection(null);
        const rowIndexes = getSelectedRowIndexes(startCell, endCell);
        const rowIds = getSelectedRowIdsByIndexes(this._database, rowIndexes);
        this._rowIds = rowIds;
        const databaseId = getClosestDatabaseId(endCell);
        (_a3 = this._service) == null ? void 0 : _a3.setRowSelection({
          type: "select",
          rowIds,
          databaseId
        });
      }
      return true;
    };
    this._onDragEnd = (ctx) => {
      const e = ctx.get("pointerState");
      const target = e.raw.target;
      if (!isInDatabase(target)) {
        return;
      }
      this._startRange = null;
      this._setColumnWidthHandleDisplay("block");
    };
    this._onClick = (ctx) => {
      var _a3;
      const e = ctx.get("pointerState");
      const target = e.raw.target;
      if (target instanceof DragHandle)
        return;
      const rowSelection = (_a3 = this._service) == null ? void 0 : _a3.getLastRowSelection();
      if (rowSelection) {
        this._clearRowSelection();
      }
    };
    this._onKeydown = (ctx) => {
      const e = ctx.get("keyboardState");
      const event = e.raw;
      const key = event.key;
      if (key === "Delete" || key === "Backspace") {
        this._onRowSelectionDelete();
      } else if (key === "Escape") {
        const service = getService("affine:database");
        const cellSelection = service.getLastCellSelection();
        if (cellSelection) {
          const { databaseId, coords: [coord] } = cellSelection;
          service.clearCellLevelSelection();
          const database = getDatabaseById(databaseId);
          const rowIds = getSelectedRowIdsByIndexes(database, [coord.rowIndex]);
          service.setRowSelection({
            type: "select",
            rowIds,
            databaseId
          });
        }
      }
    };
    this._onRowSelectionDelete = () => {
      const service = getService("affine:database");
      const rowSelection = service.getLastRowSelection();
      if (!rowSelection)
        return;
      const { rowIds } = rowSelection;
      const page = this._model.page;
      const children = this._model.children;
      page.captureSync();
      if (children.length === rowIds.length) {
        page.deleteBlock(this._model);
      } else {
        page.updateBlock(this._model, {
          children: children.filter((child) => rowIds.indexOf(child.id) === -1)
        });
      }
      service.clearRowSelection();
      return true;
    };
    this._add = (name, fn2) => {
      this._disposables.add(this._dispatcher.add(name, fn2));
    };
    this._dispatcher = dispatcher;
    this._model = model;
    this._service = getService("affine:database");
    this._add("dragStart", this._onDragStart);
    this._add("dragMove", this._onDragMove);
    this._add("dragEnd", this._onDragEnd);
    this._add("click", this._onClick);
    this._add("keyDown", this._onKeydown);
  }
  _setColumnWidthHandleDisplay(display) {
    this._columnWidthHandles.forEach((handle) => {
      handle.style.display = display;
    });
  }
  _clearRowSelection() {
    var _a3;
    this._rowIds = [];
    (_a3 = this._service) == null ? void 0 : _a3.clearRowSelection();
    resetNativeSelection(null);
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/@blocksuite/blocks/dist/database-block/table/table-view.js
var __decorate77 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles13 = css`
  affine-database-table {
    position: relative;
  }

  .affine-database-block-title-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 44px;
    margin: 18px 0 0;
  }

  .affine-database-block-table {
    position: relative;
    width: 100%;
    padding-bottom: 4px;
    overflow-x: scroll;
    overflow-y: hidden;
    border-top: 1.5px solid var(--affine-border-color);
  }
  .affine-database-block-table:hover {
    padding-bottom: 0px;
  }
  .affine-database-block-table::-webkit-scrollbar {
    -webkit-appearance: none;
    display: block;
  }
  .affine-database-block-table::-webkit-scrollbar:horizontal {
    height: 4px;
  }
  .affine-database-block-table::-webkit-scrollbar-thumb {
    border-radius: 2px;
    background-color: var(--affine-black-10);
  }
  .affine-database-block-table:hover::-webkit-scrollbar:horizontal {
    height: 8px;
  }
  .affine-database-block-table:hover::-webkit-scrollbar-thumb {
    border-radius: 16px;
    background-color: var(--affine-black-30);
  }
  .affine-database-block-table:hover::-webkit-scrollbar-track {
    background-color: var(--affine-hover-color);
  }

  .affine-database-table-container {
    position: relative;
    width: fit-content;
    min-width: 100%;
  }

  .affine-database-block-tag-circle {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
  }

  .affine-database-block-tag {
    display: inline-flex;
    border-radius: 11px;
    align-items: center;
    padding: 0 8px;
    cursor: pointer;
  }

  .affine-database-block-footer {
    display: flex;
    width: 100%;
    height: 28px;
    margin-top: -8px;
  }
  .affine-database-block-footer:hover {
    position: relative;
    z-index: 1;
    background-color: var(--affine-hover-color-filled);
  }
  .affine-database-block-footer:hover .affine-database-block-add-row {
    display: flex;
  }

  .affine-database-block-add-row {
    display: none;
    flex: 1;
    align-items: center;
    justify-content: center;
    gap: 4px;
    width: 100%;
    height: 100%;
    cursor: pointer;
    user-select: none;
    font-size: 14px;
  }
  .affine-database-block-add-row svg {
    width: 16px;
    height: 16px;
  }

  ${tooltipStyle}
`;
var DatabaseTable = class DatabaseTable2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this.flavour = "affine:database";
    this._searchState = SearchState.SearchIcon;
    this._filteredRowIds = [];
    this._hoverState = false;
    this._columnRenderer = registerInternalRenderer();
    this._initRowSelectionEvents = () => {
      this._rowSelection = new RowSelectionManager(this.root.uiEventDispatcher, this.model);
    };
    this._initCellSelectionEvents = () => {
      this._cellSelection = new CellSelectionManager(this.root.uiEventDispatcher, this.model);
    };
    this._setFilteredRowIds = (rowIds) => {
      this._filteredRowIds = rowIds;
    };
    this._setSearchState = (state2) => {
      this._searchState = state2;
    };
    this._onDatabaseScroll = (event) => {
      this._columnHeaderComponent.showAddColumnButton();
    };
    this._onMouseOver = () => {
      this._hoverState = true;
    };
    this._onMouseLeave = () => {
      if (this._searchState === SearchState.SearchIcon) {
        this._updateHoverState();
      }
    };
    this._onClick = () => {
      setTimeout(() => {
        onClickOutside(this, () => {
          if (this._searchState !== SearchState.Searching) {
            this._resetHoverState();
            this._resetSearchState();
          }
        }, "mousedown");
      });
    };
    this._addRow = (index) => {
      if (this.readonly)
        return;
      const currentSearchState = this._searchState;
      this._resetSearchState();
      this._resetHoverState();
      const page = this.model.page;
      page.captureSync();
      const id = page.addBlock("affine:paragraph", {}, this.model.id, index);
      asyncFocusRichText(page, id);
      this._setSearchState(currentSearchState);
    };
    this._addColumn = (index) => {
      if (this.readonly)
        return;
      this.model.page.captureSync();
      const currentColumns = this.model.columns;
      const defaultColumnType = "multi-select";
      const renderer = this._columnRenderer.get(defaultColumnType);
      const schema = {
        type: defaultColumnType,
        name: `Column ${currentColumns.length + 1}`,
        width: DEFAULT_COLUMN_WIDTH,
        hide: false,
        ...renderer.propertyCreator()
      };
      const id = this.model.addColumn(schema, index);
      this.model.applyColumnUpdate();
      requestAnimationFrame(() => {
        this._columnHeaderComponent.setEditingColumnId(id);
      });
    };
  }
  get columnRenderer() {
    return this._columnRenderer;
  }
  get columns() {
    return this.model.columns;
  }
  get readonly() {
    return this.model.page.readonly;
  }
  connectedCallback() {
    super.connectedCallback();
    this._updateHoverState();
    this._initRowSelectionEvents();
    this._initCellSelectionEvents();
    const disposables = this._disposables;
    disposables.addFromEvent(this, "mouseover", this._onMouseOver);
    disposables.addFromEvent(this, "mouseleave", this._onMouseLeave);
    disposables.addFromEvent(this, "click", this._onClick);
    disposables.addFromEvent(this, "keydown", this._cellSelection.onCellSelectionChange);
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => {
      var _a3;
      this.requestUpdate();
      this.querySelectorAll("affine-database-cell-container").forEach((cell) => {
        cell.requestUpdate();
      });
      (_a3 = this.querySelector("affine-database-column-header")) == null ? void 0 : _a3.requestUpdate();
    });
    this.model.childrenUpdated.on(() => {
      var _a3;
      this.requestUpdate();
      this.querySelectorAll("affine-database-cell-container").forEach((cell) => {
        cell.requestUpdate();
      });
      (_a3 = this.querySelector("affine-database-column-header")) == null ? void 0 : _a3.requestUpdate();
      this._updateHoverState();
    });
    if (this.readonly)
      return;
    const tableContent = this._tableContainer.parentElement;
    assertExists(tableContent);
    this._disposables.addFromEvent(tableContent, "scroll", this._onDatabaseScroll);
  }
  _updateHoverState() {
    if (this.model.children.length === 0) {
      this._hoverState = true;
      return;
    }
    this._resetHoverState();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._rowSelection.dispose();
    this._cellSelection.dispose();
  }
  _resetSearchState() {
    this._searchState = SearchState.SearchIcon;
  }
  _resetHoverState() {
    this._hoverState = false;
  }
  render() {
    const rows = DataBaseRowContainer(this, this._filteredRowIds, this._searchState, this.root);
    return html2`
      <div class="affine-database-table">
        <div class="affine-database-block-title-container">
          <affine-database-title
            .addRow=${this._addRow}
            .targetModel=${this.model}
          ></affine-database-title>
          <affine-database-toolbar
            .addRow=${this._addRow}
            .targetModel=${this.model}
            .hoverState=${this._hoverState}
            .searchState=${this._searchState}
            .setSearchState=${this._setSearchState}
            .setFilteredRowIds=${this._setFilteredRowIds}
          ></affine-database-toolbar>
        </div>
        <div class="affine-database-block-table">
          <div class="affine-database-table-container">
            <affine-database-column-header
              .columns=${this.columns}
              .targetModel=${this.model}
              .addColumn=${this._addColumn}
              .columnRenderer=${this.columnRenderer}
            ></affine-database-column-header>
            ${rows}
          </div>
        </div>
        ${this.readonly ? null : html2`<div class="affine-database-block-footer">
              <div
                class="affine-database-block-add-row"
                data-test-id="affine-database-add-row-button"
                role="button"
                @click=${() => this._addRow()}
              >
                ${PlusIcon}<span>New Record</span>
              </div>
            </div>`}
      </div>
    `;
  }
};
DatabaseTable.styles = styles13;
__decorate77([
  property()
], DatabaseTable.prototype, "model", void 0);
__decorate77([
  property()
], DatabaseTable.prototype, "root", void 0);
__decorate77([
  query(".affine-database-table-container")
], DatabaseTable.prototype, "_tableContainer", void 0);
__decorate77([
  query("affine-database-column-header")
], DatabaseTable.prototype, "_columnHeaderComponent", void 0);
__decorate77([
  state()
], DatabaseTable.prototype, "_searchState", void 0);
__decorate77([
  state()
], DatabaseTable.prototype, "_filteredRowIds", void 0);
__decorate77([
  state()
], DatabaseTable.prototype, "_hoverState", void 0);
DatabaseTable = __decorate77([
  customElement("affine-database-table")
], DatabaseTable);

// node_modules/@blocksuite/blocks/dist/database-block/kanban/kanban-view.js
var __decorate78 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var styles14 = css`
  affine-database-kanban {
    position: relative;
  }
`;
var DatabaseKanban = class DatabaseKanban2 extends WithDisposable(ShadowlessElement) {
  constructor() {
    super(...arguments);
    this.flavour = "affine:database";
  }
  get slots() {
    return this.host.slots;
  }
  get page() {
    return this.host.page;
  }
  get clipboard() {
    return this.host.clipboard;
  }
  get getService() {
    return this.host.getService;
  }
  connectedCallback() {
    super.connectedCallback();
  }
  render() {
    return html2`<div class="affine-database-kanban">kanban view</div>`;
  }
};
DatabaseKanban.styles = styles14;
__decorate78([
  property()
], DatabaseKanban.prototype, "model", void 0);
__decorate78([
  property()
], DatabaseKanban.prototype, "host", void 0);
DatabaseKanban = __decorate78([
  customElement("affine-database-kanban")
], DatabaseKanban);

// node_modules/@blocksuite/blocks/dist/database-block/database-service.js
var DatabaseBlockService = class extends BaseService {
  constructor() {
    super();
    this._lastRowSelection = null;
    this._lastCellSelection = null;
    this.slots = {
      tableViewRowSelectionUpdated: new Slot(),
      tableViewCellSelectionUpdated: new Slot()
    };
    this.slots.tableViewRowSelectionUpdated.on((state2) => {
      const { type } = state2;
      if (type === "select" || type === "click") {
        const { rowIds, databaseId } = state2;
        this._lastRowSelection = {
          databaseId,
          rowIds
        };
        setDatabaseRowsSelection(databaseId, rowIds);
      } else if (type === "clear") {
        this.clearLastRowSelection();
        clearAllDatabaseRowsSelection();
      }
    });
    this.slots.tableViewCellSelectionUpdated.on((state2) => {
      const { type } = state2;
      if (type === "select") {
        const { databaseId, coords } = state2;
        this._lastCellSelection = {
          databaseId,
          coords
        };
        setDatabaseCellSelection(databaseId, coords);
      } else if (type === "edit") {
        this._lastCellSelection = null;
        const { databaseId, coords } = state2;
        setDatabaseCellEditing(databaseId, coords[0]);
      } else if (type === "clear") {
        this._lastCellSelection = null;
        clearAllDatabaseCellSelection();
      }
    });
  }
  initDatabaseBlock(page, model, databaseId, isAppendNewRow = true) {
    for (let i = 0; i < 3; i++) {
      const id = page.addBlock("affine:paragraph", {
        text: new page.Text("")
      }, databaseId);
      if (i === 0)
        asyncFocusRichText(page, id);
    }
    if (isAppendNewRow) {
      const parent = page.getParent(model);
      assertExists(parent);
      page.addBlock("affine:paragraph", {}, parent.id);
    }
    const blockModel = page.getBlockById(databaseId);
    assertExists(blockModel);
    blockModel.updateColumn({
      name: "Tag",
      type: "multi-select",
      width: 200,
      hide: false,
      selection: []
    });
    blockModel.applyColumnUpdate();
  }
  block2Json(block2, begin, end2) {
    var _a3;
    const columns = [...block2.columns];
    const rowIds = block2.children.map((child) => child.id);
    return {
      flavour: block2.flavour,
      databaseProps: {
        id: block2.id,
        title: block2.title.toString(),
        titleColumnName: block2.titleColumnName,
        titleColumnWidth: block2.titleColumnWidth,
        rowIds,
        cells: block2.cells,
        columns
      },
      children: (_a3 = block2.children) == null ? void 0 : _a3.map((child, index) => {
        if (index === block2.children.length - 1) {
          return getService(child.flavour).block2Json(child, 0, end2);
        }
        return getService(child.flavour).block2Json(child);
      })
    };
  }
  async onBlockPasted(model, props) {
    const { rowIds, columns, cells } = props;
    const columnIds = columns.map((column) => column.id);
    const newColumnIds = columns.map((schema) => {
      const { id, ...nonIdProps } = schema;
      return model.updateColumn(nonIdProps);
    });
    model.applyColumnUpdate();
    const newRowIds = model.children.map((child) => child.id);
    rowIds.forEach((rowId, rowIndex) => {
      const newRowId = newRowIds[rowIndex];
      columnIds.forEach((columnId, columnIndex) => {
        var _a3;
        const cellData = (_a3 = cells[rowId]) == null ? void 0 : _a3[columnId];
        const value = cellData == null ? void 0 : cellData.value;
        if (!value)
          return;
        model.updateCell(newRowId, {
          columnId: newColumnIds[columnIndex],
          value
        });
      });
    });
  }
  clearSelection() {
    this.clearRowSelection();
    this.clearCellLevelSelection();
  }
  // row level selection
  clearRowSelection() {
    this.slots.tableViewRowSelectionUpdated.emit({
      type: "clear"
    });
  }
  setRowSelection(state2) {
    var _a3, _b;
    if (state2.type === "click" && this._lastRowSelection && ((_a3 = state2.rowIds) == null ? void 0 : _a3[0]) === ((_b = this._lastRowSelection.rowIds) == null ? void 0 : _b[0])) {
      this.clearRowSelection();
      return;
    }
    this.slots.tableViewRowSelectionUpdated.emit(state2);
  }
  setRowSelectionByElement(element) {
    const rowId = getClosestRowId(element);
    if (rowId !== "") {
      const databaseId = getClosestDatabaseId(element);
      this.setRowSelection({
        type: "select",
        databaseId,
        rowIds: [rowId]
      });
    }
  }
  clearLastRowSelection() {
    this._lastRowSelection = null;
  }
  refreshRowSelection() {
    if (!this._lastRowSelection)
      return;
    const { databaseId, rowIds } = this._lastRowSelection;
    this.setRowSelection({
      type: "select",
      databaseId,
      rowIds
    });
  }
  toggleRowSelection(element) {
    var _a3;
    const rowId = getClosestRowId(element);
    if (rowId === "")
      return false;
    const rowIds = ((_a3 = this._lastRowSelection) == null ? void 0 : _a3.rowIds) ?? [];
    if (rowIds.indexOf(rowId) > -1) {
      this.clearRowSelection();
    } else {
      this.setRowSelection({
        type: "click",
        databaseId: getClosestDatabaseId(element),
        rowIds: [rowId]
      });
    }
    return true;
  }
  getLastRowSelection() {
    return this._lastRowSelection;
  }
  // cell level selection
  clearCellLevelSelection() {
    this.slots.tableViewCellSelectionUpdated.emit({
      type: "clear"
    });
  }
  setCellSelection(cellSelectionState) {
    this.slots.tableViewCellSelectionUpdated.emit(cellSelectionState);
  }
  getLastCellSelection() {
    return this._lastCellSelection;
  }
};

// node_modules/@blocksuite/blocks/dist/database-block/database-block.js
var __decorate79 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DatabaseBlockComponent = class DatabaseBlockComponent2 extends BlockElement {
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:database", DatabaseBlockService);
    this.model.propsUpdated.on(() => this.requestUpdate());
  }
  render() {
    const databaseTag = literal`affine-database-${unsafeStatic(this.model.mode)}`;
    return html2`
      <${databaseTag}
        .root=${this.root}
        .model=${this.model}
        class="affine-block-element"
      ></${databaseTag}>
    `;
  }
};
DatabaseBlockComponent = __decorate79([
  customElement("affine-database")
], DatabaseBlockComponent);

// node_modules/@blocksuite/blocks/dist/database-block/database-model.js
var DatabaseBlockModel = class extends BaseBlockModel {
  onCreated() {
    super.onCreated();
    this.page.slots.onYEvent.on(({ event }) => {
      if (event.path.includes(this.id) && (event.path.includes("prop:columns") || event.path.includes("prop:cells"))) {
        this.propsUpdated.emit();
      }
    });
  }
  applyColumnUpdate() {
    this.page.updateBlock(this, {
      columns: this.columns
    });
  }
  applyCellsUpdate() {
    this.page.updateBlock(this, {
      cells: this.cells
    });
  }
  findColumnIndex(id) {
    let result = -1;
    this.columns.forEach((col, index) => {
      if (col.id === id)
        result = index;
    });
    return result;
  }
  getColumn(id) {
    const index = this.findColumnIndex(id);
    if (index < 0) {
      return null;
    }
    return this.columns[index];
  }
  addColumn(column, index) {
    const id = this.page.generateId();
    this.page.transact(() => {
      const col = { ...column, id };
      if (index === void 0) {
        this.columns.push(col);
      } else {
        this.columns.splice(index, 0, col);
      }
    });
    return id;
  }
  updateColumn(column) {
    const id = column.id ?? this.page.generateId();
    const index = this.findColumnIndex(id);
    this.page.transact(() => {
      if (index < 0) {
        this.columns.push({ ...column, id });
      } else {
        this.columns[index] = { ...column, id };
      }
    });
    return id;
  }
  moveColumn(from, to) {
    this.page.transact(() => {
      const column = this.columns[from];
      this.columns.splice(from, 1);
      this.columns.splice(to, 0, column);
    });
  }
  deleteColumn(columnId) {
    const index = this.findColumnIndex(columnId);
    if (index < 0)
      return;
    this.page.transact(() => this.columns.splice(index, 1));
  }
  getCell(rowId, columnId) {
    const yRow = this.cells[rowId];
    const yCell = (yRow == null ? void 0 : yRow[columnId]) ?? null;
    if (!yCell)
      return null;
    return {
      columnId: yCell.columnId,
      value: yCell.value
    };
  }
  updateCell(rowId, cell) {
    const hasRow = rowId in this.cells;
    if (!hasRow) {
      this.cells[rowId] = {};
    }
    this.page.transact(() => {
      this.cells[rowId][cell.columnId] = {
        columnId: cell.columnId,
        value: cell.value
      };
    });
  }
  copyCellsByColumn(fromId, toId) {
    this.page.transact(() => {
      Object.keys(this.cells).forEach((rowId) => {
        const cell = this.cells[rowId][fromId];
        if (cell) {
          this.cells[rowId][toId] = {
            ...cell,
            columnId: toId
          };
        }
      });
    });
  }
  deleteCellsByColumn(columnId) {
    this.page.transact(() => {
      Object.keys(this.cells).forEach((rowId) => {
        delete this.cells[rowId][columnId];
      });
    });
  }
  convertCellsByColumn(columnId, newType) {
    this.page.transact(() => {
      Object.keys(this.cells).forEach((rowId) => {
        const cell = this.cells[rowId][columnId];
        if (!cell)
          return;
        const value = cell.value;
        if (!value)
          return;
        if (newType === "select") {
          this.cells[rowId][columnId] = {
            columnId,
            value: [value[0]]
          };
          return;
        }
        if (newType === "rich-text") {
          const text = new Text2(value + "");
          this.cells[rowId][columnId] = {
            columnId,
            value: text.yText
          };
          return;
        }
      });
    });
  }
  renameSelectedCellTag(columnId, oldValue, newValue) {
    this.page.transact(() => {
      Object.keys(this.cells).forEach((rowId) => {
        const cell = this.cells[rowId][columnId];
        if (!cell)
          return;
        const selected = cell.value;
        const newSelected = [...selected];
        const index = newSelected.findIndex((s) => s.value === oldValue.value);
        newSelected[index] = newValue;
        this.cells[rowId][columnId].value = newSelected;
      });
    });
  }
  deleteSelectedCellTag(columnId, target) {
    this.page.transact(() => {
      Object.keys(this.cells).forEach((rowId) => {
        const cell = this.cells[rowId][columnId];
        if (!cell)
          return;
        const selected = cell.value;
        const newSelected = [...selected].filter((item) => item.value !== target.value);
        this.cells[rowId][columnId] = {
          columnId,
          value: newSelected
        };
      });
    });
  }
};
var DatabaseBlockSchema = defineBlockSchema({
  flavour: "affine:database",
  props: (internal) => ({
    mode: "table",
    title: internal.Text(DEFAULT_TITLE),
    cells: {},
    columns: [],
    titleColumnName: "Title",
    titleColumnWidth: 432
  }),
  metadata: {
    role: "hub",
    version: 1,
    tag: literal`affine-database`,
    parent: ["affine:frame"],
    children: ["affine:paragraph", "affine:list"]
  },
  toModel: () => {
    return new DatabaseBlockModel();
  }
});

// node_modules/@blocksuite/blocks/dist/__internal__/theme/theme-observer.js
function extractCssVariables(element) {
  const styles15 = window.getComputedStyle(element);
  const variables = VARIABLES.reduce((acc, cssName) => {
    const value = styles15.getPropertyValue(cssName).trim();
    acc[cssName] = value;
    if (cssName === "--affine-palette-transparent" && !value) {
      acc[cssName] = "#00000000";
    }
    return acc;
  }, {});
  return variables;
}
var ThemeObserver = class extends Slot {
  constructor() {
    super(...arguments);
    this._mode = "";
    this._cssVariables = null;
  }
  get cssVariables() {
    return this._cssVariables;
  }
  observer(element) {
    var _a3;
    (_a3 = this._observer) == null ? void 0 : _a3.disconnect();
    this._cssVariables = extractCssVariables(element);
    this._observer = new MutationObserver(() => {
      const mode = element.getAttribute("data-theme");
      if (this._mode !== mode) {
        this._cssVariables = extractCssVariables(element);
        this.emit(this._cssVariables);
      }
    });
    this._observer.observe(element, {
      attributes: true,
      attributeFilter: ["data-theme"]
    });
  }
  dispose() {
    var _a3;
    super.dispose();
    (_a3 = this._observer) == null ? void 0 : _a3.disconnect();
  }
};

// node_modules/@blocksuite/blocks/dist/components/portal.js
var __decorate80 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Portal = class Portal2 extends LitElement {
  constructor() {
    super(...arguments);
    this.container = document.body;
    this.template = html``;
    this._portalRoot = null;
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    (_a3 = this._portalRoot) == null ? void 0 : _a3.remove();
  }
  createRenderRoot() {
    const portalRoot = document.createElement("div");
    portalRoot.classList.add("affine-portal");
    this.container.append(portalRoot);
    this._portalRoot = portalRoot;
    return portalRoot;
  }
  render() {
    return this.template;
  }
};
__decorate80([
  property()
], Portal.prototype, "container", void 0);
__decorate80([
  property()
], Portal.prototype, "template", void 0);
Portal = __decorate80([
  customElement("affine-portal")
], Portal);

// node_modules/@blocksuite/blocks/dist/code-block/components/code-option.js
function CodeOptionTemplate({ model, position, hoverState, wrap, onClickWrap }) {
  const page = model.page;
  const readonly = page.readonly;
  const style = {
    position: "fixed",
    left: position.x + "px",
    top: position.y + "px"
  };
  return html`
    <style>
      .affine-codeblock-option-container > div {
          position: fixed;
          z-index: 1;
          box-shadow:var(--affine-shadow-2)
      }
      .affine-codeblock-option {
        box-shadow:var(--affine-shadow-2);
        padding:4px;
        border-radius:8px;
        background:var(--affine-background-overlay-panel-color)
      }

      ${tooltipStyle}
    </style>

    <div
      class="affine-codeblock-option"
      style=${styleMap(style)}
      @mouseover=${() => hoverState.emit(true)}
      @mouseout=${() => hoverState.emit(false)}
    >
      <format-bar-button
        class="has-tool-tip"
        data-testid="copy-button"
        @click=${() => copyCode(model)}
      >
        ${CopyIcon}
        <tool-tip inert tip-position="right" role="tooltip"
          >Copy to Clipboard</tool-tip
        >
      </format-bar-button>
      <format-bar-button
        class="has-tool-tip"
        data-testid="wrap-button"
        ?active=${wrap}
        @click=${onClickWrap}
      >
        ${wrap ? CancelWrapIcon : WrapIcon}
        <tool-tip inert tip-position="right" role="tooltip">Wrap code</tool-tip>
      </format-bar-button>
      ${readonly ? "" : html`<format-bar-button
            data-testid="delete-button"
            class="has-tool-tip"
            @click=${() => {
    if (readonly)
      return;
    model.page.deleteBlock(model);
  }}
          >
            ${DeleteIcon}
            <tool-tip inert tip-position="right" role="tooltip"
              >Delete</tool-tip
            >
          </format-bar-button>`}
    </div>
  `;
}

// node_modules/@blocksuite/blocks/dist/code-block/components/lang-list.js
var __decorate81 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LangList = class LangList2 extends ShadowlessElement {
  constructor() {
    super(...arguments);
    this._filterText = "";
    this._currentSelectedIndex = 0;
    this.delay = 150;
    this._clickAwayListener = (e) => {
      var _a3;
      if ((_a3 = this.renderRoot.parentElement) == null ? void 0 : _a3.contains(e.target)) {
        return;
      }
      this.dispatchEvent(createEvent("dispose", null));
    };
  }
  static get styles() {
    return css`
      lang-list {
        display: flex;
        flex-direction: column;
        position: absolute;
        background: var(--affine-background-overlay-panel-color);
        border-radius: 12px;
        top: 24px;
        z-index: 1;
      }

      .lang-list-container {
        box-shadow: var(--affine-menu-shadow);
        border-radius: 8px;
        padding: 12px 8px;
      }

      .lang-list-button-container {
        position: relative;
        overflow: scroll;
        height: 424px;
        width: 200px;
        padding-top: 5px;
        padding-left: 4px;
        padding-right: 4px;
        /*scrollbar-color: #fff0 #fff0;*/
      }

      /*
      .lang-list-button-container::-webkit-scrollbar {
        background: none;
      }
      */

      .lang-item {
        display: flex;
        justify-content: flex-start;
        padding-left: 12px;
        margin-bottom: 5px;
      }

      .input-wrapper {
        position: relative;
        display: flex;
        margin-top: 8px;
        margin-left: 4px;
      }

      #filter-input {
        display: flex;
        align-items: center;
        height: 32px;
        width: 192px;
        border: 1px solid var(--affine-border-color);
        border-radius: 8px;
        padding-left: 44px;
        padding-top: 4px;

        font-family: var(--affine-font-family);
        font-size: var(--affine-font-sm);
        box-sizing: border-box;
        color: inherit;
        background: var(--affine-background-overlay-panel-color);
      }

      #filter-input:focus {
        outline: none;
      }

      #filter-input::placeholder {
        color: var(--affine-placeholder-color);
        font-size: var(--affine-font-sm);
      }

      .search-icon {
        position: absolute;
        left: 8px;
        height: 100%;
        display: flex;
        align-items: center;
        fill: var(--affine-icon-color);
      }
    `;
  }
  async connectedCallback() {
    super.connectedCallback();
    document.addEventListener("click", this._clickAwayListener);
    setTimeout(() => {
      var _a3;
      (_a3 = this.filterInput) == null ? void 0 : _a3.focus();
    }, 0);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("click", this._clickAwayListener);
  }
  _onLanguageClicked(language) {
    this.dispatchEvent(createEvent("selected-language-changed", {
      language: (language == null ? void 0 : language.id) ?? null
    }));
  }
  render() {
    const filteredLanguages = [PLAIN_TEXT_REGISTRATION, ...languages].filter((language) => {
      var _a3;
      if (!this._filterText) {
        return true;
      }
      return language.id.startsWith(this._filterText.toLowerCase()) || ((_a3 = language.aliases) == null ? void 0 : _a3.some((alias) => alias.startsWith(this._filterText.toLowerCase())));
    }).sort((a, b) => (POPULAR_LANGUAGES_MAP[a.id] ?? Infinity) - (POPULAR_LANGUAGES_MAP[b.id] ?? Infinity));
    const onLanguageSelect = (e) => {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        this._currentSelectedIndex = (this._currentSelectedIndex + 1) % filteredLanguages.length;
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        this._currentSelectedIndex = (this._currentSelectedIndex + filteredLanguages.length - 1) % filteredLanguages.length;
      } else if (e.key === "Enter") {
        e.preventDefault();
        if (this._currentSelectedIndex === -1 || this._currentSelectedIndex >= filteredLanguages.length)
          return;
        this._onLanguageClicked(filteredLanguages[this._currentSelectedIndex]);
      }
    };
    return html`
      <div class="lang-list-container">
        <div class="input-wrapper">
          <div class="search-icon">${SearchIcon}</div>
          <input
            id="filter-input"
            type="text"
            placeholder="Search"
            @input="${() => {
      var _a3;
      this._filterText = (_a3 = this.filterInput) == null ? void 0 : _a3.value;
      this._currentSelectedIndex = 0;
    }}"
            @keydown="${onLanguageSelect}"
          />
        </div>
        <div class="lang-list-button-container">
          ${filteredLanguages.map((language, index) => html`
              <icon-button
                width="100%"
                height="32px"
                @click="${() => this._onLanguageClicked(language)}"
                class="lang-item"
                ?hover=${index === this._currentSelectedIndex}
              >
                ${language.id[0].toUpperCase() + language.id.slice(1)}
              </icon-button>
            `)}
        </div>
      </div>
    `;
  }
};
__decorate81([
  state()
], LangList.prototype, "_filterText", void 0);
__decorate81([
  state()
], LangList.prototype, "_currentSelectedIndex", void 0);
__decorate81([
  query("#filter-input")
], LangList.prototype, "filterInput", void 0);
__decorate81([
  property()
], LangList.prototype, "delay", void 0);
LangList = __decorate81([
  customElement("lang-list")
], LangList);

// node_modules/@blocksuite/blocks/dist/code-block/code-service.js
var INDENT_SYMBOL = "  ";
var LINE_BREAK_SYMBOL = "\n";
var allIndexOf = (text, symbol, start2 = 0, end2 = text.length) => {
  const indexArr = [];
  let i = start2;
  while (i < end2) {
    const index = text.indexOf(symbol, i);
    if (index === -1 || index > end2) {
      break;
    }
    indexArr.push(index);
    i = index + 1;
  }
  return indexArr;
};
var CodeBlockService = class extends BaseService {
  setLang(model, lang) {
    const standardLang = getStandardLanguage(lang);
    const langName = (standardLang == null ? void 0 : standardLang.id) ?? FALLBACK_LANG;
    model.page.updateBlock(model, {
      language: langName
    });
  }
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    const richTextElement = document.querySelector(`[${BLOCK_ID_ATTR}="${block2.id}"] rich-text`);
    if (!richTextElement) {
      return super.block2html(block2, {
        childText,
        begin,
        end: end2
      });
    }
    const preElement = document.createElement("pre");
    const codeElement = document.createElement("code");
    preElement.setAttribute("code-lang", block2.language);
    codeElement.innerHTML = Array.from(richTextElement.querySelectorAll("v-line")).map((line2) => line2.textContent + "\n").join("");
    preElement.append(codeElement);
    return preElement.outerHTML;
  }
  async json2Block(focusedBlockModel, pastedBlocks, range) {
    var _a3;
    assertExists(range);
    const texts = pastedBlocks.map((block2) => block2.text);
    const lines = texts.map((line2) => line2 == null ? void 0 : line2.map((op) => op.insert).join(""));
    const text = lines.join("\n");
    (_a3 = focusedBlockModel.text) == null ? void 0 : _a3.insert(text, range.startOffset);
    const vEditor = getVirgoByModel(focusedBlockModel);
    assertExists(vEditor);
    vEditor.setVRange({
      index: range.startOffset + text.length,
      length: 0
    });
  }
  defineKeymap(block2, virgo) {
    const keymap = super.defineKeymap(block2, virgo);
    return {
      ...keymap,
      tab: {
        key: "Tab",
        handler(range, context) {
          context.event.stopPropagation();
          const text = this.vEditor.yText.toString();
          const index = text.lastIndexOf(LINE_BREAK_SYMBOL, range.index - 1);
          const indexArr = allIndexOf(text, LINE_BREAK_SYMBOL, range.index, range.index + range.length).map((i) => i + 1).reverse();
          if (index !== -1) {
            indexArr.push(index + 1);
          } else {
            indexArr.push(0);
          }
          indexArr.forEach((i) => {
            this.vEditor.insertText({
              index: i,
              length: 0
            }, INDENT_SYMBOL);
          });
          this.vEditor.setVRange({
            index: range.index + 2,
            length: range.length + (indexArr.length - 1) * INDENT_SYMBOL.length
          });
          return PREVENT_DEFAULT;
        }
      },
      shiftTab: {
        key: "Tab",
        shiftKey: true,
        handler: function(range, context) {
          context.event.stopPropagation();
          const text = this.vEditor.yText.toString();
          const index = text.lastIndexOf(LINE_BREAK_SYMBOL, range.index - 1);
          let indexArr = allIndexOf(text, LINE_BREAK_SYMBOL, range.index, range.index + range.length).map((i) => i + 1).reverse();
          if (index !== -1) {
            indexArr.push(index + 1);
          } else {
            indexArr.push(0);
          }
          indexArr = indexArr.filter((i) => text.slice(i, i + 2) === INDENT_SYMBOL);
          indexArr.forEach((i) => {
            this.vEditor.deleteText({
              index: i,
              length: 2
            });
          });
          if (indexArr.length > 0) {
            this.vEditor.setVRange({
              index: range.index - (indexArr[indexArr.length - 1] < range.index ? 2 : 0),
              length: range.length - (indexArr.length - 1) * INDENT_SYMBOL.length
            });
          }
          return PREVENT_DEFAULT;
        }
      }
    };
  }
};

// node_modules/@blocksuite/blocks/dist/code-block/utils/code-line-renderer.js
var getCodeLineRenderer = (highlightOptionsGetter) => (delta) => {
  return html`<affine-code-line
    .delta=${delta}
    .highlightOptionsGetter=${highlightOptionsGetter}
  ></affine-code-line>`;
};

// node_modules/@blocksuite/blocks/dist/code-block/code-block.js
var __decorate82 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CodeBlockComponent = class CodeBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this._showLangList = false;
    this._optionPosition = null;
    this._wrap = false;
    this.textSchema = {
      attributesSchema: z.object({}),
      textRenderer: () => getCodeLineRenderer(() => ({
        lang: this.model.language.toLowerCase(),
        highlighter: this._highlighter
      }))
    };
    this._richTextResizeObserver = new ResizeObserver(() => {
      this._updateLineNumbers();
    });
    this._themeChangeObserver = null;
    this._preLang = null;
    this._highlighter = null;
    this.hoverState = new Slot();
  }
  async _startHighlight(lang) {
    const mode = queryCurrentMode();
    this._highlighter = await getHighlighter({
      theme: mode === "dark" ? DARK_THEME : LIGHT_THEME,
      themes: [LIGHT_THEME, DARK_THEME],
      langs: [lang],
      paths: {
        // TODO: use local path
        wasm: "https://cdn.jsdelivr.net/npm/shiki/dist",
        themes: "https://cdn.jsdelivr.net/",
        languages: "https://cdn.jsdelivr.net/npm/shiki/languages"
      }
    });
    const richText = this.querySelector("rich-text");
    assertExists(richText);
    const vEditor = richText.vEditor;
    assertExists(vEditor);
    const range = vEditor.getVRange();
    vEditor.requestUpdate();
    if (range) {
      vEditor.setVRange(range);
    }
  }
  get readonly() {
    return this.model.page.readonly;
  }
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:code", CodeBlockService);
    this._disposables.add(this.model.propsUpdated.on(() => this.requestUpdate()));
    this._disposables.add(this.model.childrenUpdated.on(() => this.requestUpdate()));
    const HEADER_HEIGHT = 64;
    const OPTION_ELEMENT_HEIGHT = 96;
    let timer;
    const updatePosition2 = () => {
      const rect = this.getBoundingClientRect();
      this._optionPosition = {
        x: rect.right + 12,
        y: Math.min(Math.max(rect.top, HEADER_HEIGHT + 12), rect.bottom - OPTION_ELEMENT_HEIGHT)
      };
    };
    this.hoverState.on((hover) => {
      clearTimeout(timer);
      if (hover) {
        updatePosition2();
        return;
      }
      timer = window.setTimeout(() => {
        this._optionPosition = null;
      }, HOVER_DELAY);
    });
    this._disposables.addFromEvent(this, "mouseover", (e) => {
      this.hoverState.emit(true);
    });
    const HOVER_DELAY = 300;
    this._disposables.addFromEvent(this, "mouseleave", (e) => {
      this.hoverState.emit(false);
    });
    const viewportElement = getViewportElement(this.model.page);
    if (viewportElement) {
      this._disposables.addFromEvent(viewportElement, "scroll", (e) => {
        if (!this._optionPosition)
          return;
        updatePosition2();
      });
    }
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    this.hoverState.dispose();
    this._richTextResizeObserver.disconnect();
    (_a3 = this._themeChangeObserver) == null ? void 0 : _a3.dispose();
  }
  _onClickWrapBtn() {
    const container = this.querySelector(".affine-code-block-container");
    assertExists(container);
    this._wrap = container.classList.toggle("wrap");
  }
  firstUpdated() {
    this._themeChangeObserver = listenToThemeChange(this, async (a) => {
      if (!this._highlighter)
        return;
      const richText = this.querySelector("rich-text");
      const vEditor = richText == null ? void 0 : richText.vEditor;
      if (!vEditor)
        return;
      setTimeout(() => {
        vEditor.requestUpdate();
      });
    });
    if (!this.model.language || this.model.language === FALLBACK_LANG) {
      this._highlighter = null;
      return;
    }
    const lang = languages.find((lang2) => lang2.id === this.model.language.toLowerCase());
    if (!lang) {
      console.warn("Unexpected language: ", this.model.language);
      return;
    }
    this._startHighlight(lang);
  }
  updated() {
    if (this.model.language !== this._preLang) {
      this._preLang = this.model.language;
      const lang = languages.find((lang2) => lang2.id === this.model.language.toLowerCase());
      if (lang) {
        if (this._highlighter) {
          const currentLangs = this._highlighter.getLoadedLanguages();
          if (!currentLangs.includes(lang.id)) {
            this._highlighter.loadLanguage(lang).then(() => {
              const richText3 = this.querySelector("rich-text");
              const vEditor2 = richText3 == null ? void 0 : richText3.vEditor;
              if (vEditor2) {
                vEditor2.requestUpdate();
              }
            });
          }
        } else {
          this._startHighlight(lang);
        }
      } else {
        this._highlighter = null;
      }
      const richText2 = this.querySelector("rich-text");
      const vEditor = richText2 == null ? void 0 : richText2.vEditor;
      if (vEditor) {
        vEditor.requestUpdate();
      }
    }
    const richText = this.querySelector("rich-text");
    assertExists(richText);
    this._richTextResizeObserver.disconnect();
    this._richTextResizeObserver.observe(richText);
  }
  _onClickLangBtn() {
    if (this.readonly)
      return;
    this._showLangList = !this._showLangList;
  }
  _langListTemplate() {
    const normalizedLang = this.model.language[0].toUpperCase() + this.model.language.slice(1);
    return html`<div
      class="lang-list-wrapper"
      style="${this._showLangList ? "visibility: visible;" : ""}"
    >
      <icon-button
        class="lang-button"
        data-testid="lang-button"
        width="auto"
        height="24px"
        ?hover=${this._showLangList}
        ?disabled=${this.readonly}
        @click=${this._onClickLangBtn}
      >
        ${normalizedLang} ${!this.readonly ? ArrowDownIcon : html``}
      </icon-button>
      ${this._showLangList ? html`<lang-list
            @selected-language-changed=${(e) => {
      getService("affine:code").setLang(this.model, e.detail.language);
      this._showLangList = false;
    }}
            @dispose=${() => {
      this._showLangList = false;
    }}
          ></lang-list>` : ""}
    </div>`;
  }
  _codeOptionTemplate() {
    if (!this._optionPosition)
      return "";
    return html`<affine-portal
      .template=${CodeOptionTemplate({
      model: this.model,
      position: this._optionPosition,
      hoverState: this.hoverState,
      wrap: this._wrap,
      onClickWrap: () => this._onClickWrapBtn()
    })}
    ></affine-portal>`;
  }
  _updateLineNumbers() {
    const lineNumbersContainer = this.querySelector("#line-numbers");
    assertExists(lineNumbersContainer);
    const next2 = this._wrap ? generateLineNumberRender() : lineNumberRender;
    render(repeat(Array.from(this.querySelectorAll("v-line")), next2), lineNumbersContainer);
  }
  render() {
    return html`<div class="affine-code-block-container">
        ${this._langListTemplate()}
        <div class="rich-text-container">
          <div id="line-numbers"></div>
          <rich-text .model=${this.model} .textSchema=${this.textSchema}>
          </rich-text>
        </div>
        ${this.content}
      </div>
      ${this._codeOptionTemplate()}`;
  }
};
CodeBlockComponent.styles = css`
    code-block {
      position: relative;
      z-index: 1;
    }

    .affine-code-block-container {
      font-size: var(--affine-font-sm);
      line-height: var(--affine-line-height);
      position: relative;
      padding: 32px 0px 12px 0px;
      background: var(--affine-background-code-block);
      border-radius: 10px;
      margin-top: calc(var(--affine-paragraph-space) + 8px);
      margin-bottom: calc(var(--affine-paragraph-space) + 8px);
    }

    /* hover area */
    .affine-code-block-container::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 50px;
      height: 100%;
      transform: translateX(100%);
    }

    /* hover area */
    .affine-code-block-container::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 50px;
      height: 100%;
      transform: translateX(100%);
    }

    .affine-code-block-container .virgo-editor {
      font-family: var(--affine-font-code-family);
      font-variant-ligatures: none;
    }

    .affine-code-block-container .lang-list-wrapper {
      position: absolute;
      font-size: var(--affine-font-sm);
      line-height: var(--affine-line-height);
      top: 12px;
      left: 12px;
    }

    .affine-code-block-container > .lang-list-wrapper {
      visibility: hidden;
    }
    .affine-code-block-container:hover > .lang-list-wrapper {
      visibility: visible;
    }

    .affine-code-block-container > .lang-list-wrapper > .lang-button {
      display: flex;
      justify-content: flex-start;
      padding: 0 8px;
    }

    .affine-code-block-container rich-text {
      /* to make sure the resize observer can be triggered as expected */
      display: block;
      position: relative;
      width: 90%;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 20px;
    }

    .affine-code-block-container .rich-text-container {
      position: relative;
      border-radius: 5px;
      padding: 4px 12px 4px 60px;
    }

    #line-numbers {
      position: absolute;
      text-align: right;
      left: 20px;
      line-height: var(--affine-line-height);
      color: var(--affine-text-secondary-color);
    }

    .affine-code-block-container .virgo-editor {
      width: 90%;
      margin: 0;
    }

    .affine-code-block-container affine-code-line span v-text {
      display: inline;
    }

    .affine-code-block-container affine-code-line span {
      white-space: pre;
    }

    .affine-code-block-container.wrap #line-numbers {
      top: calc(var(--affine-line-height) + 4px);
    }

    .affine-code-block-container.wrap #line-numbers > div {
      margin-top: calc(
        var(--top, 0) / var(--affine-zoom, 1) - var(--affine-line-height)
      );
    }

    .affine-code-block-container.wrap v-line > div {
      display: block;
    }

    .affine-code-block-container.wrap affine-code-line span {
      white-space: break-spaces;
    }

    .affine-code-block-container .virgo-editor::-webkit-scrollbar {
      display: none;
    }

    .code-block-option {
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
      list-style: none;
      padding: 4px;
      width: 40px;
      background-color: var(--affine-background-overlay-panel-color);
      margin: 0;
    }

    ${tooltipStyle}
  `;
__decorate82([
  state()
], CodeBlockComponent.prototype, "_showLangList", void 0);
__decorate82([
  state()
], CodeBlockComponent.prototype, "_optionPosition", void 0);
__decorate82([
  state()
], CodeBlockComponent.prototype, "_wrap", void 0);
CodeBlockComponent = __decorate82([
  customElement("affine-code")
], CodeBlockComponent);
function generateLineNumberRender(top2 = 0) {
  return function lineNumberRender2(e, index) {
    const style = {
      "--top": `${top2}px`
    };
    top2 = e.getBoundingClientRect().height;
    return html`<div style=${styleMap(style)}>${index + 1}</div>`;
  };
}
function lineNumberRender(_, index) {
  return html`<div>${index + 1}</div>`;
}

// node_modules/@blocksuite/blocks/dist/code-block/code-model.js
var CodeBlockSchema = defineBlockSchema({
  flavour: "affine:code",
  props: (internal) => ({
    text: internal.Text(),
    language: FALLBACK_LANG
  }),
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-code`,
    parent: ["affine:frame", "affine:paragraph", "affine:list"],
    children: []
  }
});

// node_modules/@blocksuite/blocks/dist/preset/index.js
var pagePreset = /* @__PURE__ */ new Map([
  [PageBlockSchema, literal`affine-default-page`],
  [SurfaceBlockSchema, literal`affine-surface`],
  [ListBlockSchema, literal`affine-list`],
  [FrameBlockSchema, literal`affine-frame`],
  [DatabaseBlockSchema, literal`affine-database`],
  [DividerBlockSchema, literal`affine-divider`],
  [CodeBlockSchema, literal`affine-code`],
  [EmbedBlockSchema, literal`affine-embed`],
  [ParagraphBlockSchema, literal`affine-paragraph`],
  [BookmarkBlockSchema, literal`affine-bookmark`]
]);
var edgelessPreset = /* @__PURE__ */ new Map([
  [PageBlockSchema, literal`affine-edgeless-page`],
  [SurfaceBlockSchema, literal`affine-surface`],
  [ListBlockSchema, literal`affine-list`],
  [FrameBlockSchema, literal`affine-frame`],
  [DatabaseBlockSchema, literal`affine-database`],
  [DividerBlockSchema, literal`affine-divider`],
  [CodeBlockSchema, literal`affine-code`],
  [EmbedBlockSchema, literal`affine-embed`],
  [ParagraphBlockSchema, literal`affine-paragraph`],
  [BookmarkBlockSchema, literal`affine-bookmark`]
]);

// node_modules/@blocksuite/blocks/dist/index.js
var env = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : (
  // @ts-ignore
  typeof global !== "undefined" ? (
    // @ts-ignore
    global
  ) : {}
);
var importIdentifier = "__ $BLOCKSUITE_BLOCKS$ __";
if (env[importIdentifier] === true) {
  console.error("@blocksuite/blocks was already imported. This breaks constructor checks and will lead to issues!");
}
if (typeof window === "undefined") {
  throw new Error("Seems like you are importing @blocksuite/blocks in SSR mode. Which is not supported for now.");
}
env[importIdentifier] = true;

// node_modules/@blocksuite/phasor/dist/utils/numerical.js
var EPSILON = 1e-12;
var MACHINE_EPSILON = 112e-18;

// node_modules/@blocksuite/phasor/dist/utils/line.js
var Line = class {
  static intersect(sp, ep, sp2, ep2, infinite = false) {
    const v1 = ep.subtract(sp);
    const v2 = ep2.subtract(sp2);
    const cross = v1.cross(v2);
    if (almostEqual(cross, 0, MACHINE_EPSILON))
      return null;
    const d = sp.subtract(sp2);
    let u1 = v2.cross(d) / cross;
    const u2 = v1.cross(d) / cross, epsilon = (
      /*#=*/
      EPSILON
    ), uMin = -epsilon, uMax = 1 + epsilon;
    if (infinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
      if (!infinite) {
        u1 = clamp(u1, 0, 1);
      }
      return sp.lerp(v1, u1);
    }
    return null;
  }
};

// node_modules/@blocksuite/phasor/dist/utils/vec.js
var Vec = class _Vec {
  static clamp(n, min3, max2) {
    return Math.max(min3, typeof max2 !== "undefined" ? Math.min(n, max2) : n);
  }
  static clampV(A, min3, max2) {
    return A.map((n) => max2 ? _Vec.clamp(n, min3, max2) : _Vec.clamp(n, min3));
  }
  /**
   * Cross (for point in polygon)
   *
   */
  static cross(x, y, z2) {
    return (y[0] - x[0]) * (z2[1] - x[1]) - (z2[0] - x[0]) * (y[1] - x[1]);
  }
  /**
   * Snap vector to nearest step.
   * @param A
   * @param step
   * @example
   * ```ts
   * Vec.snap([10.5, 28], 10) // [10, 30]
   * ```
   */
  static snap(a, step = 1) {
    return [Math.round(a[0] / step) * step, Math.round(a[1] / step) * step];
  }
};
Vec.neg = (A) => {
  return [-A[0], -A[1]];
};
Vec.add = (A, B) => {
  return [A[0] + B[0], A[1] + B[1]];
};
Vec.addScalar = (A, n) => {
  return [A[0] + n, A[1] + n];
};
Vec.sub = (A, B) => {
  return [A[0] - B[0], A[1] - B[1]];
};
Vec.subScalar = (A, n) => {
  return [A[0] - n, A[1] - n];
};
Vec.vec = (A, B) => {
  return [B[0] - A[0], B[1] - A[1]];
};
Vec.mul = (A, n) => {
  return [A[0] * n, A[1] * n];
};
Vec.mulV = (A, B) => {
  return [A[0] * B[0], A[1] * B[1]];
};
Vec.div = (A, n) => {
  return [A[0] / n, A[1] / n];
};
Vec.divV = (A, B) => {
  return [A[0] / B[0], A[1] / B[1]];
};
Vec.per = (A) => {
  return [A[1], -A[0]];
};
Vec.dpr = (A, B) => {
  return A[0] * B[0] + A[1] * B[1];
};
Vec.cpr = (A, B) => {
  return A[0] * B[1] - B[0] * A[1];
};
Vec.len2 = (A) => {
  return A[0] * A[0] + A[1] * A[1];
};
Vec.len = (A) => {
  return Math.hypot(A[0], A[1]);
};
Vec.pry = (A, B) => {
  return Vec.dpr(A, B) / Vec.len(B);
};
Vec.uni = (A) => {
  return Vec.div(A, Vec.len(A));
};
Vec.normalize = (A) => {
  return Vec.uni(A);
};
Vec.tangent = (A, B) => {
  return Vec.uni(Vec.sub(A, B));
};
Vec.dist2 = (A, B) => {
  return Vec.len2(Vec.sub(A, B));
};
Vec.dist = (A, B) => {
  return Math.hypot(A[1] - B[1], A[0] - B[0]);
};
Vec.fastDist = (A, B) => {
  const V = [B[0] - A[0], B[1] - A[1]];
  const aV = [Math.abs(V[0]), Math.abs(V[1])];
  let r = 1 / Math.max(aV[0], aV[1]);
  r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289);
  return [V[0] * r, V[1] * r];
};
Vec.ang = (A, B) => {
  return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B));
};
Vec.angle = (A, B) => {
  return Math.atan2(B[1] - A[1], B[0] - A[0]);
};
Vec.med = (A, B) => {
  return Vec.mul(Vec.add(A, B), 0.5);
};
Vec.rot = (A, r = 0) => {
  return [
    A[0] * Math.cos(r) - A[1] * Math.sin(r),
    A[0] * Math.sin(r) + A[1] * Math.cos(r)
  ];
};
Vec.rotWith = (A, C, r = 0) => {
  if (r === 0)
    return A;
  const s = Math.sin(r);
  const c = Math.cos(r);
  const px2 = A[0] - C[0];
  const py = A[1] - C[1];
  const nx = px2 * c - py * s;
  const ny = px2 * s + py * c;
  return [nx + C[0], ny + C[1]];
};
Vec.isEqual = (A, B) => {
  return A[0] === B[0] && A[1] === B[1];
};
Vec.lrp = (A, B, t) => {
  return Vec.add(A, Vec.mul(Vec.sub(B, A), t));
};
Vec.int = (A, B, from, to, s = 1) => {
  const t = (Vec.clamp(from, to) - from) / (to - from);
  return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s));
};
Vec.ang3 = (p1, pc, p2) => {
  const v1 = Vec.vec(pc, p1);
  const v2 = Vec.vec(pc, p2);
  return Vec.ang(v1, v2);
};
Vec.abs = (A) => {
  return [Math.abs(A[0]), Math.abs(A[1])];
};
Vec.rescale = (a, n) => {
  const l = Vec.len(a);
  return [n * a[0] / l, n * a[1] / l];
};
Vec.isLeft = (p1, pc, p2) => {
  return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1]);
};
Vec.clockwise = (p1, pc, p2) => {
  return Vec.isLeft(p1, pc, p2) > 0;
};
Vec.toFixed = (a) => {
  return a.map((v) => Math.round(v * 100) / 100);
};
Vec.nearestPointOnLineThroughPoint = (A, u, P) => {
  return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));
};
Vec.distanceToLineThroughPoint = (A, u, P) => {
  return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P));
};
Vec.nearestPointOnLineSegment = (A, B, P, clamp2 = true) => {
  const u = Vec.uni(Vec.sub(B, A));
  const C = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));
  if (clamp2) {
    if (C[0] < Math.min(A[0], B[0]))
      return A[0] < B[0] ? A : B;
    if (C[0] > Math.max(A[0], B[0]))
      return A[0] > B[0] ? A : B;
    if (C[1] < Math.min(A[1], B[1]))
      return A[1] < B[1] ? A : B;
    if (C[1] > Math.max(A[1], B[1]))
      return A[1] > B[1] ? A : B;
  }
  return C;
};
Vec.distanceToLineSegment = (A, B, P, clamp2 = true) => {
  return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp2));
};
Vec.nearestPointOnBounds = (bounds, P) => {
  return [
    Vec.clamp(P[0], bounds.minX, bounds.maxX),
    Vec.clamp(P[1], bounds.minY, bounds.maxY)
  ];
};
Vec.distanceToBounds = (bounds, P) => {
  return Vec.dist(P, Vec.nearestPointOnBounds(bounds, P));
};
Vec.nudge = (A, B, d) => {
  if (Vec.isEqual(A, B))
    return A;
  return Vec.add(A, Vec.mul(Vec.uni(Vec.sub(B, A)), d));
};
Vec.nudgeAtAngle = (A, a, d) => {
  return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]];
};
Vec.toPrecision = (a, n = 4) => {
  return [+a[0].toPrecision(n), +a[1].toPrecision(n)];
};
Vec.pointsBetween = (A, B, steps = 6) => {
  return Array.from(Array(steps)).map((_, i) => {
    const t = i / (steps - 1);
    const k = Math.min(1, 0.5 + Math.abs(0.5 - t));
    return [...Vec.lrp(A, B, t), k];
  });
};
Vec.slope = (A, B) => {
  if (A[0] === B[0])
    return NaN;
  return (A[1] - B[1]) / (A[0] - B[0]);
};
Vec.max = (...v) => {
  return [Math.max(...v.map((a) => a[0])), Math.max(...v.map((a) => a[1]))];
};
Vec.min = (...v) => {
  return [Math.min(...v.map((a) => a[0])), Math.min(...v.map((a) => a[1]))];
};
Vec.rotAround = (A, C, r) => {
  const s = Math.sin(r);
  const c = Math.cos(r);
  const px2 = A[0] - C[0];
  const py = A[1] - C[1];
  const nx = px2 * c - py * s;
  const ny = px2 * s + py * c;
  return [nx + C[0], ny + C[1]];
};

// node_modules/@blocksuite/phasor/dist/utils/tl-utils.js
var TAU = Math.PI * 2;
var TLBoundsEdge;
(function(TLBoundsEdge2) {
  TLBoundsEdge2["Top"] = "top_edge";
  TLBoundsEdge2["Right"] = "right_edge";
  TLBoundsEdge2["Bottom"] = "bottom_edge";
  TLBoundsEdge2["Left"] = "left_edge";
})(TLBoundsEdge || (TLBoundsEdge = {}));
var TLBoundsCorner;
(function(TLBoundsCorner2) {
  TLBoundsCorner2["TopLeft"] = "top_left_corner";
  TLBoundsCorner2["TopRight"] = "top_right_corner";
  TLBoundsCorner2["BottomRight"] = "bottom_right_corner";
  TLBoundsCorner2["BottomLeft"] = "bottom_left_corner";
})(TLBoundsCorner || (TLBoundsCorner = {}));
var SnapPoints;
(function(SnapPoints2) {
  SnapPoints2["minX"] = "minX";
  SnapPoints2["midX"] = "midX";
  SnapPoints2["maxX"] = "maxX";
  SnapPoints2["minY"] = "minY";
  SnapPoints2["midY"] = "midY";
  SnapPoints2["maxY"] = "maxY";
})(SnapPoints || (SnapPoints = {}));
var Utils = class _Utils {
  /* -------------------------------------------------- */
  /*                    Math & Geometry                 */
  /* -------------------------------------------------- */
  /**
   * Linear interpolation between two numbers.
   * @param y1
   * @param y2
   * @param mu
   */
  static lerp(y1, y2, mu) {
    mu = _Utils.clamp(mu, 0, 1);
    return y1 * (1 - mu) + y2 * mu;
  }
  /**
   * Linear interpolation between two colors.
   *
   * ### Example
   *
   *```ts
   * lerpColor("#000000", "#0099FF", .25)
   *```
   */
  static lerpColor(color1, color2, factor = 0.5) {
    function h2r(hex) {
      const result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return [
        parseInt(result2[1], 16),
        parseInt(result2[2], 16),
        parseInt(result2[3], 16)
      ];
    }
    function r2h(rgb) {
      return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
    }
    const c1 = h2r(color1) || [0, 0, 0];
    const c2 = h2r(color2) || [0, 0, 0];
    const result = c1.slice();
    for (let i = 0; i < 3; i++) {
      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));
    }
    return r2h(result);
  }
  /**
   * Modulate a value between two ranges.
   * @param value
   * @param rangeA from [low, high]
   * @param rangeB to [low, high]
   * @param clamp
   */
  static modulate(value, rangeA, rangeB, clamp2 = false) {
    const [fromLow, fromHigh] = rangeA;
    const [v0, v1] = rangeB;
    const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
    return clamp2 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
  }
  static clamp(n, min3, max2) {
    return Math.max(min3, typeof max2 !== "undefined" ? Math.min(n, max2) : n);
  }
  /**
   * Recursively clone an object or array.
   * @param obj
   */
  static deepClone(obj) {
    if (obj === null)
      return obj;
    if (Array.isArray(obj)) {
      return [...obj];
    }
    if (typeof obj === "object") {
      const clone2 = { ...obj };
      Object.keys(clone2).forEach((key) => clone2[key] = typeof obj[key] === "object" ? _Utils.deepClone(obj[key]) : obj[key]);
      return clone2;
    }
    return obj;
  }
  /**
   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).
   * The result will always be between -1 and 1.
   *
   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).
   */
  static rng(seed = "") {
    let x = 0;
    let y = 0;
    let z2 = 0;
    let w = 0;
    function next2() {
      const t = x ^ x << 11;
      x = y;
      y = z2;
      z2 = w;
      w ^= (w >>> 19 ^ t ^ t >>> 8) >>> 0;
      return w / 4294967296;
    }
    for (let k = 0; k < seed.length + 64; k++) {
      x ^= seed.charCodeAt(k) | 0;
      next2();
    }
    return next2;
  }
  /* ---------------------- Boxes --------------------- */
  static pointsToLineSegments(points2, closed = false) {
    const segments = [];
    for (let i = 1; i < points2.length; i++)
      segments.push([points2[i - 1], points2[i]]);
    if (closed)
      segments.push([points2[points2.length - 1], points2[0]]);
    return segments;
  }
  static getRectangleSides(point, size, rotation = 0) {
    const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
    const tl = Vec.rotWith(point, center, rotation);
    const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation);
    const br = Vec.rotWith(Vec.add(point, size), center, rotation);
    const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation);
    return [
      ["top", [tl, tr]],
      ["right", [tr, br]],
      ["bottom", [br, bl]],
      ["left", [bl, tl]]
    ];
  }
  /* --------------- Circles and Angles --------------- */
  /**
   * Get a circle from three points.
   * @param A
   * @param B
   * @param C
   * @returns [x, y, r]
   */
  static circleFromThreePoints(A, B, C) {
    const [x1, y1] = A;
    const [x2, y2] = B;
    const [x3, y3] = C;
    const a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;
    const b = (x1 * x1 + y1 * y1) * (y3 - y2) + (x2 * x2 + y2 * y2) * (y1 - y3) + (x3 * x3 + y3 * y3) * (y2 - y1);
    const c = (x1 * x1 + y1 * y1) * (x2 - x3) + (x2 * x2 + y2 * y2) * (x3 - x1) + (x3 * x3 + y3 * y3) * (x1 - x2);
    const x = -b / (2 * a);
    const y = -c / (2 * a);
    return [x, y, Math.hypot(x - x1, y - y1)];
  }
  /**
   * Find the approximate perimeter of an ellipse.
   * @param rx
   * @param ry
   */
  static perimeterOfEllipse(rx, ry) {
    const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    const p = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
    return p;
  }
  /**
   * Get the short angle distance between two angles.
   * @param a0
   * @param a1
   */
  static shortAngleDist(a0, a1) {
    const max2 = Math.PI * 2;
    const da = (a1 - a0) % max2;
    return 2 * da % max2 - da;
  }
  /**
   * Get the long angle distance between two angles.
   * @param a0
   * @param a1
   */
  static longAngleDist(a0, a1) {
    return Math.PI * 2 - _Utils.shortAngleDist(a0, a1);
  }
  /**
   * Interpolate an angle between two angles.
   * @param a0
   * @param a1
   * @param t
   */
  static lerpAngles(a0, a1, t) {
    return a0 + _Utils.shortAngleDist(a0, a1) * t;
  }
  /**
   * Get the short distance between two angles.
   * @param a0
   * @param a1
   */
  static angleDelta(a0, a1) {
    return _Utils.shortAngleDist(a0, a1);
  }
  /**
   * Get the "sweep" or short distance between two points on a circle's perimeter.
   * @param C
   * @param A
   * @param B
   */
  static getSweep(C, A, B) {
    return _Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B));
  }
  /**
   * Clamp radians within 0 and 2PI
   * @param r
   */
  static clampRadians(r) {
    return (Math.PI * 2 + r) % (Math.PI * 2);
  }
  /**
   * Clamp rotation to even segments.
   * @param r
   * @param segments
   */
  static snapAngleToSegments(r, segments) {
    const seg = Math.PI * 2 / segments;
    return Math.floor((_Utils.clampRadians(r) + seg / 2) / seg) * seg;
  }
  /**
   * Is angle c between angles a and b?
   * @param a
   * @param b
   * @param c
   */
  static isAngleBetween(a, b, c) {
    if (c === a || c === b)
      return true;
    const AB = (b - a + TAU) % TAU;
    const AC = (c - a + TAU) % TAU;
    return AB <= Math.PI !== AC > AB;
  }
  /**
   * Convert degrees to radians.
   * @param d
   */
  static degreesToRadians(d) {
    return d * Math.PI / 180;
  }
  /**
   * Convert radians to degrees.
   * @param r
   */
  static radiansToDegrees(r) {
    return r * 180 / Math.PI;
  }
  /**
   * Get the length of an arc between two points on a circle's perimeter.
   * @param C
   * @param r
   * @param A
   * @param B
   */
  static getArcLength(C, r, A, B) {
    const sweep = _Utils.getSweep(C, A, B);
    return r * (2 * Math.PI) * (sweep / (2 * Math.PI));
  }
  static getSweepFlag(A, B, C) {
    const angleAC = Vec.angle(A, C);
    const angleAB = Vec.angle(A, B);
    const angleCAB = (angleAB - angleAC + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return angleCAB > 0 ? 0 : 1;
  }
  static getLargeArcFlag(A, C, P) {
    const anglePA = Vec.angle(P, A);
    const anglePC = Vec.angle(P, C);
    const angleAPC = (anglePC - anglePA + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(angleAPC) > Math.PI / 2 ? 0 : 1;
  }
  /**
   * Get a dash offset for an arc, based on its length.
   * @param C
   * @param r
   * @param A
   * @param B
   * @param step
   */
  static getArcDashOffset(C, r, A, B, step) {
    const del0 = _Utils.getSweepFlag(C, A, B);
    const len0 = _Utils.getArcLength(C, r, A, B);
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0;
    return -off0 / 2 + step;
  }
  /**
   * Get a dash offset for an ellipse, based on its length.
   * @param A
   * @param step
   */
  static getEllipseDashOffset(A, step) {
    const c = 2 * Math.PI * A[2];
    return -c / 2 + -step;
  }
  /* -------------------- Hit Tests ------------------- */
  /**
   * Get whether a point is inside of a circle.
   * @param A
   * @param b
   * @returns
   */
  static pointInCircle(A, C, r) {
    return Vec.dist(A, C) <= r;
  }
  /**
   * Get whether a point is inside of an ellipse.
   * @param point
   * @param center
   * @param rx
   * @param ry
   * @param rotation
   * @returns
   */
  static pointInEllipse(A, C, rx, ry, rotation = 0) {
    rotation = rotation || 0;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const delta = Vec.sub(A, C);
    const tdx = cos * delta[0] + sin * delta[1];
    const tdy = sin * delta[0] - cos * delta[1];
    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;
  }
  /**
   * Get whether a point is inside of a rectangle.
   * @param point
   * @param size
   */
  static pointInRect(point, size) {
    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);
  }
  static pointInPolygon(p, points2) {
    let wn = 0;
    points2.forEach((a, i) => {
      const b = points2[(i + 1) % points2.length];
      if (a[1] <= p[1]) {
        if (b[1] > p[1] && Vec.cross(a, b, p) > 0) {
          wn += 1;
        }
      } else if (b[1] <= p[1] && Vec.cross(a, b, p) < 0) {
        wn -= 1;
      }
    });
    return wn !== 0;
  }
  /**
   * Get whether a point is inside of a bounds.
   * @param A The point to check.
   * @param b The bounds to check.
   * @returns
   */
  static pointInBounds(A, b) {
    return !(A[0] < b.minX || A[0] > b.maxX || A[1] < b.minY || A[1] > b.maxY);
  }
  /**
   * Hit test a point and a polyline using a minimum distance.
   * @param A The point to check.
   * @param points The points that make up the polyline.
   * @param distance (optional) The minimum distance that qualifies a hit.
   */
  static pointInPolyline(A, points2, distance2 = 3) {
    for (let i = 1; i < points2.length; i++) {
      if (Vec.distanceToLineSegment(points2[i - 1], points2[i], A) < distance2) {
        return true;
      }
    }
    return false;
  }
  /* --------------------- Bounds --------------------- */
  static getBoundsSides(bounds) {
    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);
  }
  /**
   * Expand a bounding box by a delta.
   *
   * ### Example
   *
   *```ts
   * expandBounds(myBounds, [100, 100])
   *```
   */
  static expandBounds(bounds, delta) {
    return {
      minX: bounds.minX - delta,
      minY: bounds.minY - delta,
      maxX: bounds.maxX + delta,
      maxY: bounds.maxY + delta,
      width: bounds.width + delta * 2,
      height: bounds.height + delta * 2
    };
  }
  /**
   * Get whether two bounds collide.
   * @param a Bounds
   * @param b Bounds
   * @returns
   */
  static boundsCollide(a, b) {
    return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY);
  }
  /**
   * Get whether the bounds of A contain the bounds of B. A perfect match will return true.
   * @param a Bounds
   * @param b Bounds
   * @returns
   */
  static boundsContain(a, b) {
    return a.minX < b.minX && a.minY < b.minY && a.maxY > b.maxY && a.maxX > b.maxX;
  }
  /**
   * Get whether the bounds of A are contained by the bounds of B.
   * @param a Bounds
   * @param b Bounds
   * @returns
   */
  static boundsContained(a, b) {
    return _Utils.boundsContain(b, a);
  }
  /**
   * Get whether two bounds are identical.
   * @param a Bounds
   * @param b Bounds
   * @returns
   */
  static boundsAreEqual(a, b) {
    return !(b.maxX !== a.maxX || b.minX !== a.minX || b.maxY !== a.maxY || b.minY !== a.minY);
  }
  /**
   * Find a bounding box from an array of points.
   * @param points
   * @param rotation (optional) The bounding box's rotation.
   */
  static getBoundsFromPoints(points2, rotation = 0) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if (points2.length < 2) {
      minX = 0;
      minY = 0;
      maxX = 1;
      maxY = 1;
    } else {
      for (const [x, y] of points2) {
        minX = Math.min(x, minX);
        minY = Math.min(y, minY);
        maxX = Math.max(x, maxX);
        maxY = Math.max(y, maxY);
      }
    }
    if (rotation !== 0) {
      return _Utils.getBoundsFromPoints(points2.map((pt) => Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation)));
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  /**
   * Center a bounding box around a given point.
   * @param bounds
   * @param center
   */
  static centerBounds(bounds, point) {
    const boundsCenter = this.getBoundsCenter(bounds);
    const dx = point[0] - boundsCenter[0];
    const dy = point[1] - boundsCenter[1];
    return this.translateBounds(bounds, [dx, dy]);
  }
  /**
   * Snap a bounding box to a grid size.
   * @param bounds
   * @param gridSize
   */
  static snapBoundsToGrid(bounds, gridSize) {
    const minX = Math.round(bounds.minX / gridSize) * gridSize;
    const minY = Math.round(bounds.minY / gridSize) * gridSize;
    const maxX = Math.round(bounds.maxX / gridSize) * gridSize;
    const maxY = Math.round(bounds.maxY / gridSize) * gridSize;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  /**
   * Move a bounding box without recalculating it.
   * @param bounds
   * @param delta
   * @returns
   */
  static translateBounds(bounds, delta) {
    return {
      minX: bounds.minX + delta[0],
      minY: bounds.minY + delta[1],
      maxX: bounds.maxX + delta[0],
      maxY: bounds.maxY + delta[1],
      width: bounds.width,
      height: bounds.height
    };
  }
  /**
   * Rotate a bounding box.
   * @param bounds
   * @param center
   * @param rotation
   */
  static rotateBounds(bounds, center, rotation) {
    const [minX, minY] = Vec.rotWith([bounds.minX, bounds.minY], center, rotation);
    const [maxX, maxY] = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation);
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: bounds.width,
      height: bounds.height
    };
  }
  /**
   * Get the rotated bounds of an ellipse.
   * @param x
   * @param y
   * @param rx
   * @param ry
   * @param rotation
   */
  static getRotatedEllipseBounds(x, y, rx, ry, rotation = 0) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    const w = Math.hypot(rx * c, ry * s);
    const h = Math.hypot(rx * s, ry * c);
    return {
      minX: x + rx - w,
      minY: y + ry - h,
      maxX: x + rx + w,
      maxY: y + ry + h,
      width: w * 2,
      height: h * 2
    };
  }
  /**
   * Get a bounding box that includes two bounding boxes.
   * @param a Bounding box
   * @param b Bounding box
   * @returns
   */
  static getExpandedBounds(a, b) {
    const minX = Math.min(a.minX, b.minX);
    const minY = Math.min(a.minY, b.minY);
    const maxX = Math.max(a.maxX, b.maxX);
    const maxY = Math.max(a.maxY, b.maxY);
    const width = Math.abs(maxX - minX);
    const height = Math.abs(maxY - minY);
    return { minX, minY, maxX, maxY, width, height };
  }
  /**
   * Get the common bounds of a group of bounds.
   * @returns
   */
  static getCommonBounds(bounds) {
    if (bounds.length < 2)
      return bounds[0];
    let result = bounds[0];
    for (let i = 1; i < bounds.length; i++) {
      result = _Utils.getExpandedBounds(result, bounds[i]);
    }
    return result;
  }
  static getRotatedCorners(b, rotation = 0) {
    const center = [b.minX + b.width / 2, b.minY + b.height / 2];
    return [
      [b.minX, b.minY],
      [b.maxX, b.minY],
      [b.maxX, b.maxY],
      [b.minX, b.maxY]
    ].map((point) => Vec.rotWith(point, center, rotation));
  }
  static getTransformedBoundingBox(bounds, handle, delta, rotation = 0, isAspectRatioLocked = false) {
    const [ax0, ay0] = [bounds.minX, bounds.minY];
    const [ax1, ay1] = [bounds.maxX, bounds.maxY];
    let [bx0, by0] = [bounds.minX, bounds.minY];
    let [bx1, by1] = [bounds.maxX, bounds.maxY];
    if (handle === "center") {
      return {
        minX: bx0 + delta[0],
        minY: by0 + delta[1],
        maxX: bx1 + delta[0],
        maxY: by1 + delta[1],
        width: bx1 - bx0,
        height: by1 - by0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const [dx, dy] = Vec.rot(delta, -rotation);
    switch (handle) {
      case TLBoundsEdge.Top:
      case TLBoundsCorner.TopLeft:
      case TLBoundsCorner.TopRight: {
        by0 += dy;
        break;
      }
      case TLBoundsEdge.Bottom:
      case TLBoundsCorner.BottomLeft:
      case TLBoundsCorner.BottomRight: {
        by1 += dy;
        break;
      }
    }
    switch (handle) {
      case TLBoundsEdge.Left:
      case TLBoundsCorner.TopLeft:
      case TLBoundsCorner.BottomLeft: {
        bx0 += dx;
        break;
      }
      case TLBoundsEdge.Right:
      case TLBoundsCorner.TopRight:
      case TLBoundsCorner.BottomRight: {
        bx1 += dx;
        break;
      }
    }
    const aw = ax1 - ax0;
    const ah = ay1 - ay0;
    const scaleX = (bx1 - bx0) / aw;
    const scaleY = (by1 - by0) / ah;
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    const bw = Math.abs(bx1 - bx0);
    const bh = Math.abs(by1 - by0);
    if (isAspectRatioLocked) {
      const ar = aw / ah;
      const isTall = ar < bw / bh;
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);
      const th = bh * (scaleX < 0 ? 1 : -1) * ar;
      switch (handle) {
        case TLBoundsCorner.TopLeft: {
          if (isTall)
            by0 = by1 + tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case TLBoundsCorner.TopRight: {
          if (isTall)
            by0 = by1 + tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case TLBoundsCorner.BottomRight: {
          if (isTall)
            by1 = by0 - tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case TLBoundsCorner.BottomLeft: {
          if (isTall)
            by1 = by0 - tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case TLBoundsEdge.Bottom:
        case TLBoundsEdge.Top: {
          const m = (bx0 + bx1) / 2;
          const w = bh * ar;
          bx0 = m - w / 2;
          bx1 = m + w / 2;
          break;
        }
        case TLBoundsEdge.Left:
        case TLBoundsEdge.Right: {
          const m = (by0 + by1) / 2;
          const h = bw / ar;
          by0 = m - h / 2;
          by1 = m + h / 2;
          break;
        }
      }
    }
    if (rotation % (Math.PI * 2) !== 0) {
      let cv = [0, 0];
      const c0 = Vec.med([ax0, ay0], [ax1, ay1]);
      const c1 = Vec.med([bx0, by0], [bx1, by1]);
      switch (handle) {
        case TLBoundsCorner.TopLeft: {
          cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation));
          break;
        }
        case TLBoundsCorner.TopRight: {
          cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation));
          break;
        }
        case TLBoundsCorner.BottomRight: {
          cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation));
          break;
        }
        case TLBoundsCorner.BottomLeft: {
          cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation));
          break;
        }
        case TLBoundsEdge.Top: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Left: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Bottom: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation));
          break;
        }
        case TLBoundsEdge.Right: {
          cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation));
          break;
        }
      }
      [bx0, by0] = Vec.sub([bx0, by0], cv);
      [bx1, by1] = Vec.sub([bx1, by1], cv);
    }
    if (bx1 < bx0) {
      [bx1, bx0] = [bx0, bx1];
    }
    if (by1 < by0) {
      [by1, by0] = [by0, by1];
    }
    return {
      minX: bx0,
      minY: by0,
      maxX: bx1,
      maxY: by1,
      width: bx1 - bx0,
      height: by1 - by0,
      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),
      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)
    };
  }
  static getTransformAnchor(type, isFlippedX, isFlippedY) {
    let anchor = type;
    switch (type) {
      case TLBoundsCorner.TopLeft: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.BottomRight;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.TopRight;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.BottomLeft;
        } else {
          anchor = TLBoundsCorner.BottomRight;
        }
        break;
      }
      case TLBoundsCorner.TopRight: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.BottomLeft;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.TopLeft;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.BottomRight;
        } else {
          anchor = TLBoundsCorner.BottomLeft;
        }
        break;
      }
      case TLBoundsCorner.BottomRight: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.TopLeft;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.BottomLeft;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.TopRight;
        } else {
          anchor = TLBoundsCorner.TopLeft;
        }
        break;
      }
      case TLBoundsCorner.BottomLeft: {
        if (isFlippedX && isFlippedY) {
          anchor = TLBoundsCorner.TopRight;
        } else if (isFlippedX) {
          anchor = TLBoundsCorner.BottomRight;
        } else if (isFlippedY) {
          anchor = TLBoundsCorner.TopLeft;
        } else {
          anchor = TLBoundsCorner.TopRight;
        }
        break;
      }
    }
    return anchor;
  }
  /**
   * Get the relative bounds (usually a child) within a transformed bounding box.
   * @param bounds
   * @param initialBounds
   * @param initialShapeBounds
   * @param isFlippedX
   * @param isFlippedY
   */
  static getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {
    const nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;
    const ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;
    const nw = initialShapeBounds.width / initialBounds.width;
    const nh = initialShapeBounds.height / initialBounds.height;
    const minX = bounds.minX + bounds.width * nx;
    const minY = bounds.minY + bounds.height * ny;
    const width = bounds.width * nw;
    const height = bounds.height * nh;
    return {
      minX,
      minY,
      maxX: minX + width,
      maxY: minY + height,
      width,
      height
    };
  }
  /**
   * Get the size of a rotated box.
   * @param size : ;
   * @param rotation
   */
  static getRotatedSize(size, rotation) {
    const center = Vec.div(size, 2);
    const points2 = [[0, 0], [size[0], 0], size, [0, size[1]]].map((point) => Vec.rotWith(point, center, rotation));
    const bounds = _Utils.getBoundsFromPoints(points2);
    return [bounds.width, bounds.height];
  }
  /**
   * Get the center of a bounding box.
   * @param bounds
   */
  static getBoundsCenter(bounds) {
    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];
  }
  /**
   * Get a bounding box with a midX and midY.
   * @param bounds
   */
  static getBoundsWithCenter(bounds) {
    const center = _Utils.getBoundsCenter(bounds);
    return {
      ...bounds,
      midX: center[0],
      midY: center[1]
    };
  }
  /**
   * Given a set of points, get their common [minX, minY].
   * @param points
   */
  static getCommonTopLeft(points2) {
    const min3 = [Infinity, Infinity];
    points2.forEach((point) => {
      min3[0] = Math.min(min3[0], point[0]);
      min3[1] = Math.min(min3[1], point[1]);
    });
    return min3;
  }
  /**
   * Get a value from a cache (a WeakMap), filling the value if it is not present.
   *
   * ### Example
   *
   *```ts
   * getFromCache(boundsCache, shape, (cache) => cache.set(shape, "value"))
   *```
   */
  static getFromCache(cache2, item, getNext) {
    let value = cache2.get(item);
    if (value === void 0) {
      cache2.set(item, getNext());
      value = cache2.get(item);
      if (value === void 0) {
        throw Error("Cache did not include item!");
      }
    }
    return value;
  }
  /**
   * Get a unique string id.
   */
  static uniqueId(a = "") {
    return a ? (
      /* eslint-disable no-bitwise */
      ((Number(a) ^ Math.random() * 16) >> Number(a) / 4).toString(16)
    ) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, _Utils.uniqueId);
  }
  /**
   * Shuffle the contents of an array.
   * @param arr
   * @param offset
   */
  static rotateArray(arr, offset2) {
    return arr.map((_, i) => arr[(i + offset2) % arr.length]);
  }
  /**
   * Debounce a function.
   */
  static debounce(fn2, ms = 0) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn2.apply(args), ms);
    };
  }
  /**
   * Turn an array of points into a path of quadratic curves.
   *
   * @param points The points returned from perfect-freehand
   * @param closed Whether the stroke is closed
   */
  static getSvgPathFromStroke(points2, closed = true) {
    const len3 = points2.length;
    if (len3 < 4) {
      return ``;
    }
    let a = points2[0];
    let b = points2[1];
    const c = points2[2];
    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;
    for (let i = 2, max2 = len3 - 1; i < max2; i++) {
      a = points2[i];
      b = points2[i + 1];
      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
    }
    if (closed) {
      result += "Z";
    }
    return result;
  }
  /**
   * Turn an array of stroke points into a path of quadratic curves.
   * @param points - the stroke points returned from perfect-freehand
   */
  static getSvgPathFromStrokePoints(points2, closed = false) {
    const len3 = points2.length;
    if (len3 < 4) {
      return ``;
    }
    let a = points2[0].point;
    let b = points2[1].point;
    const c = points2[2].point;
    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;
    for (let i = 2, max2 = len3 - 1; i < max2; i++) {
      a = points2[i].point;
      b = points2[i + 1].point;
      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
    }
    if (closed) {
      result += "Z";
    }
    return result;
  }
  /* -------------------------------------------------- */
  /*                   Browser and DOM                  */
  /* -------------------------------------------------- */
  /**
   * Get balanced dash-strokearray and dash-strokeoffset properties for a path of a given length.
   * @param length The length of the path.
   * @param strokeWidth The shape's stroke-width property.
   * @param style The stroke's style: "dashed" or "dotted" (default "dashed").
   * @param snap An interval for dashes (e.g. 4 will produce arrays with 4, 8, 16, etc dashes).
   * @param outset Whether to outset the stroke (default false).
   * @param lengthRatio The ratio to apply to dashed lines (default 2).
   */
  static getPerfectDashProps(length2, strokeWidth, style, snap = 1, outset = true, lengthRatio = 2) {
    let dashLength;
    let strokeDashoffset;
    let ratio;
    if (style.toLowerCase() === "dashed") {
      dashLength = strokeWidth * lengthRatio;
      ratio = 1;
      strokeDashoffset = outset ? (dashLength / 2).toString() : "0";
    } else if (style.toLowerCase() === "dotted") {
      dashLength = strokeWidth / 100;
      ratio = 100;
      strokeDashoffset = "0";
    } else {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
    let dashes = Math.floor(length2 / dashLength / (2 * ratio));
    dashes -= dashes % snap;
    dashes = Math.max(dashes, 4);
    const gapLength = Math.max(dashLength, (length2 - dashes * dashLength) / (outset ? dashes : dashes - 1));
    return {
      strokeDasharray: [dashLength, gapLength].join(" "),
      strokeDashoffset
    };
  }
  static isMobileSafari() {
    if (typeof window === "undefined")
      return false;
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }
  // via https://github.com/bameyrick/throttle-typescript
  static throttle(func, limit) {
    let inThrottle;
    let lastResult;
    return function(...args) {
      if (!inThrottle) {
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
        lastResult = func(...args);
      }
      return lastResult;
    };
  }
  /**
   * Find whether the current display is a touch display.
   */
  // static isTouchDisplay(): boolean {
  //   return (
  //     'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
  //   )
  // }
  /**
   * Find whether the current device is a Mac / iOS / iPadOS.
   */
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  /**
   * Get whether an event is command (mac) or control (pc).
   * @param e
   */
  static metaKey(e) {
    return _Utils.isDarwin() ? e.metaKey : e.ctrlKey;
  }
  /**
   * Reversible pseudo hash.
   * @param str string
   */
  static lns(str) {
    const result = str.split("");
    result.push(...result.splice(0, Math.round(result.length / 5)));
    result.push(...result.splice(0, Math.round(result.length / 4)));
    result.push(...result.splice(0, Math.round(result.length / 3)));
    result.push(...result.splice(0, Math.round(result.length / 2)));
    return result.reverse().map((n) => +n ? +n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n : n).join("");
  }
};
Utils.getSnapPoints = (bounds, others, snapDistance) => {
  const A = { ...bounds };
  const offset2 = [0, 0];
  const snapLines = [];
  const snaps = {
    [SnapPoints.minX]: { id: SnapPoints.minX, isSnapped: false },
    [SnapPoints.midX]: { id: SnapPoints.midX, isSnapped: false },
    [SnapPoints.maxX]: { id: SnapPoints.maxX, isSnapped: false },
    [SnapPoints.minY]: { id: SnapPoints.minY, isSnapped: false },
    [SnapPoints.midY]: { id: SnapPoints.midY, isSnapped: false },
    [SnapPoints.maxY]: { id: SnapPoints.maxY, isSnapped: false }
  };
  const xs = [SnapPoints.midX, SnapPoints.minX, SnapPoints.maxX];
  const ys = [SnapPoints.midY, SnapPoints.minY, SnapPoints.maxY];
  const snapResults = others.map((B) => {
    const rx = xs.flatMap((f, i) => xs.map((t, k) => {
      const gap = A[f] - B[t];
      const distance2 = Math.abs(gap);
      return {
        f,
        t,
        gap,
        distance: distance2,
        isCareful: i === 0 || i + k === 3
      };
    }));
    const ry = ys.flatMap((f, i) => ys.map((t, k) => {
      const gap = A[f] - B[t];
      const distance2 = Math.abs(gap);
      return {
        f,
        t,
        gap,
        distance: distance2,
        isCareful: i === 0 || i + k === 3
      };
    }));
    return [B, rx, ry];
  });
  let gapX = Infinity;
  let gapY = Infinity;
  let minX = Infinity;
  let minY = Infinity;
  snapResults.forEach(([_, rx, ry]) => {
    rx.forEach((r) => {
      if (r.distance < snapDistance && r.distance < minX) {
        minX = r.distance;
        gapX = r.gap;
      }
    });
    ry.forEach((r) => {
      if (r.distance < snapDistance && r.distance < minY) {
        minY = r.distance;
        gapY = r.gap;
      }
    });
  });
  snapResults.forEach(([B, rx, ry]) => {
    if (gapX !== Infinity) {
      rx.forEach((r) => {
        if (Math.abs(r.gap - gapX) < 2) {
          snaps[r.f] = {
            ...snaps[r.f],
            isSnapped: true,
            to: B[r.t],
            B,
            distance: r.distance
          };
        }
      });
    }
    if (gapY !== Infinity) {
      ry.forEach((r) => {
        if (Math.abs(r.gap - gapY) < 2) {
          snaps[r.f] = {
            ...snaps[r.f],
            isSnapped: true,
            to: B[r.t],
            B,
            distance: r.distance
          };
        }
      });
    }
  });
  offset2[0] = gapX === Infinity ? 0 : gapX;
  offset2[1] = gapY === Infinity ? 0 : gapY;
  A.minX -= offset2[0];
  A.midX -= offset2[0];
  A.maxX -= offset2[0];
  A.minY -= offset2[1];
  A.midY -= offset2[1];
  A.maxY -= offset2[1];
  xs.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B } = snap;
    const x = A[id];
    snapLines.push(id === SnapPoints.minX ? [
      [x, A.midY],
      [x, B.minY],
      [x, B.maxY]
    ] : [
      [x, A.minY],
      [x, A.maxY],
      [x, B.minY],
      [x, B.maxY]
    ]);
  });
  ys.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B } = snap;
    const y = A[id];
    snapLines.push(id === SnapPoints.midY ? [
      [A.midX, y],
      [B.minX, y],
      [B.maxX, y]
    ] : [
      [A.minX, y],
      [A.maxX, y],
      [B.minX, y],
      [B.maxX, y]
    ]);
  });
  return { offset: offset2, snapLines };
};
Utils.deepMerge = (target, patch) => {
  const result = { ...target };
  const entries = Object.entries(patch);
  for (const [key, value] of entries)
    result[key] = value === Object(value) && !Array.isArray(value) ? Utils.deepMerge(result[key], value) : value;
  return result;
};
function average(a, b) {
  return (a + b) / 2;
}

// node_modules/@blocksuite/phasor/dist/utils/xywh.js
function serializeXYWH(x, y, w, h) {
  return `[${x},${y},${w},${h}]`;
}
function deserializeXYWH(xywh) {
  return JSON.parse(xywh);
}

// node_modules/@blocksuite/phasor/dist/utils/bound.js
var Bound = class _Bound {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  static from(arg1) {
    return new _Bound(arg1.x, arg1.y, arg1.w, arg1.h);
  }
  get center() {
    return new Point(this.x + this.w / 2, this.y + this.h / 2);
  }
  get minX() {
    return this.x;
  }
  get minY() {
    return this.y;
  }
  get maxX() {
    return this.x + this.w;
  }
  get maxY() {
    return this.y + this.h;
  }
  get tl() {
    return new Point(this.x, this.y);
  }
  get tr() {
    return new Point(this.x + this.w, this.y);
  }
  get bl() {
    return new Point(this.x, this.y + this.h);
  }
  get br() {
    return new Point(this.x + this.w, this.y + this.h);
  }
  intersectLine(sp, ep, infinite = false) {
    const rst = [];
    [
      [this.tl, this.tr],
      [this.tl, this.bl],
      [this.tr, this.br],
      [this.bl, this.br]
    ].forEach(([p1, p2]) => {
      const p = Line.intersect(sp, ep, p1, p2, infinite);
      if (p)
        rst.push(p);
    });
    return rst.length === 0 ? null : rst;
  }
  isIntersectWithBound(bound, epsilon = EPSILON) {
    return bound.maxX > this.minX - epsilon && bound.maxY > this.minY - epsilon && bound.minX < this.maxX + epsilon && bound.minY < this.maxY + epsilon;
  }
  serialize() {
    return serializeXYWH(this.x, this.y, this.w, this.h);
  }
  static deserialize(s) {
    const [x, y, w, h] = deserializeXYWH(s);
    return new _Bound(x, y, w, h);
  }
};
function getExpandedBound(a, b) {
  const minX = Math.min(a.x, b.x);
  const minY = Math.min(a.y, b.y);
  const maxX = Math.max(a.x + a.w, b.x + b.w);
  const maxY = Math.max(a.y + a.h, b.y + b.h);
  const width = Math.abs(maxX - minX);
  const height = Math.abs(maxY - minY);
  return {
    x: minX,
    y: minY,
    w: width,
    h: height
  };
}
function getCommonBound(bounds) {
  if (!bounds.length) {
    return null;
  }
  if (bounds.length === 1) {
    const { x, y, w, h } = bounds[0];
    return new Bound(x, y, w, h);
  }
  let result = bounds[0];
  for (let i = 1; i < bounds.length; i++) {
    result = getExpandedBound(result, bounds[i]);
  }
  return new Bound(result.x, result.y, result.w, result.h);
}
function contains3(a, b) {
  return a.x <= b.x && a.x + a.w >= b.x + b.w && a.y <= b.y && a.y + a.h >= b.y + b.h;
}
function getBoundFromPoints(points2) {
  const { minX, minY, width, height } = Utils.getBoundsFromPoints(points2);
  return new Bound(minX, minY, width, height);
}
function inflateBound(bound, delta) {
  const half = delta / 2;
  const newBound = new Bound(bound.x - half, bound.y - half, bound.w + delta, bound.h + delta);
  if (newBound.w <= 0 || newBound.h <= 0) {
    throw new Error("Invalid delta range or bound size.");
  }
  return newBound;
}
function transformPointsToNewBound(points2, oldBound, oldMargin, newBound, newMargin) {
  const wholeOldMargin = oldMargin * 2;
  const wholeNewMargin = newMargin * 2;
  const oldW = Math.max(oldBound.w - wholeOldMargin, 1);
  const oldH = Math.max(oldBound.h - wholeOldMargin, 1);
  const newW = Math.max(newBound.w - wholeNewMargin, 1);
  const newH = Math.max(newBound.h - wholeNewMargin, 1);
  const transformedPoints = points2.map((p) => {
    return {
      ...p,
      x: newW * ((p.x - oldMargin) / oldW) + newMargin,
      y: newH * ((p.y - oldMargin) / oldH) + newMargin
    };
  });
  return {
    points: transformedPoints,
    bound: new Bound(newBound.x, newBound.y, newW + wholeNewMargin, newH + wholeNewMargin)
  };
}

// node_modules/@blocksuite/phasor/dist/utils/hit-utils.js
function isPointIn(a, x, y) {
  return a.x <= x && x <= a.x + a.w && a.y <= y && y <= a.y + a.h;
}
function intersects(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// node_modules/@blocksuite/phasor/dist/elements/surface-element.js
var SurfaceElement = class {
  get display() {
    return this._display;
  }
  setDisplay(display) {
    var _a3, _b;
    this._display = display;
    (_a3 = this.renderer) == null ? void 0 : _a3.removeElement(this);
    (_b = this.renderer) == null ? void 0 : _b.addElement(this);
  }
  constructor(yMap, surface, data) {
    this.renderer = null;
    this.surface = null;
    this.computedValue = (v) => v;
    this._display = true;
    this._onMap = () => {
      var _a3, _b;
      (_a3 = this.renderer) == null ? void 0 : _a3.removeElement(this);
      (_b = this.renderer) == null ? void 0 : _b.addElement(this);
    };
    if (!yMap.doc) {
      throw new Error("yMap must be bound to a Y.Doc");
    }
    this.yMap = yMap;
    if (data) {
      for (const key in data) {
        this.yMap.set(key, data[key]);
      }
    }
    this.surface = surface;
  }
  get id() {
    const id = this.yMap.get("id");
    return id;
  }
  get index() {
    const index = this.yMap.get("index");
    return index;
  }
  get type() {
    const type = this.yMap.get("type");
    return type;
  }
  get xywh() {
    const xywh = this.yMap.get("xywh");
    return xywh;
  }
  get x() {
    const [x] = deserializeXYWH(this.xywh);
    return x;
  }
  get y() {
    const [, y] = deserializeXYWH(this.xywh);
    return y;
  }
  get w() {
    const [, , w] = deserializeXYWH(this.xywh);
    return w;
  }
  get h() {
    const [, , , h] = deserializeXYWH(this.xywh);
    return h;
  }
  get seed() {
    const seed = this.yMap.get("seed");
    return seed;
  }
  get minWidth() {
    return this.w;
  }
  get minHeight() {
    return this.h;
  }
  applyUpdate(updates) {
    for (const key in updates) {
      this.yMap.set(key, updates[key]);
    }
  }
  serialize() {
    return this.yMap.toJSON();
  }
  hitTest(x, y, options2) {
    return isPointIn(this, x, y);
  }
  mount(renderer) {
    this.renderer = renderer;
    this.renderer.addElement(this);
    this.yMap.observeDeep(this._onMap);
  }
  unmount() {
    var _a3;
    this.yMap.unobserveDeep(this._onMap);
    (_a3 = this.renderer) == null ? void 0 : _a3.removeElement(this);
    this.renderer = null;
  }
  render(ctx, rc) {
    return;
  }
};

// node_modules/@blocksuite/phasor/dist/elements/brush/brush-element.js
function getSolidStrokePoints(points2, lineWidth) {
  return getStroke(points2, {
    size: lineWidth,
    thinning: 0.6,
    streamline: 0.5,
    smoothing: 0.5,
    easing: (t) => Math.sin(t * Math.PI / 2),
    simulatePressure: true
  });
}
var BrushElement = class extends SurfaceElement {
  /* Brush mouse coords relative to left-top corner */
  get points() {
    const points2 = this.yMap.get("points");
    return points2;
  }
  get color() {
    const color = this.yMap.get("color");
    return color;
  }
  get lineWidth() {
    const lineWidth = this.yMap.get("lineWidth");
    return lineWidth;
  }
  render(ctx) {
    const stroke = getSolidStrokePoints(this.points, this.lineWidth);
    const commands = Utils.getSvgPathFromStroke(stroke);
    const path = new Path2D(commands);
    ctx.fillStyle = this.computedValue(this.color);
    ctx.fill(path);
  }
  applyUpdate(props) {
    const updates = { ...props };
    const { points: points2, xywh } = props;
    if (points2 == null ? void 0 : points2.length) {
      const lineWidth = this.lineWidth;
      const bound = getBoundFromPoints(points2);
      const boundWidthLineWidth = inflateBound(bound, lineWidth);
      const relativePoints = points2.map(([x, y]) => {
        return [x - boundWidthLineWidth.x, y - boundWidthLineWidth.y];
      });
      updates.points = relativePoints;
      updates.xywh = boundWidthLineWidth.serialize();
    }
    if (xywh) {
      const bound = Bound.deserialize(xywh);
      const { lineWidth } = this;
      const transformed = transformPointsToNewBound(this.points.map(([x, y]) => ({ x, y })), this, lineWidth / 2, bound, lineWidth / 2);
      updates.points = transformed.points.map((p) => [p.x, p.y]);
      updates.xywh = transformed.bound.serialize();
    }
    if (props.lineWidth && props.lineWidth !== this.lineWidth) {
      const bound = updates.xywh ? Bound.deserialize(updates.xywh) : this;
      const points3 = updates.points ?? this.points;
      const transformed = transformPointsToNewBound(points3.map(([x, y]) => ({ x, y })), bound, this.lineWidth / 2, inflateBound(bound, props.lineWidth - this.lineWidth), props.lineWidth / 2);
      updates.points = transformed.points.map((p) => [p.x, p.y]);
      updates.xywh = transformed.bound.serialize();
    }
    for (const key in updates) {
      this.yMap.set(key, updates[key]);
    }
  }
};

// node_modules/@blocksuite/phasor/dist/elements/brush/constants.js
var BrushElementDefaultProps = {
  type: "brush",
  xywh: "[0,0,0,0]",
  points: [],
  color: "#000000",
  lineWidth: 4
};

// node_modules/@blocksuite/phasor/dist/elements/connector/utils.js
function getArrowPoints([startX, startY], [endX, endY], arrowSize = 10) {
  const dx = endX - startX;
  const dy = endY - startY;
  const angle = Math.atan2(dy, dx);
  const oneSide = [
    endX - arrowSize * Math.cos(angle - Math.PI / 10),
    endY - arrowSize * Math.sin(angle - Math.PI / 10)
  ];
  const anotherSide = [
    endX - arrowSize * Math.cos(angle + Math.PI / 10),
    endY - arrowSize * Math.sin(angle + Math.PI / 10)
  ];
  return {
    sides: [oneSide, anotherSide],
    start: [startX, startY],
    end: [endX, endY]
  };
}
function getConnectorPointsBound(controllers) {
  const last = controllers[controllers.length - 1];
  const secondToLast = controllers[controllers.length - 2];
  const arrowPoints = getArrowPoints([last.x, last.y], [secondToLast.x, secondToLast.y]);
  const points2 = arrowPoints.sides.concat(controllers.map((c) => [c.x, c.y]));
  return getBoundFromPoints(points2);
}

// node_modules/@blocksuite/phasor/dist/elements/connector/connector-element.js
var ConnectorElement = class extends SurfaceElement {
  get mode() {
    return this.yMap.get("mode");
  }
  get lineWidth() {
    return this.yMap.get("lineWidth");
  }
  get color() {
    return this.yMap.get("color");
  }
  get strokeStyle() {
    return this.yMap.get("strokeStyle");
  }
  get roughness() {
    return this.yMap.get("roughness") ?? 2;
  }
  get startElement() {
    return this.yMap.get("startElement");
  }
  get endElement() {
    return this.yMap.get("endElement");
  }
  get controllers() {
    return this.yMap.get("controllers");
  }
  render(ctx, rc) {
    const { seed, strokeStyle, color, roughness, lineWidth, controllers } = this;
    const realStrokeColor = this.computedValue(color);
    if (this.mode === ConnectorMode.Orthogonal) {
      rc.linearPath(controllers.map((controller) => [controller.x, controller.y]), {
        seed,
        roughness,
        strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
        stroke: realStrokeColor,
        strokeWidth: lineWidth
      });
    } else {
      rc.linearPath([
        [controllers[0].x, controllers[0].y],
        [
          controllers[controllers.length - 1].x,
          controllers[controllers.length - 1].y
        ]
      ], {
        seed,
        roughness,
        strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
        stroke: realStrokeColor,
        strokeWidth: lineWidth
      });
    }
    const last = this.controllers[this.controllers.length - 1];
    const secondToLast = this.controllers[this.controllers.length - 2];
    const { sides, end: end2 } = getArrowPoints([secondToLast.x, secondToLast.y], [last.x, last.y], 35);
    rc.linearPath([
      [sides[0][0], sides[0][1]],
      [end2[0], end2[1]],
      [sides[1][0], sides[1][1]]
    ], {
      seed,
      roughness,
      strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
      stroke: realStrokeColor,
      strokeWidth: lineWidth
    });
  }
  applyUpdate(props) {
    const updates = { ...props };
    const { controllers, xywh } = props;
    if (controllers == null ? void 0 : controllers.length) {
      const lineWidth = props.lineWidth ?? this.lineWidth;
      const bound = getConnectorPointsBound(controllers);
      const boundWidthLineWidth = inflateBound(bound, lineWidth);
      const relativeControllers = controllers.map((c) => {
        return {
          ...c,
          x: c.x - boundWidthLineWidth.x,
          y: c.y - boundWidthLineWidth.y
        };
      });
      updates.controllers = relativeControllers;
      updates.xywh = boundWidthLineWidth.serialize();
    }
    if (xywh) {
      const { lineWidth } = this;
      const bound = Bound.deserialize(xywh);
      const transformed = transformPointsToNewBound(this.controllers, this, lineWidth / 2, bound, lineWidth / 2);
      updates.controllers = transformed.points;
      updates.xywh = transformed.bound.serialize();
    }
    if (props.lineWidth && props.lineWidth !== this.lineWidth) {
      const bound = updates.xywh ? Bound.deserialize(updates.xywh) : this;
      const controllers2 = updates.controllers ?? this.controllers;
      const transformed = transformPointsToNewBound(controllers2, bound, this.lineWidth / 2, inflateBound(bound, props.lineWidth - this.lineWidth), props.lineWidth / 2);
      updates.controllers = transformed.points;
      updates.xywh = transformed.bound.serialize();
    }
    for (const key in updates) {
      this.yMap.set(key, updates[key]);
    }
  }
};

// node_modules/@blocksuite/phasor/dist/elements/connector/constants.js
var ConnectorElementDefaultProps = {
  type: "connector",
  xywh: "[0,0,0,0]",
  mode: ConnectorMode.Orthogonal,
  lineWidth: 4,
  color: "#000000",
  strokeStyle: StrokeStyle.Solid,
  roughness: 2,
  controllers: []
};

// node_modules/@blocksuite/phasor/dist/elements/debug/debug-element.js
var DebugElementDefaultProps = {
  type: "debug",
  xywh: "[0,0,0,0]",
  color: "#000000"
};
var DebugElement = class extends SurfaceElement {
  get color() {
    const color = this.yMap.get("color");
    return color;
  }
  render(ctx) {
    ctx.fillStyle = this.color;
    ctx.fillRect(0, 0, this.w, this.h);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/shape/constants.js
var ShapeElementDefaultProps = {
  type: "shape",
  xywh: "[0,0,0,0]",
  shapeType: "rect",
  radius: 0,
  filled: false,
  fillColor: "#ffffff",
  strokeWidth: 4,
  strokeColor: "#000000",
  strokeStyle: StrokeStyle.Solid,
  roughness: 2
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shapes/diamond.js
var DiamondMethods = {
  render(ctx, rc, element) {
    const { w, h, seed, strokeWidth, filled, realFillColor, realStrokeColor, strokeStyle, roughness } = element;
    const renderOffset = Math.max(strokeWidth, 0) / 2;
    const renderWidth = w - renderOffset * 2;
    const renderHeight = h - renderOffset * 2;
    ctx.translate(renderOffset, renderOffset);
    rc.polygon([
      [renderWidth / 2, 0],
      [renderWidth, renderHeight / 2],
      [renderWidth / 2, renderHeight],
      [0, renderHeight / 2]
    ], {
      seed,
      roughness,
      strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
      stroke: realStrokeColor,
      strokeWidth,
      fill: filled ? realFillColor : void 0
    });
  },
  hitTest(x, y, bound, options2) {
    const points2 = [
      [bound.x + bound.w / 2, bound.y + 0],
      [bound.x + bound.w, bound.y + bound.h / 2],
      [bound.x + bound.w / 2, bound.y + bound.h],
      [bound.x + 0, bound.y + bound.h / 2]
    ];
    return Utils.pointInPolygon([x, y], points2);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shapes/ellipse.js
var EllipseMethods = {
  render(ctx, rc, element) {
    const { w, h, seed, strokeWidth, filled, realFillColor, realStrokeColor, strokeStyle, roughness } = element;
    const renderOffset = Math.max(strokeWidth, 0) / 2;
    const renderWidth = Math.max(1, w - renderOffset * 2);
    const renderHeight = Math.max(1, h - renderOffset * 2);
    ctx.translate(renderOffset, renderOffset);
    rc.ellipse(renderWidth / 2, renderHeight / 2, renderWidth, renderHeight, {
      seed,
      roughness,
      strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
      stroke: realStrokeColor,
      strokeWidth,
      fill: filled ? realFillColor : void 0
    });
  },
  hitTest(x, y, bound, options2) {
    return Utils.pointInEllipse([x, y], [bound.x + bound.w / 2, bound.y + bound.h / 2], bound.w / 2, bound.h / 2);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shapes/rect.js
var kRect = 1 - 0.5522847498;
var RectMethods = {
  render(ctx, rc, element) {
    const { w, h, seed, strokeWidth, filled, realFillColor, realStrokeColor, radius, strokeStyle, roughness } = element;
    const renderOffset = Math.max(strokeWidth, 0) / 2;
    const renderWidth = w - renderOffset * 2;
    const renderHeight = h - renderOffset * 2;
    const r = Math.min(renderWidth * radius, renderHeight * radius);
    ctx.translate(renderOffset, renderOffset);
    rc.path(`
      M${r} 0
      L${renderWidth - r} 0
      C ${renderWidth - kRect * r} 0 ${renderWidth} ${kRect * r} ${renderWidth} ${r}
      L${renderWidth} ${renderHeight - r}
      C ${renderWidth} ${renderHeight - kRect * r} ${renderWidth - kRect * r} ${renderHeight} ${renderWidth - r} ${renderHeight}
      L${r} ${renderHeight}
      C ${kRect * r} ${renderHeight} 0 ${renderHeight - kRect * r} 0 ${renderHeight - r}
      L0 ${r}
      C 0 ${kRect * r} ${kRect * r} 0 ${r} 0
      Z
      `, {
      seed,
      roughness,
      strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
      stroke: realStrokeColor,
      strokeWidth,
      fill: filled ? realFillColor : void 0
    });
  },
  hitTest(x, y, bound, options2) {
    return isPointIn(bound, x, y);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shapes/triangle.js
var TriangleMethods = {
  render(ctx, rc, element) {
    const { w, h, seed, strokeWidth, filled, realFillColor, realStrokeColor, strokeStyle, roughness } = element;
    const renderOffset = Math.max(strokeWidth, 0) / 2;
    const renderWidth = w - renderOffset * 2;
    const renderHeight = h - renderOffset * 2;
    ctx.translate(renderOffset, renderOffset);
    rc.polygon([
      [renderWidth / 2, 0],
      [renderWidth, renderHeight],
      [0, renderHeight]
    ], {
      seed,
      roughness,
      strokeLineDash: strokeStyle === StrokeStyle.Dashed ? [12, 12] : void 0,
      stroke: realStrokeColor,
      strokeWidth,
      fill: filled ? realFillColor : void 0
    });
  },
  hitTest(x, y, bound, options2) {
    const points2 = [
      [bound.x + bound.w / 2, bound.y + 0],
      [bound.x + bound.w, bound.y + bound.h],
      [bound.x + 0, bound.y + bound.h]
    ];
    return Utils.pointInPolygon([x, y], points2);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shapes/index.js
var ShapeMethodsMap = {
  rect: RectMethods,
  triangle: TriangleMethods,
  ellipse: EllipseMethods,
  diamond: DiamondMethods
};

// node_modules/@blocksuite/phasor/dist/elements/shape/shape-element.js
var ShapeElement = class extends SurfaceElement {
  get shapeType() {
    const shapeType = this.yMap.get("shapeType");
    return shapeType;
  }
  get radius() {
    const radius = this.yMap.get("radius");
    return radius;
  }
  get filled() {
    const filled = this.yMap.get("filled");
    return filled;
  }
  get fillColor() {
    const fillColor = this.yMap.get("fillColor");
    return fillColor;
  }
  get strokeWidth() {
    const strokeWidth = this.yMap.get("strokeWidth");
    return strokeWidth;
  }
  get strokeColor() {
    const strokeColor = this.yMap.get("strokeColor");
    return strokeColor;
  }
  get strokeStyle() {
    const strokeStyle = this.yMap.get("strokeStyle");
    return strokeStyle;
  }
  get roughness() {
    const roughness = this.yMap.get("roughness") ?? 2;
    return roughness;
  }
  get realStrokeColor() {
    return this.computedValue(this.strokeColor);
  }
  get realFillColor() {
    return this.computedValue(this.fillColor);
  }
  hitTest(x, y, options2) {
    const { hitTest } = ShapeMethodsMap[this.shapeType];
    return hitTest(x, y, this, options2);
  }
  render(ctx, rc) {
    const { render: render2 } = ShapeMethodsMap[this.shapeType];
    render2(ctx, rc, this);
  }
};

// node_modules/@blocksuite/phasor/dist/elements/text/constants.js
var TextElementDefaultProps = {
  type: "text",
  xywh: "[0,0,0,0]",
  text: new YText(),
  color: "#000000",
  fontSize: 16,
  fontFamily: "'Kalam', cursive",
  textAlign: "center"
};

// node_modules/@blocksuite/phasor/dist/elements/text/utils.js
var RS_LTR_CHARS = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿Ⰰ-﬜﷾-﹯﻽-￿";
var RS_RTL_CHARS = "֑-߿יִ-﷽ﹰ-ﻼ";
var RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);
var isRTL = (text) => RE_RTL_CHECK.test(text);
var _a;
var isChrome = ((_a = globalThis.navigator) == null ? void 0 : _a.userAgent.indexOf("Chrome")) !== -1;
var _a2;
var isSafari = !isChrome && ((_a2 = globalThis.navigator) == null ? void 0 : _a2.userAgent.indexOf("Safari")) !== -1;
var getFontString = ({ fontSize, fontFamily, lineHeight }) => {
  return `${fontSize}px/${lineHeight} ${fontFamily}`;
};
function normalizeText(text) {
  return text.replace(/\t/g, "        ").replace(/\r?\n|\r/g, "\n");
}
var splitIntoLines = (text) => {
  return normalizeText(text).split("\n");
};
function getLineWidth(text, font) {
  const canvas = document.createElement("canvas");
  const canvas2dContext = canvas.getContext("2d");
  canvas2dContext.font = font;
  const width = canvas2dContext.measureText(text).width;
  return width;
}
function getTextWidth(text, font) {
  const lines = splitIntoLines(text);
  let width = 0;
  lines.forEach((line2) => {
    width = Math.max(width, getLineWidth(line2, font));
  });
  return width;
}
var charWidth = (() => {
  const cachedCharWidth = {};
  const calculate = (char, font) => {
    const ascii = char.charCodeAt(0);
    if (!cachedCharWidth[font]) {
      cachedCharWidth[font] = [];
    }
    if (!cachedCharWidth[font][ascii]) {
      const width = getLineWidth(char, font);
      cachedCharWidth[font][ascii] = width;
    }
    return cachedCharWidth[font][ascii];
  };
  const getCache = (font) => {
    return cachedCharWidth[font];
  };
  return {
    calculate,
    getCache
  };
})();
function transformDelta(delta) {
  const result = [];
  let tmpString = delta.insert;
  while (tmpString.length > 0) {
    const index = tmpString.indexOf("\n");
    if (index === -1) {
      result.push({
        insert: tmpString,
        attributes: delta.attributes
      });
      break;
    }
    if (tmpString.slice(0, index).length > 0) {
      result.push({
        insert: tmpString.slice(0, index),
        attributes: delta.attributes
      });
    }
    result.push("\n");
    tmpString = tmpString.slice(index + 1);
  }
  return result;
}
function deltaInsertsToChunks(delta) {
  if (delta.length === 0) {
    return [[]];
  }
  const transformedDelta = delta.flatMap(transformDelta);
  function* chunksGenerator(arr) {
    let start2 = 0;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === "\n") {
        const chunk = arr.slice(start2, i);
        start2 = i + 1;
        yield chunk;
      } else if (i === arr.length - 1) {
        yield arr.slice(start2);
      }
    }
    if (arr.at(-1) === "\n") {
      yield [];
    }
  }
  return [...chunksGenerator(transformedDelta)];
}

// node_modules/@blocksuite/phasor/dist/elements/text/text-element.js
var TextElement = class extends SurfaceElement {
  constructor() {
    super(...arguments);
    this._maxTextWidth = 0;
    this._maxTextHeight = 0;
    this._lineHeight = 0;
    this._lines = [];
  }
  get text() {
    return this.yMap.get("text");
  }
  get color() {
    return this.yMap.get("color");
  }
  get fontSize() {
    return this.yMap.get("fontSize");
  }
  get fontFamily() {
    return this.yMap.get("fontFamily");
  }
  get textAlign() {
    return this.yMap.get("textAlign");
  }
  get minWidth() {
    return this._maxTextWidth;
  }
  get minHeight() {
    return this._maxTextHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get lines() {
    return this._lines;
  }
  render(ctx) {
    const { w, text, color, fontSize, fontFamily, textAlign } = this;
    const yText = text;
    const deltas = yText.toDelta();
    const lines = deltaInsertsToChunks(deltas);
    this._lines = lines;
    const lineHeightPx = this.h / lines.length;
    const font = getFontString({
      fontSize,
      lineHeight: `${lineHeightPx}px`,
      fontFamily
    });
    this._lineHeight = lineHeightPx;
    const horizontalOffset = textAlign === "center" ? w / 2 : textAlign === "right" ? w : 0;
    for (const [lineIndex, line2] of lines.entries()) {
      let beforeTextWidth = 0;
      for (const delta of line2) {
        ctx.save();
        const str = delta.insert;
        const rtl = isRTL(str);
        const shouldTemporarilyAttach = rtl && !ctx.canvas.isConnected;
        if (shouldTemporarilyAttach) {
          document.body.appendChild(ctx.canvas);
        }
        ctx.canvas.setAttribute("dir", rtl ? "rtl" : "ltr");
        ctx.font = font;
        ctx.fillStyle = this.computedValue(color);
        ctx.textAlign = textAlign;
        ctx.textBaseline = "ideographic";
        ctx.fillText(str, horizontalOffset + beforeTextWidth, (lineIndex + 1) * lineHeightPx);
        beforeTextWidth += getTextWidth(str, fontFamily);
        if (shouldTemporarilyAttach) {
          ctx.canvas.remove();
        }
        ctx.restore();
      }
      if (beforeTextWidth > this._maxTextWidth) {
        this._maxTextWidth = beforeTextWidth;
      }
    }
    if (this._maxTextHeight < lines.length * lineHeightPx) {
      this._maxTextHeight = lines.length * lineHeightPx;
    }
  }
};

// node_modules/@blocksuite/phasor/dist/elements/index.js
var ElementCtors = {
  debug: DebugElement,
  brush: BrushElement,
  shape: ShapeElement,
  connector: ConnectorElement,
  text: TextElement
};
var ElementDefaultProps = {
  debug: DebugElementDefaultProps,
  brush: BrushElementDefaultProps,
  shape: ShapeElementDefaultProps,
  connector: ConnectorElementDefaultProps,
  text: TextElementDefaultProps
};

// node_modules/@blocksuite/phasor/dist/grid.js
function getGridIndex(val) {
  return Math.ceil(val / GRID_SIZE) - 1;
}
function rangeFromBound(a) {
  const minRow = getGridIndex(a.x);
  const maxRow = getGridIndex(a.x + a.w);
  const minCol = getGridIndex(a.y);
  const maxCol = getGridIndex(a.y + a.h);
  return [minRow, maxRow, minCol, maxCol];
}
function compare(a, b) {
  if (a.index < b.index)
    return -1;
  if (a.index > b.index)
    return 1;
  return 0;
}
var GridManager = class {
  constructor() {
    this._grids = /* @__PURE__ */ new Map();
    this._elementToGrids = /* @__PURE__ */ new Map();
  }
  _createGrid(row, col) {
    const id = row + "|" + col;
    const elements = /* @__PURE__ */ new Set();
    this._grids.set(id, elements);
    return elements;
  }
  _getGrid(row, col) {
    const id = row + "|" + col;
    return this._grids.get(id);
  }
  get isEmpty() {
    return this._grids.size === 0;
  }
  add(element) {
    const [minRow, maxRow, minCol, maxCol] = rangeFromBound(element);
    const grids = /* @__PURE__ */ new Set();
    this._elementToGrids.set(element, grids);
    for (let i = minRow; i <= maxRow; i++) {
      for (let j = minCol; j <= maxCol; j++) {
        let grid = this._getGrid(i, j);
        if (!grid) {
          grid = this._createGrid(i, j);
        }
        grid.add(element);
        grids.add(grid);
      }
    }
  }
  remove(element) {
    const grids = this._elementToGrids.get(element);
    assertExists(grids);
    for (const grid of grids) {
      grid.delete(element);
    }
  }
  boundHasChanged(a, b) {
    const [minRow, maxRow, minCol, maxCol] = rangeFromBound(a);
    const [minRow2, maxRow2, minCol2, maxCol2] = rangeFromBound(b);
    return minRow !== minRow2 || maxRow !== maxRow2 || minCol !== minCol2 || maxCol !== maxCol2;
  }
  search(bound) {
    const [minRow, maxRow, minCol, maxCol] = rangeFromBound(bound);
    const results = /* @__PURE__ */ new Set();
    for (let i = minRow; i <= maxRow; i++) {
      for (let j = minCol; j <= maxCol; j++) {
        const gridElements = this._getGrid(i, j);
        if (!gridElements)
          continue;
        for (const element of gridElements) {
          if (intersects(element, bound)) {
            results.add(element);
          }
        }
      }
    }
    const sorted = Array.from(results).sort(compare);
    return sorted;
  }
  pick(x, y) {
    const row = getGridIndex(x);
    const col = getGridIndex(y);
    const gridElements = this._getGrid(row, col);
    if (!gridElements)
      return [];
    const results = [];
    for (const element of gridElements) {
      if (isPointIn(element, x, y)) {
        results.push(element);
      }
    }
    return results;
  }
};

// node_modules/roughjs/bin/geometry.js
function rotatePoints(points2, center, degrees) {
  if (points2 && points2.length) {
    const [cx, cy] = center;
    const angle = Math.PI / 180 * degrees;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    points2.forEach((p) => {
      const [x, y] = p;
      p[0] = (x - cx) * cos - (y - cy) * sin + cx;
      p[1] = (x - cx) * sin + (y - cy) * cos + cy;
    });
  }
}
function rotateLines(lines, center, degrees) {
  const points2 = [];
  lines.forEach((line2) => points2.push(...line2));
  rotatePoints(points2, center, degrees);
}
function lineLength(line2) {
  const p1 = line2[0];
  const p2 = line2[1];
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}

// node_modules/roughjs/bin/fillers/scan-line-hachure.js
function polygonHachureLines(polygonList, o) {
  const angle = o.hachureAngle + 90;
  let gap = o.hachureGap;
  if (gap < 0) {
    gap = o.strokeWidth * 4;
  }
  gap = Math.max(gap, 0.1);
  const rotationCenter = [0, 0];
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, angle);
    }
  }
  const lines = straightHachureLines(polygonList, gap);
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, -angle);
    }
    rotateLines(lines, rotationCenter, -angle);
  }
  return lines;
}
function straightHachureLines(polygonList, gap) {
  const vertexArray = [];
  for (const polygon2 of polygonList) {
    const vertices = [...polygon2];
    if (vertices[0].join(",") !== vertices[vertices.length - 1].join(",")) {
      vertices.push([vertices[0][0], vertices[0][1]]);
    }
    if (vertices.length > 2) {
      vertexArray.push(vertices);
    }
  }
  const lines = [];
  gap = Math.max(gap, 0.1);
  const edges = [];
  for (const vertices of vertexArray) {
    for (let i = 0; i < vertices.length - 1; i++) {
      const p1 = vertices[i];
      const p2 = vertices[i + 1];
      if (p1[1] !== p2[1]) {
        const ymin = Math.min(p1[1], p2[1]);
        edges.push({
          ymin,
          ymax: Math.max(p1[1], p2[1]),
          x: ymin === p1[1] ? p1[0] : p2[0],
          islope: (p2[0] - p1[0]) / (p2[1] - p1[1])
        });
      }
    }
  }
  edges.sort((e1, e2) => {
    if (e1.ymin < e2.ymin) {
      return -1;
    }
    if (e1.ymin > e2.ymin) {
      return 1;
    }
    if (e1.x < e2.x) {
      return -1;
    }
    if (e1.x > e2.x) {
      return 1;
    }
    if (e1.ymax === e2.ymax) {
      return 0;
    }
    return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);
  });
  if (!edges.length) {
    return lines;
  }
  let activeEdges = [];
  let y = edges[0].ymin;
  while (activeEdges.length || edges.length) {
    if (edges.length) {
      let ix = -1;
      for (let i = 0; i < edges.length; i++) {
        if (edges[i].ymin > y) {
          break;
        }
        ix = i;
      }
      const removed = edges.splice(0, ix + 1);
      removed.forEach((edge) => {
        activeEdges.push({ s: y, edge });
      });
    }
    activeEdges = activeEdges.filter((ae) => {
      if (ae.edge.ymax <= y) {
        return false;
      }
      return true;
    });
    activeEdges.sort((ae1, ae2) => {
      if (ae1.edge.x === ae2.edge.x) {
        return 0;
      }
      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);
    });
    if (activeEdges.length > 1) {
      for (let i = 0; i < activeEdges.length; i = i + 2) {
        const nexti = i + 1;
        if (nexti >= activeEdges.length) {
          break;
        }
        const ce = activeEdges[i].edge;
        const ne = activeEdges[nexti].edge;
        lines.push([
          [Math.round(ce.x), y],
          [Math.round(ne.x), y]
        ]);
      }
    }
    y += gap;
    activeEdges.forEach((ae) => {
      ae.edge.x = ae.edge.x + gap * ae.edge.islope;
    });
  }
  return lines;
}

// node_modules/roughjs/bin/fillers/hachure-filler.js
var HachureFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o) {
    return this._fillPolygons(polygonList, o);
  }
  _fillPolygons(polygonList, o) {
    const lines = polygonHachureLines(polygonList, o);
    const ops = this.renderLines(lines, o);
    return { type: "fillSketch", ops };
  }
  renderLines(lines, o) {
    const ops = [];
    for (const line2 of lines) {
      ops.push(...this.helper.doubleLineOps(line2[0][0], line2[0][1], line2[1][0], line2[1][1], o));
    }
    return ops;
  }
};

// node_modules/roughjs/bin/fillers/zigzag-filler.js
var ZigZagFiller = class extends HachureFiller {
  fillPolygons(polygonList, o) {
    let gap = o.hachureGap;
    if (gap < 0) {
      gap = o.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    const o2 = Object.assign({}, o, { hachureGap: gap });
    const lines = polygonHachureLines(polygonList, o2);
    const zigZagAngle = Math.PI / 180 * o.hachureAngle;
    const zigzagLines = [];
    const dgx = gap * 0.5 * Math.cos(zigZagAngle);
    const dgy = gap * 0.5 * Math.sin(zigZagAngle);
    for (const [p1, p2] of lines) {
      if (lineLength([p1, p2])) {
        zigzagLines.push([
          [p1[0] - dgx, p1[1] + dgy],
          [...p2]
        ], [
          [p1[0] + dgx, p1[1] - dgy],
          [...p2]
        ]);
      }
    }
    const ops = this.renderLines(zigzagLines, o);
    return { type: "fillSketch", ops };
  }
};

// node_modules/roughjs/bin/fillers/hatch-filler.js
var HatchFiller = class extends HachureFiller {
  fillPolygons(polygonList, o) {
    const set = this._fillPolygons(polygonList, o);
    const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });
    const set2 = this._fillPolygons(polygonList, o2);
    set.ops = set.ops.concat(set2.ops);
    return set;
  }
};

// node_modules/roughjs/bin/fillers/dot-filler.js
var DotFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o) {
    o = Object.assign({}, o, { hachureAngle: 0 });
    const lines = polygonHachureLines(polygonList, o);
    return this.dotsOnLines(lines, o);
  }
  dotsOnLines(lines, o) {
    const ops = [];
    let gap = o.hachureGap;
    if (gap < 0) {
      gap = o.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    let fweight = o.fillWeight;
    if (fweight < 0) {
      fweight = o.strokeWidth / 2;
    }
    const ro = gap / 4;
    for (const line2 of lines) {
      const length2 = lineLength(line2);
      const dl = length2 / gap;
      const count = Math.ceil(dl) - 1;
      const offset2 = length2 - count * gap;
      const x = (line2[0][0] + line2[1][0]) / 2 - gap / 4;
      const minY = Math.min(line2[0][1], line2[1][1]);
      for (let i = 0; i < count; i++) {
        const y = minY + offset2 + i * gap;
        const cx = x - ro + Math.random() * 2 * ro;
        const cy = y - ro + Math.random() * 2 * ro;
        const el = this.helper.ellipse(cx, cy, fweight, fweight, o);
        ops.push(...el.ops);
      }
    }
    return { type: "fillSketch", ops };
  }
};

// node_modules/roughjs/bin/fillers/dashed-filler.js
var DashedFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o) {
    const lines = polygonHachureLines(polygonList, o);
    return { type: "fillSketch", ops: this.dashedLine(lines, o) };
  }
  dashedLine(lines, o) {
    const offset2 = o.dashOffset < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashOffset;
    const gap = o.dashGap < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashGap;
    const ops = [];
    lines.forEach((line2) => {
      const length2 = lineLength(line2);
      const count = Math.floor(length2 / (offset2 + gap));
      const startOffset = (length2 + gap - count * (offset2 + gap)) / 2;
      let p1 = line2[0];
      let p2 = line2[1];
      if (p1[0] > p2[0]) {
        p1 = line2[1];
        p2 = line2[0];
      }
      const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));
      for (let i = 0; i < count; i++) {
        const lstart = i * (offset2 + gap);
        const lend = lstart + offset2;
        const start2 = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        const end2 = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        ops.push(...this.helper.doubleLineOps(start2[0], start2[1], end2[0], end2[1], o));
      }
    });
    return ops;
  }
};

// node_modules/roughjs/bin/fillers/zigzag-line-filler.js
var ZigZagLineFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o) {
    const gap = o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap;
    const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;
    o = Object.assign({}, o, { hachureGap: gap + zo });
    const lines = polygonHachureLines(polygonList, o);
    return { type: "fillSketch", ops: this.zigzagLines(lines, zo, o) };
  }
  zigzagLines(lines, zo, o) {
    const ops = [];
    lines.forEach((line2) => {
      const length2 = lineLength(line2);
      const count = Math.round(length2 / (2 * zo));
      let p1 = line2[0];
      let p2 = line2[1];
      if (p1[0] > p2[0]) {
        p1 = line2[1];
        p2 = line2[0];
      }
      const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));
      for (let i = 0; i < count; i++) {
        const lstart = i * 2 * zo;
        const lend = (i + 1) * 2 * zo;
        const dz = Math.sqrt(2 * Math.pow(zo, 2));
        const start2 = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];
        const end2 = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];
        const middle = [start2[0] + dz * Math.cos(alpha + Math.PI / 4), start2[1] + dz * Math.sin(alpha + Math.PI / 4)];
        ops.push(...this.helper.doubleLineOps(start2[0], start2[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end2[0], end2[1], o));
      }
    });
    return ops;
  }
};

// node_modules/roughjs/bin/fillers/filler.js
var fillers = {};
function getFiller(o, helper2) {
  let fillerName = o.fillStyle || "hachure";
  if (!fillers[fillerName]) {
    switch (fillerName) {
      case "zigzag":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagFiller(helper2);
        }
        break;
      case "cross-hatch":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HatchFiller(helper2);
        }
        break;
      case "dots":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DotFiller(helper2);
        }
        break;
      case "dashed":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DashedFiller(helper2);
        }
        break;
      case "zigzag-line":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagLineFiller(helper2);
        }
        break;
      case "hachure":
      default:
        fillerName = "hachure";
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HachureFiller(helper2);
        }
        break;
    }
  }
  return fillers[fillerName];
}

// node_modules/roughjs/bin/math.js
function randomSeed() {
  return Math.floor(Math.random() * 2 ** 31);
}
var Random = class {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    if (this.seed) {
      return (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;
    } else {
      return Math.random();
    }
  }
};

// node_modules/path-data-parser/lib/parser.js
var COMMAND = 0;
var NUMBER = 1;
var EOD = 2;
var PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function tokenize(d) {
  const tokens = new Array();
  while (d !== "") {
    if (d.match(/^([ \t\r\n,]+)/)) {
      d = d.substr(RegExp.$1.length);
    } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
      tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };
      d = d.substr(RegExp.$1.length);
    } else if (d.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
      tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };
      d = d.substr(RegExp.$1.length);
    } else {
      return [];
    }
  }
  tokens[tokens.length] = { type: EOD, text: "" };
  return tokens;
}
function isType(token, type) {
  return token.type === type;
}
function parsePath(d) {
  const segments = [];
  const tokens = tokenize(d);
  let mode = "BOD";
  let index = 0;
  let token = tokens[index];
  while (!isType(token, EOD)) {
    let paramsCount = 0;
    const params = [];
    if (mode === "BOD") {
      if (token.text === "M" || token.text === "m") {
        index++;
        paramsCount = PARAMS[token.text];
        mode = token.text;
      } else {
        return parsePath("M0,0" + d);
      }
    } else if (isType(token, NUMBER)) {
      paramsCount = PARAMS[mode];
    } else {
      index++;
      paramsCount = PARAMS[token.text];
      mode = token.text;
    }
    if (index + paramsCount < tokens.length) {
      for (let i = index; i < index + paramsCount; i++) {
        const numbeToken = tokens[i];
        if (isType(numbeToken, NUMBER)) {
          params[params.length] = +numbeToken.text;
        } else {
          throw new Error("Param not a number: " + mode + "," + numbeToken.text);
        }
      }
      if (typeof PARAMS[mode] === "number") {
        const segment = { key: mode, data: params };
        segments.push(segment);
        index += paramsCount;
        token = tokens[index];
        if (mode === "M")
          mode = "L";
        if (mode === "m")
          mode = "l";
      } else {
        throw new Error("Bad segment: " + mode);
      }
    } else {
      throw new Error("Path data ended short");
    }
  }
  return segments;
}

// node_modules/path-data-parser/lib/absolutize.js
function absolutize(segments) {
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  const out = [];
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "m":
        cx += data[0];
        cy += data[1];
        out.push({ key: "M", data: [cx, cy] });
        subx = cx;
        suby = cy;
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "l":
        cx += data[0];
        cy += data[1];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        break;
      case "c": {
        const newdata = data.map((d, i) => i % 2 ? d + cy : d + cx);
        out.push({ key: "C", data: newdata });
        cx = newdata[4];
        cy = newdata[5];
        break;
      }
      case "Q":
        out.push({ key: "Q", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "q": {
        const newdata = data.map((d, i) => i % 2 ? d + cy : d + cx);
        out.push({ key: "Q", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "A":
        out.push({ key: "A", data: [...data] });
        cx = data[5];
        cy = data[6];
        break;
      case "a":
        cx += data[5];
        cy += data[6];
        out.push({ key: "A", data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });
        break;
      case "H":
        out.push({ key: "H", data: [...data] });
        cx = data[0];
        break;
      case "h":
        cx += data[0];
        out.push({ key: "H", data: [cx] });
        break;
      case "V":
        out.push({ key: "V", data: [...data] });
        cy = data[0];
        break;
      case "v":
        cy += data[0];
        out.push({ key: "V", data: [cy] });
        break;
      case "S":
        out.push({ key: "S", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "s": {
        const newdata = data.map((d, i) => i % 2 ? d + cy : d + cx);
        out.push({ key: "S", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "T":
        out.push({ key: "T", data: [...data] });
        cx = data[0];
        cy = data[1];
        break;
      case "t":
        cx += data[0];
        cy += data[1];
        out.push({ key: "T", data: [cx, cy] });
        break;
      case "Z":
      case "z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
  }
  return out;
}

// node_modules/path-data-parser/lib/normalize.js
function normalize(segments) {
  const out = [];
  let lastType = "";
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  let lcx = 0, lcy = 0;
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        lcx = data[2];
        lcy = data[3];
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "H":
        cx = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "V":
        cy = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "S": {
        let cx1 = 0, cy1 = 0;
        if (lastType === "C" || lastType === "S") {
          cx1 = cx + (cx - lcx);
          cy1 = cy + (cy - lcy);
        } else {
          cx1 = cx;
          cy1 = cy;
        }
        out.push({ key: "C", data: [cx1, cy1, ...data] });
        lcx = data[0];
        lcy = data[1];
        cx = data[2];
        cy = data[3];
        break;
      }
      case "T": {
        const [x, y] = data;
        let x1 = 0, y1 = 0;
        if (lastType === "Q" || lastType === "T") {
          x1 = cx + (cx - lcx);
          y1 = cy + (cy - lcy);
        } else {
          x1 = cx;
          y1 = cy;
        }
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x + 2 * (x1 - x) / 3;
        const cy2 = y + 2 * (y1 - y) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x, y] });
        lcx = x1;
        lcy = y1;
        cx = x;
        cy = y;
        break;
      }
      case "Q": {
        const [x1, y1, x, y] = data;
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x + 2 * (x1 - x) / 3;
        const cy2 = y + 2 * (y1 - y) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x, y] });
        lcx = x1;
        lcy = y1;
        cx = x;
        cy = y;
        break;
      }
      case "A": {
        const r1 = Math.abs(data[0]);
        const r2 = Math.abs(data[1]);
        const angle = data[2];
        const largeArcFlag = data[3];
        const sweepFlag = data[4];
        const x = data[5];
        const y = data[6];
        if (r1 === 0 || r2 === 0) {
          out.push({ key: "C", data: [cx, cy, x, y, x, y] });
          cx = x;
          cy = y;
        } else {
          if (cx !== x || cy !== y) {
            const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
            curves.forEach(function(curve2) {
              out.push({ key: "C", data: curve2 });
            });
            cx = x;
            cy = y;
          }
        }
        break;
      }
      case "Z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
    lastType = key;
  }
  return out;
}
function degToRad(degrees) {
  return Math.PI * degrees / 180;
}
function rotate(x, y, angleRad) {
  const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);
  const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);
  return [X, Y];
}
function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {
  const angleRad = degToRad(angle);
  let params = [];
  let f1 = 0, f2 = 0, cx = 0, cy = 0;
  if (recursive) {
    [f1, f2, cx, cy] = recursive;
  } else {
    [x1, y1] = rotate(x1, y1, -angleRad);
    [x2, y2] = rotate(x2, y2, -angleRad);
    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (r1 * r1) + y * y / (r2 * r2);
    if (h > 1) {
      h = Math.sqrt(h);
      r1 = h * r1;
      r2 = h * r2;
    }
    const sign = largeArcFlag === sweepFlag ? -1 : 1;
    const r1Pow = r1 * r1;
    const r2Pow = r2 * r2;
    const left2 = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;
    const right2 = r1Pow * y * y + r2Pow * x * x;
    const k = sign * Math.sqrt(Math.abs(left2 / right2));
    cx = k * r1 * y / r2 + (x1 + x2) / 2;
    cy = k * -r2 * x / r1 + (y1 + y2) / 2;
    f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));
    f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));
    if (x1 < cx) {
      f1 = Math.PI - f1;
    }
    if (x2 < cx) {
      f2 = Math.PI - f2;
    }
    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = Math.PI * 2 + f2;
    }
    if (sweepFlag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweepFlag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  }
  let df = f2 - f1;
  if (Math.abs(df) > Math.PI * 120 / 180) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    if (sweepFlag && f2 > f1) {
      f2 = f1 + Math.PI * 120 / 180 * 1;
    } else {
      f2 = f1 + Math.PI * 120 / 180 * -1;
    }
    x2 = cx + r1 * Math.cos(f2);
    y2 = cy + r2 * Math.sin(f2);
    params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * r1 * t;
  const hy = 4 / 3 * r2 * t;
  const m1 = [x1, y1];
  const m2 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x2 + hx * s2, y2 - hy * c2];
  const m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(params);
  } else {
    params = [m2, m3, m4].concat(params);
    const curves = [];
    for (let i = 0; i < params.length; i += 3) {
      const r12 = rotate(params[i][0], params[i][1], angleRad);
      const r22 = rotate(params[i + 1][0], params[i + 1][1], angleRad);
      const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);
      curves.push([r12[0], r12[1], r22[0], r22[1], r3[0], r3[1]]);
    }
    return curves;
  }
}

// node_modules/roughjs/bin/renderer.js
var helper = {
  randOffset,
  randOffsetWithRange,
  ellipse,
  doubleLineOps: doubleLineFillOps
};
function line(x1, y1, x2, y2, o) {
  return { type: "path", ops: _doubleLine(x1, y1, x2, y2, o) };
}
function linearPath(points2, close, o) {
  const len3 = (points2 || []).length;
  if (len3 > 2) {
    const ops = [];
    for (let i = 0; i < len3 - 1; i++) {
      ops.push(..._doubleLine(points2[i][0], points2[i][1], points2[i + 1][0], points2[i + 1][1], o));
    }
    if (close) {
      ops.push(..._doubleLine(points2[len3 - 1][0], points2[len3 - 1][1], points2[0][0], points2[0][1], o));
    }
    return { type: "path", ops };
  } else if (len3 === 2) {
    return line(points2[0][0], points2[0][1], points2[1][0], points2[1][1], o);
  }
  return { type: "path", ops: [] };
}
function polygon(points2, o) {
  return linearPath(points2, true, o);
}
function rectangle(x, y, width, height, o) {
  const points2 = [
    [x, y],
    [x + width, y],
    [x + width, y + height],
    [x, y + height]
  ];
  return polygon(points2, o);
}
function curve(points2, o) {
  let o1 = _curveWithOffset(points2, 1 * (1 + o.roughness * 0.2), o);
  if (!o.disableMultiStroke) {
    const o2 = _curveWithOffset(points2, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));
    o1 = o1.concat(o2);
  }
  return { type: "path", ops: o1 };
}
function ellipse(x, y, width, height, o) {
  const params = generateEllipseParams(width, height, o);
  return ellipseWithParams(x, y, o, params).opset;
}
function generateEllipseParams(width, height, o) {
  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));
  const stepCount = Math.ceil(Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq));
  const increment = Math.PI * 2 / stepCount;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  const curveFitRandomness = 1 - o.curveFitting;
  rx += _offsetOpt(rx * curveFitRandomness, o);
  ry += _offsetOpt(ry * curveFitRandomness, o);
  return { increment, rx, ry };
}
function ellipseWithParams(x, y, o, ellipseParams) {
  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);
  let o1 = _curve(ap1, null, o);
  if (!o.disableMultiStroke && o.roughness !== 0) {
    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);
    const o2 = _curve(ap2, null, o);
    o1 = o1.concat(o2);
  }
  return {
    estimatedPoints: cp1,
    opset: { type: "path", ops: o1 }
  };
}
function arc(x, y, width, height, start2, stop, closed, roughClosure, o) {
  const cx = x;
  const cy = y;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o);
  ry += _offsetOpt(ry * 0.01, o);
  let strt = start2;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const ellipseInc = Math.PI * 2 / o.curveStepCount;
  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);
  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);
  if (!o.disableMultiStroke) {
    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);
    ops.push(...o2);
  }
  if (closed) {
    if (roughClosure) {
      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));
    } else {
      ops.push({ op: "lineTo", data: [cx, cy] }, { op: "lineTo", data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });
    }
  }
  return { type: "path", ops };
}
function svgPath(path, o) {
  const segments = normalize(absolutize(parsePath(path)));
  const ops = [];
  let first = [0, 0];
  let current = [0, 0];
  for (const { key, data } of segments) {
    switch (key) {
      case "M": {
        const ro = 1 * (o.maxRandomnessOffset || 0);
        const pv = o.preserveVertices;
        ops.push({ op: "move", data: data.map((d) => d + (pv ? 0 : _offsetOpt(ro, o))) });
        current = [data[0], data[1]];
        first = [data[0], data[1]];
        break;
      }
      case "L":
        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));
        current = [data[0], data[1]];
        break;
      case "C": {
        const [x1, y1, x2, y2, x, y] = data;
        ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));
        current = [x, y];
        break;
      }
      case "Z":
        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));
        current = [first[0], first[1]];
        break;
    }
  }
  return { type: "path", ops };
}
function solidFillPolygon(polygonList, o) {
  const ops = [];
  for (const points2 of polygonList) {
    if (points2.length) {
      const offset2 = o.maxRandomnessOffset || 0;
      const len3 = points2.length;
      if (len3 > 2) {
        ops.push({ op: "move", data: [points2[0][0] + _offsetOpt(offset2, o), points2[0][1] + _offsetOpt(offset2, o)] });
        for (let i = 1; i < len3; i++) {
          ops.push({ op: "lineTo", data: [points2[i][0] + _offsetOpt(offset2, o), points2[i][1] + _offsetOpt(offset2, o)] });
        }
      }
    }
  }
  return { type: "fillPath", ops };
}
function patternFillPolygons(polygonList, o) {
  return getFiller(o, helper).fillPolygons(polygonList, o);
}
function patternFillArc(x, y, width, height, start2, stop, o) {
  const cx = x;
  const cy = y;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o);
  ry += _offsetOpt(ry * 0.01, o);
  let strt = start2;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const increment = (stp - strt) / o.curveStepCount;
  const points2 = [];
  for (let angle = strt; angle <= stp; angle = angle + increment) {
    points2.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);
  }
  points2.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
  points2.push([cx, cy]);
  return patternFillPolygons([points2], o);
}
function randOffset(x, o) {
  return _offsetOpt(x, o);
}
function randOffsetWithRange(min3, max2, o) {
  return _offset(min3, max2, o);
}
function doubleLineFillOps(x1, y1, x2, y2, o) {
  return _doubleLine(x1, y1, x2, y2, o, true);
}
function cloneOptionsAlterSeed(ops) {
  const result = Object.assign({}, ops);
  result.randomizer = void 0;
  if (ops.seed) {
    result.seed = ops.seed + 1;
  }
  return result;
}
function random(ops) {
  if (!ops.randomizer) {
    ops.randomizer = new Random(ops.seed || 0);
  }
  return ops.randomizer.next();
}
function _offset(min3, max2, ops, roughnessGain = 1) {
  return ops.roughness * roughnessGain * (random(ops) * (max2 - min3) + min3);
}
function _offsetOpt(x, ops, roughnessGain = 1) {
  return _offset(-x, x, ops, roughnessGain);
}
function _doubleLine(x1, y1, x2, y2, o, filling = false) {
  const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;
  const o1 = _line(x1, y1, x2, y2, o, true, false);
  if (singleStroke) {
    return o1;
  }
  const o2 = _line(x1, y1, x2, y2, o, true, true);
  return o1.concat(o2);
}
function _line(x1, y1, x2, y2, o, move, overlay) {
  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
  const length2 = Math.sqrt(lengthSq);
  let roughnessGain = 1;
  if (length2 < 200) {
    roughnessGain = 1;
  } else if (length2 > 500) {
    roughnessGain = 0.4;
  } else {
    roughnessGain = -16668e-7 * length2 + 1.233334;
  }
  let offset2 = o.maxRandomnessOffset || 0;
  if (offset2 * offset2 * 100 > lengthSq) {
    offset2 = length2 / 10;
  }
  const halfOffset = offset2 / 2;
  const divergePoint = 0.2 + random(o) * 0.2;
  let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;
  let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;
  midDispX = _offsetOpt(midDispX, o, roughnessGain);
  midDispY = _offsetOpt(midDispY, o, roughnessGain);
  const ops = [];
  const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);
  const randomFull = () => _offsetOpt(offset2, o, roughnessGain);
  const preserveVertices = o.preserveVertices;
  if (move) {
    if (overlay) {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : randomHalf()),
          y1 + (preserveVertices ? 0 : randomHalf())
        ]
      });
    } else {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : _offsetOpt(offset2, o, roughnessGain)),
          y1 + (preserveVertices ? 0 : _offsetOpt(offset2, o, roughnessGain))
        ]
      });
    }
  }
  if (overlay) {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),
        midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),
        x2 + (preserveVertices ? 0 : randomHalf()),
        y2 + (preserveVertices ? 0 : randomHalf())
      ]
    });
  } else {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),
        midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),
        midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),
        midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),
        x2 + (preserveVertices ? 0 : randomFull()),
        y2 + (preserveVertices ? 0 : randomFull())
      ]
    });
  }
  return ops;
}
function _curveWithOffset(points2, offset2, o) {
  const ps = [];
  ps.push([
    points2[0][0] + _offsetOpt(offset2, o),
    points2[0][1] + _offsetOpt(offset2, o)
  ]);
  ps.push([
    points2[0][0] + _offsetOpt(offset2, o),
    points2[0][1] + _offsetOpt(offset2, o)
  ]);
  for (let i = 1; i < points2.length; i++) {
    ps.push([
      points2[i][0] + _offsetOpt(offset2, o),
      points2[i][1] + _offsetOpt(offset2, o)
    ]);
    if (i === points2.length - 1) {
      ps.push([
        points2[i][0] + _offsetOpt(offset2, o),
        points2[i][1] + _offsetOpt(offset2, o)
      ]);
    }
  }
  return _curve(ps, null, o);
}
function _curve(points2, closePoint, o) {
  const len3 = points2.length;
  const ops = [];
  if (len3 > 3) {
    const b = [];
    const s = 1 - o.curveTightness;
    ops.push({ op: "move", data: [points2[1][0], points2[1][1]] });
    for (let i = 1; i + 2 < len3; i++) {
      const cachedVertArray = points2[i];
      b[0] = [cachedVertArray[0], cachedVertArray[1]];
      b[1] = [cachedVertArray[0] + (s * points2[i + 1][0] - s * points2[i - 1][0]) / 6, cachedVertArray[1] + (s * points2[i + 1][1] - s * points2[i - 1][1]) / 6];
      b[2] = [points2[i + 1][0] + (s * points2[i][0] - s * points2[i + 2][0]) / 6, points2[i + 1][1] + (s * points2[i][1] - s * points2[i + 2][1]) / 6];
      b[3] = [points2[i + 1][0], points2[i + 1][1]];
      ops.push({ op: "bcurveTo", data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });
    }
    if (closePoint && closePoint.length === 2) {
      const ro = o.maxRandomnessOffset;
      ops.push({ op: "lineTo", data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });
    }
  } else if (len3 === 3) {
    ops.push({ op: "move", data: [points2[1][0], points2[1][1]] });
    ops.push({
      op: "bcurveTo",
      data: [
        points2[1][0],
        points2[1][1],
        points2[2][0],
        points2[2][1],
        points2[2][0],
        points2[2][1]
      ]
    });
  } else if (len3 === 2) {
    ops.push(..._doubleLine(points2[0][0], points2[0][1], points2[1][0], points2[1][1], o));
  }
  return ops;
}
function _computeEllipsePoints(increment, cx, cy, rx, ry, offset2, overlap, o) {
  const coreOnly = o.roughness === 0;
  const corePoints = [];
  const allPoints = [];
  if (coreOnly) {
    increment = increment / 4;
    allPoints.push([
      cx + rx * Math.cos(-increment),
      cy + ry * Math.sin(-increment)
    ]);
    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {
      const p = [
        cx + rx * Math.cos(angle),
        cy + ry * Math.sin(angle)
      ];
      corePoints.push(p);
      allPoints.push(p);
    }
    allPoints.push([
      cx + rx * Math.cos(0),
      cy + ry * Math.sin(0)
    ]);
    allPoints.push([
      cx + rx * Math.cos(increment),
      cy + ry * Math.sin(increment)
    ]);
  } else {
    const radOffset = _offsetOpt(0.5, o) - Math.PI / 2;
    allPoints.push([
      _offsetOpt(offset2, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),
      _offsetOpt(offset2, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)
    ]);
    const endAngle = Math.PI * 2 + radOffset - 0.01;
    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {
      const p = [
        _offsetOpt(offset2, o) + cx + rx * Math.cos(angle),
        _offsetOpt(offset2, o) + cy + ry * Math.sin(angle)
      ];
      corePoints.push(p);
      allPoints.push(p);
    }
    allPoints.push([
      _offsetOpt(offset2, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),
      _offsetOpt(offset2, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),
      _offsetOpt(offset2, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),
      _offsetOpt(offset2, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)
    ]);
  }
  return [allPoints, corePoints];
}
function _arc(increment, cx, cy, rx, ry, strt, stp, offset2, o) {
  const radOffset = strt + _offsetOpt(0.1, o);
  const points2 = [];
  points2.push([
    _offsetOpt(offset2, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),
    _offsetOpt(offset2, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)
  ]);
  for (let angle = radOffset; angle <= stp; angle = angle + increment) {
    points2.push([
      _offsetOpt(offset2, o) + cx + rx * Math.cos(angle),
      _offsetOpt(offset2, o) + cy + ry * Math.sin(angle)
    ]);
  }
  points2.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  points2.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  return _curve(points2, null, o);
}
function _bezierTo(x1, y1, x2, y2, x, y, current, o) {
  const ops = [];
  const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
  let f = [0, 0];
  const iterations = o.disableMultiStroke ? 1 : 2;
  const preserveVertices = o.preserveVertices;
  for (let i = 0; i < iterations; i++) {
    if (i === 0) {
      ops.push({ op: "move", data: [current[0], current[1]] });
    } else {
      ops.push({ op: "move", data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });
    }
    f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];
    ops.push({
      op: "bcurveTo",
      data: [
        x1 + _offsetOpt(ros[i], o),
        y1 + _offsetOpt(ros[i], o),
        x2 + _offsetOpt(ros[i], o),
        y2 + _offsetOpt(ros[i], o),
        f[0],
        f[1]
      ]
    });
  }
  return ops;
}

// node_modules/points-on-curve/lib/curve-to-bezier.js
function clone(p) {
  return [...p];
}
function curveToBezier(pointsIn, curveTightness = 0) {
  const len3 = pointsIn.length;
  if (len3 < 3) {
    throw new Error("A curve must have at least three points.");
  }
  const out = [];
  if (len3 === 3) {
    out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));
  } else {
    const points2 = [];
    points2.push(pointsIn[0], pointsIn[0]);
    for (let i = 1; i < pointsIn.length; i++) {
      points2.push(pointsIn[i]);
      if (i === pointsIn.length - 1) {
        points2.push(pointsIn[i]);
      }
    }
    const b = [];
    const s = 1 - curveTightness;
    out.push(clone(points2[0]));
    for (let i = 1; i + 2 < points2.length; i++) {
      const cachedVertArray = points2[i];
      b[0] = [cachedVertArray[0], cachedVertArray[1]];
      b[1] = [cachedVertArray[0] + (s * points2[i + 1][0] - s * points2[i - 1][0]) / 6, cachedVertArray[1] + (s * points2[i + 1][1] - s * points2[i - 1][1]) / 6];
      b[2] = [points2[i + 1][0] + (s * points2[i][0] - s * points2[i + 2][0]) / 6, points2[i + 1][1] + (s * points2[i][1] - s * points2[i + 2][1]) / 6];
      b[3] = [points2[i + 1][0], points2[i + 1][1]];
      out.push(b[1], b[2], b[3]);
    }
  }
  return out;
}

// node_modules/points-on-curve/lib/index.js
function distance(p1, p2) {
  return Math.sqrt(distanceSq(p1, p2));
}
function distanceSq(p1, p2) {
  return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);
}
function distanceToSegmentSq(p, v, w) {
  const l2 = distanceSq(v, w);
  if (l2 === 0) {
    return distanceSq(p, v);
  }
  let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;
  t = Math.max(0, Math.min(1, t));
  return distanceSq(p, lerp(v, w, t));
}
function lerp(a, b, t) {
  return [
    a[0] + (b[0] - a[0]) * t,
    a[1] + (b[1] - a[1]) * t
  ];
}
function flatness(points2, offset2) {
  const p1 = points2[offset2 + 0];
  const p2 = points2[offset2 + 1];
  const p3 = points2[offset2 + 2];
  const p4 = points2[offset2 + 3];
  let ux = 3 * p2[0] - 2 * p1[0] - p4[0];
  ux *= ux;
  let uy = 3 * p2[1] - 2 * p1[1] - p4[1];
  uy *= uy;
  let vx = 3 * p3[0] - 2 * p4[0] - p1[0];
  vx *= vx;
  let vy = 3 * p3[1] - 2 * p4[1] - p1[1];
  vy *= vy;
  if (ux < vx) {
    ux = vx;
  }
  if (uy < vy) {
    uy = vy;
  }
  return ux + uy;
}
function getPointsOnBezierCurveWithSplitting(points2, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness(points2, offset2) < tolerance) {
    const p0 = points2[offset2 + 0];
    if (outPoints.length) {
      const d = distance(outPoints[outPoints.length - 1], p0);
      if (d > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points2[offset2 + 3]);
  } else {
    const t = 0.5;
    const p1 = points2[offset2 + 0];
    const p2 = points2[offset2 + 1];
    const p3 = points2[offset2 + 2];
    const p4 = points2[offset2 + 3];
    const q1 = lerp(p1, p2, t);
    const q2 = lerp(p2, p3, t);
    const q3 = lerp(p3, p4, t);
    const r1 = lerp(q1, q2, t);
    const r2 = lerp(q2, q3, t);
    const red = lerp(r1, r2, t);
    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify(points2, distance2) {
  return simplifyPoints(points2, 0, points2.length, distance2);
}
function simplifyPoints(points2, start2, end2, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s = points2[start2];
  const e = points2[end2 - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i = start2 + 1; i < end2 - 1; ++i) {
    const distSq = distanceToSegmentSq(points2[i], s, e);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints(points2, start2, maxNdx + 1, epsilon, outPoints);
    simplifyPoints(points2, maxNdx, end2, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s);
    }
    outPoints.push(e);
  }
  return outPoints;
}
function pointsOnBezierCurves(points2, tolerance = 0.15, distance2) {
  const newPoints = [];
  const numSegments = (points2.length - 1) / 3;
  for (let i = 0; i < numSegments; i++) {
    const offset2 = i * 3;
    getPointsOnBezierCurveWithSplitting(points2, offset2, tolerance, newPoints);
  }
  if (distance2 && distance2 > 0) {
    return simplifyPoints(newPoints, 0, newPoints.length, distance2);
  }
  return newPoints;
}

// node_modules/points-on-path/lib/index.js
function pointsOnPath(path, tolerance, distance2) {
  const segments = parsePath(path);
  const normalized = normalize(absolutize(segments));
  const sets = [];
  let currentPoints = [];
  let start2 = [0, 0];
  let pendingCurve = [];
  const appendPendingCurve = () => {
    if (pendingCurve.length >= 4) {
      currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));
    }
    pendingCurve = [];
  };
  const appendPendingPoints = () => {
    appendPendingCurve();
    if (currentPoints.length) {
      sets.push(currentPoints);
      currentPoints = [];
    }
  };
  for (const { key, data } of normalized) {
    switch (key) {
      case "M":
        appendPendingPoints();
        start2 = [data[0], data[1]];
        currentPoints.push(start2);
        break;
      case "L":
        appendPendingCurve();
        currentPoints.push([data[0], data[1]]);
        break;
      case "C":
        if (!pendingCurve.length) {
          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start2;
          pendingCurve.push([lastPoint[0], lastPoint[1]]);
        }
        pendingCurve.push([data[0], data[1]]);
        pendingCurve.push([data[2], data[3]]);
        pendingCurve.push([data[4], data[5]]);
        break;
      case "Z":
        appendPendingCurve();
        currentPoints.push([start2[0], start2[1]]);
        break;
    }
  }
  appendPendingPoints();
  if (!distance2) {
    return sets;
  }
  const out = [];
  for (const set of sets) {
    const simplifiedSet = simplify(set, distance2);
    if (simplifiedSet.length) {
      out.push(simplifiedSet);
    }
  }
  return out;
}

// node_modules/roughjs/bin/generator.js
var NOS = "none";
var RoughGenerator = class {
  constructor(config2) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: false,
      disableMultiStrokeFill: false,
      preserveVertices: false
    };
    this.config = config2 || {};
    if (this.config.options) {
      this.defaultOptions = this._o(this.config.options);
    }
  }
  static newSeed() {
    return randomSeed();
  }
  _o(options2) {
    return options2 ? Object.assign({}, this.defaultOptions, options2) : this.defaultOptions;
  }
  _d(shape, sets, options2) {
    return { shape, sets: sets || [], options: options2 || this.defaultOptions };
  }
  line(x1, y1, x2, y2, options2) {
    const o = this._o(options2);
    return this._d("line", [line(x1, y1, x2, y2, o)], o);
  }
  rectangle(x, y, width, height, options2) {
    const o = this._o(options2);
    const paths = [];
    const outline = rectangle(x, y, width, height, o);
    if (o.fill) {
      const points2 = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];
      if (o.fillStyle === "solid") {
        paths.push(solidFillPolygon([points2], o));
      } else {
        paths.push(patternFillPolygons([points2], o));
      }
    }
    if (o.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("rectangle", paths, o);
  }
  ellipse(x, y, width, height, options2) {
    const o = this._o(options2);
    const paths = [];
    const ellipseParams = generateEllipseParams(width, height, o);
    const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);
    if (o.fill) {
      if (o.fillStyle === "solid") {
        const shape = ellipseWithParams(x, y, o, ellipseParams).opset;
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));
      }
    }
    if (o.stroke !== NOS) {
      paths.push(ellipseResponse.opset);
    }
    return this._d("ellipse", paths, o);
  }
  circle(x, y, diameter, options2) {
    const ret = this.ellipse(x, y, diameter, diameter, options2);
    ret.shape = "circle";
    return ret;
  }
  linearPath(points2, options2) {
    const o = this._o(options2);
    return this._d("linearPath", [linearPath(points2, false, o)], o);
  }
  arc(x, y, width, height, start2, stop, closed = false, options2) {
    const o = this._o(options2);
    const paths = [];
    const outline = arc(x, y, width, height, start2, stop, closed, true, o);
    if (closed && o.fill) {
      if (o.fillStyle === "solid") {
        const fillOptions = Object.assign({}, o);
        fillOptions.disableMultiStroke = true;
        const shape = arc(x, y, width, height, start2, stop, true, false, fillOptions);
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillArc(x, y, width, height, start2, stop, o));
      }
    }
    if (o.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("arc", paths, o);
  }
  curve(points2, options2) {
    const o = this._o(options2);
    const paths = [];
    const outline = curve(points2, o);
    if (o.fill && o.fill !== NOS && points2.length >= 3) {
      const bcurve = curveToBezier(points2);
      const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);
      if (o.fillStyle === "solid") {
        paths.push(solidFillPolygon([polyPoints], o));
      } else {
        paths.push(patternFillPolygons([polyPoints], o));
      }
    }
    if (o.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("curve", paths, o);
  }
  polygon(points2, options2) {
    const o = this._o(options2);
    const paths = [];
    const outline = linearPath(points2, true, o);
    if (o.fill) {
      if (o.fillStyle === "solid") {
        paths.push(solidFillPolygon([points2], o));
      } else {
        paths.push(patternFillPolygons([points2], o));
      }
    }
    if (o.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("polygon", paths, o);
  }
  path(d, options2) {
    const o = this._o(options2);
    const paths = [];
    if (!d) {
      return this._d("path", paths, o);
    }
    d = (d || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const hasFill = o.fill && o.fill !== "transparent" && o.fill !== NOS;
    const hasStroke = o.stroke !== NOS;
    const simplified = !!(o.simplification && o.simplification < 1);
    const distance2 = simplified ? 4 - 4 * o.simplification : (1 + o.roughness) / 2;
    const sets = pointsOnPath(d, 1, distance2);
    if (hasFill) {
      if (o.fillStyle === "solid") {
        paths.push(solidFillPolygon(sets, o));
      } else {
        paths.push(patternFillPolygons(sets, o));
      }
    }
    if (hasStroke) {
      if (simplified) {
        sets.forEach((set) => {
          paths.push(linearPath(set, false, o));
        });
      } else {
        paths.push(svgPath(d, o));
      }
    }
    return this._d("path", paths, o);
  }
  opsToPath(drawing, fixedDecimals) {
    let path = "";
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d) => +d.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          path += `M${data[0]} ${data[1]} `;
          break;
        case "bcurveTo":
          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;
          break;
        case "lineTo":
          path += `L${data[0]} ${data[1]} `;
          break;
      }
    }
    return path.trim();
  }
  toPaths(drawable) {
    const sets = drawable.sets || [];
    const o = drawable.options || this.defaultOptions;
    const paths = [];
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path":
          path = {
            d: this.opsToPath(drawing),
            stroke: o.stroke,
            strokeWidth: o.strokeWidth,
            fill: NOS
          };
          break;
        case "fillPath":
          path = {
            d: this.opsToPath(drawing),
            stroke: NOS,
            strokeWidth: 0,
            fill: o.fill || NOS
          };
          break;
        case "fillSketch":
          path = this.fillSketch(drawing, o);
          break;
      }
      if (path) {
        paths.push(path);
      }
    }
    return paths;
  }
  fillSketch(drawing, o) {
    let fweight = o.fillWeight;
    if (fweight < 0) {
      fweight = o.strokeWidth / 2;
    }
    return {
      d: this.opsToPath(drawing),
      stroke: o.fill || NOS,
      strokeWidth: fweight,
      fill: NOS
    };
  }
};

// node_modules/roughjs/bin/canvas.js
var RoughCanvas = class {
  constructor(canvas, config2) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext("2d");
    this.gen = new RoughGenerator(config2);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o = drawable.options || this.getDefaultOptions();
    const ctx = this.ctx;
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      switch (drawing.type) {
        case "path":
          ctx.save();
          ctx.strokeStyle = o.stroke === "none" ? "transparent" : o.stroke;
          ctx.lineWidth = o.strokeWidth;
          if (o.strokeLineDash) {
            ctx.setLineDash(o.strokeLineDash);
          }
          if (o.strokeLineDashOffset) {
            ctx.lineDashOffset = o.strokeLineDashOffset;
          }
          this._drawToContext(ctx, drawing, precision);
          ctx.restore();
          break;
        case "fillPath": {
          ctx.save();
          ctx.fillStyle = o.fill || "";
          const fillRule = drawable.shape === "curve" || drawable.shape === "polygon" || drawable.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(ctx, drawing, precision, fillRule);
          ctx.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(ctx, drawing, o);
          break;
      }
    }
  }
  fillSketch(ctx, drawing, o) {
    let fweight = o.fillWeight;
    if (fweight < 0) {
      fweight = o.strokeWidth / 2;
    }
    ctx.save();
    if (o.fillLineDash) {
      ctx.setLineDash(o.fillLineDash);
    }
    if (o.fillLineDashOffset) {
      ctx.lineDashOffset = o.fillLineDashOffset;
    }
    ctx.strokeStyle = o.fill || "";
    ctx.lineWidth = fweight;
    this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);
    ctx.restore();
  }
  _drawToContext(ctx, drawing, fixedDecimals, rule = "nonzero") {
    ctx.beginPath();
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d) => +d.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          ctx.moveTo(data[0], data[1]);
          break;
        case "bcurveTo":
          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);
          break;
        case "lineTo":
          ctx.lineTo(data[0], data[1]);
          break;
      }
    }
    if (drawing.type === "fillPath") {
      ctx.fill(rule);
    } else {
      ctx.stroke();
    }
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(x1, y1, x2, y2, options2) {
    const d = this.gen.line(x1, y1, x2, y2, options2);
    this.draw(d);
    return d;
  }
  rectangle(x, y, width, height, options2) {
    const d = this.gen.rectangle(x, y, width, height, options2);
    this.draw(d);
    return d;
  }
  ellipse(x, y, width, height, options2) {
    const d = this.gen.ellipse(x, y, width, height, options2);
    this.draw(d);
    return d;
  }
  circle(x, y, diameter, options2) {
    const d = this.gen.circle(x, y, diameter, options2);
    this.draw(d);
    return d;
  }
  linearPath(points2, options2) {
    const d = this.gen.linearPath(points2, options2);
    this.draw(d);
    return d;
  }
  polygon(points2, options2) {
    const d = this.gen.polygon(points2, options2);
    this.draw(d);
    return d;
  }
  arc(x, y, width, height, start2, stop, closed = false, options2) {
    const d = this.gen.arc(x, y, width, height, start2, stop, closed, options2);
    this.draw(d);
    return d;
  }
  curve(points2, options2) {
    const d = this.gen.curve(points2, options2);
    this.draw(d);
    return d;
  }
  path(d, options2) {
    const drawing = this.gen.path(d, options2);
    this.draw(drawing);
    return drawing;
  }
};

// node_modules/@blocksuite/phasor/dist/renderer.js
var Renderer2 = class {
  constructor() {
    this.gridManager = new GridManager();
    this._left = 0;
    this._top = 0;
    this._width = 0;
    this._height = 0;
    this._zoom = 1;
    this._center = new Point();
    this._shouldUpdate = false;
    this.applyDeltaCenter = (deltaX, deltaY) => {
      this.setCenter(this.centerX + deltaX, this.centerY + deltaY);
    };
    const canvas = document.createElement("canvas");
    this.canvas = canvas;
    this.ctx = this.canvas.getContext("2d");
    this.rc = new RoughCanvas(canvas);
  }
  get left() {
    return this._left;
  }
  get top() {
    return this._top;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get zoom() {
    return this._zoom;
  }
  get centerX() {
    return this._center.x;
  }
  get centerY() {
    return this._center.y;
  }
  get center() {
    return this._center;
  }
  get viewportX() {
    const { centerX, width, zoom } = this;
    return centerX - width / 2 / zoom;
  }
  get viewportY() {
    const { centerY, height, zoom } = this;
    return centerY - height / 2 / zoom;
  }
  get viewportMinXY() {
    const { centerX, centerY, width, height, zoom } = this;
    return {
      x: centerX - width / 2 / zoom,
      y: centerY - height / 2 / zoom
    };
  }
  get viewportMaxXY() {
    const { centerX, centerY, width, height, zoom } = this;
    return {
      x: centerX + width / 2 / zoom,
      y: centerY + height / 2 / zoom
    };
  }
  get viewportBounds() {
    const { viewportMinXY, viewportMaxXY } = this;
    return {
      ...viewportMinXY,
      w: viewportMaxXY.x - viewportMinXY.x,
      h: viewportMaxXY.y - viewportMinXY.y
    };
  }
  toModelCoord(viewX, viewY) {
    const { viewportX, viewportY, zoom } = this;
    return [viewportX + viewX / zoom, viewportY + viewY / zoom];
  }
  toViewCoord(logicalX, logicalY) {
    const { viewportX, viewportY, zoom } = this;
    return [(logicalX - viewportX) * zoom, (logicalY - viewportY) * zoom];
  }
  setCenter(centerX, centerY) {
    this._center.set(centerX, centerY);
    this._shouldUpdate = true;
  }
  /**
   *
   * @param zoom zoom
   * @param focusPoint canvas coordinate
   */
  setZoom(zoom, focusPoint) {
    const prevZoom = this.zoom;
    focusPoint = focusPoint ?? this._center;
    this._zoom = clamp(zoom, ZOOM_MIN, ZOOM_MAX);
    const newZoom = this.zoom;
    const offset2 = this.center.subtract(focusPoint);
    const newCenter = focusPoint.add(offset2.scale(prevZoom / newZoom));
    this.setCenter(newCenter.x, newCenter.y);
    this._shouldUpdate = true;
  }
  addElement(element) {
    this.gridManager.add(element);
    this._shouldUpdate = true;
  }
  removeElement(element) {
    this.gridManager.remove(element);
    this._shouldUpdate = true;
  }
  load(elements) {
    for (let i = 0; i < elements.length; i++) {
      this.gridManager.add(elements[i]);
    }
    this._shouldUpdate = true;
  }
  refresh() {
    this._shouldUpdate = true;
  }
  attach(container) {
    assertNotExists(this._container, "Phasor surface is attached multiple times");
    this._container = container;
    container.appendChild(this.canvas);
    this._resetSize();
    this._loop();
  }
  onResize() {
    const oldWidth = this.width;
    const oldHeight = this.height;
    this._resetSize();
    this.setCenter(this.centerX - (oldWidth - this.width) / 2, this.centerY - (oldHeight - this.height) / 2);
    this._render();
    this._shouldUpdate = false;
  }
  _resetSize() {
    const { canvas } = this;
    const dpr2 = window.devicePixelRatio;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    const bbox = canvas.getBoundingClientRect();
    canvas.width = Math.ceil(bbox.width * dpr2);
    canvas.height = Math.ceil(bbox.height * dpr2);
    this._left = bbox.left;
    this._top = bbox.top;
    this._width = bbox.width;
    this._height = bbox.height;
    this._shouldUpdate = true;
  }
  _loop() {
    requestAnimationFrame(() => {
      if (this._shouldUpdate) {
        this._render();
      }
      this._shouldUpdate = false;
      this._loop();
    });
  }
  _render() {
    const { ctx, gridManager, viewportBounds, width, height, rc, zoom } = this;
    const dpr2 = window.devicePixelRatio;
    ctx.clearRect(0, 0, width * dpr2, height * dpr2);
    ctx.save();
    ctx.setTransform(zoom * dpr2, 0, 0, zoom * dpr2, 0, 0);
    const elements = gridManager.search(viewportBounds);
    for (const element of elements) {
      const dx = element.x - viewportBounds.x;
      const dy = element.y - viewportBounds.y;
      ctx.save();
      ctx.translate(dx, dy);
      if (intersects(element, viewportBounds) && element.display) {
        element.render(ctx, rc);
      }
      ctx.restore();
    }
    ctx.restore();
  }
};

// node_modules/fractional-indexing/src/index.js
var BASE_62_DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function midpoint(a, b, digits) {
  const zero = digits[0];
  if (b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a.slice(-1) === zero || b && b.slice(-1) === zero) {
    throw new Error("trailing zero");
  }
  if (b) {
    let n = 0;
    while ((a[n] || zero) === b[n]) {
      n++;
    }
    if (n > 0) {
      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);
    }
  }
  const digitA = a ? digits.indexOf(a[0]) : 0;
  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;
  if (digitB - digitA > 1) {
    const midDigit = Math.round(0.5 * (digitA + digitB));
    return digits[midDigit];
  } else {
    if (b && b.length > 1) {
      return b.slice(0, 1);
    } else {
      return digits[digitA] + midpoint(a.slice(1), null, digits);
    }
  }
}
function validateInteger(int) {
  if (int.length !== getIntegerLength(int[0])) {
    throw new Error("invalid integer part of order key: " + int);
  }
}
function getIntegerLength(head) {
  if (head >= "a" && head <= "z") {
    return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
  } else if (head >= "A" && head <= "Z") {
    return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
  } else {
    throw new Error("invalid order key head: " + head);
  }
}
function getIntegerPart(key) {
  const integerPartLength = getIntegerLength(key[0]);
  if (integerPartLength > key.length) {
    throw new Error("invalid order key: " + key);
  }
  return key.slice(0, integerPartLength);
}
function validateOrderKey(key, digits) {
  if (key === "A" + digits[0].repeat(26)) {
    throw new Error("invalid order key: " + key);
  }
  const i = getIntegerPart(key);
  const f = key.slice(i.length);
  if (f.slice(-1) === digits[0]) {
    throw new Error("invalid order key: " + key);
  }
}
function incrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let carry = true;
  for (let i = digs.length - 1; carry && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) + 1;
    if (d === digits.length) {
      digs[i] = digits[0];
    } else {
      digs[i] = digits[d];
      carry = false;
    }
  }
  if (carry) {
    if (head === "Z") {
      return "a" + digits[0];
    }
    if (head === "z") {
      return null;
    }
    const h = String.fromCharCode(head.charCodeAt(0) + 1);
    if (h > "a") {
      digs.push(digits[0]);
    } else {
      digs.pop();
    }
    return h + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function decrementInteger(x, digits) {
  validateInteger(x);
  const [head, ...digs] = x.split("");
  let borrow = true;
  for (let i = digs.length - 1; borrow && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) - 1;
    if (d === -1) {
      digs[i] = digits.slice(-1);
    } else {
      digs[i] = digits[d];
      borrow = false;
    }
  }
  if (borrow) {
    if (head === "a") {
      return "Z" + digits.slice(-1);
    }
    if (head === "A") {
      return null;
    }
    const h = String.fromCharCode(head.charCodeAt(0) - 1);
    if (h < "Z") {
      digs.push(digits.slice(-1));
    } else {
      digs.pop();
    }
    return h + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {
  if (a != null) {
    validateOrderKey(a, digits);
  }
  if (b != null) {
    validateOrderKey(b, digits);
  }
  if (a != null && b != null && a >= b) {
    throw new Error(a + " >= " + b);
  }
  if (a == null) {
    if (b == null) {
      return "a" + digits[0];
    }
    const ib2 = getIntegerPart(b);
    const fb2 = b.slice(ib2.length);
    if (ib2 === "A" + digits[0].repeat(26)) {
      return ib2 + midpoint("", fb2, digits);
    }
    if (ib2 < b) {
      return ib2;
    }
    const res = decrementInteger(ib2, digits);
    if (res == null) {
      throw new Error("cannot decrement any more");
    }
    return res;
  }
  if (b == null) {
    const ia2 = getIntegerPart(a);
    const fa2 = a.slice(ia2.length);
    const i2 = incrementInteger(ia2, digits);
    return i2 == null ? ia2 + midpoint(fa2, null, digits) : i2;
  }
  const ia = getIntegerPart(a);
  const fa = a.slice(ia.length);
  const ib = getIntegerPart(b);
  const fb = b.slice(ib.length);
  if (ia === ib) {
    return ia + midpoint(fa, fb, digits);
  }
  const i = incrementInteger(ia, digits);
  if (i == null) {
    throw new Error("cannot increment any more");
  }
  if (i < b) {
    return i;
  }
  return ia + midpoint(fa, null, digits);
}
function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {
  if (n === 0) {
    return [];
  }
  if (n === 1) {
    return [generateKeyBetween(a, b, digits)];
  }
  if (b == null) {
    let c2 = generateKeyBetween(a, b, digits);
    const result = [c2];
    for (let i = 0; i < n - 1; i++) {
      c2 = generateKeyBetween(c2, b, digits);
      result.push(c2);
    }
    return result;
  }
  if (a == null) {
    let c2 = generateKeyBetween(a, b, digits);
    const result = [c2];
    for (let i = 0; i < n - 1; i++) {
      c2 = generateKeyBetween(a, c2, digits);
      result.push(c2);
    }
    result.reverse();
    return result;
  }
  const mid = Math.floor(n / 2);
  const c = generateKeyBetween(a, b, digits);
  return [
    ...generateNKeysBetween(a, c, mid, digits),
    c,
    ...generateNKeysBetween(c, b, n - mid - 1, digits)
  ];
}

// node_modules/@blocksuite/phasor/dist/utils/std.js
function generateElementId() {
  return nanoid(10);
}
function normalizeWheelDeltaY(delta, zoom = 1) {
  const sign = Math.sign(delta);
  const abs = Math.abs(delta);
  const maxStep = ZOOM_STEP * 100;
  if (abs > maxStep) {
    delta = maxStep * sign;
  }
  let newZoom = zoom - delta / 100;
  newZoom += Math.log10(Math.max(1, zoom)) * -sign * // reduced amplification for small deltas (small movements on a trackpad)
  Math.min(1, abs / 20);
  return newZoom;
}

// node_modules/@blocksuite/phasor/dist/surface.js
var SurfaceManager = class {
  constructor(yContainer, computedValue = (v) => v) {
    this._elements = /* @__PURE__ */ new Map();
    this._bindings = /* @__PURE__ */ new Map();
    this.indexes = { min: "a0", max: "a0" };
    this._onYContainer = (event) => {
      if (event.changes.keys.size === 0)
        return;
      event.keysChanged.forEach((id) => {
        const type = event.changes.keys.get(id);
        if (!type) {
          console.error("invalid event", event);
          return;
        }
        if (type.action === "add") {
          const yElement = this._yContainer.get(id);
          const type2 = yElement.get("type");
          const ElementCtor = ElementCtors[type2];
          assertExists(ElementCtor);
          const element = new ElementCtor(yElement, this);
          element.computedValue = this._computedValue;
          element.mount(this._renderer);
          this._elements.set(element.id, element);
          if (element.index > this.indexes.max) {
            this.indexes.max = element.index;
          }
          this._updateBindings(element);
        } else if (type.action === "update") {
          console.error("update event on yElements is not supported", event);
        } else if (type.action === "delete") {
          const element = this._elements.get(id);
          assertExists(element);
          element.unmount();
          this._elements.delete(id);
          if (element.index === this.indexes.min) {
            this.indexes.min = generateKeyBetween(element.index, null);
          }
        }
      });
    };
    this._renderer = new Renderer2();
    this._yContainer = yContainer;
    this._computedValue = computedValue;
    this._syncFromExistingContainer();
    this._yContainer.observe(this._onYContainer);
  }
  get viewport() {
    return this._renderer;
  }
  _addBinding(id0, id1) {
    var _a3;
    if (!this._bindings.has(id0)) {
      this._bindings.set(id0, /* @__PURE__ */ new Set());
    }
    (_a3 = this._bindings.get(id0)) == null ? void 0 : _a3.add(id1);
  }
  _updateBindings(element) {
    if (element instanceof ConnectorElement) {
      if (element.startElement) {
        this._addBinding(element.startElement.id, element.id);
        this._addBinding(element.id, element.startElement.id);
      }
      if (element.endElement) {
        this._addBinding(element.endElement.id, element.id);
        this._addBinding(element.id, element.endElement.id);
      }
    }
  }
  _syncFromExistingContainer() {
    this._transact(() => {
      this._yContainer.forEach((yElement) => {
        const type = yElement.get("type");
        const ElementCtor = ElementCtors[type];
        assertExists(ElementCtor);
        const element = new ElementCtor(yElement, this);
        element.computedValue = this._computedValue;
        element.mount(this._renderer);
        this._elements.set(element.id, element);
        if (element.index > this.indexes.max) {
          this.indexes.max = element.index;
        } else if (element.index < this.indexes.min) {
          this.indexes.min = element.index;
        }
        this._updateBindings(element);
      });
    });
  }
  _transact(callback) {
    const doc = this._yContainer.doc;
    doc.transact(callback, doc.clientID);
  }
  refresh() {
    this._renderer.refresh();
  }
  updateIndexes(keys, elements, callback) {
    this._transact(() => {
      let newIndex;
      let i = 0;
      const len3 = elements.length;
      for (; i < len3; i++) {
        newIndex = keys[i];
        const yElement = this._yContainer.get(elements[i].id);
        const oldIndex = yElement.get("index");
        if (oldIndex === newIndex)
          continue;
        yElement.set("index", newIndex);
      }
      callback(keys);
    });
  }
  attach(container) {
    this._renderer.attach(container);
  }
  onResize() {
    this._renderer.onResize();
  }
  getElementsBound() {
    return getCommonBound([...this._elements.values()]);
  }
  addElement(type, properties) {
    const id = generateElementId();
    const yMap = new YMap();
    const defaultProps = ElementDefaultProps[type];
    const props = {
      ...defaultProps,
      ...properties,
      id,
      index: generateKeyBetween(this.indexes.max, null),
      seed: randomSeed()
    };
    this._transact(() => {
      for (const [key, value] of Object.entries(props)) {
        if (key === "text" && !(value instanceof YText)) {
          yMap.set(key, new YText(value));
        } else {
          yMap.set(key, value);
        }
      }
      this._yContainer.set(id, yMap);
    });
    return id;
  }
  updateElement(id, properties) {
    this._transact(() => {
      const element = this._elements.get(id);
      assertExists(element);
      element.applyUpdate(properties);
    });
  }
  setElementBound(id, bound) {
    this.updateElement(id, {
      xywh: serializeXYWH(bound.x, bound.y, bound.w, bound.h)
    });
  }
  removeElement(id) {
    this._transact(() => {
      this._yContainer.delete(id);
    });
  }
  hasElement(id) {
    return this._yContainer.has(id);
  }
  toModelCoord(viewX, viewY) {
    return this._renderer.toModelCoord(viewX, viewY);
  }
  toViewCoord(modelX, modelY) {
    return this._renderer.toViewCoord(modelX, modelY);
  }
  pickById(id) {
    return this._elements.get(id);
  }
  pickByPoint(x, y, options2) {
    const bound = { x: x - 1, y: y - 1, w: 2, h: 2 };
    const candidates = this._renderer.gridManager.search(bound);
    const picked = candidates.filter((element) => {
      return element.hitTest(x, y, options2);
    });
    return picked;
  }
  pickTop(x, y) {
    const results = this.pickByPoint(x, y);
    return results[results.length - 1] ?? null;
  }
  pickByBound(bound) {
    const candidates = this._renderer.gridManager.search(bound);
    const picked = candidates.filter((element) => {
      return contains3(bound, element) || intersects(bound, element);
    });
    return picked;
  }
  getSortedElementsWithViewportBounds() {
    return this.pickByBound(this.viewport.viewportBounds).sort(compare);
  }
  getBindingElements(id) {
    const bindingIds = this._bindings.get(id);
    if (!(bindingIds == null ? void 0 : bindingIds.size)) {
      return [];
    }
    return [...bindingIds.values()].map((bindingId) => this.pickById(bindingId)).filter((e) => !!e);
  }
  dispose() {
    this._yContainer.unobserve(this._onYContainer);
  }
  /** @internal Only for testing */
  initDefaultGestureHandler() {
    const { _renderer } = this;
    _renderer.canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      if (!e.ctrlKey) {
        const dx = e.deltaX / _renderer.zoom;
        const dy = e.deltaY / _renderer.zoom;
        _renderer.setCenter(_renderer.centerX + dx, _renderer.centerY + dy);
      } else {
        const zoom = normalizeWheelDeltaY(e.deltaY);
        _renderer.setZoom(zoom);
      }
    });
  }
  getElements() {
    return [...this._elements.values()];
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/edgeless-clipboard.js
var EdgelessClipboard = class {
  constructor(page, edgeless) {
    this._onCut = (e) => {
      if (!activeEditorManager.isActive(this._edgeless)) {
        return;
      }
      e.preventDefault();
      this._onCopy(e);
      const { state: state2 } = this.selection;
      if (state2.active) {
        deleteModelsByRange(this._page);
        return;
      }
      this._page.transact(() => {
        state2.selected.forEach((selected) => {
          if (isTopLevelBlock(selected)) {
            this._page.deleteBlock(selected);
          } else {
            this.surface.removeElement(selected.id);
          }
        });
      });
      this.slots.selectionUpdated.emit({ active: false, selected: [] });
    };
    this._onCopy = (e) => {
      if (!activeEditorManager.isActive(this._edgeless)) {
        return;
      }
      e.preventDefault();
      const { state: state2 } = this.selection;
      if (state2.active) {
        if (state2.selected[0] instanceof TextElement) {
          copySurfaceText(this._edgeless);
        } else {
          const range = getCurrentBlockRange(this._page);
          assertExists(range);
          copyBlocks(range);
        }
        return;
      }
      const data = state2.selected.map((selected) => {
        if (isTopLevelBlock(selected)) {
          return getBlockClipboardInfo(selected).json;
        } else {
          return selected.serialize();
        }
      }).filter((d) => !!d);
      const clipboardItems = createSurfaceClipboardItems(data);
      performNativeCopy(clipboardItems);
    };
    this._onPaste = async (e) => {
      if (!activeEditorManager.isActive(this._edgeless)) {
        return;
      }
      e.preventDefault();
      const { state: state2 } = this.selection;
      if (state2.active) {
        if (!(state2.selected[0] instanceof TextElement)) {
          this._pasteInTextFrame(e);
        }
        return;
      }
      const elementsRawData = getSurfaceClipboardData(e);
      if (!elementsRawData) {
        return;
      }
      this._pasteShapesAndFrames(elementsRawData);
    };
    this._page = page;
    this._edgeless = edgeless;
  }
  init(page = this._page) {
    this._page = page;
    document.body.addEventListener("cut", this._onCut);
    document.body.addEventListener("copy", this._onCopy);
    document.body.addEventListener("paste", this._onPaste);
  }
  get selection() {
    return this._edgeless.selection;
  }
  get slots() {
    return this._edgeless.slots;
  }
  get surface() {
    return this._edgeless.surface;
  }
  dispose() {
    document.body.removeEventListener("cut", this._onCut);
    document.body.removeEventListener("copy", this._onCopy);
    document.body.removeEventListener("paste", this._onPaste);
  }
  async _pasteInTextFrame(e) {
    const blocks = await clipboardData2Blocks(this._page, e.clipboardData);
    if (!blocks.length) {
      return;
    }
    this._page.captureSync();
    deleteModelsByRange(this._page);
    const range = getCurrentBlockRange(this._page);
    const focusedBlockModel = range == null ? void 0 : range.models[0];
    assertExists(focusedBlockModel);
    const service = getService(focusedBlockModel.flavour);
    assertExists(range);
    await service.json2Block(focusedBlockModel, blocks, range);
  }
  _createPhasorElements(elements) {
    const phasorElements = (elements == null ? void 0 : elements.map((d) => {
      const id = this.surface.addElement(d.type, d);
      const element = this.surface.pickById(id);
      return element;
    }).filter((e) => !!e)) || [];
    return phasorElements;
  }
  async _createFrameBlocks(frames, pasteX, pasteY, oldCommonBound) {
    const frameIds = await Promise.all(frames.map(async ({ xywh, children, background }) => {
      var _a3;
      const [oldX, oldY, oldW, oldH] = xywh ? deserializeXYWH(xywh) : [
        oldCommonBound.x,
        oldCommonBound.y,
        DEFAULT_FRAME_WIDTH,
        DEFAULT_FRAME_HEIGHT
      ];
      const newXywh = serializeXYWH(pasteX + oldX - oldCommonBound.x, pasteY + oldY - oldCommonBound.y, oldW, oldH);
      const frameId = this._page.addBlock("affine:frame", {
        xywh: newXywh,
        background
      }, (_a3 = this._page.root) == null ? void 0 : _a3.id);
      const frame = this._page.getBlockById(frameId);
      assertExists(frame);
      await addSerializedBlocks(this._page, children, frame, 0);
      return frameId;
    }));
    return frameIds;
  }
  _getOldCommonBound(phasorElements, frames) {
    const commonBound = getCommonBound([
      ...phasorElements,
      ...frames.map(({ xywh }) => {
        if (!xywh) {
          return;
        }
        const [x, y, w, h] = deserializeXYWH(xywh);
        return {
          x,
          y,
          w,
          h
        };
      }).filter((b) => !!b)
    ]);
    assertExists(commonBound);
    return commonBound;
  }
  _emitSelectionChangeAfterPaste(phasorElementIds, frameIds) {
    const newSelected = [
      ...phasorElementIds.map((id) => this.surface.pickById(id)).filter((e) => !!e),
      ...frameIds.map((id) => this._page.getBlockById(id)).filter((f) => !!f && f.flavour === "affine:frame")
    ];
    this.slots.selectionUpdated.emit({
      active: false,
      selected: newSelected
    });
  }
  async _pasteShapesAndFrames(elementsRawData) {
    const groupedByType = groupBy(elementsRawData, (data) => isTopLevelBlock(data) ? "frames" : "elements");
    const elements = this._createPhasorElements(groupedByType.elements || []);
    const oldCommonBound = this._getOldCommonBound(elements, groupedByType.frames || []);
    const { lastMousePos } = this.selection;
    const [modelX, modelY] = this.surface.toModelCoord(lastMousePos.x, lastMousePos.y);
    const pasteX = modelX - oldCommonBound.w / 2;
    const pasteY = modelY - oldCommonBound.h / 2;
    elements.forEach((ele) => {
      const newXYWH = serializeXYWH(pasteX + ele.x - oldCommonBound.x, pasteY + ele.y - oldCommonBound.y, ele.w, ele.h);
      this.surface.updateElement(ele.id, {
        xywh: newXYWH
      });
    });
    const frameIds = await this._createFrameBlocks(groupedByType.frames || [], pasteX, pasteY, oldCommonBound);
    this._emitSelectionChangeAfterPaste(elements.map((ele) => ele.id), frameIds);
  }
};

// node_modules/@blocksuite/blocks/dist/__internal__/clipboard/page-clipboard.js
var PageClipboard = class {
  constructor(pageEle) {
    this._onPaste = async (e) => {
      if (!activeEditorManager.isActive(this._ele)) {
        return;
      }
      const range = getCurrentBlockRange(this._page);
      if (!e.clipboardData || !range) {
        return;
      }
      e.preventDefault();
      const blocks = await clipboardData2Blocks(this._page, e.clipboardData);
      const normalizedBlocks = normalizePasteBlocks(this._page, blocks);
      if (!normalizedBlocks.length) {
        return;
      }
      this._page.captureSync();
      const focusedBlockModel = deleteModelsByRange(this._page, range);
      assertExists(focusedBlockModel);
      const service = getService(focusedBlockModel.flavour);
      assertExists(range);
      await service.json2Block(focusedBlockModel, normalizedBlocks, range);
      this._page.captureSync();
      this._page.slots.pasted.emit(blocks);
    };
    this._onCopy = (e, range = getCurrentBlockRange(this._page)) => {
      if (!activeEditorManager.isActive(this._ele)) {
        return;
      }
      if (!range) {
        return;
      }
      e.preventDefault();
      this._page.captureSync();
      copyBlocks(range);
      this._page.captureSync();
      this._page.slots.copied.emit();
    };
    this._onCut = (e) => {
      if (!activeEditorManager.isActive(this._ele)) {
        return;
      }
      const range = getCurrentBlockRange(this._page);
      if (!range) {
        return;
      }
      e.preventDefault();
      this._onCopy(e, range);
      deleteModelsByRange(this._page, range);
    };
    this._ele = pageEle;
  }
  init(page) {
    this._page = page;
    document.body.addEventListener("cut", this._onCut);
    document.body.addEventListener("copy", this._onCopy);
    document.body.addEventListener("paste", this._onPaste);
  }
  dispose() {
    document.body.removeEventListener("cut", this._onCut);
    document.body.removeEventListener("copy", this._onCopy);
    document.body.removeEventListener("paste", this._onPaste);
  }
};

// node_modules/@blocksuite/blocks/dist/bookmark-block/bookmark-model.js
var defaultBookmarkProps = {
  url: "",
  title: "",
  description: "",
  icon: "",
  image: "",
  caption: "",
  crawled: false
};
var BookmarkBlockSchema = defineBlockSchema({
  flavour: "affine:bookmark",
  props: (internal) => defaultBookmarkProps,
  metadata: {
    version: 1,
    role: "content",
    tag: literal`affine-bookmark`,
    parent: ["affine:frame"]
  }
});

// node_modules/@blocksuite/blocks/dist/bookmark-block/utils.js
async function reloadBookmarkBlock(model, bookmarkElement, force = false) {
  var _a3, _b;
  if ((_b = (_a3 = window == null ? void 0 : window.apis) == null ? void 0 : _a3.ui) == null ? void 0 : _b.getBookmarkDataByLink) {
    if ((model.crawled || !model.url) && !force) {
      return;
    }
    bookmarkElement.loading = true;
    const metaData = await window.apis.ui.getBookmarkDataByLink(model.url);
    if (!model.page.getBlockById(model.id)) {
      return;
    }
    model.page.withoutTransact(() => {
      model.page.updateBlock(model, {
        ...metaData,
        url: model.url,
        crawled: true
      });
    });
    bookmarkElement.loading = false;
  }
}
function cloneBookmarkProperties(model) {
  return Object.keys(defaultBookmarkProps).reduce((props, key) => {
    props[key] = model[key];
    return props;
  }, {});
}

// node_modules/@blocksuite/blocks/dist/bookmark-block/components/bookmark-operation-popper.js
var __decorate83 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function createBookmarkOperationMenu(reference2, props) {
  const menu = document.createElement("bookmark-operation-menu");
  menu.model = props.model;
  menu.onSelected = props.onSelected;
  reference2.appendChild(menu);
  const popper2 = createPopper3(reference2, menu, {
    placement: "top-start",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 6]
        }
      }
    ]
  });
  return {
    element: menu,
    dispose: () => {
      menu.remove();
      popper2.destroy();
    }
  };
}
var operations = [
  {
    type: "copy",
    icon: CopyIcon2,
    label: "Copy original link",
    action: (model, callback) => {
      copyBlocks({
        type: "Block",
        models: [model],
        startOffset: 0,
        endOffset: 0
      });
      toast("Copied link to clipboard");
      callback == null ? void 0 : callback("copy");
    }
  },
  {
    type: "duplicate",
    icon: DuplicateIcon2,
    label: "Duplicate",
    action: (model, callback) => {
      const { page } = model;
      const parent = page.getParent(model);
      const index = parent == null ? void 0 : parent.children.indexOf(model);
      const clonedProps = cloneBookmarkProperties(model);
      page.addBlock("affine:bookmark", clonedProps, parent, index);
      callback == null ? void 0 : callback("duplicate");
    }
  },
  {
    type: "reload",
    icon: RefreshIcon,
    label: "Reload",
    action: (model, callback) => {
      reloadBookmarkBlock(model, getBlockElementByModel(model), true);
      callback == null ? void 0 : callback("reload");
    }
  },
  {
    type: "delete",
    icon: DeleteIcon2,
    label: "Delete",
    action: (model, callback) => {
      model.page.deleteBlock(model);
      callback == null ? void 0 : callback("delete");
    }
  }
];
var BookmarkOperationMenu = class BookmarkOperationMenu2 extends WithDisposable(LitElement) {
  connectedCallback() {
    super.connectedCallback();
  }
  render() {
    const menuItems = repeat(operations, ({ type }) => type, ({ type, icon, label, action, divider }) => {
      return html`<icon-button
            width="130px"
            height="32px"
            class="menu-item ${type}"
            @click=${() => {
        action(this.model, this.onSelected, this);
      }}
          >
            ${icon} ${label}
          </icon-button>
          ${divider ? html`<div class="divider"></div>` : nothing} `;
    });
    return html` <div class="bookmark-operation-menu">${menuItems}</div> `;
  }
};
BookmarkOperationMenu.styles = css`
    .bookmark-operation-menu {
      border-radius: 8px 8px 8px 0;
      padding: 8px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
    }
    .menu-item {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      fill: var(--affine-icon-color);
      color: var(--affine-text-primary-color);
    }
    .menu-item:hover {
      background: var(--affine-hover-color);
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }
    .menu-item svg {
      margin: 0 8px;
    }
  `;
__decorate83([
  property()
], BookmarkOperationMenu.prototype, "model", void 0);
__decorate83([
  property()
], BookmarkOperationMenu.prototype, "root", void 0);
__decorate83([
  property()
], BookmarkOperationMenu.prototype, "onSelected", void 0);
__decorate83([
  query(".bookmark-bar")
], BookmarkOperationMenu.prototype, "formatQuickBarElement", void 0);
BookmarkOperationMenu = __decorate83([
  customElement("bookmark-operation-menu")
], BookmarkOperationMenu);

// node_modules/@blocksuite/blocks/dist/bookmark-block/components/bookmark-toolbar.js
var __decorate84 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var config = [
  {
    type: "link",
    icon: LinkIcon2,
    tooltip: "Turn into Link view",
    action: (model, callback) => {
      const { page } = model;
      const parent = page.getParent(model);
      const index = parent == null ? void 0 : parent.children.indexOf(model);
      const yText = new YText();
      const insert = model.title || model.caption || model.url;
      yText.insert(0, insert);
      yText.format(0, insert.length, { link: model.url });
      const text = new page.Text(yText);
      page.addBlock("affine:paragraph", {
        text
      }, parent, index);
      model.page.deleteBlock(model);
      callback == null ? void 0 : callback("link");
    },
    divider: true
  },
  {
    type: "caption",
    icon: CaptionIcon2,
    tooltip: "Add Caption",
    action: (model, callback) => {
      callback == null ? void 0 : callback("caption");
    }
  },
  {
    type: "edit",
    icon: EditIcon2,
    tooltip: "Edit",
    action: (model, callback) => {
      callback == null ? void 0 : callback("edit");
    },
    divider: true
  }
];
var BookmarkToolbar = class BookmarkToolbar2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._menu = null;
  }
  _toggleMenu() {
    if (this._menu) {
      this._menu.dispose();
      this._menu = null;
    } else {
      this._menu = createBookmarkOperationMenu(this.moreButton, {
        model: this.model,
        onSelected: (type) => {
          var _a3;
          this._toggleMenu();
          (_a3 = this.onSelected) == null ? void 0 : _a3.call(this, type);
        }
      });
    }
  }
  connectedCallback() {
    super.connectedCallback();
  }
  render() {
    const buttons = repeat(config, ({ type }) => type, ({ type, icon, tooltip, action, divider }) => {
      return html`<icon-button
            width="32px"
            height="32px"
            class="bookmark-toolbar-button has-tool-tip ${type}"
            @click=${() => {
        action(this.model, this.onSelected, this);
      }}
          >
            ${icon}
            <tool-tip inert role="tooltip">${tooltip}</tool-tip>
          </icon-button>
          ${divider ? html`<div class="divider"></div>` : nothing} `;
    });
    return html`
      <div class="bookmark-bar">
        ${buttons}

        <div class="more-button-wrapper">
          <icon-button
            width="32px"
            height="32px"
            class="has-tool-tip more-button"
            @click=${() => {
      this._toggleMenu();
    }}
          >
            ${MoreIcon}
            <tool-tip inert role="tooltip">More</tool-tip>
          </icon-button>
        </div>
      </div>
    `;
  }
};
BookmarkToolbar.styles = css`
    ${tooltipStyle}
    .bookmark-bar {
      box-sizing: border-box;
      position: absolute;
      right: 0;
      top: -40px;
      display: flex;
      align-items: center;
      padding: 4px 8px;
      gap: 4px;
      height: 40px;

      border-radius: 8px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      z-index: var(--affine-z-index-popover);
      user-select: none;
    }
    .divider {
      width: 1px;
      height: 24px;
      background-color: var(--affine-border-color);
    }
  `;
__decorate84([
  property()
], BookmarkToolbar.prototype, "model", void 0);
__decorate84([
  property()
], BookmarkToolbar.prototype, "onSelected", void 0);
__decorate84([
  query(".bookmark-bar")
], BookmarkToolbar.prototype, "formatQuickBarElement", void 0);
__decorate84([
  query(".more-button-wrapper")
], BookmarkToolbar.prototype, "moreButton", void 0);
BookmarkToolbar = __decorate84([
  customElement("bookmark-toolbar")
], BookmarkToolbar);

// node_modules/@blocksuite/blocks/dist/bookmark-block/components/bookmark-edit-modal.js
var __decorate85 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var bookmarkModalStyles = html`
  <style>
    .bookmark-modal-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      display: flex;
    }
    .bookmark-modal-mask {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;
    }
    .bookmark-modal-wrapper {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;

      width: 360px;
      height: 260px;
      background: var(--affine-background-primary-color);
      box-shadow: var(--affine-menu-shadow);
      border-radius: var(--affine-popover-radius);
      padding: 36px 40px 24px;
    }
    .bookmark-modal-close-button {
      position: absolute;
      right: 20px;
      top: 12px;
    }
    .bookmark-modal-title {
      font-size: var(--affine-font-h-6);
      font-weight: 600;
    }
    .bookmark-modal-desc {
      font-size: var(--affine-font-base);
      margin-top: 20px;
      caret-color: var(--affine-primary-color);
    }
    .bookmark-input {
      width: 100%;
      height: 32px;
      font-size: var(--affine-font-base);
      margin-top: 20px;
      caret-color: var(--affine-primary-color);
      transition: border-color 0.15s;

      line-height: 22px;
      padding: 8px 12px;
      color: var(--affine-text-primary-color);
      border: 1px solid;
      border-color: var(--affine-border-color);
      background-color: var(--affine-white);
      border-radius: 10px;
      outline: medium;
    }
    .bookmark-input:focus {
      border-color: var(--affine-primary-color);
    }

    .bookmark-input::placeholder {
      color: var(--affine-placeholder-color);
      font-size: var(--affine-font-base);
    }

    .bookmark-modal-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 40px;
    }
    .bookmark-confirm-button {
      padding: 4px 20px;
      height: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: var(--affine-font-base);
      background: var(--affine-primary-color);
      color: var(--affine-white);
      border-color: var(--affine-primary-color);
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
`;
var BookmarkEditModal = class BookmarkEditModal2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._modalKeyboardListener = (e) => {
      var _a3;
      if (e.key === "Enter") {
        this._onConfirm();
      }
      if (e.key === "Escape") {
        (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
      }
    };
  }
  get id() {
    return `bookmark-modal-${this.model.id.split(":")[0]}`;
  }
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("keydown", this._modalKeyboardListener);
    requestAnimationFrame(() => {
      const titleInput = document.querySelector(`#${this.id} input.title`);
      titleInput.focus();
      titleInput.setSelectionRange(0, titleInput.value.length);
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("keydown", this._modalKeyboardListener);
  }
  _onConfirm() {
    var _a3;
    const titleInput = document.querySelector(`#${this.id} input.title`);
    const descInput = document.querySelector(`#${this.id} input.description`);
    this.model.page.updateBlock(this.model, {
      title: titleInput.value,
      description: descInput.value
    });
    (_a3 = this.onConfirm) == null ? void 0 : _a3.call(this);
  }
  render() {
    const modal = html`${bookmarkModalStyles}
      <div class="bookmark-modal" id="${this.id}">
        <div
          class="bookmark-modal-mask"
          @click=${() => {
      var _a3;
      (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
    }}
        ></div>
        <div class="bookmark-modal-wrapper">
          <icon-button
            width="32px"
            height="32px"
            class="bookmark-modal-close-button"
            @click=${() => {
      var _a3;
      (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
    }}
            >${CloseIcon2}</icon-button
          >

          <div class="bookmark-modal-title">Edit</div>
          <input
            type="text"
            class="bookmark-input title"
            placeholder="Title"
            value=${this.model.title || "Bookmark"}
            tabindex="1"
          />
          <input
            type="text"
            class="bookmark-input description"
            placeholder="Description"
            value=${this.model.description || this.model.url}
            tabindex="2"
          />
          <div class="bookmark-modal-footer">
            <div
              class="bookmark-confirm-button"
              tabindex="3"
              @click=${() => {
      this._onConfirm();
    }}
            >
              Save
            </div>
          </div>
        </div>
      </div>`;
    return html`<affine-portal .template=${modal}></affine-portal>`;
  }
};
__decorate85([
  property()
], BookmarkEditModal.prototype, "model", void 0);
__decorate85([
  property()
], BookmarkEditModal.prototype, "onCancel", void 0);
__decorate85([
  property()
], BookmarkEditModal.prototype, "onConfirm", void 0);
BookmarkEditModal = __decorate85([
  customElement("bookmark-edit-modal")
], BookmarkEditModal);

// node_modules/@blocksuite/blocks/dist/bookmark-block/components/bookmark-create-modal.js
var __decorate86 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BookmarkCreateModal = class BookmarkCreateModal2 extends WithDisposable(LitElement) {
  constructor() {
    super(...arguments);
    this._modalKeyboardListener = (e) => {
      var _a3;
      if (e.key === "Enter") {
        this._onConfirm();
      }
      if (e.key === "Escape") {
        (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
      }
    };
  }
  get id() {
    return `bookmark-create-modal-${this.model.id.split(":")[0]}`;
  }
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => {
      const linkInput = document.querySelector(`#${this.id} input.link`);
      linkInput.focus();
    });
    document.addEventListener("keydown", this._modalKeyboardListener);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("keydown", this._modalKeyboardListener);
  }
  _onConfirm() {
    var _a3;
    const linkInput = document.querySelector(`#${this.id} input.link`);
    if (!linkInput.value) {
      toast("Bookmark url can not be empty");
      return;
    }
    this.model.page.updateBlock(this.model, {
      url: linkInput.value
    });
    (_a3 = this.onConfirm) == null ? void 0 : _a3.call(this);
  }
  render() {
    const modal = html`${bookmarkModalStyles}
      <div class="bookmark-modal" id="${this.id}">
        <div
          class="bookmark-modal-mask"
          @click=${() => {
      var _a3;
      (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
      this.model.page.deleteBlock(this.model);
    }}
        ></div>
        <div class="bookmark-modal-wrapper" style="width:480px">
          <icon-button
            width="32px"
            height="32px"
            class="bookmark-modal-close-button"
            @click=${() => {
      var _a3;
      (_a3 = this.onCancel) == null ? void 0 : _a3.call(this);
      this.model.page.deleteBlock(this.model);
    }}
            >${CloseIcon2}</icon-button
          >

          <div class="bookmark-modal-title">Bookmark</div>
          <div class="bookmark-modal-desc">
            Create a Bookmark that previews a link in card view.
          </div>
          <input
            tabindex="1"
            type="text"
            class="bookmark-input link"
            placeholder="Input in https://..."
          />

          <div class="bookmark-modal-footer">
            <div
              tabindex="2"
              class="bookmark-confirm-button"
              @click=${() => this._onConfirm()}
            >
              Confirm
            </div>
          </div>
        </div>
      </div>`;
    return html`<affine-portal .template=${modal}></affine-portal>`;
  }
};
__decorate86([
  property()
], BookmarkCreateModal.prototype, "model", void 0);
__decorate86([
  property()
], BookmarkCreateModal.prototype, "onCancel", void 0);
__decorate86([
  property()
], BookmarkCreateModal.prototype, "onConfirm", void 0);
BookmarkCreateModal = __decorate86([
  customElement("bookmark-create-modal")
], BookmarkCreateModal);

// node_modules/@blocksuite/blocks/dist/bookmark-block/components/loader.js
var __decorate87 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Loader3 = class Loader4 extends LitElement {
  constructor() {
    super(...arguments);
    this.size = "50px";
    this.color = "blue";
  }
  firstUpdated() {
    this.updateComplete.then(() => {
      const { size, color } = this;
      this.style.setProperty("--loader-size", typeof size === "string" ? size : `${size}px`);
      this.style.setProperty("--loader-color", color);
    });
  }
  render() {
    return html`<div class="bookmark-loader-wrapper">
      <svg class="bookmark-loader" x="0px" y="0px" viewBox="0 0 150 150">
        <circle class="bookmark-loader-block" cx="75" cy="75" r="60" />
      </svg>
    </div>`;
  }
};
Loader3.styles = css`
    .bookmark-loader-wrapper {
      display: flex;
      width: var(--loader-size);
      height: var(--loader-size);
    }
    .bookmark-loader {
      width: var(--loader-size);
      animation: loading 3s linear infinite;
    }
    .bookmark-loader-block {
      animation: loading-circle 2s linear infinite;
      stroke-dashoffset: 0;
      stroke-dasharray: 300;
      stroke-width: 15;
      stroke-miterlimit: 10;
      stroke-linecap: round;
      stroke: var(--loader-color);
      fill: transparent;
    }

    @keyframes loading {
      0% {
        transform: rotate(0);
      }
      100% {
        transform: rotate(360deg);
      }
    }
    @keyframes loading-circle {
      0% {
        stroke-dashoffset: 0;
      }
      100% {
        stroke-dashoffset: -600;
      }
    }
  `;
__decorate87([
  property()
], Loader3.prototype, "size", void 0);
__decorate87([
  property()
], Loader3.prototype, "color", void 0);
Loader3 = __decorate87([
  customElement("bookmark-loader")
], Loader3);

// node_modules/@blocksuite/blocks/dist/bookmark-block/bookmark-service.js
var BookmarkBlockService = class extends BaseService {
  block2html(block2, { childText = "", begin, end: end2 } = {}) {
    return block2.url;
  }
  block2Text(block2, { childText = "", begin = 0, end: end2 } = {}) {
    return block2.url;
  }
  block2Json(block2, begin, end2) {
    const clonedProps = cloneBookmarkProperties(block2);
    return {
      flavour: block2.flavour,
      children: [],
      ...clonedProps
    };
  }
};

// node_modules/@blocksuite/blocks/dist/bookmark-block/images/banners.js
var DefaultBanner = html`<svg
  width="140"
  height="96"
  viewBox="0 0 140 96"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <g clip-path="url(#clip0_3433_80247)">
    <g opacity="0.4">
      <g clip-path="url(#clip1_3433_80247)">
        <g clip-path="url(#clip2_3433_80247)">
          <g opacity="0.8" filter="url(#filter0_f_3433_80247)">
            <ellipse
              cx="45.5713"
              cy="61.2938"
              rx="45.5713"
              ry="61.2938"
              transform="matrix(-0.275152 -0.961401 0.994111 -0.108365 23.6692 80.3025)"
              fill="#5076FF"
            />
          </g>
          <g opacity="0.8" filter="url(#filter1_f_3433_80247)">
            <ellipse
              cx="49.6555"
              cy="50.1114"
              rx="49.6555"
              ry="50.1114"
              transform="matrix(-0.517539 -0.855659 0.945307 -0.326182 10.3975 87.9766)"
              fill="#77FFCE"
            />
          </g>
          <g opacity="0.8" filter="url(#filter2_f_3433_80247)">
            <path
              d="M141.154 3.03247C167.539 22.8936 134.54 99.5878 124.212 92.7915C117.912 88.6456 113.733 60.4772 94.173 45.9086C81.6691 36.5955 56.6586 38.5939 41.1056 37.1878C1.22291 33.5821 114.548 -16.9943 141.154 3.03247Z"
              fill="#35B7E0"
            />
          </g>
          <path
            d="M78.5971 45.1263C77.9794 49.5216 81.121 53.5957 85.6131 54.2271C90.1053 54.8584 94.2481 51.808 94.8658 47.4128C95.4835 43.0175 92.342 38.9434 87.8498 38.312C83.3577 37.6807 79.2149 40.7311 78.5971 45.1263Z"
            fill="url(#paint0_linear_3433_80247)"
          />
          <path
            d="M120.378 78.3637L119.989 81.1303C119.731 82.9654 119.562 84.15 119.36 85.0413C119.166 85.8959 118.999 86.1992 118.895 86.3451C118.499 86.9002 117.932 87.3171 117.277 87.5363C117.105 87.5938 116.76 87.6677 115.867 87.6141C114.934 87.5582 113.723 87.3905 111.847 87.1268L80.6109 82.7369C78.735 82.4733 77.524 82.3006 76.6125 82.0973C75.7385 81.9024 75.4276 81.7365 75.278 81.6337C74.7087 81.2424 74.2794 80.6856 74.0516 80.0428C73.9917 79.8739 73.9142 79.5361 73.9635 78.6612C74.0149 77.7488 74.1789 76.5635 74.4369 74.7283L75.6584 66.0369C75.8058 65.9369 75.9505 65.8411 76.0924 65.7498C77.1899 65.0437 78.3629 64.4423 79.7464 64.1873C81.8083 63.8072 83.9443 64.0829 85.8427 64.9742C87.1166 65.5723 88.0991 66.452 88.9822 67.4137C89.5619 68.0451 90.1807 68.8058 90.8604 69.6691L94.5285 66.9912C95.9295 65.9684 97.1371 65.0867 98.1922 64.4415C99.3051 63.761 100.491 63.1868 101.879 62.9626C103.947 62.6286 106.075 62.9506 107.951 63.8817C109.21 64.5065 110.172 65.4058 111.033 66.385C111.033 66.385 117.277 74.3919 120.378 78.3637Z"
            fill="url(#paint1_linear_3433_80247)"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M18.0193 52.2289C18.1346 51.4086 18.8931 50.837 19.7134 50.9523L67.2463 57.6326C68.0667 57.7479 68.6382 58.5064 68.5229 59.3268C68.4076 60.1471 67.6491 60.7187 66.8288 60.6034L19.2959 53.9231C18.4755 53.8078 17.904 53.0493 18.0193 52.2289Z"
            fill="white"
            fill-opacity="0.8"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M21.5681 26.9771C21.7218 25.8833 22.7332 25.1212 23.827 25.2749L47.5934 28.6151C48.6872 28.7688 49.4493 29.7801 49.2956 30.874C49.1419 31.9678 48.1305 32.7299 47.0367 32.5762L23.2703 29.236C22.1765 29.0823 21.4144 28.0709 21.5681 26.9771Z"
            fill="white"
            fill-opacity="0.8"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M19.55 41.336C19.6653 40.5156 20.4238 39.9441 21.2442 40.0593L68.7771 46.7397C69.5974 46.8549 70.169 47.6135 70.0537 48.4338C69.9384 49.2542 69.1799 49.8258 68.3595 49.7105L20.8267 43.0301C20.0063 42.9149 19.4347 42.1564 19.55 41.336Z"
            fill="white"
            fill-opacity="0.8"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M16.4883 63.1219C16.6036 62.3015 17.3621 61.7299 18.1824 61.8452L65.7153 68.5255C66.5357 68.6408 67.1072 69.3993 66.9919 70.2197C66.8766 71.0401 66.1181 71.6116 65.2978 71.4963L17.7649 64.816C16.9445 64.7007 16.373 63.9422 16.4883 63.1219Z"
            fill="white"
            fill-opacity="0.8"
          />
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M15.2358 72.0344C15.3511 71.214 16.1096 70.6424 16.93 70.7577L64.4628 77.438C65.2832 77.5533 65.8548 78.3118 65.7395 79.1322C65.6242 79.9525 64.8657 80.5241 64.0453 80.4088L16.5125 73.7285C15.6921 73.6132 15.1205 72.8547 15.2358 72.0344Z"
            fill="white"
            fill-opacity="0.4"
          />
        </g>
      </g>
    </g>
  </g>
  <defs>
    <filter
      id="filter0_f_3433_80247"
      x="-14.1589"
      y="-38.4709"
      width="172.444"
      height="136.638"
      filterUnits="userSpaceOnUse"
      color-interpolation-filters="sRGB"
    >
      <feFlood flood-opacity="0" result="BackgroundImageFix" />
      <feBlend
        mode="normal"
        in="SourceGraphic"
        in2="BackgroundImageFix"
        result="shape"
      />
      <feGaussianBlur
        stdDeviation="12"
        result="effect1_foregroundBlur_3433_80247"
      />
    </filter>
    <filter
      id="filter1_f_3433_80247"
      x="-45.8333"
      y="-40.3932"
      width="155.805"
      height="139.072"
      filterUnits="userSpaceOnUse"
      color-interpolation-filters="sRGB"
    >
      <feFlood flood-opacity="0" result="BackgroundImageFix" />
      <feBlend
        mode="normal"
        in="SourceGraphic"
        in2="BackgroundImageFix"
        result="shape"
      />
      <feGaussianBlur
        stdDeviation="12"
        result="effect1_foregroundBlur_3433_80247"
      />
    </filter>
    <filter
      id="filter2_f_3433_80247"
      x="8.68726"
      y="-25.6425"
      width="166.468"
      height="142.859"
      filterUnits="userSpaceOnUse"
      color-interpolation-filters="sRGB"
    >
      <feFlood flood-opacity="0" result="BackgroundImageFix" />
      <feBlend
        mode="normal"
        in="SourceGraphic"
        in2="BackgroundImageFix"
        result="shape"
      />
      <feGaussianBlur
        stdDeviation="12"
        result="effect1_foregroundBlur_3433_80247"
      />
    </filter>
    <linearGradient
      id="paint0_linear_3433_80247"
      x1="102.492"
      y1="40.3698"
      x2="96.2289"
      y2="84.9319"
      gradientUnits="userSpaceOnUse"
    >
      <stop offset="0.578125" stop-color="white" />
      <stop offset="1" stop-color="white" stop-opacity="0" />
    </linearGradient>
    <linearGradient
      id="paint1_linear_3433_80247"
      x1="102.492"
      y1="40.3698"
      x2="96.2289"
      y2="84.9319"
      gradientUnits="userSpaceOnUse"
    >
      <stop offset="0.578125" stop-color="white" />
      <stop offset="1" stop-color="white" stop-opacity="0" />
    </linearGradient>
    <clipPath id="clip0_3433_80247">
      <rect width="140" height="96" fill="white" />
    </clipPath>
    <clipPath id="clip1_3433_80247">
      <rect
        x="11.7563"
        y="3.38196"
        width="130"
        height="88"
        rx="4"
        transform="rotate(8 11.7563 3.38196)"
        fill="white"
      />
    </clipPath>
    <clipPath id="clip2_3433_80247">
      <rect
        width="130"
        height="88"
        fill="white"
        transform="translate(11.7563 3.38196) rotate(8)"
      />
    </clipPath>
  </defs>
</svg>`;

// node_modules/@blocksuite/blocks/dist/bookmark-block/bookmark-block.js
var __decorate88 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var BookmarkBlockComponent = class BookmarkBlockComponent2 extends BlockElement {
  constructor() {
    super(...arguments);
    this.slots = {
      openInitialModal: new Slot()
    };
    this._showCreateModal = false;
    this._showToolbar = false;
    this._showEditModal = false;
    this._isLoading = false;
    this._timer = null;
    this._onToolbarSelected = (type) => {
      if (type === "caption") {
        this._input.classList.add("caption-show");
        requestAnimationFrame(() => {
          this._input.focus();
        });
      }
      if (type === "edit") {
        this._showEditModal = true;
      }
      this._showToolbar = false;
    };
  }
  set loading(value) {
    this._isLoading = value;
  }
  get loading() {
    return this._isLoading;
  }
  firstUpdated() {
    this.model.propsUpdated.on(() => this.requestUpdate());
    this.updateComplete.then(() => {
      var _a3;
      this._caption = ((_a3 = this.model) == null ? void 0 : _a3.caption) ?? "";
      if (this._caption) {
        this._input.classList.add("caption-show");
      }
    });
  }
  connectedCallback() {
    super.connectedCallback();
    registerService("affine:bookmark", BookmarkBlockService);
    reloadBookmarkBlock(this.model, this);
    this.slots.openInitialModal.on(() => {
      this._showCreateModal = true;
    });
  }
  _onInputChange() {
    this._caption = this._input.value;
    this.model.page.updateBlock(this.model, { caption: this._caption });
  }
  _onInputBlur() {
    if (!this._caption) {
      this._input.classList.remove("caption-show");
    }
  }
  _onHover() {
    if (this._isLoading)
      return;
    this._showToolbar = true;
    this._timer && clearTimeout(this._timer);
  }
  _onHoverOut() {
    this._timer = setTimeout(() => {
      this._showToolbar = false;
    }, 100);
  }
  render() {
    const { url, title, description, icon, image } = this.model;
    const mode = queryCurrentMode();
    const createModal = this._showCreateModal ? html`<bookmark-create-modal
          .model=${this.model}
          .onCancel=${() => {
      this._showCreateModal = false;
    }}
          .onConfirm=${() => {
      reloadBookmarkBlock(this.model, this, true);
      this._showCreateModal = false;
    }}
        ></bookmark-create-modal>` : nothing;
    const editModal = this._showEditModal ? html`<bookmark-edit-modal
          .model=${this.model}
          .onCancel=${() => {
      this._showEditModal = false;
    }}
          .onConfirm=${() => {
      this._showEditModal = false;
    }}
        ></bookmark-edit-modal>` : nothing;
    const toolbar = this._showToolbar ? html`<bookmark-toolbar
          .model=${this.model}
          .onSelected=${this._onToolbarSelected}
        ></bookmark-toolbar>` : nothing;
    const loading = this._isLoading ? html`<div
          class="affine-bookmark-loading ${mode === "light" ? "" : "dark"}"
        >
          <div class="affine-bookmark-title">
            <bookmark-loader
              size="15px"
              color="var(--affine-primary-color)"
            ></bookmark-loader>
            <div class="affine-bookmark-title-content">Loading...</div>
          </div>
          <div class="affine-bookmark-banner">
            ${mode === "light" ? LoadingBanner : DarkLoadingBanner}
          </div>
        </div>` : nothing;
    const linkCard = html`<a
      href="${url}"
      target="_blank"
      class="affine-bookmark-link"
    >
      <div class="affine-bookmark-content-wrapper">
        <div class="affine-bookmark-title">
          <div class="affine-bookmark-icon">
            ${icon ? html`<img src="${icon}" alt="icon" />` : DefaultIcon}
          </div>
          <div class="affine-bookmark-title-content">
            ${title || "Bookmark"}
          </div>
        </div>

        <div class="affine-bookmark-description">${description || url}</div>
        <div class="affine-bookmark-url">${url}</div>
      </div>
      <div class="affine-bookmark-banner ${image ? "shadow" : ""}">
        ${image ? html`<img src="${image}" alt="image" />` : DefaultBanner}
      </div>
    </a>`;
    if (!url) {
      return createModal;
    }
    return html`
      ${editModal}
      <div
        class="affine-bookmark-block-container"
        @mouseover="${this._onHover}"
        @mouseout="${this._onHoverOut}"
      >
        ${toolbar} ${this._isLoading ? loading : linkCard}
        <input
          .disabled=${this.model.page.readonly}
          placeholder="Write a caption"
          class="affine-bookmark-caption"
          value=${this._caption}
          @input=${this._onInputChange}
          @blur=${this._onInputBlur}
          @click=${(e) => {
      e.stopPropagation();
    }}
        />
      </div>
    `;
  }
};
BookmarkBlockComponent.styles = css`
    .affine-bookmark-block-container {
      width: 100%;
      margin-top: calc(var(--affine-paragraph-space) + 8px);
      position: relative;
    }
    .affine-bookmark-link {
      height: 112px;
      box-shadow: var(--affine-shadow-1);
      background: var(--affine-card-background-blue);
      border: 3px solid var(--affine-background-secondary-color);
      border-radius: 12px;
      padding: 16px 24px;
      display: flex;
      cursor: pointer;
      text-decoration: none;
      color: var(--affine-text-primary-color);
      overflow: hidden;
      line-height: calc(1em + 4px);
      position: relative;
    }
    .affine-bookmark-banner {
      width: 140px;
      height: 93px;
      margin-left: 20px;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
      flex-shrink: 0;
    }
    .affine-bookmark-banner.shadow {
      box-shadow: var(--affine-shadow-1);
    }

    .affine-bookmark-banner img,
    .affine-bookmark-banner svg {
      width: 140px;
      height: 93px;
      object-fit: cover;
    }
    .affine-bookmark-content-wrapper {
      flex-grow: 1;
      overflow: hidden;
    }
    .affine-bookmark-title {
      height: 18px;
      display: flex;
      align-items: center;
      font-size: var(--affine-font-sm);
      font-weight: 600;
    }
    .affine-bookmark-title-content {
      flex-grow: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-left: 8px;
    }
    .affine-bookmark-icon {
      width: 18px;
      height: 18px;
      color: var(--affine-text-secondary-color);
      flex-shrink: 0;
    }
    .affine-bookmark-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .affine-bookmark-description {
      height: 32px;
      line-height: 16px;
      margin-top: 4px;
      font-size: var(--affine-font-xs);

      display: -webkit-box;
      word-break: break-all;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .affine-bookmark-url {
      font-size: var(--affine-font-xs);
      color: var(--affine-text-secondary-color);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 2px;
    }
    .affine-bookmark-caption {
      width: 100%;
      font-size: var(--affine-font-sm);
      outline: none;
      border: 0;
      font-family: inherit;
      text-align: center;
      color: var(--affine-icon-color);
      display: none;
      background: var(--affine-background-primary-color);
    }
    .affine-bookmark-caption::placeholder {
      color: var(--affine-placeholder-color);
    }
    .affine-bookmark-caption.caption-show {
      display: inline-block;
    }
    .affine-bookmark-loading {
      width: 100%;
      height: 112px;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      box-shadow: var(--affine-shadow-1);
      background: var(--affine-hover-color);
      border: 3px solid var(--affine-background-secondary-color);
      color: var(--affine-placeholder-color);
      border-radius: 12px;
    }
  `;
__decorate88([
  query("input.affine-bookmark-caption")
], BookmarkBlockComponent.prototype, "_input", void 0);
__decorate88([
  state()
], BookmarkBlockComponent.prototype, "_showCreateModal", void 0);
__decorate88([
  state()
], BookmarkBlockComponent.prototype, "_showToolbar", void 0);
__decorate88([
  state()
], BookmarkBlockComponent.prototype, "_showEditModal", void 0);
__decorate88([
  state()
], BookmarkBlockComponent.prototype, "_caption", void 0);
__decorate88([
  state()
], BookmarkBlockComponent.prototype, "_isLoading", void 0);
BookmarkBlockComponent = __decorate88([
  customElement("affine-bookmark")
], BookmarkBlockComponent);

// node_modules/@blocksuite/blocks/dist/services.js
var blockService = {
  "affine:code": CodeBlockService,
  "affine:database": DatabaseBlockService,
  "affine:paragraph": ParagraphBlockService,
  "affine:list": ListBlockService,
  "affine:embed": EmbedBlockService,
  "affine:divider": DividerBlockService,
  "affine:frame": FrameBlockService,
  "affine:bookmark": BookmarkBlockService
};

// node_modules/@blocksuite/blocks/dist/__internal__/service.js
var services = /* @__PURE__ */ new Map();
function hasService(flavour) {
  return services.has(flavour);
}
function registerService(flavour, Constructor) {
  if (services.has(flavour)) {
    return;
  }
  const service = new Constructor();
  services.set(flavour, service);
  return;
}
function getService(flavour) {
  const service = services.get(flavour);
  if (!service) {
    throw new Error(`cannot find service by flavour ${flavour}`);
  }
  return service;
}
function getServiceOrRegister(flavour) {
  const service = services.get(flavour);
  if (!service) {
    const Constructor = blockService[flavour] ?? BaseService;
    const result = registerService(flavour, Constructor);
    if (result instanceof Promise) {
      return result.then(() => services.get(flavour));
    } else {
      return services.get(flavour);
    }
  }
  return service;
}

export {
  WithDisposable,
  ShadowlessElement,
  getCurrentBlockRange,
  uploadImageFromLocal,
  BookmarkBlockSchema,
  BlockHub,
  getAllowSelectedBlocks,
  CodeBlockSchema,
  DividerBlockSchema,
  EmbedBlockSchema,
  FrameBlockSchema,
  ListBlockSchema,
  ParagraphBlockSchema,
  hasService,
  registerService,
  getService,
  getServiceOrRegister,
  tryUpdateFrameSize,
  PageBlockSchema,
  SurfaceBlockSchema,
  ThemeObserver,
  pagePreset,
  edgelessPreset
};
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

lit-html/development/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/join.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-ZGY32QOB.js.map
