import { Slot } from '@blocksuite/global/utils';
import * as Y from 'yjs';
import type { AwarenessStore } from '../awareness.js';
import type { BlockSchemaType } from '../base.js';
import type { BlobManager } from '../persistence/blob/types.js';
import { type InlineSuggestionProvider, type StoreOptions } from '../store.js';
import { BacklinkIndexer } from './indexer/backlink.js';
import { type QueryContent, SearchIndexer } from './indexer/search.js';
import { type PageMeta, WorkspaceMeta } from './meta.js';
import { Page } from './page.js';
import { Schema } from './schema.js';
export type WorkspaceOptions = {
    experimentalInlineSuggestionProvider?: InlineSuggestionProvider;
} & StoreOptions;
export declare class Workspace {
    static Y: typeof Y;
    private _store;
    private readonly _schema;
    private readonly _storages;
    private readonly _blobStorage;
    meta: WorkspaceMeta;
    slots: {
        pagesUpdated: Slot<void>;
        pageAdded: Slot<string>;
        pageRemoved: Slot<string>;
        blobUpdate: Slot<void>;
    };
    indexer: {
        search: SearchIndexer;
        backlink: BacklinkIndexer;
    };
    readonly inlineSuggestionProvider?: InlineSuggestionProvider;
    constructor({ experimentalInlineSuggestionProvider, ...storeOptions }: WorkspaceOptions);
    get id(): string;
    get isEmpty(): boolean;
    get awarenessStore(): AwarenessStore;
    get providers(): import("../index.js").DocProvider[];
    get blobs(): BlobManager;
    private get _pages();
    getPageNameList(): `space:${string}`[];
    get doc(): import("../yjs/doc.js").BlockSuiteDoc<import("../yjs/doc.js").BlockSuiteDocData>;
    get idGenerator(): import("../index.js").IdGenerator;
    get schema(): Schema;
    register(blockSchema: BlockSchemaType[]): this;
    private _hasPage;
    getPage(pageId: string): Page | null;
    private _bindPageMetaEvents;
    /**
     * By default, only an empty page will be created.
     * If the `init` parameter is passed, a `surface`, `frame`, and `paragraph` block
     * will be created in the page simultaneously.
     */
    createPage(options?: {
        id?: string;
        init?: true | {
            title: string;
        };
    } | string): Page;
    /** Update page meta state. Note that this intentionally does not mutate page state. */
    setPageMeta(pageId: string, props: Partial<PageMeta>): void;
    /**
     * @deprecated
     */
    shiftPage(pageId: string, newIndex: number): void;
    removePage(pageId: string): void;
    search(query: QueryContent): Map<string, string>;
    /**
     * @internal Only for testing
     */
    exportYDoc(): void;
    /** @internal Only for testing */
    importYDoc(): Promise<void>;
    /**
     * @internal
     * Import an object expression of a page.
     * Specify the page you want to update by passing the `pageId` parameter and it will
     * create a new page if it does not exist.
     */
    importPageSnapshot(json: any, pageId: string): Promise<void>;
    /** @internal Only for testing */
    exportSnapshot(): Record<string, unknown>;
    /** @internal Only for testing */
    exportJSX(blockId?: string, pageId?: string | undefined): import("../utils/jsx.js").JSXElement | null;
}
//# sourceMappingURL=workspace.d.ts.map