import FlexSearch from 'flexsearch';
import { Text as YText } from 'yjs';
const DocumentIndexer = FlexSearch.Document;
const Index = FlexSearch.Index;
function tokenize(locale) {
    const tokenizer = Intl?.Segmenter;
    if (tokenizer) {
        // extract the latin encoder inside flexsearch
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const latinIndexer = new Index({ charset: 'latin:advanced' });
        const latinEncoder = latinIndexer.encode.bind(latinIndexer);
        // check latin characters
        const latinChecker = /^[\p{Script=Latin}\p{Mark}\d]+$/u;
        const segmenter = new tokenizer([locale], { granularity: 'word' });
        return (text) => {
            const latinChars = [];
            const cjkChars = Array.from(segmenter.segment(text))
                .filter(s => {
                if (s.isWordLike) {
                    if (!latinChecker.test(s.segment)) {
                        return true;
                    }
                    latinChars.push(s.segment);
                }
                return false;
            })
                .map(s => s.segment);
            return [...cjkChars, ...latinEncoder(latinChars.join(' '))];
        };
    }
    return (text) => {
        // eslint-disable-next-line no-control-regex
        return text.replace(/[\x00-\x7F]/g, '').split('');
    };
}
export class SearchIndexer {
    constructor(doc, 
    // locale string based on https://www.w3.org/International/articles/bcp47/
    locale = 'en-US') {
        this._doc = doc;
        this._indexer = new DocumentIndexer({
            document: {
                id: 'id',
                index: ['content', 'reference', 'space'],
                tag: 'tags',
                store: ['space'],
            },
            encode: tokenize(locale),
            tokenize: 'forward',
            context: true,
        });
        Array.from(doc.share.keys())
            .filter(pageId => pageId !== 'space:meta')
            .map(k => [k, this._getPage(k)])
            .forEach(([pageId, page]) => this._handlePageIndexing(pageId, page));
    }
    // TODO: remove this method, observe page meta instead
    onPageCreated(pageId) {
        this._handlePageIndexing(pageId, this._getPage(pageId));
    }
    search(query) {
        return new Map(this._search(query).flatMap(({ result }) => result.map(r => [r.id, r.doc.space])));
    }
    _search(query) {
        if (typeof query === 'object') {
            return this._indexer.search({
                ...query,
                enrich: true,
            });
        }
        else {
            return this._indexer.search(query, {
                enrich: true,
            });
        }
    }
    _handlePageIndexing(pageId, page) {
        if (page) {
            page.forEach((_, key) => {
                this._refreshIndex(pageId, key, 'add', page.get(key));
            });
            page.observeDeep(events => {
                const keys = events.flatMap(e => {
                    // eslint-disable-next-line no-bitwise
                    if ((e.path?.length | 0) > 0) {
                        return [[e.path[0], 'update']];
                    }
                    return Array.from(e.changes.keys.entries()).map(([k, { action }]) => [k, action]);
                });
                if (keys.length) {
                    keys.forEach(([key, action]) => {
                        this._refreshIndex(pageId, key, action, page.get(key));
                    });
                }
            });
        }
    }
    _refreshIndex(page, id, action, block) {
        switch (action) {
            case 'add':
            case 'update': {
                if (block) {
                    const content = this._toContent(block.get('prop:title') || block.get('prop:text'));
                    if (content) {
                        this._indexer.add(id, {
                            content,
                            space: page,
                            tags: [page],
                        });
                    }
                }
                break;
            }
            case 'delete': {
                this._indexer.remove(id);
                break;
            }
        }
    }
    _toContent(obj) {
        if (obj) {
            if (typeof obj === 'string') {
                return obj;
            }
            else if (obj instanceof YText) {
                return obj.toJSON();
            }
        }
        return undefined;
    }
    _getPage(key) {
        try {
            if (!key.startsWith('space:')) {
                key = `space:${key}`;
            }
            return this._doc.getMap(key);
        }
        catch (_) {
            return undefined;
        }
    }
}
//# sourceMappingURL=search.js.map