import type { SerializedBlock } from '@blocksuite/blocks';
import { Slot } from '@blocksuite/global/utils';
import * as Y from 'yjs';
import type { AwarenessStore } from '../awareness.js';
import { BaseBlockModel } from '../base.js';
import { Space } from '../space.js';
import { Text } from '../text-adapter.js';
import type { IdGenerator } from '../utils/id-generator.js';
import type { BlockSuiteDoc } from '../yjs/index.js';
import type { PageMeta } from './meta.js';
import type { Workspace } from './workspace.js';
export type YBlock = Y.Map<unknown>;
export type YBlocks = Y.Map<YBlock>;
/** JSON-serializable properties of a block */
export type BlockProps = {
    id: string;
    flavour: string;
    text?: Text;
    children?: BaseBlockModel[];
    [index: string]: any;
};
export type PrefixedBlockProps = Record<string, unknown> & {
    'sys:id': string;
    'sys:flavour': string;
};
type FlatBlockMap = {
    [key: string]: YBlock;
};
type PageOptions = {
    id: string;
    workspace: Workspace;
    doc: BlockSuiteDoc;
    awarenessStore: AwarenessStore;
    idGenerator?: IdGenerator;
};
export declare class Page extends Space<FlatBlockMap> {
    private readonly _workspace;
    private readonly _idGenerator;
    private _history;
    private _root;
    private _blockMap;
    private _synced;
    private _shouldTransact;
    private _ignoredKeys;
    readonly slots: {
        historyUpdated: Slot<void>;
        rootAdded: Slot<BaseBlockModel<object>>;
        rootDeleted: Slot<string | string[]>;
        textUpdated: Slot<Y.YTextEvent>;
        yUpdated: Slot<void>;
        onYEvent: Slot<{
            event: Y.YEvent<YBlock | Y.Text | Y.Array<unknown>>;
        }>;
        blockUpdated: Slot<{
            type: 'add' | 'delete' | 'update';
            id: string;
        }>;
        copied: Slot<void>;
        pasted: Slot<SerializedBlock[]>;
    };
    constructor({ id, workspace, doc, awarenessStore, idGenerator, }: PageOptions);
    get readonly(): boolean;
    get history(): Y.UndoManager;
    get workspace(): Workspace;
    get schema(): import("./schema.js").Schema;
    get meta(): PageMeta;
    get blobs(): import("../index.js").BlobManager;
    /** key-value store of blocks */
    private get _yBlocks();
    get root(): BaseBlockModel<object> | null;
    getYBlockById(id: string): YBlock | undefined;
    get isEmpty(): boolean;
    get canUndo(): boolean;
    get canRedo(): boolean;
    get YText(): typeof Y.Text;
    get YMap(): typeof Y.Map;
    get Text(): typeof Text;
    withoutTransact(callback: () => void): void;
    transact(fn: () => void, shouldTransact?: boolean): void;
    undo(): void;
    redo(): void;
    /** Capture current operations to undo stack synchronously. */
    captureSync(): void;
    resetHistory(): void;
    generateId(): string;
    getBlockById(id: string): BaseBlockModel<object> | null;
    getBlockByFlavour(blockFlavour: string): BaseBlockModel<object>[];
    hasFlavour(flavour: string): boolean;
    getParent(target: BaseBlockModel | string): BaseBlockModel | null;
    getPreviousSibling(block: BaseBlockModel): BaseBlockModel<object> | null;
    getPreviousSiblings(block: BaseBlockModel): BaseBlockModel<object>[];
    getNextSibling(block: BaseBlockModel): BaseBlockModel<object> | null;
    getNextSiblings(block: BaseBlockModel): BaseBlockModel<object>[];
    getSchemaByFlavour(flavour: string): {
        model: {
            role: "content" | "root" | "hub";
            tag: {
                _$litStatic$: string;
                r: symbol;
            };
            flavour: string;
            parent?: string[] | undefined;
            children?: string[] | undefined;
            props?: ((args_0: import("../base.js").InternalPrimitives, ...args_1: unknown[]) => Record<string, any>) | undefined;
            toModel?: ((...args: unknown[]) => BaseBlockModel<object>) | undefined;
        };
        version: number;
    } | undefined;
    getInitialPropsByFlavour(flavour: string): Record<string, any>;
    addBlocks(blocks: Array<{
        flavour: string;
        blockProps?: Partial<BlockProps & Omit<BlockProps, 'flavour' | 'id'>>;
    }>, parent?: BaseBlockModel | string | null, parentIndex?: number): string[];
    addBlock(flavour: string, blockProps?: Partial<BlockProps & Omit<BlockProps, 'flavour'>>, parent?: BaseBlockModel | string | null, parentIndex?: number): string;
    private _populateParentChildrenMap;
    private _repositionBlocks;
    moveBlocks(blocksToMove: BaseBlockModel[], newParent: BaseBlockModel, targetSibling?: BaseBlockModel | null, shouldInsertBeforeSibling?: boolean): void;
    updateBlock<T extends Partial<BlockProps>>(model: BaseBlockModel, props: T): void;
    addSiblingBlocks(targetModel: BaseBlockModel, props: Array<Partial<BaseBlockModel>>, place?: 'after' | 'before'): string[];
    deleteBlock(model: BaseBlockModel, options?: {
        bringChildrenTo: 'parent' | BaseBlockModel | false;
    }): void;
    trySyncFromExistingDoc(): void;
    dispose(): void;
    private _initYBlocks;
    private _getYBlock;
    private _historyAddObserver;
    private _historyPopObserver;
    private _historyObserver;
    private _createBlockModel;
    private _handleYBlockAdd;
    private _handleYBlockDelete;
    private _handleYBlockUpdate;
    private _handleYEvent;
    private _handleYEvents;
    private _handleVersion;
}
export {};
//# sourceMappingURL=page.d.ts.map