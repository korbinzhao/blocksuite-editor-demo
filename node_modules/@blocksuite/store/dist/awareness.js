import { Slot } from '@blocksuite/global/utils';
import { merge } from 'merge';
import { uuidv4 } from './utils/id-generator.js';
export class AwarenessStore {
    constructor(store, awareness, defaultFlags) {
        this.slots = {
            update: new Slot(),
        };
        this._onAwarenessChange = (diff) => {
            const { added, removed, updated } = diff;
            const states = this.awareness.getStates();
            added.forEach(id => {
                this.slots.update.emit({
                    id,
                    type: 'add',
                    state: states.get(id),
                });
            });
            updated.forEach(id => {
                this.slots.update.emit({
                    id,
                    type: 'update',
                    state: states.get(id),
                });
            });
            removed.forEach(id => {
                this.slots.update.emit({
                    id,
                    type: 'remove',
                });
            });
        };
        this._onAwarenessMessage = (awMsg) => {
            if (this.getFlag('enable_set_remote_flag') === true) {
                this._handleRemoteFlags();
            }
        };
        this.store = store;
        this.awareness = awareness;
        this.awareness.on('change', this._onAwarenessChange);
        this.slots.update.on(this._onAwarenessMessage);
        const upstreamFlags = awareness.getLocalState()?.flags;
        if (upstreamFlags) {
            this.awareness.setLocalStateField('flags', merge(true, defaultFlags, upstreamFlags));
        }
        else {
            this.awareness.setLocalStateField('flags', { ...defaultFlags });
        }
    }
    setFlag(field, value) {
        const oldFlags = this.awareness.getLocalState()?.flags ?? {};
        this.awareness.setLocalStateField('flags', { ...oldFlags, [field]: value });
    }
    getFlag(field) {
        const flags = this.awareness.getLocalState()?.flags ?? {};
        return flags[field];
    }
    setReadonly(space, value) {
        const flags = this.getFlag('readonly') ?? {};
        this.setFlag('readonly', {
            ...flags,
            [space.prefixedId]: value,
        });
    }
    isReadonly(space) {
        const rd = this.getFlag('readonly');
        if (rd && typeof rd === 'object') {
            return Boolean(rd[space.prefixedId]);
        }
        else {
            return false;
        }
    }
    setRemoteFlag(clientId, field, value) {
        if (!this.getFlag('enable_set_remote_flag')) {
            console.error('set remote flag feature disabled');
            return;
        }
        const oldRequest = this.awareness.getLocalState()?.request ?? [];
        this.awareness.setLocalStateField('request', [
            ...oldRequest,
            {
                id: uuidv4(),
                clientId,
                field,
                value,
            },
        ]);
    }
    setLocalRange(space, range) {
        const rangeMap = this.awareness.getLocalState()?.rangeMap ?? {};
        if (range === null) {
            delete rangeMap[space.prefixedId];
            this.awareness.setLocalStateField('rangeMap', rangeMap);
        }
        else {
            this.awareness.setLocalStateField('rangeMap', {
                ...rangeMap,
                [space.prefixedId]: range,
            });
        }
    }
    getLocalRange(space) {
        return this.awareness.getLocalState()?.['rangeMap']?.[space.prefixedId];
    }
    getStates() {
        return this.awareness.getStates();
    }
    _handleRemoteFlags() {
        const nextTick = [];
        const localState = this.awareness.getLocalState();
        const request = (localState?.request ?? []);
        const selfResponse = [];
        const fakeDirtyResponse = [];
        if (localState && Array.isArray(localState.response)) {
            selfResponse.push(...localState.response);
            fakeDirtyResponse.push(...localState.response);
        }
        const response = [];
        for (const [clientId, state] of this.awareness.getStates()) {
            if (clientId === this.awareness.clientID) {
                continue;
            }
            if (Array.isArray(state.response)) {
                response.push(...state.response);
            }
            if (Array.isArray(state.request)) {
                const remoteRequest = state.request;
                selfResponse.forEach((response, idx) => {
                    if (response === null) {
                        return;
                    }
                    const index = remoteRequest.findIndex(request => request.id === response.id);
                    if (index === -1) {
                        fakeDirtyResponse[idx].id = 'remove';
                    }
                });
                remoteRequest.forEach(request => {
                    if (request.clientId === this.awareness.clientID) {
                        // handle request
                        nextTick.push(() => {
                            this.setFlag(request.field, request.value);
                        });
                        selfResponse.push({
                            id: request.id,
                        });
                    }
                });
            }
        }
        response.forEach(response => {
            const idx = request.findIndex(request => request.id === response.id);
            if (idx !== -1) {
                request.splice(idx, 1);
            }
        });
        nextTick.push(() => {
            this.awareness.setLocalStateField('request', request);
            this.awareness.setLocalStateField('response', selfResponse.filter((response, idx) => fakeDirtyResponse[idx] ? fakeDirtyResponse[idx].id !== 'remove' : true));
        });
        setTimeout(() => {
            nextTick.forEach(fn => fn());
        }, 100);
    }
    destroy() {
        if (this.awareness) {
            this.awareness.off('change', this._onAwarenessChange);
            this.slots.update.dispose();
        }
    }
}
//# sourceMappingURL=awareness.js.map