/// <reference types="@blocksuite/global" />
import { Awareness } from 'y-protocols/awareness.js';
import { AwarenessStore, type RawAwarenessState } from './awareness.js';
import type { BlobStorage } from './persistence/blob/types.js';
import type { DocProvider, DocProviderConstructor } from './persistence/doc/index.js';
import type { Space } from './space.js';
import type { IdGenerator } from './utils/id-generator.js';
import { BlockSuiteDoc } from './yjs/index.js';
export interface SerializedStore {
    [key: string]: {
        [key: string]: unknown;
    };
}
export declare enum Generator {
    /**
     * Default mode, generator for the unpredictable id
     */
    NanoID = "nanoID",
    UUIDv4 = "uuidV4",
    /**
     * This generator is trying to fix the real-time collaboration on debug mode.
     * This will make generator predictable and won't make conflict
     * @link https://docs.yjs.dev/api/faq#i-get-a-new-clientid-for-every-session-is-there-a-way-to-make-it-static-for-a-peer-accessing-the-doc
     */
    AutoIncrementByClientId = "autoIncrementByClientId",
    /**
     * **Warning**: This generator mode will crash the collaborative feature
     *  if multiple clients are adding new blocks.
     * Use this mode only if you know what you're doing.
     */
    AutoIncrement = "autoIncrement"
}
/**
 * @example
 *  const workspace = new Workspace({
 *    isSSR: typeof window === 'undefined'
 *  })
 */
export interface SSROptions {
    isSSR?: boolean;
}
export type InlineSuggestionProvider = (context: {
    title: string;
    text: string;
    abortSignal: AbortSignal;
}) => string | Promise<string>;
export interface StoreOptions<Flags extends Record<string, unknown> = BlockSuiteFlags> extends SSROptions {
    id: string;
    providers?: DocProviderConstructor[];
    awareness?: Awareness<RawAwarenessState<Flags>>;
    idGenerator?: Generator;
    defaultFlags?: Partial<Flags>;
    blobStorages?: ((id: string) => BlobStorage)[];
}
export declare class Store {
    readonly id: string;
    readonly doc: BlockSuiteDoc;
    readonly providers: DocProvider[];
    readonly spaces: Map<string, Space<Record<string, any>>>;
    readonly awarenessStore: AwarenessStore;
    readonly idGenerator: IdGenerator;
    constructor({ id, providers, awareness, idGenerator, defaultFlags, }?: StoreOptions);
    addSpace(space: Space): void;
    removeSpace(space: Space): void;
    /**
     * @internal Only for testing, 'page0' should be replaced by props 'spaceId'
     */
    exportJSX(pageId: string, blockId?: string): import("./utils/jsx.js").JSXElement | null;
}
//# sourceMappingURL=store.d.ts.map