import { assertExists } from '@blocksuite/global/utils';
import { UIEventStateContext } from './base.js';
import { PointerEventState } from './state.js';
import { isFarEnough } from './utils.js';
export class PointerControl {
    constructor(_dispatcher) {
        this._dispatcher = _dispatcher;
        this._lastPointerDownEvent = null;
        this._startDragState = null;
        this._lastDragState = null;
        this._pointerDownCount = 0;
        this._dragging = false;
        this._startX = -Infinity;
        this._startY = -Infinity;
        this._reset = () => {
            this._startX = -Infinity;
            this._startY = -Infinity;
            this._lastDragState = null;
            this._dragging = false;
        };
        this._down = (event) => {
            if (this._lastPointerDownEvent &&
                event.timeStamp - this._lastPointerDownEvent.timeStamp < 500 &&
                !isFarEnough(event, this._lastPointerDownEvent)) {
                this._pointerDownCount++;
            }
            else {
                this._pointerDownCount = 1;
            }
            const pointerEventState = new PointerEventState({
                event,
                rect: this._rect,
                startX: this._startX,
                startY: this._startY,
                last: null,
            });
            this._startX = pointerEventState.point.x;
            this._startY = pointerEventState.point.y;
            this._startDragState = pointerEventState;
            this._lastDragState = pointerEventState;
            this._lastPointerDownEvent = event;
            this._dispatcher.run('pointerDown', UIEventStateContext.from(pointerEventState));
            this._dispatcher.disposables.addFromEvent(document, 'pointermove', this._move);
            this._dispatcher.disposables.addFromEvent(document, 'pointerup', this._up);
        };
        this._up = (event) => {
            const pointerEventState = new PointerEventState({
                event,
                rect: this._rect,
                startX: this._startX,
                startY: this._startY,
                last: this._lastDragState,
            });
            const context = UIEventStateContext.from(pointerEventState);
            const run = () => {
                if (this._dragging) {
                    this._dispatcher.run('dragEnd', context);
                    return;
                }
                this._dispatcher.run('click', context);
                if (this._pointerDownCount === 2) {
                    this._dispatcher.run('doubleClick', context);
                }
                if (this._pointerDownCount === 3) {
                    this._dispatcher.run('tripleClick', context);
                }
            };
            run();
            this._dispatcher.run('pointerUp', context);
            this._reset();
            document.removeEventListener('pointermove', this._move);
            document.removeEventListener('pointerup', this._up);
        };
        this._move = (event) => {
            const last = this._lastDragState;
            const state = new PointerEventState({
                event,
                rect: this._rect,
                startX: this._startX,
                startY: this._startY,
                last,
            });
            this._lastDragState = state;
            assertExists(this._startDragState);
            if (!this._dragging && isFarEnough(this._startDragState.raw, state.raw)) {
                this._dragging = true;
                this._dispatcher.run('dragStart', UIEventStateContext.from(this._startDragState));
            }
            if (this._dragging) {
                this._dispatcher.run('dragMove', UIEventStateContext.from(state));
            }
        };
        this._moveOn = (event) => {
            const state = new PointerEventState({
                event,
                rect: this._rect,
                startX: this._startX,
                startY: this._startY,
                last: this._lastDragState,
            });
            this._dispatcher.run('pointerMove', UIEventStateContext.from(state));
        };
        this._out = (event) => {
            const state = new PointerEventState({
                event,
                rect: this._rect,
                startX: -Infinity,
                startY: -Infinity,
                last: null,
            });
            this._dispatcher.run('pointerOut', UIEventStateContext.from(state));
        };
    }
    listen() {
        this._dispatcher.disposables.addFromEvent(this._dispatcher.root, 'pointerdown', this._down);
        this._dispatcher.disposables.addFromEvent(this._dispatcher.root, 'pointermove', this._moveOn);
        this._dispatcher.disposables.addFromEvent(this._dispatcher.root, 'pointerout', this._out);
    }
    get _rect() {
        return this._dispatcher.root.getBoundingClientRect();
    }
}
//# sourceMappingURL=pointer.js.map