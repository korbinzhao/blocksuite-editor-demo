var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { activeEditorManager, edgelessPreset, getPageBlock, getServiceOrRegister, pagePreset, ThemeObserver, } from '@blocksuite/blocks';
import { BlockSuiteRoot, ShadowlessElement, WithDisposable, } from '@blocksuite/lit';
import { isFirefox, Slot } from '@blocksuite/store';
import { html } from 'lit';
import { customElement, property, query } from 'lit/decorators.js';
import { keyed } from 'lit/directives/keyed.js';
import { checkEditorElementActive, createBlockHub } from '../utils/editor.js';
BlockSuiteRoot;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function forwardSlot(from, to) {
    Object.entries(from).forEach(([key, slot]) => {
        const target = to[key];
        if (target) {
            slot.pipe(target);
        }
    });
}
let EditorContainer = class EditorContainer extends WithDisposable(ShadowlessElement) {
    constructor() {
        super(...arguments);
        this.mode = 'page';
        this.autofocus = false;
        this.themeObserver = new ThemeObserver();
        this.slots = {
            pageLinkClicked: new Slot(),
            pageModeSwitched: new Slot(),
        };
    }
    get model() {
        return this.page.root;
    }
    connectedCallback() {
        super.connectedCallback();
        activeEditorManager.setIfNoActive(this);
        const keydown = (e) => {
            if (e.altKey && e.metaKey && e.code === 'KeyC') {
                e.preventDefault();
            }
            // `esc`  clear selection
            if (e.code !== 'Escape') {
                return;
            }
            const pageModel = this.model;
            if (!pageModel)
                return;
            if (this.mode === 'page') {
                getPageBlock(pageModel)?.selection.clear();
            }
            const selection = getSelection();
            if (!selection || selection.isCollapsed || !checkEditorElementActive()) {
                return;
            }
            selection.removeAllRanges();
        };
        // Question: Why do we prevent this?
        if (isFirefox) {
            this._disposables.addFromEvent(document.body, 'keydown', keydown);
        }
        else {
            this._disposables.addFromEvent(window, 'keydown', keydown);
        }
        if (!this.page) {
            throw new Error('Missing page for EditorContainer!');
        }
        // connect mouse mode event changes
        // this._disposables.addFromEvent(
        //   window,
        //   'affine.switch-mouse-mode',
        //   ({ detail }) => {
        //     this.mouseMode = detail;
        //   }
        // );
        // subscribe store
        this._disposables.add(this.page.slots.rootAdded.on(() => {
            // add the 'page' as requesting property to
            // make sure the `forwardSlot` is called in `updated` lifecycle
            this.requestUpdate('page');
        }));
        this._disposables.add(this.page.slots.blockUpdated.on(async ({ type, id }) => {
            const block = this.page.getBlockById(id);
            if (!block)
                return;
            if (type === 'update') {
                const service = await getServiceOrRegister(block.flavour);
                service.updateEffect(block);
            }
        }));
        this.themeObserver.observer(document.documentElement);
        this._disposables.add(this.themeObserver);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        activeEditorManager.clearActive();
        this.page.awarenessStore.setLocalRange(this.page, null);
    }
    firstUpdated() {
        // todo: refactor to a better solution
        getServiceOrRegister('affine:code');
        if (this.mode === 'page') {
            setTimeout(() => {
                const defaultPage = this.querySelector('affine-default-page');
                if (this.autofocus) {
                    defaultPage?.titleVEditor.focusEnd();
                }
            });
        }
    }
    updated(changedProperties) {
        if (changedProperties.has('mode')) {
            this.slots.pageModeSwitched.emit(this.mode);
        }
        if (!changedProperties.has('page') && !changedProperties.has('mode')) {
            return;
        }
        requestAnimationFrame(() => {
            if (this._defaultPageBlock) {
                forwardSlot(this._defaultPageBlock.slots, this.slots);
            }
            if (this._edgelessPageBlock) {
                forwardSlot(this._edgelessPageBlock.slots, this.slots);
            }
        });
    }
    async createBlockHub() {
        await this.updateComplete;
        if (!this.page.root) {
            await new Promise(res => this.page.slots.rootAdded.once(res));
        }
        return createBlockHub(this, this.page);
    }
    render() {
        if (!this.model)
            return null;
        const rootContainer = keyed(this.model.id, html `<block-suite-root
        .page=${this.page}
        .componentMap=${this.mode === 'page' ? pagePreset : edgelessPreset}
      ></block-suite-root>`);
        const remoteSelectionContainer = html `
      <remote-selection .page=${this.page}></remote-selection>
    `;
        return html `
      <style>
        editor-container * {
          box-sizing: border-box;
        }
        editor-container,
        .affine-editor-container {
          display: block;
          height: 100%;
          position: relative;
          overflow: hidden;
          font-family: var(--affine-font-family);
          background: var(--affine-background-primary-color);
        }
        @media print {
          editor-container,
          .affine-editor-container {
            height: auto;
          }
        }
      </style>
      ${rootContainer} ${remoteSelectionContainer}
    `;
    }
};
__decorate([
    property()
], EditorContainer.prototype, "page", void 0);
__decorate([
    property()
], EditorContainer.prototype, "mode", void 0);
__decorate([
    property()
], EditorContainer.prototype, "autofocus", void 0);
__decorate([
    query('affine-default-page')
], EditorContainer.prototype, "_defaultPageBlock", void 0);
__decorate([
    query('affine-edgeless-page')
], EditorContainer.prototype, "_edgelessPageBlock", void 0);
EditorContainer = __decorate([
    customElement('editor-container')
], EditorContainer);
export { EditorContainer };
//# sourceMappingURL=editor-container.js.map