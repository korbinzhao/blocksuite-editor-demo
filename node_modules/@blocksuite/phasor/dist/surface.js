import { assertExists } from '@blocksuite/global/utils';
import { randomSeed } from 'roughjs/bin/math.js';
import * as Y from 'yjs';
import { ConnectorElement, ElementCtors, ElementDefaultProps, } from './elements/index.js';
import { compare } from './grid.js';
import { Renderer } from './renderer.js';
import { contains, getCommonBound } from './utils/bound.js';
import { intersects } from './utils/hit-utils.js';
import { generateElementId, generateKeyBetween, normalizeWheelDeltaY, } from './utils/std.js';
import { serializeXYWH } from './utils/xywh.js';
export class SurfaceManager {
    constructor(yContainer, computedValue = v => v) {
        this._elements = new Map();
        this._bindings = new Map();
        this.indexes = { min: 'a0', max: 'a0' };
        this._onYContainer = (event) => {
            // skip empty event
            if (event.changes.keys.size === 0)
                return;
            event.keysChanged.forEach(id => {
                const type = event.changes.keys.get(id);
                if (!type) {
                    console.error('invalid event', event);
                    return;
                }
                if (type.action === 'add') {
                    const yElement = this._yContainer.get(id);
                    const type = yElement.get('type');
                    const ElementCtor = ElementCtors[type];
                    assertExists(ElementCtor);
                    const element = new ElementCtor(yElement, this);
                    element.computedValue = this._computedValue;
                    element.mount(this._renderer);
                    this._elements.set(element.id, element);
                    if (element.index > this.indexes.max) {
                        this.indexes.max = element.index;
                    }
                    this._updateBindings(element);
                }
                else if (type.action === 'update') {
                    console.error('update event on yElements is not supported', event);
                }
                else if (type.action === 'delete') {
                    const element = this._elements.get(id);
                    assertExists(element);
                    element.unmount();
                    this._elements.delete(id);
                    if (element.index === this.indexes.min) {
                        this.indexes.min = generateKeyBetween(element.index, null);
                    }
                }
            });
        };
        this._renderer = new Renderer();
        this._yContainer = yContainer;
        this._computedValue = computedValue;
        this._syncFromExistingContainer();
        this._yContainer.observe(this._onYContainer);
    }
    get viewport() {
        return this._renderer;
    }
    _addBinding(id0, id1) {
        if (!this._bindings.has(id0)) {
            this._bindings.set(id0, new Set());
        }
        this._bindings.get(id0)?.add(id1);
    }
    _updateBindings(element) {
        if (element instanceof ConnectorElement) {
            if (element.startElement) {
                this._addBinding(element.startElement.id, element.id);
                this._addBinding(element.id, element.startElement.id);
            }
            if (element.endElement) {
                this._addBinding(element.endElement.id, element.id);
                this._addBinding(element.id, element.endElement.id);
            }
        }
    }
    _syncFromExistingContainer() {
        this._transact(() => {
            this._yContainer.forEach(yElement => {
                const type = yElement.get('type');
                const ElementCtor = ElementCtors[type];
                assertExists(ElementCtor);
                const element = new ElementCtor(yElement, this);
                element.computedValue = this._computedValue;
                element.mount(this._renderer);
                this._elements.set(element.id, element);
                if (element.index > this.indexes.max) {
                    this.indexes.max = element.index;
                }
                else if (element.index < this.indexes.min) {
                    this.indexes.min = element.index;
                }
                this._updateBindings(element);
            });
        });
    }
    _transact(callback) {
        const doc = this._yContainer.doc;
        doc.transact(callback, doc.clientID);
    }
    refresh() {
        this._renderer.refresh();
    }
    updateIndexes(keys, elements, callback) {
        this._transact(() => {
            let newIndex;
            let i = 0;
            const len = elements.length;
            for (; i < len; i++) {
                newIndex = keys[i];
                const yElement = this._yContainer.get(elements[i].id);
                const oldIndex = yElement.get('index');
                if (oldIndex === newIndex)
                    continue;
                yElement.set('index', newIndex);
            }
            callback(keys);
        });
    }
    attach(container) {
        this._renderer.attach(container);
    }
    onResize() {
        this._renderer.onResize();
    }
    getElementsBound() {
        return getCommonBound([...this._elements.values()]);
    }
    addElement(type, properties) {
        const id = generateElementId();
        const yMap = new Y.Map();
        const defaultProps = ElementDefaultProps[type];
        const props = {
            ...defaultProps,
            ...properties,
            id,
            index: generateKeyBetween(this.indexes.max, null),
            seed: randomSeed(),
        };
        this._transact(() => {
            for (const [key, value] of Object.entries(props)) {
                if (key === 'text' && !(value instanceof Y.Text)) {
                    yMap.set(key, new Y.Text(value));
                }
                else {
                    yMap.set(key, value);
                }
            }
            this._yContainer.set(id, yMap);
        });
        return id;
    }
    updateElement(id, properties) {
        this._transact(() => {
            const element = this._elements.get(id);
            assertExists(element);
            element.applyUpdate(properties);
        });
    }
    setElementBound(id, bound) {
        this.updateElement(id, {
            xywh: serializeXYWH(bound.x, bound.y, bound.w, bound.h),
        });
    }
    removeElement(id) {
        this._transact(() => {
            this._yContainer.delete(id);
        });
    }
    hasElement(id) {
        return this._yContainer.has(id);
    }
    toModelCoord(viewX, viewY) {
        return this._renderer.toModelCoord(viewX, viewY);
    }
    toViewCoord(modelX, modelY) {
        return this._renderer.toViewCoord(modelX, modelY);
    }
    pickById(id) {
        return this._elements.get(id);
    }
    pickByPoint(x, y, options) {
        const bound = { x: x - 1, y: y - 1, w: 2, h: 2 };
        const candidates = this._renderer.gridManager.search(bound);
        const picked = candidates.filter(element => {
            return element.hitTest(x, y, options);
        });
        return picked;
    }
    pickTop(x, y) {
        const results = this.pickByPoint(x, y);
        return results[results.length - 1] ?? null;
    }
    pickByBound(bound) {
        const candidates = this._renderer.gridManager.search(bound);
        const picked = candidates.filter((element) => {
            return contains(bound, element) || intersects(bound, element);
        });
        return picked;
    }
    getSortedElementsWithViewportBounds() {
        return this.pickByBound(this.viewport.viewportBounds).sort(compare);
    }
    getBindingElements(id) {
        const bindingIds = this._bindings.get(id);
        if (!bindingIds?.size) {
            return [];
        }
        return [...bindingIds.values()]
            .map(bindingId => this.pickById(bindingId))
            .filter(e => !!e);
    }
    dispose() {
        this._yContainer.unobserve(this._onYContainer);
    }
    /** @internal Only for testing */
    initDefaultGestureHandler() {
        const { _renderer } = this;
        _renderer.canvas.addEventListener('wheel', e => {
            e.preventDefault();
            // pan
            if (!e.ctrlKey) {
                const dx = e.deltaX / _renderer.zoom;
                const dy = e.deltaY / _renderer.zoom;
                _renderer.setCenter(_renderer.centerX + dx, _renderer.centerY + dy);
            }
            // zoom
            else {
                const zoom = normalizeWheelDeltaY(e.deltaY);
                _renderer.setZoom(zoom);
            }
        });
    }
    getElements() {
        return [...this._elements.values()];
    }
}
//# sourceMappingURL=surface.js.map