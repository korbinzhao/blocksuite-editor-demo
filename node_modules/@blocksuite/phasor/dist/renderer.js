import { clamp, Point } from '@blocksuite/blocks/std';
import { assertNotExists } from '@blocksuite/global/utils';
import { RoughCanvas } from 'roughjs/bin/canvas.js';
import { ZOOM_MAX, ZOOM_MIN } from './consts.js';
import { GridManager } from './grid.js';
import { intersects } from './utils/hit-utils.js';
export class Renderer {
    constructor() {
        this.gridManager = new GridManager();
        this._left = 0;
        this._top = 0;
        this._width = 0;
        this._height = 0;
        this._zoom = 1.0;
        this._center = new Point();
        this._shouldUpdate = false;
        this.applyDeltaCenter = (deltaX, deltaY) => {
            this.setCenter(this.centerX + deltaX, this.centerY + deltaY);
        };
        const canvas = document.createElement('canvas');
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d');
        this.rc = new RoughCanvas(canvas);
    }
    get left() {
        return this._left;
    }
    get top() {
        return this._top;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get zoom() {
        return this._zoom;
    }
    get centerX() {
        return this._center.x;
    }
    get centerY() {
        return this._center.y;
    }
    get center() {
        return this._center;
    }
    get viewportX() {
        const { centerX, width, zoom } = this;
        return centerX - width / 2 / zoom;
    }
    get viewportY() {
        const { centerY, height, zoom } = this;
        return centerY - height / 2 / zoom;
    }
    get viewportMinXY() {
        const { centerX, centerY, width, height, zoom } = this;
        return {
            x: centerX - width / 2 / zoom,
            y: centerY - height / 2 / zoom,
        };
    }
    get viewportMaxXY() {
        const { centerX, centerY, width, height, zoom } = this;
        return {
            x: centerX + width / 2 / zoom,
            y: centerY + height / 2 / zoom,
        };
    }
    get viewportBounds() {
        const { viewportMinXY, viewportMaxXY } = this;
        return {
            ...viewportMinXY,
            w: viewportMaxXY.x - viewportMinXY.x,
            h: viewportMaxXY.y - viewportMinXY.y,
        };
    }
    toModelCoord(viewX, viewY) {
        const { viewportX, viewportY, zoom } = this;
        return [viewportX + viewX / zoom, viewportY + viewY / zoom];
    }
    toViewCoord(logicalX, logicalY) {
        const { viewportX, viewportY, zoom } = this;
        return [(logicalX - viewportX) * zoom, (logicalY - viewportY) * zoom];
    }
    setCenter(centerX, centerY) {
        this._center.set(centerX, centerY);
        this._shouldUpdate = true;
    }
    /**
     *
     * @param zoom zoom
     * @param focusPoint canvas coordinate
     */
    setZoom(zoom, focusPoint) {
        const prevZoom = this.zoom;
        focusPoint = focusPoint ?? this._center;
        this._zoom = clamp(zoom, ZOOM_MIN, ZOOM_MAX);
        const newZoom = this.zoom;
        const offset = this.center.subtract(focusPoint);
        const newCenter = focusPoint.add(offset.scale(prevZoom / newZoom));
        this.setCenter(newCenter.x, newCenter.y);
        this._shouldUpdate = true;
    }
    addElement(element) {
        this.gridManager.add(element);
        this._shouldUpdate = true;
    }
    removeElement(element) {
        this.gridManager.remove(element);
        this._shouldUpdate = true;
    }
    load(elements) {
        for (let i = 0; i < elements.length; i++) {
            this.gridManager.add(elements[i]);
        }
        this._shouldUpdate = true;
    }
    refresh() {
        this._shouldUpdate = true;
    }
    attach(container) {
        assertNotExists(this._container, 'Phasor surface is attached multiple times');
        this._container = container;
        container.appendChild(this.canvas);
        this._resetSize();
        this._loop();
    }
    onResize() {
        const oldWidth = this.width;
        const oldHeight = this.height;
        this._resetSize();
        this.setCenter(this.centerX - (oldWidth - this.width) / 2, this.centerY - (oldHeight - this.height) / 2);
        // Re-render once the canvas size changed. Otherwise it will flicker.
        // Because the observer will be called after DOM element rendered,
        // by the time the canvas content is stale.
        this._render();
        this._shouldUpdate = false;
    }
    _resetSize() {
        const { canvas } = this;
        const dpr = window.devicePixelRatio;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        const bbox = canvas.getBoundingClientRect();
        canvas.width = Math.ceil(bbox.width * dpr);
        canvas.height = Math.ceil(bbox.height * dpr);
        this._left = bbox.left;
        this._top = bbox.top;
        this._width = bbox.width;
        this._height = bbox.height;
        this._shouldUpdate = true;
    }
    _loop() {
        requestAnimationFrame(() => {
            if (this._shouldUpdate) {
                this._render();
            }
            this._shouldUpdate = false;
            this._loop();
        });
    }
    _render() {
        const { ctx, gridManager, viewportBounds, width, height, rc, zoom } = this;
        const dpr = window.devicePixelRatio;
        ctx.clearRect(0, 0, width * dpr, height * dpr);
        ctx.save();
        ctx.setTransform(zoom * dpr, 0, 0, zoom * dpr, 0, 0);
        const elements = gridManager.search(viewportBounds);
        for (const element of elements) {
            const dx = element.x - viewportBounds.x;
            const dy = element.y - viewportBounds.y;
            ctx.save();
            ctx.translate(dx, dy);
            if (intersects(element, viewportBounds) && element.display) {
                element.render(ctx, rc);
            }
            ctx.restore();
        }
        ctx.restore();
    }
}
//# sourceMappingURL=renderer.js.map