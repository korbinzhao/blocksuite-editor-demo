import { SurfaceElement } from '../surface-element.js';
import { deltaInsertsToChunks, getFontString, getTextWidth, isRTL, } from './utils.js';
export class TextElement extends SurfaceElement {
    constructor() {
        super(...arguments);
        this._maxTextWidth = 0;
        this._maxTextHeight = 0;
        this._lineHeight = 0;
        this._lines = [];
    }
    get text() {
        return this.yMap.get('text');
    }
    get color() {
        return this.yMap.get('color');
    }
    get fontSize() {
        return this.yMap.get('fontSize');
    }
    get fontFamily() {
        return this.yMap.get('fontFamily');
    }
    get textAlign() {
        return this.yMap.get('textAlign');
    }
    get minWidth() {
        return this._maxTextWidth;
    }
    get minHeight() {
        return this._maxTextHeight;
    }
    get lineHeight() {
        return this._lineHeight;
    }
    get lines() {
        return this._lines;
    }
    render(ctx) {
        const { w, text, color, fontSize, fontFamily, textAlign } = this;
        const yText = text;
        const deltas = yText.toDelta();
        const lines = deltaInsertsToChunks(deltas);
        this._lines = lines;
        const lineHeightPx = this.h / lines.length;
        const font = getFontString({
            fontSize: fontSize,
            lineHeight: `${lineHeightPx}px`,
            fontFamily: fontFamily,
        });
        this._lineHeight = lineHeightPx;
        const horizontalOffset = textAlign === 'center' ? w / 2 : textAlign === 'right' ? w : 0;
        for (const [lineIndex, line] of lines.entries()) {
            let beforeTextWidth = 0;
            for (const delta of line) {
                ctx.save();
                const str = delta.insert;
                const rtl = isRTL(str);
                const shouldTemporarilyAttach = rtl && !ctx.canvas.isConnected;
                if (shouldTemporarilyAttach) {
                    // to correctly render RTL text mixed with LTR, we have to append it
                    // to the DOM
                    document.body.appendChild(ctx.canvas);
                }
                ctx.canvas.setAttribute('dir', rtl ? 'rtl' : 'ltr');
                ctx.font = font;
                ctx.fillStyle = this.computedValue(color);
                ctx.textAlign = textAlign;
                ctx.textBaseline = 'ideographic';
                ctx.fillText(str, horizontalOffset + beforeTextWidth, (lineIndex + 1) * lineHeightPx);
                beforeTextWidth += getTextWidth(str, fontFamily);
                if (shouldTemporarilyAttach) {
                    ctx.canvas.remove();
                }
                ctx.restore();
            }
            if (beforeTextWidth > this._maxTextWidth) {
                this._maxTextWidth = beforeTextWidth;
            }
        }
        if (this._maxTextHeight < lines.length * lineHeightPx) {
            this._maxTextHeight = lines.length * lineHeightPx;
        }
    }
}
//# sourceMappingURL=text-element.js.map