import type { NullablePartial } from '@blocksuite/global/types';
import { Slot } from '@blocksuite/global/utils';
import type * as Y from 'yjs';
import type { VirgoLine } from './components/index.js';
import { VirgoAttributeService, VirgoDeltaService, VirgoEventService, VirgoRangeService } from './services/index.js';
import type { DeltaInsert, TextPoint, VRange, VRangeUpdatedProp } from './types.js';
import { type BaseTextAttributes, nativePointToTextPoint, textPointToDomPoint } from './utils/index.js';
import { getTextNodesFromElement } from './utils/text.js';
type VirgoElement<T extends BaseTextAttributes = BaseTextAttributes> = HTMLElement & {
    virgoEditor: VEditor<T>;
};
export declare class VEditor<TextAttributes extends BaseTextAttributes = BaseTextAttributes> {
    static nativePointToTextPoint: typeof nativePointToTextPoint;
    static textPointToDomPoint: typeof textPointToDomPoint;
    static getTextNodesFromElement: typeof getTextNodesFromElement;
    private readonly _yText;
    private readonly _isActive;
    private _rootElement;
    private _isReadonly;
    private _eventService;
    private _rangeService;
    private _attributeService;
    private _deltaService;
    shouldLineScrollIntoView: boolean;
    shouldCursorScrollIntoView: boolean;
    slots: {
        mounted: Slot;
        unmounted: Slot;
        updated: Slot;
        vRangeUpdated: Slot<VRangeUpdatedProp>;
        rangeUpdated: Slot<Range>;
        scrollUpdated: Slot<number>;
    };
    get yText(): Y.Text;
    get rootElement(): VirgoElement<TextAttributes>;
    get eventService(): VirgoEventService<TextAttributes>;
    get rangeService(): VirgoRangeService<TextAttributes>;
    get attributeService(): VirgoAttributeService<TextAttributes>;
    get deltaService(): VirgoDeltaService<TextAttributes>;
    get marks(): TextAttributes | null;
    setAttributeSchema: (schema: import("zod").ZodType<TextAttributes, import("zod").ZodTypeDef, unknown>) => void;
    setAttributeRenderer: (renderer: import("./types.js").AttributeRenderer<TextAttributes>) => void;
    setMarks: (marks: TextAttributes) => void;
    resetMarks: () => void;
    getFormat: (vRange: VRange, loose?: boolean) => TextAttributes;
    bindHandlers: (handlers?: {
        keydown?: ((event: KeyboardEvent) => void) | undefined;
        paste?: ((event: ClipboardEvent) => void) | undefined;
        virgoInput?: ((ctx: import("./services/event.js").VHandlerContext<TextAttributes, InputEvent>) => import("./services/event.js").VHandlerContext<TextAttributes, InputEvent>) | undefined;
        virgoCompositionEnd?: ((ctx: import("./services/event.js").VHandlerContext<TextAttributes, CompositionEvent>) => import("./services/event.js").VHandlerContext<TextAttributes, CompositionEvent>) | undefined;
    }) => void;
    toDomRange: (vRange: VRange) => Range | null;
    toVRange: (selection: Selection) => VRange | null;
    getVRange: () => VRange | null;
    setVRange: (vRange: VRange) => void;
    syncVRange: () => void;
    getDeltasByVRange: (vRange: VRange) => import("./types.js").DeltaEntry<TextAttributes>[];
    getDeltaByRangeIndex: (rangeIndex: number) => DeltaInsert<TextAttributes> | null;
    mapDeltasInVRange: <Result>(vRange: VRange, callback: (delta: DeltaInsert<TextAttributes>, index: number) => Result) => Result[];
    constructor(yText: VEditor['yText'], ops?: {
        active?: () => boolean;
    });
    mount(rootElement: HTMLElement): void;
    unmount(): void;
    requestUpdate(): void;
    getNativeSelection(): Selection | null;
    getTextPoint(rangeIndex: VRange['index']): TextPoint;
    getLine(rangeIndex: VRange['index']): readonly [VirgoLine, number];
    setReadonly(isReadonly: boolean): void;
    get isReadonly(): boolean;
    get isActive(): boolean;
    /**
     * the vRange is synced to the native selection asynchronically
     */
    focusEnd(): void;
    deleteText(vRange: VRange): void;
    insertText(vRange: VRange, text: string, attributes?: TextAttributes): void;
    insertLineBreak(vRange: VRange): void;
    formatText(vRange: VRange, attributes: NullablePartial<TextAttributes>, options?: {
        match?: (delta: DeltaInsert, deltaVRange: VRange) => boolean;
        mode?: 'replace' | 'merge';
    }): void;
    resetText(vRange: VRange): void;
    setText(text: string, attributes?: TextAttributes): void;
    private _onYTextChange;
    private _transact;
}
export {};
//# sourceMappingURL=virgo.d.ts.map