import { assertExists, Slot } from '@blocksuite/global/utils';
import { VirgoAttributeService, VirgoDeltaService, VirgoEventService, VirgoRangeService, } from './services/index.js';
import { findDocumentOrShadowRoot, nativePointToTextPoint, textPointToDomPoint, } from './utils/index.js';
import { calculateTextLength, getTextNodesFromElement } from './utils/text.js';
class VEditor {
    get yText() {
        return this._yText;
    }
    get rootElement() {
        assertExists(this._rootElement);
        return this._rootElement;
    }
    get eventService() {
        return this._eventService;
    }
    get rangeService() {
        return this._rangeService;
    }
    get attributeService() {
        return this._attributeService;
    }
    get deltaService() {
        return this._deltaService;
    }
    // Expose attribute service API
    get marks() {
        return this._attributeService.marks;
    }
    constructor(yText, ops) {
        this._rootElement = null;
        this._isReadonly = false;
        this._eventService = new VirgoEventService(this);
        this._rangeService = new VirgoRangeService(this);
        this._attributeService = new VirgoAttributeService(this);
        this._deltaService = new VirgoDeltaService(this);
        this.shouldLineScrollIntoView = true;
        this.shouldCursorScrollIntoView = true;
        this.setAttributeSchema = this._attributeService.setAttributeSchema;
        this.setAttributeRenderer = this._attributeService.setAttributeRenderer;
        this.setMarks = this._attributeService.setMarks;
        this.resetMarks = this._attributeService.resetMarks;
        this.getFormat = this._attributeService.getFormat;
        // Expose event service API
        this.bindHandlers = this._eventService.bindHandlers;
        // Expose range service API
        this.toDomRange = this.rangeService.toDomRange;
        this.toVRange = this.rangeService.toVRange;
        this.getVRange = this.rangeService.getVRange;
        this.setVRange = this.rangeService.setVRange;
        this.syncVRange = this.rangeService.syncVRange;
        // Expose delta service API
        this.getDeltasByVRange = this.deltaService.getDeltasByVRange;
        this.getDeltaByRangeIndex = this.deltaService.getDeltaByRangeIndex;
        this.mapDeltasInVRange = this.deltaService.mapDeltasInVRange;
        this._onYTextChange = () => {
            if (this.yText.toString().includes('\r')) {
                throw new Error('yText must not contain \r because it will break the range synchronization');
            }
            Promise.resolve().then(() => {
                assertExists(this._rootElement);
                this.deltaService.render();
            });
        };
        if (!yText.doc) {
            throw new Error('yText must be attached to a Y.Doc');
        }
        if (yText.toString().includes('\r')) {
            throw new Error('yText must not contain \r because it will break the range synchronization');
        }
        this._yText = yText;
        this._isActive = ops?.active ?? (() => true);
        this.slots = {
            mounted: new Slot(),
            unmounted: new Slot(),
            updated: new Slot(),
            vRangeUpdated: new Slot(),
            rangeUpdated: new Slot(),
            scrollUpdated: new Slot(),
        };
        this.slots.vRangeUpdated.on(this.rangeService.onVRangeUpdated);
        this.slots.scrollUpdated.on(this.rangeService.onScrollUpdated);
    }
    mount(rootElement) {
        const virgoElement = rootElement;
        virgoElement.virgoEditor = this;
        this._rootElement = virgoElement;
        this._rootElement.replaceChildren();
        this._rootElement.contentEditable = 'true';
        this._rootElement.dataset.virgoRoot = 'true';
        this.yText.observe(this._onYTextChange);
        this._deltaService.render();
        this._eventService.mount();
        this.slots.mounted.emit();
    }
    unmount() {
        this._eventService.unmount();
        this.yText.unobserve(this._onYTextChange);
        this._rootElement?.replaceChildren();
        this._rootElement = null;
        this.slots.unmounted.emit();
    }
    requestUpdate() {
        Promise.resolve().then(() => {
            assertExists(this._rootElement);
            this._deltaService.render();
        });
    }
    getNativeSelection() {
        const selectionRoot = findDocumentOrShadowRoot(this);
        const selection = selectionRoot.getSelection();
        if (!selection)
            return null;
        if (selection.rangeCount === 0)
            return null;
        return selection;
    }
    getTextPoint(rangeIndex) {
        assertExists(this._rootElement);
        const vLines = Array.from(this._rootElement.querySelectorAll('v-line'));
        let index = 0;
        for (const vLine of vLines) {
            const texts = VEditor.getTextNodesFromElement(vLine);
            for (const text of texts) {
                if (!text.textContent) {
                    throw new Error('text element should have textContent');
                }
                if (index + text.textContent.length >= rangeIndex) {
                    return [text, rangeIndex - index];
                }
                index += calculateTextLength(text);
            }
            index += 1;
        }
        throw new Error('failed to find leaf');
    }
    // the number is related to the VirgoLine's textLength
    getLine(rangeIndex) {
        assertExists(this._rootElement);
        const lineElements = Array.from(this._rootElement.querySelectorAll('v-line'));
        let index = 0;
        for (const lineElement of lineElements) {
            if (rangeIndex >= index && rangeIndex <= index + lineElement.textLength) {
                return [lineElement, rangeIndex - index];
            }
            if (rangeIndex === index + lineElement.textLength &&
                rangeIndex === this.yText.length) {
                return [lineElement, rangeIndex - index];
            }
            index += lineElement.textLength + 1;
        }
        throw new Error('failed to find line');
    }
    setReadonly(isReadonly) {
        this.rootElement.contentEditable = isReadonly ? 'false' : 'true';
        this._isReadonly = isReadonly;
    }
    get isReadonly() {
        return this._isReadonly;
    }
    get isActive() {
        return this._isActive();
    }
    /**
     * the vRange is synced to the native selection asynchronically
     */
    focusEnd() {
        this.rangeService.setVRange({
            index: this.yText.length,
            length: 0,
        });
    }
    deleteText(vRange) {
        this._transact(() => {
            this.yText.delete(vRange.index, vRange.length);
        });
    }
    insertText(vRange, text, attributes = {}) {
        if (this._attributeService.marks) {
            attributes = { ...attributes, ...this._attributeService.marks };
        }
        const normalizedAttributes = this._attributeService.normalizeAttributes(attributes);
        if (!text || !text.length) {
            throw new Error('text must not be empty');
        }
        this._transact(() => {
            this.yText.delete(vRange.index, vRange.length);
            this.yText.insert(vRange.index, text, normalizedAttributes);
        });
    }
    insertLineBreak(vRange) {
        this._transact(() => {
            this.yText.delete(vRange.index, vRange.length);
            this.yText.insert(vRange.index, '\n');
        });
    }
    formatText(vRange, attributes, options = {}) {
        const { match = () => true, mode = 'merge' } = options;
        const deltas = this._deltaService.getDeltasByVRange(vRange);
        deltas
            .filter(([delta, deltaVRange]) => match(delta, deltaVRange))
            .forEach(([delta, deltaVRange]) => {
            const targetVRange = this._rangeService.mergeRanges(vRange, deltaVRange);
            if (mode === 'replace') {
                this.resetText(targetVRange);
            }
            this._transact(() => {
                this.yText.format(targetVRange.index, targetVRange.length, attributes);
            });
        });
    }
    resetText(vRange) {
        const coverDeltas = [];
        for (let i = vRange.index; i <= vRange.index + vRange.length; i++) {
            const delta = this.getDeltaByRangeIndex(i);
            if (delta) {
                coverDeltas.push(delta);
            }
        }
        const unset = Object.fromEntries(coverDeltas.flatMap(delta => delta.attributes
            ? Object.keys(delta.attributes).map(key => [key, null])
            : []));
        this._transact(() => {
            this.yText.format(vRange.index, vRange.length, {
                ...unset,
            });
        });
    }
    setText(text, attributes = {}) {
        this._transact(() => {
            this.yText.delete(0, this.yText.length);
            this.yText.insert(0, text, attributes);
        });
    }
    _transact(fn) {
        const doc = this.yText.doc;
        if (!doc) {
            throw new Error('yText is not attached to a doc');
        }
        doc.transact(fn, doc.clientID);
    }
}
VEditor.nativePointToTextPoint = nativePointToTextPoint;
VEditor.textPointToDomPoint = textPointToDomPoint;
VEditor.getTextNodesFromElement = getTextNodesFromElement;
export { VEditor };
//# sourceMappingURL=virgo.js.map