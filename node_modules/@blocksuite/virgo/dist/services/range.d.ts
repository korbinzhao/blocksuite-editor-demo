import type { VRange } from '../types.js';
import type { VRangeUpdatedProp } from '../types.js';
import { type BaseTextAttributes } from '../utils/index.js';
import type { VEditor } from '../virgo.js';
export declare class VirgoRangeService<TextAttributes extends BaseTextAttributes> {
    private readonly _editor;
    private _vRange;
    private _lastScrollLeft;
    constructor(editor: VEditor<TextAttributes>);
    onVRangeUpdated: ([newVRange, origin]: VRangeUpdatedProp) => void;
    getVRange: () => VRange | null;
    /**
     * the vRange is synced to the native selection asynchronically
     */
    setVRange: (vRange: VRange) => void;
    /**
     * sync the dom selection from vRange for **this Editor**
     */
    syncVRange: () => void;
    /**
     * calculate the dom selection from vRange for **this Editor**
     */
    toDomRange: (vRange: VRange) => Range | null;
    /**
     * calculate the vRange from dom selection for **this Editor**
     * there are three cases when the vRange of this Editor is not null:
     * (In the following, "|" mean anchor and focus, each line is a separate Editor)
     * 1. anchor and focus are in this Editor
     *    aaaaaa
     *    b|bbbb|b
     *    cccccc
     *    the vRange of second Editor is {index: 1, length: 4}, the others are null
     * 2. anchor and focus one in this Editor, one in another Editor
     *    aaa|aaa    aaaaaa
     *    bbbbb|b or bbbbb|b
     *    cccccc     cc|cccc
     *    2.1
     *        the vRange of first Editor is {index: 3, length: 3}, the second is {index: 0, length: 5},
     *        the third is null
     *    2.2
     *        the vRange of first Editor is null, the second is {index: 5, length: 1},
     *        the third is {index: 0, length: 2}
     * 3. anchor and focus are in another Editor
     *    aa|aaaa
     *    bbbbbb
     *    cccc|cc
     *    the vRange of first Editor is {index: 2, length: 4},
     *    the second is {index: 0, length: 6}, the third is {index: 0, length: 4}
     */
    toVRange: (selection: Selection) => VRange | null;
    mergeRanges: (range1: VRange, range2: VRange) => VRange;
    onScrollUpdated: (scrollLeft: number) => void;
    private _applyVRange;
    private _scrollLineIntoViewIfNeeded;
    private _scrollCursorIntoViewIfNeeded;
}
//# sourceMappingURL=range.d.ts.map