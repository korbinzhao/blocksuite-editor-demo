import { DisposableGroup } from '@blocksuite/store';
import { getService } from '../../../__internal__/service.js';
import { resetNativeSelection } from '../../../std.js';
import { getCellCoord } from '../components/selection/utils.js';
const CELL_SELECTION_MOVE_KEYS = [
    'Tab',
    'Enter',
    'ArrowUp',
    'ArrowDown',
    'ArrowLeft',
    'ArrowRight',
];
const CELL_SELECTION_ENTER_KEYS = ['Tab', 'Escape'];
export class CellSelectionManager {
    constructor(dispatcher, model) {
        this._disposables = new DisposableGroup();
        this._service = null;
        this._onClick = (ctx) => {
            this._service?.clearCellLevelSelection();
        };
        this._onCellSelectionMove = (ctx) => {
            const e = ctx.get('keyboardState');
            const event = e.raw;
            if (CELL_SELECTION_MOVE_KEYS.indexOf(event.key) <= -1)
                return;
            const service = getService('affine:database');
            const cellSelection = service.getLastCellSelection();
            if (!cellSelection)
                return;
            event.preventDefault();
            const { databaseId, coords } = cellSelection;
            if (event.key === 'Enter') {
                // enter editing state
                service.setCellSelection({
                    type: 'edit',
                    coords,
                    databaseId,
                });
            }
            else {
                // set cell selection
                const nextCoord = getCellCoord(coords[0], databaseId, event.key);
                service.setCellSelection({
                    type: 'select',
                    coords: [nextCoord],
                    databaseId,
                });
            }
            return true;
        };
        this._add = (name, fn) => {
            this._disposables.add(this._dispatcher.add(name, fn));
        };
        this.onCellSelectionChange = (event) => {
            if (!isValidKey(event.key))
                return;
            event.preventDefault();
            event.stopPropagation();
            const element = event.target;
            selectCellByElement(element, this._model.id, event.key);
        };
        this._dispatcher = dispatcher;
        this._model = model;
        this._service = getService('affine:database');
        this._add('click', this._onClick);
        this._add('keyDown', this._onCellSelectionMove);
    }
    dispose() {
        this._disposables.dispose();
    }
}
function isValidKey(key) {
    return CELL_SELECTION_ENTER_KEYS.indexOf(key) > -1;
}
export function selectCellByElement(element, databaseId, key) {
    const rowsContainer = element.closest('.affine-database-block-rows');
    const currentCell = element.closest('.database-cell');
    if (!rowsContainer)
        return;
    if (!currentCell)
        return;
    const editor = currentCell.querySelector('.virgo-editor');
    editor?.blur();
    resetNativeSelection(null);
    const nextCoord = getCellCoord(currentCell, databaseId, key);
    const service = getService('affine:database');
    // TODO
    // Maybe we can no longer trigger the cell selection logic after selecting the row selection.
    const hasRowSelection = service.getLastRowSelection() !== null;
    if (hasRowSelection)
        return;
    service.setCellSelection({
        type: 'select',
        coords: [nextCoord],
        databaseId,
    });
}
//# sourceMappingURL=cell.js.map