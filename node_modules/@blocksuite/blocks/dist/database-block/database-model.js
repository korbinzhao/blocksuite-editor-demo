import { Text } from '@blocksuite/store';
import { BaseBlockModel, defineBlockSchema } from '@blocksuite/store';
import { literal } from 'lit/static-html.js';
import { DEFAULT_TITLE } from './table/consts.js';
export class DatabaseBlockModel extends BaseBlockModel {
    onCreated() {
        super.onCreated();
        this.page.slots.onYEvent.on(({ event }) => {
            if (event.path.includes(this.id) &&
                (event.path.includes('prop:columns') ||
                    event.path.includes('prop:cells'))) {
                this.propsUpdated.emit();
            }
        });
    }
    applyColumnUpdate() {
        this.page.updateBlock(this, {
            columns: this.columns,
        });
    }
    applyCellsUpdate() {
        this.page.updateBlock(this, {
            cells: this.cells,
        });
    }
    findColumnIndex(id) {
        let result = -1;
        this.columns.forEach((col, index) => {
            if (col.id === id)
                result = index;
        });
        return result;
    }
    getColumn(id) {
        const index = this.findColumnIndex(id);
        if (index < 0) {
            return null;
        }
        return this.columns[index];
    }
    addColumn(column, index) {
        const id = this.page.generateId();
        this.page.transact(() => {
            const col = { ...column, id };
            if (index === undefined) {
                this.columns.push(col);
            }
            else {
                this.columns.splice(index, 0, col);
            }
        });
        return id;
    }
    updateColumn(column) {
        const id = column.id ?? this.page.generateId();
        const index = this.findColumnIndex(id);
        this.page.transact(() => {
            if (index < 0) {
                this.columns.push({ ...column, id });
            }
            else {
                this.columns[index] = { ...column, id };
            }
        });
        return id;
    }
    moveColumn(from, to) {
        this.page.transact(() => {
            const column = this.columns[from];
            this.columns.splice(from, 1);
            this.columns.splice(to, 0, column);
        });
    }
    deleteColumn(columnId) {
        const index = this.findColumnIndex(columnId);
        if (index < 0)
            return;
        this.page.transact(() => this.columns.splice(index, 1));
    }
    getCell(rowId, columnId) {
        const yRow = this.cells[rowId];
        const yCell = yRow?.[columnId] ?? null;
        if (!yCell)
            return null;
        return {
            columnId: yCell.columnId,
            value: yCell.value,
        };
    }
    updateCell(rowId, cell) {
        const hasRow = rowId in this.cells;
        if (!hasRow) {
            this.cells[rowId] = {};
        }
        this.page.transact(() => {
            this.cells[rowId][cell.columnId] = {
                columnId: cell.columnId,
                value: cell.value,
            };
        });
    }
    copyCellsByColumn(fromId, toId) {
        this.page.transact(() => {
            Object.keys(this.cells).forEach(rowId => {
                const cell = this.cells[rowId][fromId];
                if (cell) {
                    this.cells[rowId][toId] = {
                        ...cell,
                        columnId: toId,
                    };
                }
            });
        });
    }
    deleteCellsByColumn(columnId) {
        this.page.transact(() => {
            Object.keys(this.cells).forEach(rowId => {
                delete this.cells[rowId][columnId];
            });
        });
    }
    convertCellsByColumn(columnId, newType) {
        this.page.transact(() => {
            Object.keys(this.cells).forEach(rowId => {
                const cell = this.cells[rowId][columnId];
                if (!cell)
                    return;
                const value = cell.value;
                if (!value)
                    return;
                if (newType === 'select') {
                    this.cells[rowId][columnId] = {
                        columnId,
                        value: [value[0]],
                    };
                    return;
                }
                if (newType === 'rich-text') {
                    const text = new Text(value + '');
                    this.cells[rowId][columnId] = {
                        columnId,
                        value: text.yText,
                    };
                    return;
                }
            });
        });
    }
    renameSelectedCellTag(columnId, oldValue, newValue) {
        this.page.transact(() => {
            Object.keys(this.cells).forEach(rowId => {
                const cell = this.cells[rowId][columnId];
                if (!cell)
                    return;
                const selected = cell.value;
                const newSelected = [...selected];
                const index = newSelected.findIndex(s => s.value === oldValue.value);
                newSelected[index] = newValue;
                this.cells[rowId][columnId].value = newSelected;
            });
        });
    }
    deleteSelectedCellTag(columnId, target) {
        this.page.transact(() => {
            Object.keys(this.cells).forEach(rowId => {
                const cell = this.cells[rowId][columnId];
                if (!cell)
                    return;
                const selected = cell.value;
                const newSelected = [...selected].filter(item => item.value !== target.value);
                this.cells[rowId][columnId] = {
                    columnId,
                    value: newSelected,
                };
            });
        });
    }
}
export const DatabaseBlockSchema = defineBlockSchema({
    flavour: 'affine:database',
    props: (internal) => ({
        mode: 'table',
        title: internal.Text(DEFAULT_TITLE),
        cells: {},
        columns: [],
        titleColumnName: 'Title',
        titleColumnWidth: 432,
    }),
    metadata: {
        role: 'hub',
        version: 1,
        tag: literal `affine-database`,
        parent: ['affine:frame'],
        children: ['affine:paragraph', 'affine:list'],
    },
    toModel: () => {
        return new DatabaseBlockModel();
    },
});
//# sourceMappingURL=database-model.js.map