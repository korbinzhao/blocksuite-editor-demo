var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { WithDisposable } from '@blocksuite/lit';
import { createPopper } from '@popperjs/core';
import { css, html, LitElement, nothing } from 'lit';
import { customElement, property, query } from 'lit/decorators.js';
import { repeat } from 'lit/directives/repeat.js';
import { toast } from '../..//components/toast.js';
import { copyBlocks } from '../../__internal__/clipboard/index.js';
import { getBlockElementByModel } from '../../__internal__/index.js';
import { CopyIcon, DeleteIcon, DuplicateIcon, RefreshIcon, } from '../images/icons.js';
import { cloneBookmarkProperties, reloadBookmarkBlock } from '../utils.js';
export function createBookmarkOperationMenu(reference, props) {
    const menu = document.createElement('bookmark-operation-menu');
    menu.model = props.model;
    menu.onSelected = props.onSelected;
    reference.appendChild(menu);
    const popper = createPopper(reference, menu, {
        placement: 'top-start',
        modifiers: [
            {
                name: 'offset',
                options: {
                    offset: [0, 6],
                },
            },
        ],
    });
    return {
        element: menu,
        dispose: () => {
            menu.remove();
            popper.destroy();
        },
    };
}
const operations = [
    {
        type: 'copy',
        icon: CopyIcon,
        label: 'Copy original link',
        action: (model, callback) => {
            copyBlocks({
                type: 'Block',
                models: [model],
                startOffset: 0,
                endOffset: 0,
            });
            toast('Copied link to clipboard');
            callback?.('copy');
        },
    },
    {
        type: 'duplicate',
        icon: DuplicateIcon,
        label: 'Duplicate',
        action: (model, callback) => {
            const { page } = model;
            const parent = page.getParent(model);
            const index = parent?.children.indexOf(model);
            const clonedProps = cloneBookmarkProperties(model);
            page.addBlock('affine:bookmark', clonedProps, parent, index);
            callback?.('duplicate');
        },
    },
    {
        type: 'reload',
        icon: RefreshIcon,
        label: 'Reload',
        action: (model, callback) => {
            reloadBookmarkBlock(model, getBlockElementByModel(model), true);
            callback?.('reload');
        },
    },
    {
        type: 'delete',
        icon: DeleteIcon,
        label: 'Delete',
        action: (model, callback) => {
            model.page.deleteBlock(model);
            callback?.('delete');
        },
    },
];
let BookmarkOperationMenu = class BookmarkOperationMenu extends WithDisposable(LitElement) {
    connectedCallback() {
        super.connectedCallback();
    }
    render() {
        const menuItems = repeat(operations, ({ type }) => type, ({ type, icon, label, action, divider }) => {
            return html `<icon-button
            width="130px"
            height="32px"
            class="menu-item ${type}"
            @click=${() => {
                action(this.model, this.onSelected, this);
            }}
          >
            ${icon} ${label}
          </icon-button>
          ${divider ? html `<div class="divider"></div>` : nothing} `;
        });
        return html ` <div class="bookmark-operation-menu">${menuItems}</div> `;
    }
};
BookmarkOperationMenu.styles = css `
    .bookmark-operation-menu {
      border-radius: 8px 8px 8px 0;
      padding: 8px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
    }
    .menu-item {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      fill: var(--affine-icon-color);
      color: var(--affine-text-primary-color);
    }
    .menu-item:hover {
      background: var(--affine-hover-color);
      fill: var(--affine-primary-color);
      color: var(--affine-primary-color);
    }
    .menu-item svg {
      margin: 0 8px;
    }
  `;
__decorate([
    property()
], BookmarkOperationMenu.prototype, "model", void 0);
__decorate([
    property()
], BookmarkOperationMenu.prototype, "root", void 0);
__decorate([
    property()
], BookmarkOperationMenu.prototype, "onSelected", void 0);
__decorate([
    query('.bookmark-bar')
], BookmarkOperationMenu.prototype, "formatQuickBarElement", void 0);
BookmarkOperationMenu = __decorate([
    customElement('bookmark-operation-menu')
], BookmarkOperationMenu);
export { BookmarkOperationMenu };
//# sourceMappingURL=bookmark-operation-popper.js.map