var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { ShadowlessElement, WithDisposable } from '@blocksuite/lit';
import { Bound } from '@blocksuite/phasor';
import { assertExists } from '@blocksuite/store';
import { VEditor } from '@blocksuite/virgo';
import { html } from 'lit';
import { customElement, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { isCssVariable } from '../../../__internal__/theme/css-variables.js';
import { getSelectedRect } from './utils.js';
let SurfaceTextEditor = class SurfaceTextEditor extends WithDisposable(ShadowlessElement) {
    constructor() {
        super(...arguments);
        this._vEditor = null;
        this._element = null;
        this._edgeless = null;
        this._keeping = false;
    }
    get vEditor() {
        return this._vEditor;
    }
    setKeeping(keeping) {
        this._keeping = keeping;
    }
    _syncRect() {
        const edgeless = this._edgeless;
        const element = this._element;
        if (edgeless && element) {
            const rect = this._virgoContainer.getBoundingClientRect();
            const vLines = Array.from(this._virgoContainer.querySelectorAll('v-line'));
            const lineHeight = vLines[0].getBoundingClientRect().height;
            edgeless.surface.updateElement(element.id, {
                xywh: new Bound(element.x, element.y, rect.width / edgeless.surface.viewport.zoom, (vLines.length / edgeless.surface.viewport.zoom) * lineHeight).serialize(),
            });
            edgeless.slots.selectionUpdated.emit({
                selected: [element],
                active: true,
            });
        }
    }
    mount(element, edgeless) {
        this._element = element;
        this._edgeless = edgeless;
        this._vEditor = new VEditor(element.text);
        this._vEditor.slots.updated.on(() => {
            this._syncRect();
        });
        this._disposables.add(edgeless.slots.viewportUpdated.on(() => {
            this.requestUpdate();
            requestAnimationFrame(() => {
                this._syncRect();
            });
        }));
        this.requestUpdate();
        requestAnimationFrame(() => {
            assertExists(this._vEditor);
            this._element?.setDisplay(false);
            this._vEditor.mount(this._virgoContainer);
            this._virgoContainer.addEventListener('blur', () => {
                if (this._keeping)
                    return;
                this._unmount();
            }, {
                once: true,
            });
        });
    }
    _unmount() {
        this.vEditor?.unmount();
        this._element?.setDisplay(true);
        if (this._element?.text.length === 0) {
            this._edgeless?.surface.removeElement(this._element?.id);
        }
        this.remove();
        assertExists(this._edgeless);
        this._edgeless.slots.selectionUpdated.emit({
            selected: [],
            active: false,
        });
    }
    render() {
        const viewport = this._edgeless?.surface.viewport;
        let virgoStyle = styleMap({});
        if (viewport && this._element && this._edgeless) {
            const zoom = viewport.zoom;
            const rect = getSelectedRect([this._element], this._edgeless.surface.viewport);
            virgoStyle = styleMap({
                position: 'absolute',
                left: rect.x + 'px',
                top: rect.y + 'px',
                fontSize: this._element.fontSize + 'px',
                fontFamily: this._element.fontFamily,
                lineHeight: 'initial',
                outline: 'none',
                transform: `scale(${zoom}, ${zoom})`,
                transformOrigin: 'top left',
                color: isCssVariable(this._element.color)
                    ? `var(${this._element.color})`
                    : this._element.color,
            });
        }
        return html `<div style=${virgoStyle} class="virgo-container"></div>`;
    }
};
__decorate([
    query('.virgo-container')
], SurfaceTextEditor.prototype, "_virgoContainer", void 0);
SurfaceTextEditor = __decorate([
    customElement('surface-text-editor')
], SurfaceTextEditor);
export { SurfaceTextEditor };
//# sourceMappingURL=surface-text-editor.js.map