var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import '../tool-icon-button.js';
import '../color-panel.js';
import { ConnectorLIcon, ConnectorXIcon, LineStyleIcon, } from '@blocksuite/global/config';
import { StrokeStyle } from '@blocksuite/phasor';
import { ConnectorMode } from '@blocksuite/phasor';
import { DisposableGroup } from '@blocksuite/store';
import { css, html, LitElement } from 'lit';
import { customElement, property, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { countBy, maxBy } from '../../../../__internal__/utils/std.js';
import { generateConnectorPath, getConnectorAttachedInfo, } from '../../utils.js';
import { DEFAULT_SELECTED_COLOR } from '../color-panel.js';
import { lineSizeButtonStyles } from '../line-size-button.js';
import { LineStylesPanel, lineStylesPanelStyles, } from '../line-styles-panel.js';
import { createButtonPopper } from '../utils.js';
function getMostCommonColor(elements) {
    const colors = countBy(elements, (ele) => ele.color);
    const max = maxBy(Object.entries(colors), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonMode(elements) {
    const modes = countBy(elements, (ele) => ele.mode);
    const max = maxBy(Object.entries(modes), ([k, count]) => count);
    return max ? Number(max[0]) : null;
}
function getMostCommonLineWidth(elements) {
    const sizes = countBy(elements, (ele) => {
        return ele.lineWidth === 4 ? 's' : 'l';
    });
    const max = maxBy(Object.entries(sizes), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonLineStyle(elements) {
    const sizes = countBy(elements, (ele) => {
        switch (ele.strokeStyle) {
            case StrokeStyle.Solid: {
                return 'solid';
            }
            case StrokeStyle.Dashed: {
                return 'dash';
            }
            case StrokeStyle.None: {
                return 'none';
            }
        }
    });
    const max = maxBy(Object.entries(sizes), ([k, count]) => count);
    return max ? max[0] : null;
}
let EdgelessChangeConnectorButton = class EdgelessChangeConnectorButton extends LitElement {
    constructor() {
        super(...arguments);
        this.elements = [];
        this._colorPanelPopper = null;
        this._disposables = new DisposableGroup();
        this._lineStylesPanelPopper = null;
        this._popperShow = false;
    }
    _forceUpdateSelection() {
        // FIXME: force update selection, because connector mode changed
        this.slots.selectionUpdated.emit({ ...this.selectionState });
    }
    _setConnectorMode(mode) {
        this.page.captureSync();
        this.elements.forEach(element => {
            if (element.mode !== mode) {
                if (element.mode === ConnectorMode.Orthogonal) {
                    const controllers = [
                        element.controllers[0],
                        element.controllers[element.controllers.length - 1],
                    ].map(c => {
                        return {
                            ...c,
                            x: c.x + element.x,
                            y: c.y + element.y,
                        };
                    });
                    this.surface.updateElement(element.id, {
                        controllers,
                        mode,
                    });
                }
                else {
                    const { start, end } = getConnectorAttachedInfo(element, this.surface, this.page);
                    const route = generateConnectorPath(start.rect, end.rect, start.point, end.point, []);
                    this.surface.updateElement(element.id, {
                        controllers: route,
                        mode,
                    });
                }
            }
        });
        this._forceUpdateSelection();
    }
    _setConnectorColor(color) {
        this.page.captureSync();
        this.elements.forEach(element => {
            if (element.color !== color) {
                this.surface.updateElement(element.id, { color });
            }
        });
    }
    _setShapeStrokeWidth(lineWidth) {
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                lineWidth,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStrokeStyle(strokeStyle) {
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                strokeStyle,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStyles({ type, value }) {
        if (type === 'size') {
            const strokeWidth = value === 's' ? 4 : 10;
            this._setShapeStrokeWidth(strokeWidth);
        }
        else if (type === 'lineStyle') {
            switch (value) {
                case 'solid': {
                    this._setShapeStrokeStyle(StrokeStyle.Solid);
                    break;
                }
                case 'dash': {
                    this._setShapeStrokeStyle(StrokeStyle.Dashed);
                    break;
                }
                case 'none': {
                    this._setShapeStrokeStyle(StrokeStyle.None);
                    break;
                }
            }
        }
    }
    firstUpdated(changedProperties) {
        const _disposables = this._disposables;
        this._colorPanelPopper = createButtonPopper(this._colorButton, this._colorPanel);
        _disposables.add(this._colorPanelPopper);
        this._lineStylesPanelPopper = createButtonPopper(this._lineStylesButton, this._lineStylesPanel, ({ display }) => {
            this._popperShow = display === 'show';
        });
        _disposables.add(this._lineStylesPanelPopper);
        super.firstUpdated(changedProperties);
    }
    render() {
        const selectedColor = getMostCommonColor(this.elements) ?? DEFAULT_SELECTED_COLOR;
        const style = {
            backgroundColor: `var(${selectedColor})`,
        };
        const selectedMode = getMostCommonMode(this.elements);
        const selectedLineSize = getMostCommonLineWidth(this.elements) ?? 's';
        const selectedLineStyle = getMostCommonLineStyle(this.elements) ?? 'solid';
        return html `
      <edgeless-tool-icon-button
        .tooltip=${'Straight line'}
        .tipPosition=${'bottom'}
        @click=${() => this._setConnectorMode(ConnectorMode.Straight)}
      >
        <div
          class="connector-mode-button"
          ?active=${selectedMode === ConnectorMode.Straight}
        >
          ${ConnectorLIcon}
        </div>
      </edgeless-tool-icon-button>
      <edgeless-tool-icon-button
        .tooltip=${'Connector'}
        .tipPosition=${'bottom'}
        @click=${() => this._setConnectorMode(ConnectorMode.Orthogonal)}
      >
        <div
          class="connector-mode-button"
          ?active=${selectedMode === ConnectorMode.Orthogonal}
        >
          ${ConnectorXIcon}
        </div>
      </edgeless-tool-icon-button>
      <menu-divider .vertical=${true}></menu-divider>
      <edgeless-tool-icon-button
        class="connector-color-button"
        .tooltip=${'Color'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._colorPanelPopper?.toggle()}
      >
        <div>
          <div class="color" style=${styleMap(style)}></div>
        </div>
      </edgeless-tool-icon-button>
      <div class="color-panel-container">
        <edgeless-color-panel
          .value=${selectedColor}
          @select=${(e) => this._setConnectorColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <edgeless-tool-icon-button
        class="line-styles-button"
        .tooltip=${this._popperShow ? '' : 'Border style'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._lineStylesPanelPopper?.toggle()}
      >
        ${LineStyleIcon}
      </edgeless-tool-icon-button>
      ${LineStylesPanel({
            selectedLineSize,
            selectedLineStyle,
            lineStyle: ['solid', 'dash'],
            onClick: event => {
                this._setShapeStyles(event);
            },
        })}
    `;
    }
};
EdgelessChangeConnectorButton.styles = [
    lineSizeButtonStyles,
    lineStylesPanelStyles,
    css `
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        color: var(--affine-text-primary-color);
        fill: currentColor;
      }

      menu-divider {
        height: 24px;
      }

      .color-panel-container {
        display: none;
        padding: 4px;
        justify-content: center;
        align-items: center;
        background: var(--affine-background-overlay-panel-color);
        box-shadow: var(--affine-shadow-2);
        border-radius: 8px;
      }

      .color-panel-container[data-show] {
        display: block;
      }

      .connector-mode-button {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        border-radius: 4px;
        cursor: pointer;
      }

      .connector-mode-button[active] {
        background-color: var(--affine-hover-color);
      }

      .connector-color-button .color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
      }

      .line-style-panel {
        display: none;
      }
      .line-style-panel[data-show] {
        display: flex;
      }
    `,
];
__decorate([
    property()
], EdgelessChangeConnectorButton.prototype, "elements", void 0);
__decorate([
    property({ type: Object })
], EdgelessChangeConnectorButton.prototype, "selectionState", void 0);
__decorate([
    property()
], EdgelessChangeConnectorButton.prototype, "page", void 0);
__decorate([
    property()
], EdgelessChangeConnectorButton.prototype, "surface", void 0);
__decorate([
    property()
], EdgelessChangeConnectorButton.prototype, "slots", void 0);
__decorate([
    query('.connector-color-button')
], EdgelessChangeConnectorButton.prototype, "_colorButton", void 0);
__decorate([
    query('.color-panel-container')
], EdgelessChangeConnectorButton.prototype, "_colorPanel", void 0);
__decorate([
    query('.line-styles-button')
], EdgelessChangeConnectorButton.prototype, "_lineStylesButton", void 0);
__decorate([
    query('.line-style-panel')
], EdgelessChangeConnectorButton.prototype, "_lineStylesPanel", void 0);
EdgelessChangeConnectorButton = __decorate([
    customElement('edgeless-change-connector-button')
], EdgelessChangeConnectorButton);
export { EdgelessChangeConnectorButton };
//# sourceMappingURL=change-connector-button.js.map