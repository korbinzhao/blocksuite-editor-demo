var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import '../tool-icon-button.js';
import '../color-panel.js';
import '../../toolbar/shape-tool/shape-menu.js';
import { LineStyleIcon } from '@blocksuite/global/config';
import { WithDisposable } from '@blocksuite/lit';
import { StrokeStyle, } from '@blocksuite/phasor';
import { css, html, LitElement } from 'lit';
import { customElement, property, query, state } from 'lit/decorators.js';
import { countBy, maxBy } from '../../../../__internal__/utils/std.js';
import { ShapeComponentConfigMap } from '../../toolbar/shape-tool/shape-menu-config.js';
import { isTransparent } from '../color-panel.js';
import { ColorUnit } from '../color-panel.js';
import { lineSizeButtonStyles } from '../line-size-button.js';
import { LineStylesPanel, lineStylesPanelStyles, } from '../line-styles-panel.js';
import { createButtonPopper } from '../utils.js';
function getMostCommonShape(elements) {
    const shapeTypes = countBy(elements, (ele) => {
        return ele.shapeType === 'rect' && ele.radius
            ? 'roundedRect'
            : ele.shapeType;
    });
    const max = maxBy(Object.entries(shapeTypes), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonFillColor(elements) {
    const colors = countBy(elements, (ele) => {
        return ele.filled ? ele.fillColor : '--affine-palette-transparent';
    });
    const max = maxBy(Object.entries(colors), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonStrokeColor(elements) {
    const colors = countBy(elements, (ele) => {
        return ele.strokeColor;
    });
    const max = maxBy(Object.entries(colors), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonLineSize(elements) {
    const sizes = countBy(elements, (ele) => {
        return ele.strokeWidth === 4 ? 's' : 'l';
    });
    const max = maxBy(Object.entries(sizes), ([k, count]) => count);
    return max ? max[0] : null;
}
function getMostCommonLineStyle(elements) {
    const sizes = countBy(elements, (ele) => {
        switch (ele.strokeStyle) {
            case StrokeStyle.Solid: {
                return 'solid';
            }
            case StrokeStyle.Dashed: {
                return 'dash';
            }
            case StrokeStyle.None: {
                return 'none';
            }
        }
    });
    const max = maxBy(Object.entries(sizes), ([k, count]) => count);
    return max ? max[0] : null;
}
const FILL_COLORS = [
    '--affine-palette-shape-yellow',
    '--affine-palette-shape-orange',
    '--affine-palette-shape-tangerine',
    '--affine-palette-shape-red',
    '--affine-palette-shape-magenta',
    '--affine-palette-shape-purple',
    '--affine-palette-shape-green',
    '--affine-palette-shape-blue',
    '--affine-palette-shape-navy',
    '--affine-palette-shape-black',
    '--affine-palette-shape-white',
    '--affine-palette-transparent',
];
export const DEFAULT_SHAPE_FILL_COLOR = FILL_COLORS[11];
const STROKE_COLORS = [
    '--affine-palette-line-yellow',
    '--affine-palette-line-orange',
    '--affine-palette-line-tangerine',
    '--affine-palette-line-red',
    '--affine-palette-line-magenta',
    '--affine-palette-line-purple',
    '--affine-palette-line-green',
    '--affine-palette-line-blue',
    '--affine-palette-line-navy',
    '--affine-palette-line-black',
    '--affine-palette-line-white',
    '--affine-palette-transparent',
];
export const DEFAULT_SHAPE_STROKE_COLOR = STROKE_COLORS[9];
let EdgelessChangeShapeButton = class EdgelessChangeShapeButton extends WithDisposable(LitElement) {
    constructor() {
        super(...arguments);
        this.elements = [];
        this._popperShow = false;
        this._shapeMenuPopper = null;
        this._fillColorMenuPopper = null;
        this._strokeColorMenuPopper = null;
        this._lineStylesPanelPopper = null;
    }
    _forceUpdateSelection() {
        // FIXME: force update selection, because connector mode changed
        this.slots.selectionUpdated.emit({ ...this.selectionState });
    }
    _setShapeFillColor(color) {
        const filled = !isTransparent(color);
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                filled,
                fillColor: color,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStrokeColor(color) {
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                strokeColor: color,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStrokeWidth(strokeWidth) {
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                strokeWidth,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStrokeStyle(strokeStyle) {
        this.elements.forEach(ele => {
            this.surface.updateElement(ele.id, {
                strokeStyle,
            });
        });
        this._forceUpdateSelection();
    }
    _setShapeStyles({ type, value }) {
        if (type === 'size') {
            const strokeWidth = value === 's' ? 4 : 10;
            this._setShapeStrokeWidth(strokeWidth);
        }
        else if (type === 'lineStyle') {
            switch (value) {
                case 'solid': {
                    this._setShapeStrokeStyle(StrokeStyle.Solid);
                    break;
                }
                case 'dash': {
                    this._setShapeStrokeStyle(StrokeStyle.Dashed);
                    break;
                }
                case 'none': {
                    this._setShapeStrokeStyle(StrokeStyle.None);
                    break;
                }
            }
        }
    }
    firstUpdated(changedProperties) {
        const _disposables = this._disposables;
        this._shapeMenuPopper = createButtonPopper(this._changeShapeButton, this._shapeMenu, ({ display }) => {
            this._popperShow = display === 'show';
        });
        _disposables.add(this._shapeMenuPopper);
        _disposables.add(this._shapeMenu.slots.select.on(shapeType => {
            const updatedProps = shapeType === 'roundedRect'
                ? { shapeType: 'rect', radius: 0.1 }
                : { shapeType, radius: 0 };
            this.page.captureSync();
            this.elements.forEach(element => {
                this.surface.updateElement(element.id, updatedProps);
            });
            this._forceUpdateSelection();
        }));
        this._fillColorMenuPopper = createButtonPopper(this._fillColorButton, this._fillColorMenu, ({ display }) => {
            this._popperShow = display === 'show';
        });
        _disposables.add(this._fillColorMenuPopper);
        this._strokeColorMenuPopper = createButtonPopper(this._strokeColorButton, this._strokeColorMenu, ({ display }) => {
            this._popperShow = display === 'show';
        });
        _disposables.add(this._strokeColorMenuPopper);
        this._lineStylesPanelPopper = createButtonPopper(this._lineStylesButton, this._lineStylesPanel, ({ display }) => {
            this._popperShow = display === 'show';
        });
        _disposables.add(this._lineStylesPanelPopper);
        super.firstUpdated(changedProperties);
    }
    render() {
        const selectedShape = getMostCommonShape(this.elements);
        const icon = selectedShape
            ? ShapeComponentConfigMap[selectedShape].icon
            : null;
        const selectedFillColor = getMostCommonFillColor(this.elements) ?? FILL_COLORS[0];
        const selectedStrokeColor = getMostCommonStrokeColor(this.elements) ?? STROKE_COLORS[0];
        const selectedLineSize = getMostCommonLineSize(this.elements) ?? 's';
        const selectedLineStyle = getMostCommonLineStyle(this.elements) ?? 'solid';
        return html `
      <edgeless-tool-icon-button
        class="change-shape-button"
        .tooltip=${this._popperShow ? '' : 'Switch type'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._shapeMenuPopper?.toggle()}
      >
        ${icon}
      </edgeless-tool-icon-button>
      <edgeless-shape-menu .selectedShape=${selectedShape}>
      </edgeless-shape-menu>

      <menu-divider .vertical=${true}></menu-divider>

      <edgeless-tool-icon-button
        class="fill-color-button"
        .tooltip=${this._popperShow ? '' : 'Shape color'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._fillColorMenuPopper?.toggle()}
      >
        ${ColorUnit(selectedFillColor)}
      </edgeless-tool-icon-button>
      <div class="color-panel-container fill-color">
        <edgeless-color-panel
          .value=${selectedFillColor}
          .options=${FILL_COLORS}
          @select=${(e) => this._setShapeFillColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <edgeless-tool-icon-button
        class="stroke-color-button"
        .tooltip=${this._popperShow ? '' : 'Border color'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._strokeColorMenuPopper?.toggle()}
      >
        ${ColorUnit(selectedStrokeColor, { hollowCircle: true })}
      </edgeless-tool-icon-button>
      <div class="color-panel-container stroke-color">
        <edgeless-color-panel
          .value=${selectedStrokeColor}
          .options=${STROKE_COLORS}
          .hollowCircle=${true}
          @select=${(e) => this._setShapeStrokeColor(e.detail)}
        >
        </edgeless-color-panel>
      </div>

      <menu-divider .vertical=${true}></menu-divider>

      <edgeless-tool-icon-button
        class="line-styles-button"
        .tooltip=${this._popperShow ? '' : 'Border style'}
        .tipPosition=${'bottom'}
        .active=${false}
        @click=${() => this._lineStylesPanelPopper?.toggle()}
      >
        ${LineStyleIcon}
      </edgeless-tool-icon-button>
      ${LineStylesPanel({
            selectedLineSize,
            selectedLineStyle,
            onClick: event => {
                this._setShapeStyles(event);
            },
        })}
    `;
    }
};
EdgelessChangeShapeButton.styles = [
    lineSizeButtonStyles,
    lineStylesPanelStyles,
    css `
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        color: var(--affine-text-primary-color);
        stroke: none;
        fill: currentColor;
      }

      menu-divider {
        height: 24px;
      }

      edgeless-shape-menu {
        display: none;
      }

      edgeless-shape-menu[data-show] {
        display: block;
      }

      .change-shape-button {
        fill: none;
        stroke: currentColor;
      }

      .color-panel-container {
        display: none;
        padding: 4px;
        justify-content: center;
        align-items: center;
        background: var(--affine-background-overlay-panel-color);
        box-shadow: var(--affine-shadow-2);
        border-radius: 8px;
      }

      .color-panel-container[data-show] {
        display: block;
      }

      .shape-color-button-indicator {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        border-radius: 4px;
        cursor: pointer;
      }

      .shape-color-button-indicator div {
        border-radius: 50%;
        width: 16px;
        height: 16px;
      }

      .line-style-panel {
        display: none;
      }
      .line-style-panel[data-show] {
        display: flex;
      }
    `,
];
__decorate([
    property()
], EdgelessChangeShapeButton.prototype, "elements", void 0);
__decorate([
    property()
], EdgelessChangeShapeButton.prototype, "page", void 0);
__decorate([
    property()
], EdgelessChangeShapeButton.prototype, "surface", void 0);
__decorate([
    property()
], EdgelessChangeShapeButton.prototype, "selectionState", void 0);
__decorate([
    property()
], EdgelessChangeShapeButton.prototype, "slots", void 0);
__decorate([
    state()
], EdgelessChangeShapeButton.prototype, "_popperShow", void 0);
__decorate([
    query('.change-shape-button')
], EdgelessChangeShapeButton.prototype, "_changeShapeButton", void 0);
__decorate([
    query('edgeless-shape-menu')
], EdgelessChangeShapeButton.prototype, "_shapeMenu", void 0);
__decorate([
    query('.fill-color-button')
], EdgelessChangeShapeButton.prototype, "_fillColorButton", void 0);
__decorate([
    query('.color-panel-container.fill-color')
], EdgelessChangeShapeButton.prototype, "_fillColorMenu", void 0);
__decorate([
    query('.stroke-color-button')
], EdgelessChangeShapeButton.prototype, "_strokeColorButton", void 0);
__decorate([
    query('.color-panel-container.stroke-color')
], EdgelessChangeShapeButton.prototype, "_strokeColorMenu", void 0);
__decorate([
    query('.line-styles-button')
], EdgelessChangeShapeButton.prototype, "_lineStylesButton", void 0);
__decorate([
    query('.line-style-panel')
], EdgelessChangeShapeButton.prototype, "_lineStylesPanel", void 0);
EdgelessChangeShapeButton = __decorate([
    customElement('edgeless-change-shape-button')
], EdgelessChangeShapeButton);
export { EdgelessChangeShapeButton };
//# sourceMappingURL=change-shape-button.js.map