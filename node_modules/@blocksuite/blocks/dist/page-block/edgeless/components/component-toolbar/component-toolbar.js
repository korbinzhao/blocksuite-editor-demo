var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import '../tool-icon-button.js';
import './change-shape-button.js';
import './change-brush-button.js';
import './change-connector-button.js';
import './change-frame-button.js';
import './change-text-button.js';
import './more-button.js';
import { css, html, LitElement, nothing } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { join } from 'lit/directives/join.js';
import { atLeastNMatches, groupBy, } from '../../../../__internal__/utils/std.js';
import { isTopLevelBlock, stopPropagation } from '../../utils.js';
let EdgelessComponentToolbar = class EdgelessComponentToolbar extends LitElement {
    constructor() {
        super(...arguments);
        this.selected = [];
    }
    _groupSelected() {
        const result = groupBy(this.selected, s => {
            if (isTopLevelBlock(s)) {
                return 'frame';
            }
            return s.type;
        });
        return result;
    }
    _getShapeButton(shapeElements) {
        const shapeButton = shapeElements?.length
            ? html `<edgeless-change-shape-button
          .elements=${shapeElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-shape-button>`
            : null;
        return shapeButton;
    }
    _getBrushButton(brushElements) {
        return brushElements?.length
            ? html `<edgeless-change-brush-button
          .elements=${brushElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-brush-button>`
            : null;
    }
    _getConnectorButton(connectorElements) {
        return connectorElements?.length
            ? html ` <edgeless-change-connector-button
          .elements=${connectorElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-connector-button>`
            : null;
    }
    _getFrameButton(blocks) {
        return blocks?.length
            ? html `<edgeless-change-frame-button
          .frames=${blocks}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-frame-button>`
            : null;
    }
    _getTextButton(textElements) {
        return textElements?.length
            ? html `<edgeless-change-text-button
          .texts=${textElements}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${this.selectionState}
        >
        </edgeless-change-text-button>`
            : null;
    }
    render() {
        const groupedSelected = this._groupSelected();
        const { shape, brush, connector, frame, text } = groupedSelected;
        // when selected types more than two, only show `more` button
        const selectedAtLeastTwoTypes = atLeastNMatches(Object.values(groupedSelected), e => !!e.length, 2);
        const buttons = selectedAtLeastTwoTypes
            ? []
            : [
                this._getShapeButton(shape),
                this._getBrushButton(brush),
                this._getConnectorButton(connector),
                this._getFrameButton(frame),
                this._getTextButton(text),
            ].filter(b => !!b);
        const divider = !buttons.length
            ? nothing
            : html `<menu-divider .vertical=${true}></menu-divider>`;
        return html `<div class="container" @pointerdown=${stopPropagation}>
      ${join(buttons, () => '')} ${divider}
      <edgeless-more-button
        .elements=${this.selected}
        .page=${this.page}
        .surface=${this.surface}
        .slots=${this.slots}
      >
      </edgeless-more-button>
    </div>`;
    }
};
EdgelessComponentToolbar.styles = css `
    :host {
      display: block;
      user-select: none;
    }

    .container {
      display: flex;
      align-items: center;
      height: 48px;
      background: var(--affine-background-overlay-panel-color);
      box-shadow: var(--affine-shadow-2);
      border-radius: 8px;
    }

    menu-divider {
      height: 24px;
    }
  `;
__decorate([
    property()
], EdgelessComponentToolbar.prototype, "selected", void 0);
__decorate([
    property({ type: Object })
], EdgelessComponentToolbar.prototype, "selectionState", void 0);
__decorate([
    property()
], EdgelessComponentToolbar.prototype, "page", void 0);
__decorate([
    property()
], EdgelessComponentToolbar.prototype, "surface", void 0);
__decorate([
    property()
], EdgelessComponentToolbar.prototype, "slots", void 0);
EdgelessComponentToolbar = __decorate([
    customElement('edgeless-component-toolbar')
], EdgelessComponentToolbar);
export { EdgelessComponentToolbar };
//# sourceMappingURL=component-toolbar.js.map