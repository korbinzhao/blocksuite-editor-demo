var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import './component-toolbar/component-toolbar.js';
import { WithDisposable } from '@blocksuite/lit';
import { serializeXYWH, TextElement, } from '@blocksuite/phasor';
import { deserializeXYWH, SurfaceManager } from '@blocksuite/phasor';
import { Page } from '@blocksuite/store';
import { createPopper } from '@popperjs/core';
import { css, html, LitElement, nothing } from 'lit';
import { customElement, property, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { FRAME_MIN_HEIGHT, FRAME_MIN_WIDTH, handleElementChangedEffectForConnector, isTopLevelBlock, stopPropagation, } from '../utils.js';
import { ResizeHandles } from './resize-handles.js';
import { HandleResizeManager } from './resize-manager.js';
import { SingleConnectorHandles } from './single-connector-handles.js';
import { getCommonRectStyle, getSelectableBounds, getSelectedRect, } from './utils.js';
let EdgelessSelectedRect = class EdgelessSelectedRect extends WithDisposable(LitElement) {
    constructor() {
        super();
        this._componentToolbarPopper = null;
        this._lock = false;
        this._onDragMove = (newBounds) => {
            const { page, state, surface } = this;
            const selectedMap = new Map(state.selected.map(element => [element.id, element]));
            newBounds.forEach((bound, id) => {
                const element = selectedMap.get(id);
                if (!element)
                    return;
                if (isTopLevelBlock(element)) {
                    let frameX = bound.x;
                    let frameY = bound.y;
                    let frameW = bound.w;
                    let frameH = deserializeXYWH(element.xywh)[3];
                    // Limit the width of the selected frame
                    if (frameW < FRAME_MIN_WIDTH) {
                        frameW = FRAME_MIN_WIDTH;
                        frameX = bound.x;
                    }
                    // Limit the height of the selected frame
                    if (frameH < FRAME_MIN_HEIGHT) {
                        frameH = FRAME_MIN_HEIGHT;
                        frameY = bound.y;
                    }
                    page.updateBlock(element, {
                        xywh: JSON.stringify([frameX, frameY, frameW, frameH]),
                    });
                }
                else {
                    if (element instanceof TextElement) {
                        const p = bound.h / element.h;
                        bound.w = element.w * p;
                        surface.updateElement(id, {
                            xywh: serializeXYWH(bound.x, bound.y, bound.w, bound.h),
                            fontSize: element.fontSize * p,
                        });
                    }
                    else {
                        surface.setElementBound(element.id, bound);
                    }
                }
                handleElementChangedEffectForConnector(element, [element], surface, page);
            });
            this.requestUpdate();
        };
        this._onDragEnd = () => {
            if (this._lock) {
                this.page.captureSync();
            }
            this._lock = false;
        };
        this._resizeManager = new HandleResizeManager(this._onDragMove, this._onDragEnd);
        this.addEventListener('pointerdown', stopPropagation);
    }
    get zoom() {
        return this.surface.viewport.zoom;
    }
    get resizeMode() {
        if (this.state.selected.length === 1 &&
            this.state.selected[0].type === 'connector') {
            return 'none';
        }
        const hasBlockElement = this.state.selected.find(elem => isTopLevelBlock(elem));
        return hasBlockElement ? 'edge' : 'corner';
    }
    firstUpdated() {
        const { _disposables, slots } = this;
        _disposables.add(slots.viewportUpdated.on(() => this.requestUpdate()));
        _disposables.add(slots.pressShiftKeyUpdated.on(pressed => this._resizeManager.onPressShiftKey(pressed)));
        this._componentToolbarPopper = this._componentToolbar
            ? createPopper(this._selectedRect, this._componentToolbar, {
                placement: 'top',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: [0, 12],
                        },
                    },
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['bottom'],
                        },
                    },
                ],
            })
            : null;
        _disposables.add(() => this._componentToolbarPopper?.destroy());
        if (this._componentToolbar) {
            // This hook is not waiting all children updated.
            // But children effect popper position. So we use ResizeObserver watching sizing change.
            const resizeObserver = new ResizeObserver(() => this._componentToolbarPopper?.update());
            resizeObserver.observe(this._componentToolbar);
            _disposables.add(() => resizeObserver.disconnect());
        }
    }
    updated(changedProperties) {
        // when viewport updates, popper should update too.
        this._componentToolbarPopper?.update();
        super.updated(changedProperties);
    }
    render() {
        const { state } = this;
        const { active, selected } = state;
        if (selected.length === 0 ||
            (active && selected[0] instanceof TextElement)) {
            return nothing;
        }
        const { page, surface, resizeMode, _resizeManager } = this;
        const selectedRect = getSelectedRect(selected, surface.viewport);
        const style = getCommonRectStyle(selectedRect, active, true);
        const hasResizeHandles = !active && !page.readonly;
        const resizeHandles = hasResizeHandles
            ? ResizeHandles(resizeMode, (e, direction) => {
                const bounds = getSelectableBounds(selected);
                _resizeManager.onPointerDown(e, direction, bounds, resizeMode, this.zoom);
            })
            : nothing;
        const connectorHandles = selected.length === 1 && selected[0].type === 'connector'
            ? SingleConnectorHandles(selected[0], this.surface, this.page, () => {
                this.slots.selectionUpdated.emit({ ...state });
            })
            : nothing;
        const componentToolbar = active
            ? nothing
            : html `<edgeless-component-toolbar
          .selected=${selected}
          .page=${this.page}
          .surface=${this.surface}
          .slots=${this.slots}
          .selectionState=${state}
        >
        </edgeless-component-toolbar>`;
        return html `
      <div class="affine-edgeless-selected-rect" style=${styleMap(style)}>
        ${resizeHandles} ${connectorHandles}
      </div>
      ${componentToolbar}
    `;
    }
};
EdgelessSelectedRect.styles = css `
    :host {
      display: block;
      user-select: none;
    }

    .affine-edgeless-selected-rect {
      position: absolute;
      border-radius: 0;
      pointer-events: none;
      box-sizing: border-box;
      z-index: 1;
      border: var(--affine-border-width) solid var(--affine-blue);
    }

    .affine-edgeless-selected-rect > [aria-label^='handle'] {
      position: absolute;
      width: 12px;
      height: 12px;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 10;
      border: 2px var(--affine-blue) solid;
      background: white;
      pointer-events: auto;
      user-select: none;
      outline: none;

      /**
       * Fix: pointerEvent stops firing after a short time.
       * When a gesture is started, the browser intersects the touch-action values of the touched element and its ancestors,
       * up to the one that implements the gesture (in other words, the first containing scrolling element)
       * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
       */
      touchaction: none;
    }

    :host([disabled='true'])
      .affine-edgeless-selected-rect
      > [aria-label^='handle'] {
      pointer-events: none;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-top-left'] {
      cursor: nwse-resize;
      left: -6px;
      top: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-top-right'] {
      cursor: nesw-resize;
      top: -6px;
      right: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-bottom-right'] {
      cursor: nwse-resize;
      right: -6px;
      bottom: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-bottom-left'] {
      cursor: nesw-resize;
      bottom: -6px;
      left: -6px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left'],
    .affine-edgeless-selected-rect > [aria-label='handle-right'] {
      cursor: ew-resize;
      top: 0;
      bottom: 0;
      height: 100%;
      width: 6px;
      border: 0;
      background: transparent;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left'] {
      left: -3.5px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-right'] {
      right: -3.5px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left']:after,
    .affine-edgeless-selected-rect > [aria-label='handle-right']:after {
      position: absolute;
      width: 12px;
      height: 12px;
      box-sizing: border-box;
      border-radius: 6px;
      z-index: 10;
      border: 2px var(--affine-blue) solid;
      content: '';
      top: calc(50% - 6px);
      background: white;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-left']:after {
      left: -3px;
    }

    .affine-edgeless-selected-rect > [aria-label='handle-right']:after {
      right: -3px;
    }

    edgeless-component-toolbar {
      /* greater than handle */
      z-index: 11;
    }
  `;
__decorate([
    property({ type: Page })
], EdgelessSelectedRect.prototype, "page", void 0);
__decorate([
    property({ type: SurfaceManager })
], EdgelessSelectedRect.prototype, "surface", void 0);
__decorate([
    property({ type: Object })
], EdgelessSelectedRect.prototype, "state", void 0);
__decorate([
    property()
], EdgelessSelectedRect.prototype, "slots", void 0);
__decorate([
    query('.affine-edgeless-selected-rect')
], EdgelessSelectedRect.prototype, "_selectedRect", void 0);
__decorate([
    query('edgeless-component-toolbar')
], EdgelessSelectedRect.prototype, "_componentToolbar", void 0);
EdgelessSelectedRect = __decorate([
    customElement('edgeless-selected-rect')
], EdgelessSelectedRect);
export { EdgelessSelectedRect };
//# sourceMappingURL=edgeless-selected-rect.js.map