import './components/edgeless-selected-rect.js';
import './toolbar/edgeless-toolbar.js';
import { BlockElement } from '@blocksuite/lit';
import { SurfaceManager } from '@blocksuite/phasor';
import { type BaseBlockModel, type Page, Slot } from '@blocksuite/store';
import { EdgelessClipboard } from '../../__internal__/clipboard/index.js';
import { type Point, type ReorderingAction, type TopLevelBlockModel } from '../../__internal__/index.js';
import { getService } from '../../__internal__/service.js';
import type { BlockHost, DragHandle, FrameBlockModel, MouseMode, PageBlockModel } from '../../index.js';
import { EdgelessSelectionManager, type EdgelessSelectionState, type Selectable } from './selection-manager.js';
import { EdgelessToolbar, type ZoomAction } from './toolbar/edgeless-toolbar.js';
export interface EdgelessSelectionSlots {
    hoverUpdated: Slot;
    viewportUpdated: Slot;
    selectionUpdated: Slot<EdgelessSelectionState>;
    surfaceUpdated: Slot;
    mouseModeUpdated: Slot<MouseMode>;
    reorderingFramesUpdated: Slot<ReorderingAction<Selectable>>;
    reorderingShapesUpdated: Slot<ReorderingAction<Selectable>>;
    pressShiftKeyUpdated: Slot<boolean>;
}
export interface EdgelessContainer extends HTMLElement {
    readonly page: Page;
    readonly surface: SurfaceManager;
    readonly slots: EdgelessSelectionSlots;
}
export declare class EdgelessPageBlockComponent extends BlockElement<PageBlockModel> implements EdgelessContainer, BlockHost {
    static styles: import("lit").CSSResult;
    flavour: "edgeless";
    /**
     * Shared components
     */
    components: {
        dragHandle: DragHandle | null;
        toolbar: EdgelessToolbar | null;
    };
    mouseRoot: HTMLElement;
    showGrid: boolean;
    mouseMode: MouseMode;
    private _rectsOfSelectedBlocks;
    private _surfaceContainer;
    pageBlockContainer: HTMLDivElement;
    clipboard: EdgelessClipboard;
    slots: {
        viewportUpdated: Slot<void>;
        selectedBlocksUpdated: Slot<(import("../../__internal__/rich-text/rich-text.js").RichText | import("../../bookmark-block/components/bookmark-operation-popper.js").BookmarkOperationMenu | import("../../bookmark-block/components/bookmark-toolbar.js").BookmarkToolbar | import("../../bookmark-block/components/bookmark-edit-modal.js").BookmarkEditModal | import("../../bookmark-block/components/bookmark-create-modal.js").BookmarkCreateModal | import("../../index.js").BookmarkBlockComponent | import("../../index.js").ListBlockComponent | import("../../index.js").CodeBlockComponent | import("../../database-block/table/table-view.js").DatabaseTable | import("../../database-block/kanban/kanban-view.js").DatabaseKanban | import("../../index.js").DatabaseBlockComponent | import("../default/default-page-block.js").DefaultPageBlockComponent | EdgelessPageBlockComponent | import("../../index.js").EmbedBlockComponent | import("../../index.js").ImageBlockComponent | import("../../index.js").DividerBlockComponent | import("../../index.js").ParagraphBlockComponent | import("../../index.js").FrameBlockComponent)[]>;
        selectionUpdated: Slot<EdgelessSelectionState>;
        hoverUpdated: Slot<void>;
        surfaceUpdated: Slot<void>;
        mouseModeUpdated: Slot<MouseMode>;
        reorderingFramesUpdated: Slot<ReorderingAction<Selectable>>;
        reorderingShapesUpdated: Slot<ReorderingAction<Selectable>>;
        zoomUpdated: Slot<ZoomAction>;
        pressShiftKeyUpdated: Slot<boolean>;
        subpageLinked: Slot<{
            pageId: string;
        }>;
        subpageUnlinked: Slot<{
            pageId: string;
        }>;
        pageLinkClicked: Slot<{
            pageId: string;
            blockId?: string | undefined;
        }>;
    };
    surface: SurfaceManager;
    indexes: {
        max: string;
        min: string;
    };
    getService: typeof getService;
    selection: EdgelessSelectionManager;
    get frames(): FrameBlockModel[];
    get sortedFrames(): FrameBlockModel[];
    private _resizeObserver;
    private _frameResizeObserver;
    private _clearSelection;
    private _initSurface;
    private _handleToolbarFlag;
    private _initDragHandle;
    private _initSlotEffects;
    /**
     * Brings to front or sends to back.
     */
    private _reorderTo;
    /**
     * Brings forward or sends backward layer by layer.
     */
    private _reorder;
    updateIndexes(keys: string[], elements: TopLevelBlockModel[], callback: (keys: string[]) => void): void;
    getSortedElementsWithViewportBounds(elements: Selectable[]): FrameBlockModel[];
    reorderFrames: ({ elements, type }: ReorderingAction<Selectable>) => void;
    reorderShapes: ({ elements, type }: ReorderingAction<Selectable>) => void;
    /**
     * Adds a new frame with the given point on the editor-container.
     *
     * @param: point Point
     * @returns: The id of new frame
     */
    addFrameWithPoint(point: Point, options?: {
        width?: number;
        height?: number;
        parentId?: string;
        frameIndex?: number;
        offsetX?: number;
        offsetY?: number;
    }): string;
    /**
     * Adds a new frame with the given blocks and point.
     * @param blocks Array<Partial<BaseBlockModel>>
     * @param point Point
     */
    addNewFrame(blocks: Array<Partial<BaseBlockModel>>, point: Point, options?: {
        width?: number;
        height?: number;
        parentId?: string;
        frameIndex?: number;
        offsetX?: number;
        offsetY?: number;
    }): {
        frameId: string;
        ids: string[];
    };
    /** Moves selected blocks into a new frame at the given point. */
    moveBlocksWithNewFrame(blocks: BaseBlockModel[], point: Point, { rect, focus, parentId, frameIndex, }?: {
        rect?: DOMRect;
        focus?: boolean;
        parentId?: string;
        frameIndex?: number;
    }): void;
    setSelection(frameId: string, active: boolean | undefined, blockId: string, point?: Point): void;
    /**
     * Clear selected blocks.
     */
    clearSelectedBlocks(): void;
    update(changedProperties: Map<string, unknown>): void;
    private _initResizeEffect;
    firstUpdated(): void;
    updated(changedProperties: Map<string, unknown>): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    render(): import("lit").TemplateResult<1>;
}
declare global {
    interface HTMLElementTagNameMap {
        'affine-edgeless-page': EdgelessPageBlockComponent;
    }
}
//# sourceMappingURL=edgeless-page-block.d.ts.map