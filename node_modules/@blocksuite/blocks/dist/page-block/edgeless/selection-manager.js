import { normalizeWheelDeltaY } from '@blocksuite/phasor';
import { AbstractSelectionManager, getEditorContainerByElement, isDatabaseInput, isInsideEdgelessTextEditor, isInsidePageTitle, isPinchEvent, Point, } from '../../__internal__/index.js';
import { activeEditorManager } from '../../__internal__/utils/active-editor-manager.js';
import { updateLocalSelectionRange } from '../default/selection-manager/utils.js';
import { BrushModeController } from './mode-controllers/brush-mode.js';
import { ConnectorModeController } from './mode-controllers/connector-mode.js';
import { DefaultModeController } from './mode-controllers/default-mode.js';
import { NoteModeController } from './mode-controllers/note-mode.js';
import { PanModeController } from './mode-controllers/pan-mode.js';
import { ShapeModeController } from './mode-controllers/shape-mode.js';
import { TextModeController } from './mode-controllers/text-mode.js';
import { getSelectionBoxBound, getXYWH, isTopLevelBlock, pickTopBlock, } from './utils.js';
function shouldFilterMouseEvent(event) {
    const target = event.target;
    if (!target || !(target instanceof HTMLElement)) {
        return false;
    }
    if (target.tagName === 'INPUT') {
        return true;
    }
    if (target.tagName === 'FORMAT-QUICK-BAR') {
        return true;
    }
    if (target.tagName === 'AFFINE-DRAG-HANDLE') {
        return true;
    }
    return false;
}
export class EdgelessSelectionManager extends AbstractSelectionManager {
    get isActive() {
        return this.state.active;
    }
    get lastMousePos() {
        return this._lastMousePos;
    }
    get mouseMode() {
        return this._mouseMode;
    }
    set mouseMode(mode) {
        this._mouseMode = mode;
        // sync mouse mode
        this._controllers[this._mouseMode.type].mouseMode = this._mouseMode;
    }
    get currentController() {
        return this._controllers[this.mouseMode.type];
    }
    get draggingArea() {
        if (!this.currentController.draggingArea)
            return null;
        const { start, end } = this.currentController.draggingArea;
        const minX = Math.min(start.x, end.x);
        const minY = Math.min(start.y, end.y);
        const maxX = Math.max(start.x, end.x);
        const maxY = Math.max(start.y, end.y);
        return new DOMRect(minX, minY, maxX - minX, maxY - minY);
    }
    get shiftKey() {
        return this._shiftKey;
    }
    set shiftKey(pressed) {
        this._shiftKey = pressed;
        this.currentController.onPressShiftKey(pressed);
    }
    constructor(container, dispacher) {
        super(container, dispacher);
        this._mouseMode = {
            type: 'default',
        };
        /** Latest mouse position in view coords */
        this._lastMousePos = { x: 0, y: 0 };
        this._rightClickTimer = null;
        // pressed shift key
        this._shiftKey = false;
        // selected blocks
        this.selectedBlocks = [];
        // Cache the last edited elements.
        this.lastState = null;
        // Holds the state of the current selected elements.
        this.state = {
            selected: [],
            active: false,
        };
        this._add = (name, fn) => {
            this._disposables.add(this._dispatcher.add(name, fn));
        };
        this._onContainerDragStart = (e) => {
            if (this.page.readonly)
                return;
            // do nothing when holding right-key and not in pan mode
            if (e.button === 2 && this.mouseMode.type !== 'pan')
                return;
            return this.currentController.onContainerDragStart(e);
        };
        this._onContainerDragMove = (e) => {
            if (this.page.readonly)
                return;
            // do nothing when holding right-key and not in pan mode
            if (e.button === 2 && this.mouseMode.type !== 'pan')
                return;
            return this.currentController.onContainerDragMove(e);
        };
        this._onContainerDragEnd = (e) => {
            if (this.page.readonly)
                return;
            // do nothing when holding right-key and not in pan mode
            if (e.button === 2 && this.mouseMode.type !== 'pan')
                return;
            return this.currentController.onContainerDragEnd(e);
        };
        this._onContainerClick = (e) => {
            const container = getEditorContainerByElement(this.container);
            activeEditorManager.setActive(container);
            return this.currentController.onContainerClick(e);
        };
        this._onContainerDblClick = (e) => {
            return this.currentController.onContainerDblClick(e);
        };
        this._onContainerTripleClick = (e) => {
            return this.currentController.onContainerTripleClick(e);
        };
        this._onContainerPointerMove = (e) => {
            this._updateLastMousePos(e);
            this.container.slots.hoverUpdated.emit();
            return this._controllers[this.mouseMode.type].onContainerMouseMove(e);
        };
        this._onContainerPointerOut = (e) => {
            return this._controllers[this.mouseMode.type].onContainerMouseOut(e);
        };
        this._onContainerContextMenu = (e) => {
            e.raw.preventDefault();
            const mouseMode = this.mouseMode;
            if (mouseMode.type !== 'pan' && !this._rightClickTimer) {
                this._rightClickTimer = {
                    mouseMode,
                    timeStamp: e.raw.timeStamp,
                    timer: window.setTimeout(() => {
                        this._controllers['pan'].onContainerDragStart(e);
                    }, 233),
                };
            }
        };
        this._onContainerPointerUp = (e) => {
            if (e.button === 2 && this._rightClickTimer) {
                const { timer, timeStamp, mouseMode } = this._rightClickTimer;
                if (e.raw.timeStamp - timeStamp > 233) {
                    this.container.slots.mouseModeUpdated.emit(mouseMode);
                }
                else {
                    clearTimeout(timer);
                }
                this._rightClickTimer = null;
            }
        };
        this._onSelectionChangeWithoutDebounce = () => {
            updateLocalSelectionRange(this.page);
        };
        this.setMouseMode = (mouseMode, state = {
            selected: [],
            active: false,
        }) => {
            if (this.mouseMode === mouseMode)
                return;
            if (mouseMode.type === 'default') {
                if (!state.selected.length && this.lastState) {
                    state = this.lastState;
                    this.lastState = null;
                }
                else {
                    this.lastState = state;
                }
            }
            else if (this.state.selected.length) {
                this.lastState = this.state;
            }
            this.container.slots.mouseModeUpdated.emit(mouseMode);
            this.container.slots.selectionUpdated.emit(state);
        };
        this._controllers = {
            default: new DefaultModeController(this.container),
            text: new TextModeController(this.container),
            shape: new ShapeModeController(this.container),
            brush: new BrushModeController(this.container),
            pan: new PanModeController(this.container),
            note: new NoteModeController(this.container),
            connector: new ConnectorModeController(this.container),
        };
        this._initMouseAndWheelEvents();
    }
    _updateLastMousePos(e) {
        this._lastMousePos = {
            x: e.x,
            y: e.y,
        };
    }
    async _initMouseAndWheelEvents() {
        // due to surface initializing after one frame, the events handler should register after that.
        if (!this.container.surface) {
            await new Promise(resolve => requestAnimationFrame(resolve));
        }
        this._add('dragStart', ctx => {
            const event = ctx.get('pointerState');
            if (shouldFilterMouseEvent(event.raw))
                return;
            if (!isInsidePageTitle(event.raw.target) &&
                !isDatabaseInput(event.raw.target) &&
                !isInsideEdgelessTextEditor(event.raw.target)) {
                event.raw.preventDefault();
            }
            this._onContainerDragStart(event);
        });
        this._add('dragMove', ctx => {
            const event = ctx.get('pointerState');
            if (shouldFilterMouseEvent(event.raw))
                return;
            if (!isInsidePageTitle(event.raw.target) &&
                !isDatabaseInput(event.raw.target) &&
                !isInsideEdgelessTextEditor(event.raw.target)) {
                event.raw.preventDefault();
            }
            this._onContainerDragMove(event);
        });
        this._add('dragEnd', ctx => {
            const event = ctx.get('pointerState');
            if (!isInsidePageTitle(event.raw.target) &&
                !isDatabaseInput(event.raw.target) &&
                !isInsideEdgelessTextEditor(event.raw.target)) {
                event.raw.preventDefault();
            }
            this._onContainerDragEnd(event);
        });
        this._add('click', ctx => {
            const event = ctx.get('pointerState');
            if (!isInsidePageTitle(event.raw.target) &&
                !isDatabaseInput(event.raw.target) &&
                !isInsideEdgelessTextEditor(event.raw.target)) {
                event.raw.preventDefault();
            }
            this._onContainerClick(event);
        });
        this._add('doubleClick', ctx => {
            const event = ctx.get('pointerState');
            if (shouldFilterMouseEvent(event.raw))
                return;
            this._onContainerDblClick(event);
        });
        this._add('tripleClick', ctx => {
            const event = ctx.get('pointerState');
            if (shouldFilterMouseEvent(event.raw))
                return;
            this._onContainerTripleClick(event);
        });
        this._add('pointerMove', ctx => {
            const event = ctx.get('pointerState');
            if (shouldFilterMouseEvent(event.raw))
                return;
            if (!isInsidePageTitle(event.raw.target) &&
                !isDatabaseInput(event.raw.target) &&
                !isInsideEdgelessTextEditor(event.raw.target)) {
                event.raw.preventDefault();
            }
            this._onContainerPointerMove(event);
        });
        this._add('pointerUp', ctx => {
            const event = ctx.get('pointerState');
            this._onContainerPointerUp(event);
        });
        this._add('pointerOut', ctx => {
            const event = ctx.get('pointerState');
            this._onContainerPointerOut(event);
        });
        this._add('contextMenu', ctx => {
            const event = ctx.get('pointerState');
            this._onContainerContextMenu(event);
        });
        this._add('selectionChange', () => {
            this._onSelectionChangeWithoutDebounce();
        });
        this._add('wheel', ctx => {
            const state = ctx.get('defaultState');
            const e = state.event;
            if (!(e instanceof WheelEvent))
                return;
            e.preventDefault();
            const container = this.container;
            const { viewport } = container.surface;
            // pan
            if (!isPinchEvent(e)) {
                const dx = e.deltaX / viewport.zoom;
                const dy = e.deltaY / viewport.zoom;
                viewport.applyDeltaCenter(dx, dy);
                container.slots.viewportUpdated.emit();
            }
            // zoom
            else {
                const rect = container.getBoundingClientRect();
                // Perform zooming relative to the mouse position
                const [baseX, baseY] = container.surface.toModelCoord(e.clientX - rect.x, e.clientY - rect.y);
                const zoom = normalizeWheelDeltaY(e.deltaY, viewport.zoom);
                viewport.setZoom(zoom, new Point(baseX, baseY));
                container.slots.viewportUpdated.emit();
            }
        });
    }
    refreshRemoteSelection() {
        const element = document.querySelector('remote-selection');
        if (element) {
            element.requestUpdate();
        }
    }
    getHoverState() {
        if (!this.currentController.enableHover) {
            return null;
        }
        const { surface } = this.container;
        const frames = (this.page.root?.children ?? []).filter(child => child.flavour === 'affine:frame');
        const { x, y } = this._lastMousePos;
        const [modelX, modelY] = surface.toModelCoord(x, y);
        const hovered = surface.pickTop(modelX, modelY) || pickTopBlock(frames, modelX, modelY);
        // See https://github.com/toeverything/blocksuite/issues/1812
        if (
        // if not frame block
        !isTopLevelBlock(hovered) ||
            // if in other mouse mode
            this.mouseMode.type !== 'default' ||
            // if current selection is not active
            !this.state.active ||
            // if current selected block is not the hovered block
            this.state.selected[0].id !== hovered.id) {
            this.container.components.dragHandle?.hide();
        }
        if (!hovered || this.state.active) {
            return null;
        }
        const xywh = getXYWH(hovered);
        return {
            rect: getSelectionBoxBound(surface.viewport, xywh),
            content: hovered,
        };
    }
    switchToDefaultMode(state) {
        this.setMouseMode({ type: 'default' }, state);
    }
    clear() {
        this.selectedBlocks = [];
        this.lastState = null;
        this.state = {
            selected: [],
            active: false,
        };
    }
    dispose() {
        this._disposables.dispose();
    }
}
//# sourceMappingURL=selection-manager.js.map