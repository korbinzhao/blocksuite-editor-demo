import { SCROLL_THRESHOLD } from '@blocksuite/global/config';
import { matchFlavours } from '@blocksuite/store';
import { contains, getBlockElementsExcludeSubtrees, getRectByBlockElement, } from '../../../__internal__/index.js';
import { getExtendBlockRange } from '../../../__internal__/utils/block-range.js';
// distance to the upper and lower boundaries of the viewport
const threshold = SCROLL_THRESHOLD / 2;
function intersects(a, b, offset) {
    return (a.left + offset.x < b.right &&
        a.right + offset.x > b.left &&
        a.top + offset.y < b.bottom &&
        a.bottom + offset.y > b.top);
}
// See https://github.com/toeverything/blocksuite/pull/904 and
// https://github.com/toeverything/blocksuite/issues/839#issuecomment-1411742112
// for more context.
//
// The `bound` is a rect of drag-and-drop selection.
export function filterBlocksExcludeSubtrees(blockCache, bound, offset) {
    const entries = Array.from(blockCache.entries());
    const len = entries.length;
    const results = [];
    // empty
    if (len === 0)
        return results;
    let prevIndex = -1;
    for (let i = 0; i < len; i++) {
        const [block, rect] = entries[i];
        if (intersects(rect, bound, offset)) {
            if (prevIndex === -1) {
                prevIndex = i;
            }
            else {
                let prevBlock = entries[prevIndex][0];
                // prev block before and contains block
                if (contains(prevBlock, block)) {
                    if (matchFlavours(prevBlock.model, ['affine:database'])) {
                        continue;
                    }
                    else {
                        // not continuous block
                        if (results.length > 1) {
                            continue;
                        }
                        prevIndex = i;
                        results.shift();
                    }
                }
                else {
                    // backward search parent block and remove its subtree
                    // only keep blocks of same level
                    const { previousElementSibling } = block;
                    // previousElementSibling is not prev block and previousElementSibling contains prev block
                    if (previousElementSibling &&
                        previousElementSibling !== prevBlock &&
                        contains(previousElementSibling, prevBlock)) {
                        let n = i;
                        let m = results.length;
                        while (n--) {
                            prevBlock = entries[n][0];
                            if (prevBlock === previousElementSibling) {
                                results.push({ block: prevBlock, index: n });
                                break;
                            }
                            else if (m > 0) {
                                results.pop();
                                m--;
                            }
                        }
                    }
                    prevIndex = i;
                }
            }
            results.push({ block, index: i });
        }
    }
    return results;
}
export function updateLocalSelectionRange(page) {
    const blockRange = getExtendBlockRange(page);
    if (!blockRange || blockRange.type === 'Block') {
        return;
    }
    const userRange = {
        startOffset: blockRange.startOffset,
        endOffset: blockRange.endOffset,
        blockIds: blockRange.models.map(m => m.id),
    };
    page.awarenessStore.setLocalRange(page, userRange);
}
/*
function computeSelectionType(
  selectedBlocks: Element[],
  selectionType?: PageSelectionType
) {
  let newSelectionType: PageSelectionType = selectionType ?? 'native';

  const isOnlyBlock = selectedBlocks.length === 1;
  for (const block of selectedBlocks) {
    if (selectionType) continue;
    if (!('model' in block)) continue;

    // Calculate selection type
    const model = getModelByElement(block);
    newSelectionType = 'block';

    // Other selection types are possible if only one block is selected
    if (!isOnlyBlock) continue;

    const flavour = model.flavour;
    switch (flavour) {
      case 'affine:embed': {
        newSelectionType = 'embed';
        break;
      }
      case 'affine:database': {
        newSelectionType = 'database';
        break;
      }
    }
  }
  return newSelectionType;
}
*/
export function setSelectedBlocks(state, slots, selectedBlocks, rects) {
    state.selectedBlocks = selectedBlocks;
    if (rects) {
        slots.selectedRectsUpdated.emit(rects);
        return;
    }
    const calculatedRects = [];
    for (const block of getBlockElementsExcludeSubtrees(selectedBlocks)) {
        calculatedRects.push(getRectByBlockElement(block));
    }
    slots.selectedRectsUpdated.emit(calculatedRects);
}
export function autoScroll(selection, e, hooks) {
    const { state } = selection;
    const { y } = e.point;
    const { viewportElement } = selection;
    const { viewport } = state;
    const { scrollHeight, clientHeight } = viewport;
    let { scrollTop } = viewport;
    const max = scrollHeight - clientHeight;
    hooks.init();
    let auto = true;
    const autoScroll = () => {
        if (!auto) {
            state.clearRaf();
            return;
        }
        else {
            state.rafID = requestAnimationFrame(autoScroll);
        }
        // TODO: for the behavior of scrolling, see the native selection
        // speed easeOutQuad + easeInQuad
        if (Math.ceil(scrollTop) < max && clientHeight - y < threshold) {
            // ↓
            const d = (threshold - (clientHeight - y)) * 0.25;
            scrollTop += d;
            auto = Math.ceil(scrollTop) < max;
            viewportElement.scrollTop = scrollTop;
            hooks.onScroll(d);
        }
        else if (scrollTop > 0 && y < threshold) {
            // ↑
            const d = (y - threshold) * 0.25;
            scrollTop += d;
            auto = scrollTop > 0;
            viewportElement.scrollTop = scrollTop;
            hooks.onScroll(d);
        }
        else {
            auto = false;
            hooks.onMove();
        }
    };
    state.clearRaf();
    state.rafID = requestAnimationFrame(autoScroll);
}
//# sourceMappingURL=utils.js.map