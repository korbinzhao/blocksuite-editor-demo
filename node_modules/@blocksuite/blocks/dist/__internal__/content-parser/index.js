import { assertExists } from '@blocksuite/global/utils';
import { Slot } from '@blocksuite/store';
import { toPng } from 'html-to-image';
import { marked } from 'marked';
import { getFileFromClipboard } from '../clipboard/utils/pure.js';
import { getEditorContainer } from '../utils/index.js';
import { FileExporter } from './file-exporter/file-exporter.js';
import { HtmlParser } from './parse-html.js';
export class ContentParser {
    constructor(page, fetchFileHandler, textStyleHandler, tableParserHandler) {
        this.slots = {
            beforeHtml2Block: new Slot(),
        };
        this._parsers = {};
        this.urlPattern = /(?<=\s|^)https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)(?=\s|$)/g;
        this._page = page;
        this._htmlParser = new HtmlParser(this, page, fetchFileHandler, textStyleHandler, tableParserHandler);
        this._htmlParser.registerParsers();
    }
    async exportHtml() {
        const root = this._page.root;
        if (!root)
            return;
        const htmlContent = await this.block2Html(this._getSelectedBlock(root).children[1].children);
        FileExporter.exportHtml(root.title.toString(), htmlContent);
    }
    async exportMarkdown() {
        const root = this._page.root;
        if (!root)
            return;
        const htmlContent = await this.block2Html(this._getSelectedBlock(root).children[1].children);
        FileExporter.exportHtmlAsMarkdown(root.title.toString(), htmlContent);
    }
    async exportPng() {
        const root = this._page.root;
        if (!root)
            return;
        const editorContainer = getEditorContainer(this._page);
        const styleElement = document.createElement('style');
        styleElement.textContent =
            'editor-container,.affine-editor-container {height: auto;}';
        editorContainer.appendChild(styleElement);
        FileExporter.exportPng(root.title.toString(), await toPng(editorContainer, {
            cacheBust: true,
        }));
        editorContainer.removeChild(styleElement);
    }
    async exportPdf() {
        const root = this._page.root;
        if (!root)
            return;
        window.print();
    }
    async block2Html(blocks) {
        let htmlText = '';
        for (let currentIndex = 0; currentIndex < blocks.length; currentIndex++) {
            htmlText =
                htmlText +
                    (await this._getHtmlInfoBySelectionInfo(blocks[currentIndex]));
        }
        return htmlText;
    }
    async block2Text(blocks) {
        return (await Promise.all(blocks.map(block => this._getTextInfoBySelectionInfo(block)))).reduce((text, block) => text + block, '');
    }
    async htmlText2Block(html) {
        const htmlEl = document.createElement('html');
        htmlEl.innerHTML = html;
        htmlEl.querySelector('head')?.remove();
        this.slots.beforeHtml2Block.emit(htmlEl);
        return this._convertHtml2Blocks(htmlEl);
    }
    async file2Blocks(clipboardData) {
        const file = getFileFromClipboard(clipboardData);
        if (file) {
            if (file.type.includes('image')) {
                // TODO: upload file to file server
                // XXX: should use blob storage here?
                const storage = this._page.blobs;
                assertExists(storage);
                const id = await storage.set(file);
                return [
                    {
                        flavour: 'affine:embed',
                        type: 'image',
                        sourceId: id,
                        children: [],
                    },
                ];
            }
        }
        return [];
    }
    async markdown2Block(text) {
        const underline = {
            name: 'underline',
            level: 'inline',
            start(src) {
                return src.indexOf('~');
            },
            tokenizer(src) {
                const rule = /^~([^~]+)~/;
                const match = rule.exec(src);
                if (match) {
                    return {
                        type: 'underline',
                        raw: match[0],
                        text: match[1].trim(), // You can add additional properties to your tokens to pass along to the renderer
                    };
                }
                return;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            renderer(token) {
                return `<u>${token.text}</u>`;
            },
        };
        const inlineCode = {
            name: 'inlineCode',
            level: 'inline',
            start(src) {
                return src.indexOf('`');
            },
            tokenizer(src) {
                const rule = /^(?:`)(`{2,}?|[^`]+)(?:`)$/g;
                const match = rule.exec(src);
                if (match) {
                    return {
                        type: 'inlineCode',
                        raw: match[0],
                        text: match[1].trim(), // You can add additional properties to your tokens to pass along to the renderer
                    };
                }
                return;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            renderer(token) {
                return `<code>${token.text}</code>`;
            },
        };
        marked.use({ extensions: [underline, inlineCode] });
        const md2html = marked.parse(text);
        return this.htmlText2Block(md2html);
    }
    async importMarkdown(text, insertPositionId) {
        const blocks = await this.markdown2Block(text);
        const insertBlockModel = this._page.getBlockById(insertPositionId);
        assertExists(insertBlockModel);
        const { getServiceOrRegister } = await import('../service.js');
        const service = await getServiceOrRegister(insertBlockModel.flavour);
        service.json2Block(insertBlockModel, blocks);
    }
    async importHtml(text, insertPositionId) {
        const blocks = await this.htmlText2Block(text);
        const insertBlockModel = this._page.getBlockById(insertPositionId);
        assertExists(insertBlockModel);
        const { getServiceOrRegister } = await import('../service.js');
        const service = await getServiceOrRegister(insertBlockModel.flavour);
        service.json2Block(insertBlockModel, blocks);
    }
    registerParserHtmlText2Block(name, handler) {
        this._parsers[name] = handler;
    }
    getParserHtmlText2Block(name) {
        return this._parsers[name] || null;
    }
    text2blocks(text) {
        return text.split('\n').map((str) => {
            const splitText = str.split(this.urlPattern);
            const urls = str.match(this.urlPattern);
            const result = [];
            for (let i = 0; i < splitText.length; i++) {
                if (splitText[i]) {
                    result.push({ insert: splitText[i] });
                }
                if (urls && urls[i]) {
                    result.push({ insert: urls[i], attributes: { link: urls[i] } });
                }
            }
            return {
                flavour: 'affine:paragraph',
                type: 'text',
                text: result,
                children: [],
            };
        });
    }
    _getSelectedBlock(model) {
        return {
            id: model.id,
            children: model.children.map(child => this._getSelectedBlock(child)),
        };
    }
    async _getHtmlInfoBySelectionInfo(block) {
        const model = this._page.getBlockById(block.id);
        if (!model) {
            return '';
        }
        const children = [];
        for (let currentIndex = 0; currentIndex < block.children.length; currentIndex++) {
            const childText = await this._getHtmlInfoBySelectionInfo(block.children[currentIndex]);
            childText && children.push(childText);
        }
        const { getServiceOrRegister } = await import('../service.js');
        const service = await getServiceOrRegister(model.flavour);
        return service.block2html(model, {
            childText: children.join(''),
            begin: block.startPos,
            end: block.endPos,
        });
    }
    async _getTextInfoBySelectionInfo(selectedBlock) {
        const model = this._page.getBlockById(selectedBlock.id);
        if (!model) {
            return '';
        }
        const children = [];
        for (const child of selectedBlock.children) {
            const childText = await this._getTextInfoBySelectionInfo(child);
            childText && children.push(childText);
        }
        const { getServiceOrRegister } = await import('../service.js');
        const service = await getServiceOrRegister(model.flavour);
        return service.block2Text(model, {
            childText: children.join(''),
            begin: selectedBlock.startPos,
            end: selectedBlock.endPos,
        });
    }
    async _convertHtml2Blocks(element) {
        const openBlockPromises = Array.from(element.children).map(async (childElement) => {
            return ((await this.getParserHtmlText2Block('nodeParser')?.(childElement)) ||
                []);
        });
        const results = [];
        for (const item of openBlockPromises) {
            results.push(await item);
        }
        return results.flat().filter(v => v);
    }
}
//# sourceMappingURL=index.js.map