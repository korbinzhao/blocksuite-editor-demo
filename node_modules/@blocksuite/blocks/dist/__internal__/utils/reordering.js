// Reorders the shapes or frames.
/**
 * Gets indexes of a from b.
 */
export function getIndexesWith(a, b) {
    return a.map(e => b.findIndex(element => element === e));
}
/**
 * Generates the ranges via indexes;
 */
export function generateRanges(indexes) {
    let curr;
    let i = 1;
    let start = indexes[0];
    let end = indexes[0];
    const ranges = [{ start, end }];
    const len = indexes.length;
    for (; i < len; i++) {
        curr = indexes[i];
        if (curr - end === 1) {
            ranges[ranges.length - 1].end = end = curr;
        }
        else {
            start = end = curr;
            ranges.push({ start, end });
        }
    }
    return ranges;
}
/**
 * Reorders the elements, moving multiple ranges of child elements to the end.
 */
export function bringToFront(ranges, elements) {
    let n = 0;
    let i = ranges.length;
    const t = elements.length;
    while (i) {
        i--;
        const { start, end } = ranges[i];
        const temp = elements.splice(start, end + 1 - start);
        n += temp.length;
        elements.splice(t - n, 0, ...temp);
    }
}
/**
 * Reorders the elements, moving multiple ranges of child elements forward.
 */
export function bringForward(ranges, elements) {
    let i = ranges.length;
    while (i) {
        i--;
        const { start, end } = ranges[i];
        const temp = elements.splice(start, end + 1 - start);
        elements.splice(start + 1, 0, ...temp);
    }
}
/**
 * Reorders the elements, moving multiple ranges of child elements backward.
 */
export function sendBackward(ranges, elements) {
    let i = 0;
    const len = ranges.length;
    for (; i < len; i++) {
        const { start, end } = ranges[i];
        if (start === 0)
            continue;
        const temp = elements.splice(start, end + 1 - start);
        elements.splice(start - 1, 0, ...temp);
    }
}
/**
 * Reorders the elements, moving multiple ranges of child elements to the start.
 */
export function sendToBack(ranges, elements) {
    let i = 0;
    let n = 0;
    const len = ranges.length;
    for (; i < len; i++) {
        const { start, end } = ranges[i];
        const temp = elements.splice(start, end + 1 - start);
        elements.splice(n, 0, ...temp);
        n += temp.length;
    }
}
/**
 * Brings to front or sends to back.
 */
export function reorderTo(elements, compare, getIndexes, genKeys, setIndexes) {
    if (!elements.length) {
        return;
    }
    elements.sort(compare);
    const { start, end } = getIndexes(elements);
    const keys = genKeys(start, end, elements.length);
    setIndexes(keys, elements);
}
/**
 * Brings forward or sends backward layer by layer.
 */
export function reorder(elements, compare, pick, getIndexes, order, genKeys, setIndexes) {
    if (!elements.length) {
        return;
    }
    elements.sort(compare);
    const pickedElements = pick().sort(compare);
    const { start, end } = getIndexes(pickedElements);
    const indexes = getIndexesWith(elements, pickedElements);
    const ranges = generateRanges(indexes);
    order(ranges, pickedElements);
    const keys = genKeys(start, end, pickedElements.length);
    setIndexes(keys, pickedElements);
}
/**
 * Generates bounds with selected elements.
 */
export function generateBounds(elements, getXYWH) {
    const bounds = {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
    };
    const len = elements.length;
    if (len) {
        let i = 0;
        const { x, y, w, h } = getXYWH(elements[i]);
        let minX = x;
        let minY = y;
        let maxX = x + w;
        let maxY = y + h;
        for (i++; i < len; i++) {
            const { x, y, w, h } = getXYWH(elements[i]);
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x + w);
            maxY = Math.max(maxY, y + h);
        }
        bounds.x = minX;
        bounds.y = minY;
        bounds.w = maxX - minX;
        bounds.h = maxY - minY;
    }
    return bounds;
}
//# sourceMappingURL=reordering.js.map