import type { PointerEventState } from '@blocksuite/lit';
import type { BaseBlockModel, Page } from '@blocksuite/store';
import type { FrameBlockComponent } from '../../frame-block/index.js';
import type { SelectionPosition } from './types.js';
/**
 * As the title is a text area, this function does not yet have support for `SelectionPosition`.
 */
export declare function focusTitle(page: Page, index?: number, len?: number): void;
export declare function focusRichText(editableContainer: Element, position?: SelectionPosition, zoom?: number): Promise<void>;
export declare function focusBlockByModel(model: BaseBlockModel, position?: SelectionPosition, zoom?: number): void;
export declare function focusPreviousBlock(model: BaseBlockModel, position?: SelectionPosition, zoom?: number): void;
export declare function focusNextBlock(model: BaseBlockModel, position?: SelectionPosition, zoom?: number): void;
export declare function resetNativeSelection(range: Range | null): void;
export declare function clearSelection(page: Page): void;
/**
 * Return true if has native selection in the document.
 *
 * @example
 * ```ts
 * const isNativeSelection = hasNativeSelection();
 * if (isNativeSelection) {
 *   // do something
 * }
 * ```
 */
export declare function hasNativeSelection(): boolean;
export declare function isCollapsedNativeSelection(): boolean;
export declare function isRangeNativeSelection(): boolean;
/**
 * Determine if the range contains multiple block.
 *
 * Please check the difference between {@link isMultiLineRange} before use this function
 */
export declare function isMultiBlockRange(range?: Range): boolean;
/**
 * Determine if the range contains multiple lines.
 *
 * Note that this function is very similar to {@link isMultiBlockRange},
 * but they are slightly different.
 *
 * Consider the following scenarios:
 * One block contains multiple lines,
 * if you select multiple lines of text under this block,
 * this function will return true,
 * but {@link isMultiBlockRange} will return false.
 */
export declare function isMultiLineRange(range?: Range): boolean;
export declare function getCurrentNativeRange(selection?: Selection | null): Range;
export declare function handleNativeRangeDragMove(startRange: Range | null, e: PointerEventState): void;
export declare function isBlankArea(e: PointerEventState): boolean;
export declare function handleNativeRangeClick(page: Page, e: PointerEventState, container?: HTMLElement): void;
export declare function handleNativeRangeAtPoint(x: number, y: number): void;
export declare function handleNativeRangeDblClick(): Range | null;
/**
 * left first search all leaf text nodes
 * @example
 *  <div><p>he<em>ll</em>o</p><p>world</p></div>
 *  => [he, ll, o, world]
 **/
export declare function leftFirstSearchLeafNodes(node: Node, leafNodes?: Node[]): Text[];
export declare function getLastTextNode(node: Node): Text | undefined;
export declare function getFirstTextNode(node: Node): Text;
export declare function getSplicedTitle(title: HTMLTextAreaElement): string;
export declare function isEmbed(e: PointerEventState): boolean;
export declare function isDatabase(e: PointerEventState): boolean;
/**
 * Get the closest element in the horizontal position
 */
export declare function getHorizontalClosestElement<K extends keyof HTMLElementTagNameMap>(clientY: number, selectors: K, container?: Element): HTMLElementTagNameMap[K] | null;
export declare function getHorizontalClosestElement<K extends keyof SVGElementTagNameMap>(clientY: number, selectors: K, container?: Element): SVGElementTagNameMap[K] | null;
export declare function getHorizontalClosestElement<E extends Element = Element>(clientY: number, selectors: string, container?: Element): E | null;
/**
 * Get the closest editor element in the horizontal position
 */
export declare function getClosestEditor(clientY: number, container?: HTMLElement): Element | null;
/**
 * Get the closest frame element in the horizontal position
 */
export declare function getClosestFrame(clientY: number): FrameBlockComponent | null;
/**
 * Handle native range with triple click.
 */
export declare function handleNativeRangeTripleClick(e: PointerEventState): Range | null;
//# sourceMappingURL=selection.d.ts.map