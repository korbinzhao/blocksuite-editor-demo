export type ReorderingType = 'front' | 'forward' | 'backward' | 'back';
export interface ReorderingAction<T> {
    type: ReorderingType;
    elements: T[];
}
export interface ReorderingRange {
    start: number;
    end: number;
}
/**
 * Gets indexes of a from b.
 */
export declare function getIndexesWith<T>(a: T[], b: T[]): number[];
/**
 * Generates the ranges via indexes;
 */
export declare function generateRanges(indexes: number[]): ReorderingRange[];
/**
 * Reorders the elements, moving multiple ranges of child elements to the end.
 */
export declare function bringToFront<T>(ranges: ReorderingRange[], elements: T[]): void;
/**
 * Reorders the elements, moving multiple ranges of child elements forward.
 */
export declare function bringForward<T>(ranges: ReorderingRange[], elements: T[]): void;
/**
 * Reorders the elements, moving multiple ranges of child elements backward.
 */
export declare function sendBackward<T>(ranges: ReorderingRange[], elements: T[]): void;
/**
 * Reorders the elements, moving multiple ranges of child elements to the start.
 */
export declare function sendToBack<T>(ranges: ReorderingRange[], elements: T[]): void;
/**
 * Brings to front or sends to back.
 */
export declare function reorderTo<T>(elements: T[], compare: (a: T, b: T) => number, getIndexes: (elements: T[]) => {
    start: string | null;
    end: string | null;
}, genKeys: (start: string | null, end: string | null, len: number) => string[], setIndexes: (keys: string[], elements: T[]) => void): void;
/**
 * Brings forward or sends backward layer by layer.
 */
export declare function reorder<T>(elements: T[], compare: (a: T, b: T) => number, pick: () => T[], getIndexes: (pickedElements: T[]) => {
    start: string | null;
    end: string | null;
}, order: (ranges: ReorderingRange[], pickedElements: T[]) => void, genKeys: (start: string | null, end: string | null, len: number) => string[], setIndexes: (keys: string[], pickedElements: T[]) => void): void;
/**
 * Generates bounds with selected elements.
 */
export declare function generateBounds<T>(elements: T[], getXYWH: (e: T) => {
    x: number;
    y: number;
    h: number;
    w: number;
}): {
    x: number;
    y: number;
    h: number;
    w: number;
};
//# sourceMappingURL=reordering.d.ts.map