import { assertExists, } from '@blocksuite/store';
import { getDefaultPage, getModelByElement, getModelsByRange, getVirgoByModel, isInsidePageTitle, } from './query.js';
import { focusTitle, getCurrentNativeRange, hasNativeSelection, resetNativeSelection, } from './selection.js';
export function getCurrentBlockRange(page) {
    // check exist block selection
    const pageBlock = getDefaultPage(page);
    if (pageBlock) {
        const selectedBlocks = pageBlock.selection.state.selectedBlocks;
        // Add embeds block to fix click image and delete case
        const selectedEmbeds = pageBlock.selection.state.selectedEmbeds;
        // Fix order may be wrong
        const models = [...selectedBlocks, ...selectedEmbeds]
            .map(element => getModelByElement(element))
            .filter(Boolean);
        if (models.length) {
            return {
                type: 'Block',
                startOffset: 0,
                endOffset: models[models.length - 1].text?.length ?? 0,
                models,
            };
        }
    }
    // check exist native selection
    if (hasNativeSelection()) {
        const range = getCurrentNativeRange();
        const blockRange = nativeRangeToBlockRange(range);
        if (!blockRange) {
            return null;
        }
        return { ...blockRange, nativeRange: range };
    }
    return null;
}
export function blockRangeToNativeRange(blockRange) {
    // special case for title
    if (blockRange.type === 'Title') {
        const page = blockRange.models[0].page;
        const pageElement = getDefaultPage(page);
        if (!pageElement) {
            // Maybe in edgeless mode
            return null;
        }
        const titleVEditor = pageElement.titleVEditor;
        const [startNode, startOffset] = titleVEditor.getTextPoint(blockRange.startOffset);
        const [endNode, endOffset] = titleVEditor.getTextPoint(blockRange.endOffset);
        const range = new Range();
        range.setStart(startNode, startOffset);
        range.setEnd(endNode, endOffset);
        return range;
    }
    const models = blockRange.models.filter(model => model.text);
    if (!models.length) {
        // BlockRange may be selected embeds, and it don't have text
        // so we can't convert it to native range
        return null;
    }
    const [startNode, startOffset] = getTextNodeByModel(models[0], blockRange.startOffset);
    const [endNode, endOffset] = getTextNodeByModel(models[models.length - 1], blockRange.endOffset);
    const range = new Range();
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
    return range;
}
export function nativeRangeToBlockRange(range) {
    // TODO check range is in page
    const models = getModelsByRange(range);
    if (!models.length) {
        // NativeRange may be outside of the editor
        // so we can't convert it to block range
        return null;
    }
    const startVRange = getVRangeByNode(range.startContainer);
    const endVRange = getVRangeByNode(range.endContainer);
    if (!startVRange || !endVRange) {
        return null;
    }
    const startOffset = startVRange.index;
    const endOffset = endVRange.index + endVRange.length;
    return {
        type: 'Native',
        startOffset,
        endOffset,
        models,
    };
}
/**
 * Sometimes, the block in the block range is updated, we need to update the block range manually.
 *
 * Note: it will mutate the `blockRange` object.
 */
export function updateBlockRange(blockRange, oldModel, newModel) {
    blockRange.models = blockRange.models.map(model => model === oldModel ? newModel : model);
    return blockRange;
}
/**
 * Restore the block selection.
 * See also {@link resetNativeSelection}
 */
export function restoreSelection(blockRange) {
    if (!blockRange.models.length) {
        throw new Error("Can't restore selection, blockRange.models is empty");
    }
    const page = blockRange.models[0].page;
    const defaultPageBlock = getDefaultPage(page);
    if (blockRange.type === 'Native') {
        const range = blockRangeToNativeRange(blockRange);
        resetNativeSelection(range);
        // In the default mode
        if (defaultPageBlock) {
            defaultPageBlock.selection.state.clearBlockSelection();
            defaultPageBlock.selection.state.type = 'native';
        }
        return;
    }
    if (blockRange.type === 'Block') {
        // In the default mode
        if (defaultPageBlock) {
            defaultPageBlock.selection.state.type = 'block';
            defaultPageBlock.selection.refreshSelectedBlocksRectsByModels(blockRange.models);
        }
        // Try clean native selection
        resetNativeSelection(null);
        document.activeElement.blur();
        return;
    }
    // In the default mode
    if (defaultPageBlock && blockRange.type === 'Title') {
        focusTitle(page, blockRange.startOffset, blockRange.endOffset - blockRange.startOffset);
        return;
    }
    throw new Error('Invalid block range type: ' + blockRange.type);
}
/**
 * Get the block range that includes the title range.
 *
 * In most cases, we should use {@link getCurrentBlockRange} to get current block range.
 *
 */
export function getExtendBlockRange(page) {
    const basicBlockRange = getCurrentBlockRange(page);
    if (basicBlockRange)
        return basicBlockRange;
    // Check title
    if (!hasNativeSelection()) {
        return null;
    }
    const range = getCurrentNativeRange();
    const isTitleRange = isInsidePageTitle(range.startContainer) &&
        isInsidePageTitle(range.endContainer);
    if (isTitleRange) {
        const pageModel = page.root;
        assertExists(pageModel);
        return {
            type: 'Title',
            startOffset: range.startOffset,
            endOffset: range.endOffset,
            models: [pageModel],
        };
    }
    return null;
}
export function getVRangeByNode(node) {
    if (!node.parentElement)
        return null;
    const virgoElement = node.parentElement.closest('[data-virgo-root="true"]') ||
        (node instanceof HTMLElement
            ? node.querySelector('[data-virgo-root="true"]')
            : null);
    const vEditor = virgoElement?.virgoEditor;
    if (!vEditor)
        return null;
    return vEditor.getVRange();
}
/**
 * Get the specific text node and offset by the selected block.
 * The reverse implementation of {@link getVRangeByNode}
 * See also {@link getVRangeByNode}
 *
 * ```ts
 * const [startNode, startOffset] = getTextNodeBySelectedBlock(startModel, startOffset);
 * const [endNode, endOffset] = getTextNodeBySelectedBlock(endModel, endOffset);
 *
 * const range = new Range();
 * range.setStart(startNode, startOffset);
 * range.setEnd(endNode, endOffset);
 *
 * const selection = window.getSelection();
 * selection.removeAllRanges();
 * selection.addRange(range);
 * ```
 */
export function getTextNodeByModel(model, offset = 0) {
    const text = model.text;
    if (!text) {
        throw new Error("Failed to get block's text!");
    }
    if (offset > text.length) {
        offset = text.length;
        // FIXME enable strict check
        // console.error(
        //   'Offset is out of range! model: ',
        //   model,
        //   'offset: ',
        //   offset,
        //   'text: ',
        //   text.toString(),
        //   'text.length: ',
        //   text.length
        // );
    }
    const vEditor = getVirgoByModel(model);
    // TODO this assert is unreliable
    assertExists(vEditor);
    const [leaf, leafOffset] = vEditor.getTextPoint(offset);
    return [leaf, leafOffset];
}
export const experimentCreateBlockRange = (rangeOrBlockRange) => {
    let cacheRange = rangeOrBlockRange instanceof Range ? rangeOrBlockRange : null;
    const blockRange = rangeOrBlockRange instanceof Range
        ? nativeRangeToBlockRange(rangeOrBlockRange)
        : rangeOrBlockRange;
    if (!blockRange) {
        return null;
    }
    if (!blockRange.models.length) {
        throw new Error('Block range must have at least one model.');
    }
    const getRange = () => {
        // cache range may be expired
        if (cacheRange) {
            return cacheRange;
        }
        cacheRange = blockRangeToNativeRange(blockRange);
        return cacheRange;
    };
    return {
        ...blockRange,
        startModel: blockRange.models[0],
        endModel: blockRange.models[blockRange.models.length - 1],
        betweenModels: blockRange.models.slice(1, blockRange.models.length - 1),
        get range() {
            return getRange();
        },
        collapsed: blockRange.models.length === 1 &&
            blockRange.startOffset === blockRange.endOffset,
        apply() {
            restoreSelection(blockRange);
        },
    };
};
//# sourceMappingURL=block-range.js.map