import { type BaseBlockModel, type Page } from '@blocksuite/store';
import type { VRange } from '@blocksuite/virgo';
/**
 * The {@link BlockRange} is designed to make consistency between the browser-native range and the block range.
 *
 * It's different from {@link VRange} since the user can select multiple blocks at a time, and {@link VRange} can't handle range cross blocks.
 */
/**
 * Use {@link getCurrentBlockRange} to get current block range.
 *
 * You can use {@link nativeRangeToBlockRange} and {@link blockRangeToNativeRange} convert between native range and block range.
 */
export type BlockRange = {
    /**
     * 'Native' for native selection, 'Block' for block selection
     */
    type: 'Native' | 'Block';
    /**
     * Promise the length of models is greater than 0
     */
    models: BaseBlockModel[];
    startOffset: number;
    endOffset: number;
};
type ExtendBlockRange = {
    type: 'Title';
    startOffset: number;
    endOffset: number;
    /**
     * Only one model, the page model
     */
    models: [BaseBlockModel];
};
export declare function getCurrentBlockRange(page: Page): {
    type: "Block";
    startOffset: number;
    endOffset: number;
    models: BaseBlockModel<object>[];
} | {
    nativeRange: Range;
    type: "Native";
    startOffset: number;
    endOffset: number;
    models: BaseBlockModel<object>[];
} | null;
export declare function blockRangeToNativeRange(blockRange: BlockRange | ExtendBlockRange): Range | null;
export declare function nativeRangeToBlockRange(range: Range): {
    type: "Native";
    startOffset: number;
    endOffset: number;
    models: BaseBlockModel<object>[];
} | null;
/**
 * Sometimes, the block in the block range is updated, we need to update the block range manually.
 *
 * Note: it will mutate the `blockRange` object.
 */
export declare function updateBlockRange(blockRange: BlockRange, oldModel: BaseBlockModel, newModel: BaseBlockModel): BlockRange;
/**
 * Restore the block selection.
 * See also {@link resetNativeSelection}
 */
export declare function restoreSelection(blockRange: BlockRange | ExtendBlockRange): void;
/**
 * Get the block range that includes the title range.
 *
 * In most cases, we should use {@link getCurrentBlockRange} to get current block range.
 *
 */
export declare function getExtendBlockRange(page: Page): BlockRange | ExtendBlockRange | null;
export declare function getVRangeByNode(node: Node): VRange | null;
/**
 * Get the specific text node and offset by the selected block.
 * The reverse implementation of {@link getVRangeByNode}
 * See also {@link getVRangeByNode}
 *
 * ```ts
 * const [startNode, startOffset] = getTextNodeBySelectedBlock(startModel, startOffset);
 * const [endNode, endOffset] = getTextNodeBySelectedBlock(endModel, endOffset);
 *
 * const range = new Range();
 * range.setStart(startNode, startOffset);
 * range.setEnd(endNode, endOffset);
 *
 * const selection = window.getSelection();
 * selection.removeAllRanges();
 * selection.addRange(range);
 * ```
 */
export declare function getTextNodeByModel(model: BaseBlockModel, offset?: number): readonly [Text, number];
type ExperimentBlockRange = {
    type: 'Native' | 'Block';
    range: Range | null;
    models: BaseBlockModel[];
    startModel: BaseBlockModel;
    endModel: BaseBlockModel;
    betweenModels: BaseBlockModel[];
    startOffset: number;
    endOffset: number;
    collapsed: boolean;
    apply: () => void;
};
export declare const experimentCreateBlockRange: (rangeOrBlockRange: Range | BlockRange) => ExperimentBlockRange | null;
export {};
//# sourceMappingURL=block-range.d.ts.map