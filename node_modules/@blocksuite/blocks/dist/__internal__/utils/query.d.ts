import type { BaseBlockModel, Page } from '@blocksuite/store';
import { type AbstractEditor } from '../../__internal__/utils/types.js';
import type { DefaultPageBlockComponent } from '../../page-block/default/default-page-block.js';
import type { EdgelessPageBlockComponent } from '../../page-block/edgeless/edgeless-page-block.js';
import type { RichText } from '../rich-text/rich-text.js';
import { type Point, Rect } from './rect.js';
type ElementTagName = keyof HTMLElementTagNameMap;
export type BlockComponentElement = HTMLElementTagNameMap[keyof HTMLElementTagNameMap] extends infer U ? U extends {
    model: infer M;
} ? M extends BaseBlockModel ? U : never : never : never;
/**
 * @deprecated Use `page.getParent` instead
 */
export declare function getParentBlockById<T extends ElementTagName>(id: string, ele?: Element): RichText | import("../../bookmark-block/components/bookmark-operation-popper.js").BookmarkOperationMenu | import("../../bookmark-block/components/bookmark-toolbar.js").BookmarkToolbar | import("../../bookmark-block/components/bookmark-edit-modal.js").BookmarkEditModal | import("../../bookmark-block/components/bookmark-create-modal.js").BookmarkCreateModal | import("../../index.js").BookmarkBlockComponent | import("../../index.js").ListBlockComponent | import("../../index.js").CodeBlockComponent | import("../../database-block/table/table-view.js").DatabaseTable | import("../../database-block/kanban/kanban-view.js").DatabaseKanban | import("../../index.js").DatabaseBlockComponent | DefaultPageBlockComponent | EdgelessPageBlockComponent | import("../../index.js").EmbedBlockComponent | import("../../index.js").ImageBlockComponent | import("../../index.js").DividerBlockComponent | import("../../index.js").ParagraphBlockComponent | import("../../index.js").FrameBlockComponent;
/**
 *
 * @example
 * ```md
 * page
 * - frame
 *  - paragraph <- when invoked here, the traverse order will be following
 *    - child <- 1
 *  - sibling <- 2
 * - frame <- 3 (will be skipped)
 *   - paragraph <- 4
 * ```
 *
 * NOTE: this method will skip the `affine:frame` block
 */
export declare function getNextBlock(model: BaseBlockModel, map?: Record<string, true>): BaseBlockModel | null;
/**
 *
 * @example
 * ```md
 * page
 * - frame
 *   - paragraph <- 5
 * - frame <- 4 (will be skipped)
 *  - paragraph <- 3
 *    - child <- 2
 *      - child <- 1
 *  - paragraph <- when invoked here, the traverse order will be above
 * ```
 *
 * NOTE: this method will skip the `affine:frame` and `affine:page` block
 */
export declare function getPreviousBlock(model: BaseBlockModel, map?: Record<string, true>): BaseBlockModel | null;
/**
 * Returns `DefaultPageBlockComponent` | `EdgelessPageBlockComponent` if it exists
 * otherwise return `null`.
 */
export declare function getPageBlock(model: BaseBlockModel): DefaultPageBlockComponent | EdgelessPageBlockComponent | null;
/**
 * If it's not in the page mode, it will return `null` directly.
 */
export declare function getDefaultPage(page: Page): DefaultPageBlockComponent | null;
/**
 * If it's not in the edgeless mode, it will return `null` directly.
 */
export declare function getEdgelessPage(page: Page): EdgelessPageBlockComponent | null;
/**
 * This function exposes higher levels of abstraction.
 *
 * PLEASE USE IT WITH CAUTION!
 */
export declare function getEditorContainer(page: Page): AbstractEditor;
export declare function getEditorContainerByElement(ele: Element): Element;
export declare function isPageMode(page: Page): boolean;
/**
 * Get editor viewport element.
 *
 * @example
 * ```ts
 * const viewportElement = getViewportElement(this.model.page);
 * if (!viewportElement) return;
 * this._disposables.addFromEvent(viewportElement, 'scroll', () => {
 *   updatePosition();
 * });
 * ```
 */
export declare function getViewportElement(page: Page): HTMLDivElement | null;
export declare function getBlockElementByModel(model: BaseBlockModel): BlockComponentElement | null;
export declare function asyncGetBlockElementByModel(model: BaseBlockModel): Promise<BlockComponentElement | null>;
export declare function getStartModelBySelection(range?: Range): BaseBlockModel<object> | null;
/**
 * @deprecated In most cases, you not need RichText, you can use {@link getVirgoByModel} instead.
 */
export declare function getRichTextByModel(model: BaseBlockModel): RichText | null;
export declare function asyncGetRichTextByModel(model: BaseBlockModel): Promise<RichText | null>;
export declare function getVirgoByModel(model: BaseBlockModel): import("../rich-text/virgo/types.js").AffineVEditor | null;
export declare function asyncGetVirgoByModel(model: BaseBlockModel): Promise<import("../rich-text/virgo/types.js").AffineVEditor | null>;
export declare function getModelsByRange(range: Range): BaseBlockModel[];
export declare function getModelByElement(element: Element): BaseBlockModel;
export declare function getDOMRectByLine(rectList: DOMRectList, lineType: 'first' | 'last'): DOMRect;
export declare function isInsideRichText(element: unknown): element is RichText;
export declare function isInsidePageTitle(element: unknown): boolean;
export declare function isInsideEdgelessTextEditor(element: unknown): boolean;
export declare function isToggleIcon(element: unknown): element is SVGPathElement;
export declare function isDatabaseInput(element: unknown): boolean;
export declare function isRawInput(element: unknown): boolean;
export declare function isInsideDatabaseTitle(element: unknown): boolean;
export declare function isCaptionElement(node: unknown): node is HTMLInputElement;
export declare function getElementFromEventTarget(target: EventTarget | null): Element | null;
/**
 * Returns `16` if node is contained in the parent.
 * Otherwise return `0`.
 */
export declare function contains(parent: Element, node: Element): number;
/**
 * Returns `true` if node is contained in the elements.
 */
export declare function isContainedIn(elements: Element[], node: Element): boolean;
/**
 * Returns `true` if element has `data-block-id` attribute.
 */
export declare function hasBlockId(element: Element): boolean;
/**
 * Returns `true` if element is default page.
 */
export declare function isDefaultPage({ tagName }: Element): boolean;
/**
 * Returns `true` if element is edgeless page.
 */
export declare function isEdgelessPage({ tagName }: Element): boolean;
/**
 * Returns `true` if element is default/edgeless page or frame.
 */
export declare function isPageOrFrameOrSurface(element: Element): boolean;
/**
 * Returns `true` if element is not page or frame.
 */
export declare function isBlock(element: Element): boolean;
/**
 * Returns `true` if element is image.
 */
export declare function isImage({ tagName, firstElementChild }: Element): boolean;
/**
 * Returns `true` if element is edgeless block child.
 */
export declare function isEdgelessBlockChild({ classList }: Element): boolean;
/**
 * Returns the closest block element by a point in the rect.
 *
 * ```
 * ############### block
 * ||############# block
 * ||||########### block
 * ||||    ...
 * ||||  y - 2 * n
 * ||||    ...
 * ||||----------- cursor
 * ||||    ...
 * ||||  y + 2 * n
 * ||||    ...
 * ||||########### block
 * ||############# block
 * ############### block
 * ```
 */
export declare function getClosestBlockElementByPoint(point: Point, state?: {
    rect?: Rect;
    container?: Element;
    snapToEdge?: {
        x: boolean;
        y: boolean;
    };
} | null, scale?: number): Element | null;
/**
 * Returns the closest block element by element that does not contain the page element and frame element.
 */
export declare function getClosestBlockElementByElement(element: Element | null): Element | null;
/**
 * Returns the model of the block element.
 */
export declare function getModelByBlockElement(element: Element): BaseBlockModel<object>;
/**
 * Returns all block elements in an element.
 */
export declare function getBlockElementsByElement(element?: BlockComponentElement | Document | Element): Element[];
/**
 * Returns the block element by id with the parent.
 */
export declare function getBlockElementById(id: string, parent?: BlockComponentElement | Document | Element): Element | null;
/**
 * Returns the closest frame block element by id with the parent.
 */
export declare function getClosestFrameBlockElementById(id: string, parent?: BlockComponentElement | Document | Element): Element | null;
/**
 * Returns rect of the block element.
 *
 * Compatible with Safari!
 * https://github.com/toeverything/blocksuite/issues/902
 * https://github.com/toeverything/blocksuite/pull/1121
 */
export declare function getRectByBlockElement(element: Element | BlockComponentElement): DOMRect;
/**
 * Returns selected state rect of the block element.
 */
export declare function getSelectedStateRectByBlockElement(element: Element | BlockComponentElement): DOMRect;
/**
 * Returns block elements excluding their subtrees.
 * Only keep block elements of same level.
 */
export declare function getBlockElementsExcludeSubtrees(elements: Element[] | BlockComponentElement[]): Element[] | (RichText | import("../../bookmark-block/components/bookmark-operation-popper.js").BookmarkOperationMenu | import("../../bookmark-block/components/bookmark-toolbar.js").BookmarkToolbar | import("../../bookmark-block/components/bookmark-edit-modal.js").BookmarkEditModal | import("../../bookmark-block/components/bookmark-create-modal.js").BookmarkCreateModal | import("../../index.js").BookmarkBlockComponent | import("../../index.js").ListBlockComponent | import("../../index.js").CodeBlockComponent | import("../../database-block/table/table-view.js").DatabaseTable | import("../../database-block/kanban/kanban-view.js").DatabaseKanban | import("../../index.js").DatabaseBlockComponent | DefaultPageBlockComponent | EdgelessPageBlockComponent | import("../../index.js").EmbedBlockComponent | import("../../index.js").ImageBlockComponent | import("../../index.js").DividerBlockComponent | import("../../index.js").ParagraphBlockComponent | import("../../index.js").FrameBlockComponent)[];
/**
 * Returns block elements including their subtrees.
 */
export declare function getBlockElementsIncludeSubtrees(elements: Element[]): Element[];
/**
 * query current mode whether is light or dark
 */
export declare function queryCurrentMode(): 'light' | 'dark';
/**
 * Get hovering frame with given a point in edgeless mode.
 */
export declare function getHoveringFrame(point: Point): Element | null;
/**
 * Returns `true` if the database is empty.
 */
export declare function isEmptyDatabase(model: BaseBlockModel): boolean;
/**
 * Gets the table of the database.
 */
export declare function getDatabaseBlockTableElement(element: Element): Element | null;
/**
 * Gets the column header of the database.
 */
export declare function getDatabaseBlockColumnHeaderElement(element: Element): Element | null;
/**
 * Gets the rows of the database.
 */
export declare function getDatabaseBlockRowsElement(element: Element): Element | null;
/**
 * Returns a flag for the drop target.
 */
export declare enum DropFlags {
    Normal = 0,
    Database = 1,
    EmptyDatabase = 2
}
/**
 * Gets the drop rect by block and point.
 */
export declare function getDropRectByPoint(point: Point, model: BaseBlockModel, element: Element): {
    rect: DOMRect;
    flag: DropFlags;
};
/**
 * Returns `true` if the target is `Element`.
 */
export declare function isElement(target: EventTarget | null): boolean | null;
/**
 * Returns `true` if the target is `affine-selected-blocks`.
 */
export declare function isSelectedBlocks(target: Element): boolean;
/**
 * Returns `true` if the target is `affine-drag-handle`.
 */
export declare function isDragHandle(target: Element): boolean;
/**
 * Returns `true` if block elements have database block element.
 */
export declare function hasDatabase(elements: Element[]): boolean;
export {};
//# sourceMappingURL=query.d.ts.map