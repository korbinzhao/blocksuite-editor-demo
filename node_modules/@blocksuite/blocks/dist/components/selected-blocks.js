var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { WithDisposable } from '@blocksuite/lit';
import { css, html, LitElement, nothing } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { repeat } from 'lit/directives/repeat.js';
import { styleMap } from 'lit/directives/style-map.js';
import {} from '../__internal__/index.js';
let AffineSelectedBlocks = class AffineSelectedBlocks extends WithDisposable(LitElement) {
    constructor() {
        super(...arguments);
        this.offset = { x: 0, y: 0 };
        this.state = { rects: [], grab: false };
    }
    _onPointerUp({ clientX, clientY, shiftKey }) {
        this.removeAttribute('data-grab');
        document.dispatchEvent(new PointerEvent('pointerup', {
            bubbles: true,
            clientX,
            clientY,
            shiftKey,
        }));
    }
    connectedCallback() {
        super.connectedCallback();
        // trigger click event on editor container
        this._disposables.addFromEvent(this, 'pointerup', this._onPointerUp);
    }
    willUpdate() {
        const { rects: [firstRect], grab, } = this.state;
        if (firstRect) {
            const { x, y } = this.offset;
            this.style.top = `${firstRect.top + y}px`;
            this.style.left = `${firstRect.left + x}px`;
        }
        this.toggleAttribute('data-grab', Boolean(firstRect && grab));
    }
    render() {
        const { rects } = this.state;
        const firstRect = rects[0];
        return firstRect
            ? repeat(rects, rect => html `<div
            style=${styleMap({
                width: `${rect.width}px`,
                height: `${rect.height}px`,
                top: `${rect.top - firstRect.top}px`,
                left: `${rect.left - firstRect.left}px`,
            })}
          ></div>`)
            : nothing;
    }
};
AffineSelectedBlocks.styles = css `
    :host {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    :host([data-grab]) {
      pointer-events: auto;
    }

    :host([data-grab]:hover) {
      cursor: grab;
    }

    :host > div {
      position: absolute;
      border-radius: 5px;
      background: var(--affine-hover-color);
    }
  `;
__decorate([
    property()
], AffineSelectedBlocks.prototype, "mouseRoot", void 0);
__decorate([
    property()
], AffineSelectedBlocks.prototype, "offset", void 0);
__decorate([
    property()
], AffineSelectedBlocks.prototype, "state", void 0);
AffineSelectedBlocks = __decorate([
    customElement('affine-selected-blocks')
], AffineSelectedBlocks);
export { AffineSelectedBlocks };
//# sourceMappingURL=selected-blocks.js.map