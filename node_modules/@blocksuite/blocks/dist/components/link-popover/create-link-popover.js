import { assertExists } from '@blocksuite/global/utils';
import { getDefaultPage, getModelByElement, noop, } from '../../__internal__/utils/index.js';
import { calcSafeCoordinate } from '../../page-block/utils/position.js';
function updatePosition(element, anchorEl) {
    const rect = anchorEl.getBoundingClientRect();
    const offsetY = 5;
    const safeCoordinate = calcSafeCoordinate({
        positioningPoint: { x: rect.x, y: rect.top + rect.height + offsetY },
        objRect: element.popoverContainer?.getBoundingClientRect(),
        offsetY,
    });
    element.left = `${safeCoordinate.x}px`;
    element.top = `${safeCoordinate.y}px`;
}
function createEditLinkElement(anchorEl, container, { showMask, previewLink, page, }) {
    const linkPanel = document.createElement('edit-link-panel');
    linkPanel.showMask = showMask;
    linkPanel.previewLink = previewLink;
    linkPanel.showBookmarkOperation = !!page.awarenessStore.getFlag('enable_bookmark_operation');
    container.appendChild(linkPanel);
    requestAnimationFrame(() => {
        updatePosition(linkPanel, anchorEl);
    });
    return linkPanel;
}
function bindHoverState(target, popover, controller) {
    // TODO export as options
    const hoverCloseDelay = 300;
    let timer;
    const handleMouseEnter = (e) => {
        clearTimeout(timer);
    };
    const handleMouseLeave = (e) => {
        // we want to leave the popover open
        // if the mouse entered the popover immediately
        // after leaving the target (or vice versa).
        timer = window.setTimeout(() => {
            controller.abort();
        }, hoverCloseDelay);
    };
    const abortHandler = () => {
        controller.abort();
    };
    target.addEventListener('mouseover', handleMouseEnter);
    target.addEventListener('mouseout', handleMouseLeave);
    popover.addEventListener('mouseover', handleMouseEnter);
    popover.addEventListener('mouseout', handleMouseLeave);
    const model = getModelByElement(target);
    const pageBlock = getDefaultPage(model.page);
    const viewport = pageBlock?.viewportElement;
    viewport?.addEventListener('scroll', abortHandler);
    return () => {
        target.removeEventListener('mouseover', handleMouseEnter);
        target.removeEventListener('mouseout', handleMouseLeave);
        popover.removeEventListener('mouseover', handleMouseEnter);
        popover.removeEventListener('mouseout', handleMouseLeave);
        viewport?.removeEventListener('scroll', abortHandler);
    };
}
export async function showLinkPopover({ anchorEl, page, container = document.body, text = '', link = '', showMask = true, interactionKind = 'always', abortController = new AbortController(), }) {
    assertExists(anchorEl, "Can't show tooltip without anchor element!");
    if (abortController.signal.aborted) {
        return Promise.resolve({ type: 'cancel' });
    }
    const editLinkEle = createEditLinkElement(anchorEl, container, {
        showMask,
        previewLink: link,
        page,
    });
    const unsubscribeHoverAbort = interactionKind === 'hover'
        ? bindHoverState(anchorEl, editLinkEle, abortController)
        : noop;
    return new Promise(res => {
        abortController.signal.addEventListener('abort', () => {
            editLinkEle.remove();
            res({ type: 'cancel' });
        });
        editLinkEle.addEventListener('editLink', e => {
            if (abortController.signal.aborted) {
                return;
            }
            editLinkEle.type = 'edit';
            editLinkEle.showMask = true;
            editLinkEle.text = text;
            unsubscribeHoverAbort();
            requestAnimationFrame(() => {
                updatePosition(editLinkEle, anchorEl);
            });
        });
        editLinkEle.addEventListener('updateLink', e => {
            if (abortController.signal.aborted) {
                return;
            }
            editLinkEle.remove();
            res(e.detail);
        });
    });
}
//# sourceMappingURL=create-link-popover.js.map