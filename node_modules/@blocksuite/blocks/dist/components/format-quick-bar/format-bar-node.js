var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FormatQuickBar_1;
import './button.js';
import { ArrowDownIcon, paragraphConfig, } from '@blocksuite/global/config';
import { WithDisposable } from '@blocksuite/lit';
import { assertExists, matchFlavours, } from '@blocksuite/store';
import { Slot } from '@blocksuite/store';
import { html, LitElement } from 'lit';
import { customElement, property, query, state } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { getCurrentBlockRange, restoreSelection, } from '../../__internal__/utils/block-range.js';
import { getRichTextByModel } from '../../__internal__/utils/index.js';
import { stopPropagation } from '../../page-block/edgeless/utils.js';
import { actionConfig } from '../../page-block/utils/const.js';
import { formatConfig } from '../../page-block/utils/format-config.js';
import { getCurrentCombinedFormat, onModelElementUpdated, updateBlockType, } from '../../page-block/utils/index.js';
import { compareTopAndBottomSpace } from '../../page-block/utils/position.js';
import { formatQuickBarStyle } from './styles.js';
function ParagraphPanel(showParagraphPanel, paragraphPanelMaxHeight, paragraphType, models, positionUpdated, onHover, onHoverEnd, onUpdateModels, onParagraphTypeChange) {
    if (showParagraphPanel === 'hidden') {
        return html ``;
    }
    const page = models[0].page;
    assertExists(page);
    const styles = styleMap({
        left: '0',
        top: showParagraphPanel === 'bottom' ? 'calc(100% + 4px)' : null,
        bottom: showParagraphPanel === 'top' ? 'calc(100% + 4px)' : null,
        maxHeight: paragraphPanelMaxHeight,
    });
    const updateParagraphType = (flavour, type) => {
        // Already in the target format, should convert back to text
        const alreadyTargetType = paragraphType === `${flavour}/${type}`;
        const { flavour: defaultFlavour, type: defaultType } = paragraphConfig[0];
        const targetFlavour = alreadyTargetType ? defaultFlavour : flavour;
        const targetType = alreadyTargetType ? defaultType : type;
        const newModels = updateBlockType(models, targetFlavour, targetType);
        // Reset selection if the target is code block
        if (targetFlavour === 'affine:code') {
            if (newModels.length !== 1) {
                throw new Error("Failed to reset selection! New model length isn't 1");
            }
            const codeModel = newModels[0];
            onModelElementUpdated(codeModel, () => {
                restoreSelection({
                    type: 'Block',
                    startOffset: 0,
                    endOffset: codeModel.text?.length ?? 0,
                    models: [codeModel],
                });
            });
        }
        onUpdateModels(newModels);
        onParagraphTypeChange(`${targetFlavour}/${targetType}`);
        positionUpdated.emit();
    };
    return html ` <div
    class="paragraph-panel"
    style="${styles}"
    @mouseover="${onHover}"
    @mouseout="${onHoverEnd}"
  >
    ${paragraphConfig
        .filter(({ flavour }) => flavour !== 'affine:divider')
        .filter(({ flavour }) => page.schema.flavourSchemaMap.has(flavour))
        .map(({ flavour, type, name, icon }) => html `<format-bar-button
          width="100%"
          style="padding-left: 12px; justify-content: flex-start;"
          text="${name}"
          data-testid="${flavour}/${type}"
          @click="${() => updateParagraphType(flavour, type)}"
        >
          ${icon}
        </format-bar-button>`)}
  </div>`;
}
let FormatQuickBar = FormatQuickBar_1 = class FormatQuickBar extends WithDisposable(LitElement) {
    constructor() {
        super(...arguments);
        this.left = null;
        this.top = null;
        this.abortController = new AbortController();
        // Sometimes the quick bar need to update position
        this.positionUpdated = new Slot();
        this.models = [];
        this._paragraphType = `${paragraphConfig[0].flavour}/${paragraphConfig[0].type}`;
        this._paragraphPanelHoverDelay = 150;
        this._paragraphPanelTimer = 0;
        this._showParagraphPanel = 'hidden';
        this.paragraphPanelMaxHeight = null;
        this._format = {};
        this._customElements = [];
        this._selectionChangeHandler = () => {
            const blockRange = getCurrentBlockRange(this.page);
            if (!blockRange) {
                this.abortController.abort();
                return;
            }
            // If the selection is collapsed, abort the format quick bar
            if (blockRange.type === 'Native' &&
                blockRange.models.length === 1 &&
                blockRange.startOffset === blockRange.endOffset) {
                this.abortController.abort();
                return;
            }
            this._format = getCurrentCombinedFormat(this.page);
            this.positionUpdated.emit();
        };
    }
    update(changedProperties) {
        super.update(changedProperties);
        if (this._customElements.length === 0 &&
            FormatQuickBar_1.customElements.length !== 0) {
            this._customElements = FormatQuickBar_1.customElements.map(element => element(this.page, () => getCurrentBlockRange(this.page)));
            this.customItemsElement.append(...this._customElements);
            this._disposables.add(() => {
                this._customElements.forEach(element => {
                    element.remove();
                });
                this._customElements = [];
                this.customItemsElement.innerHTML = '';
            });
        }
    }
    connectedCallback() {
        super.connectedCallback();
        const startModel = this.models[0];
        this._paragraphType = `${startModel.flavour}/${startModel.type}`;
        this._format = getCurrentCombinedFormat(this.page);
        this.addEventListener('pointerdown', (e) => {
            // Prevent click event from making selection lost
            e.preventDefault();
            e.stopPropagation();
        });
        this.abortController.signal.addEventListener('abort', () => {
            this.remove();
        });
        document.addEventListener('selectionchange', this._selectionChangeHandler);
        const mutationObserver = new MutationObserver(() => {
            if (!this.page) {
                return;
            }
            this._format = getCurrentCombinedFormat(this.page);
        });
        this.models.forEach(model => {
            const richText = getRichTextByModel(model);
            if (!richText) {
                console.warn('Format quick bar may not work properly! Cannot find rich text node by model. model:', model);
                return;
            }
            mutationObserver.observe(richText, {
                // One or more children have been added to and/or removed
                // from the tree.
                childList: true,
                // Omit (or set to false) to observe only changes to the parent node
                subtree: true,
            });
        });
        this._disposables.add(() => mutationObserver.disconnect());
        this._disposables.add(() => document.removeEventListener('selectionchange', this._selectionChangeHandler));
    }
    _onHover() {
        if (this._showParagraphPanel !== 'hidden') {
            clearTimeout(this._paragraphPanelTimer);
            return;
        }
        this._paragraphPanelTimer = window.setTimeout(async () => {
            const { placement, height } = compareTopAndBottomSpace(this.formatQuickBarElement, document.body, 10);
            this._showParagraphPanel = placement;
            this.paragraphPanelMaxHeight = height + 'px';
        }, this._paragraphPanelHoverDelay);
    }
    _onHoverEnd() {
        if (this._showParagraphPanel !== 'hidden') {
            // Prepare to disappear
            this._paragraphPanelTimer = window.setTimeout(async () => {
                this._showParagraphPanel = 'hidden';
            }, this._paragraphPanelHoverDelay * 2);
            return;
        }
        clearTimeout(this._paragraphPanelTimer);
    }
    render() {
        const page = this.page;
        if (!this.models.length || !page) {
            console.error('Failed to render format-quick-bar! no model or page not found!', this.models, page);
            return html ``;
        }
        const styles = styleMap({
            left: this.left,
            top: this.top,
        });
        const actionItems = actionConfig
            .filter(({ showWhen = () => true }) => showWhen(page, this.models))
            .map(({ id, name, icon, action, enabledWhen, disabledToolTip }) => {
            const enabled = enabledWhen(page);
            const toolTip = enabled
                ? html `<tool-tip inert role="tooltip">${name}</tool-tip>`
                : html `<tool-tip tip-position="top" inert role="tooltip"
              >${disabledToolTip}</tool-tip
            >`;
            return html `<format-bar-button
          class="has-tool-tip"
          data-testid=${id}
          ?disabled=${!enabled}
          @click=${() => enabled && action({ page })}
        >
          ${icon}${toolTip}
        </format-bar-button>`;
        });
        if (this.models.length === 1 &&
            matchFlavours(this.models[0], ['affine:database'])) {
            return html `<div
        class="format-quick-bar"
        style="${styles}"
        @pointerdown=${stopPropagation}
      >
        ${actionItems}
      </div>`;
        }
        const paragraphIcon = paragraphConfig.find(({ flavour, type }) => `${flavour}/${type}` === this._paragraphType)?.icon ?? paragraphConfig[0].icon;
        const paragraphItems = html ` <format-bar-button
      class="paragraph-button"
      width="52px"
      @mouseover="${this._onHover}"
      @mouseout="${this._onHoverEnd}"
    >
      ${paragraphIcon} ${ArrowDownIcon}
    </format-bar-button>`;
        const paragraphPanel = ParagraphPanel(this._showParagraphPanel, this.paragraphPanelMaxHeight, this._paragraphType, this.models, this.positionUpdated, this._onHover, this._onHoverEnd, newModels => (this.models = newModels), paragraphType => (this._paragraphType = paragraphType));
        const formatItems = formatConfig
            .filter(({ showWhen = () => true }) => showWhen(this.models))
            .map(({ id, name, icon, action, activeWhen }) => html ` <format-bar-button
          class="has-tool-tip"
          data-testid=${id}
          ?active=${activeWhen(this._format)}
          @click=${() => {
            action({
                page,
                abortController: this.abortController,
                format: this._format,
            });
            // format state need to update after format
            this._format = getCurrentCombinedFormat(page);
            this.positionUpdated.emit();
        }}
        >
          ${icon}
          <tool-tip inert role="tooltip">${name}</tool-tip>
        </format-bar-button>`);
        return html ` <div
      class="format-quick-bar"
      style="${styles}"
      @pointerdown=${stopPropagation}
    >
      <div class="custom-items"></div>
      ${this._customElements.length > 0
            ? html `<div class="divider"></div>`
            : null}
      ${paragraphItems}
      <div class="divider"></div>
      ${formatItems}
      ${formatItems.length ? html ` <div class="divider"></div>` : ''}
      ${actionItems} ${paragraphPanel}
    </div>`;
    }
};
FormatQuickBar.styles = formatQuickBarStyle;
FormatQuickBar.customElements = [];
__decorate([
    property()
], FormatQuickBar.prototype, "page", void 0);
__decorate([
    property()
], FormatQuickBar.prototype, "left", void 0);
__decorate([
    property()
], FormatQuickBar.prototype, "top", void 0);
__decorate([
    property()
], FormatQuickBar.prototype, "abortController", void 0);
__decorate([
    property()
], FormatQuickBar.prototype, "positionUpdated", void 0);
__decorate([
    property()
], FormatQuickBar.prototype, "models", void 0);
__decorate([
    state()
], FormatQuickBar.prototype, "_paragraphType", void 0);
__decorate([
    state()
], FormatQuickBar.prototype, "_paragraphPanelHoverDelay", void 0);
__decorate([
    state()
], FormatQuickBar.prototype, "_paragraphPanelTimer", void 0);
__decorate([
    state()
], FormatQuickBar.prototype, "_showParagraphPanel", void 0);
__decorate([
    state()
], FormatQuickBar.prototype, "_format", void 0);
__decorate([
    query('.format-quick-bar')
], FormatQuickBar.prototype, "formatQuickBarElement", void 0);
__decorate([
    query('.custom-items')
], FormatQuickBar.prototype, "customItemsElement", void 0);
FormatQuickBar = FormatQuickBar_1 = __decorate([
    customElement('format-quick-bar')
], FormatQuickBar);
export { FormatQuickBar };
//# sourceMappingURL=format-bar-node.js.map