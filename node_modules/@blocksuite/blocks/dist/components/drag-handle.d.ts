import type { PointerEventState } from '@blocksuite/lit';
import { ShadowlessElement } from '@blocksuite/lit';
import type { BaseBlockModel } from '@blocksuite/store';
import { LitElement } from 'lit';
import { type BlockComponentElement, type DroppingType, type EditingState, Point, type Rect } from '../__internal__/index.js';
export declare class DragIndicator extends LitElement {
    static styles: import("lit").CSSResult;
    rect: Rect | null;
    render(): import("lit").TemplateResult<1> | null;
}
export declare class DragPreview extends ShadowlessElement {
    offset: {
        x: number;
        y: number;
    };
    render(): import("lit").TemplateResult<1>;
}
declare const DragHandle_base: typeof LitElement & (new (...args: any[]) => import("@blocksuite/lit").DisposableClass);
export declare class DragHandle extends DragHandle_base {
    static styles: import("lit").CSSResult;
    constructor(options: {
        container: HTMLElement;
        onDropCallback: (point: Point, draggingBlockElements: BlockComponentElement[], lastModelState: EditingState | null, lastType: DroppingType) => void;
        setDragType: (dragging: boolean) => void;
        setSelectedBlock: (selectedBlock: EditingState | null, element?: Element) => void;
        getSelectedBlocks: () => BlockComponentElement[] | null;
        getClosestBlockElement: (point: Point) => Element | null;
    });
    /**
     * A function that returns all blocks that are allowed to be moved to
     *
     * If there is `draggingBlock`, the user is dragging a block to another place
     *
     */
    getDropAllowedBlocks: (draggingBlockIds: string[] | null) => BaseBlockModel[];
    onDropCallback: (point: Point, draggingBlockElements: BlockComponentElement[], lastModelState: EditingState | null, lastType: DroppingType) => void;
    setDragType: (dragging: boolean) => void;
    setSelectedBlock: (selectedBlock: EditingState | null, element?: Element) => void;
    private _getSelectedBlocks;
    private _getClosestBlockElement;
    private _dragHandle;
    private _draggingElements;
    private _scale;
    private _currentClientX;
    private _currentClientY;
    private _stopPropagation;
    /**
     * Current drag handle model state
     */
    private _handleAnchorState;
    private _handleAnchorDisposable;
    /**
     * Last drag handle dropping target state
     */
    private _lastDroppingTarget;
    private _lastDroppingType;
    private _indicator;
    private _container;
    private _dragPreview;
    protected get selectedBlocks(): (import("../__internal__/rich-text/rich-text.js").RichText | import("../bookmark-block/components/bookmark-operation-popper.js").BookmarkOperationMenu | import("../bookmark-block/components/bookmark-toolbar.js").BookmarkToolbar | import("../bookmark-block/components/bookmark-edit-modal.js").BookmarkEditModal | import("../bookmark-block/components/bookmark-create-modal.js").BookmarkCreateModal | import("../index.js").BookmarkBlockComponent | import("../index.js").ListBlockComponent | import("../index.js").CodeBlockComponent | import("../database-block/table/table-view.js").DatabaseTable | import("../database-block/kanban/kanban-view.js").DatabaseKanban | import("../index.js").DatabaseBlockComponent | import("../index.js").DefaultPageBlockComponent | import("../index.js").EdgelessPageBlockComponent | import("../index.js").EmbedBlockComponent | import("../index.js").ImageBlockComponent | import("../index.js").DividerBlockComponent | import("../index.js").ParagraphBlockComponent | import("../index.js").FrameBlockComponent)[];
    onContainerMouseMove(event: PointerEventState, modelState: EditingState | null): void;
    hide(force?: boolean): void;
    reset(): void;
    setPointerEvents(value: 'auto' | 'none'): void;
    setScale(value?: number): void;
    firstUpdated(): void;
    disconnectedCallback(): void;
    private _onMouseMoveOnHost;
    private _calcDragHandleY;
    private _createDragPreview;
    private _removeDragPreview;
    private _onClick;
    private _onDragOverDocument;
    onDragStart: (e: DragEvent, draggable?: boolean) => void;
    onDrag: (e: DragEvent, passed?: boolean, isScrolling?: boolean) => void;
    onDragEnd: (e: DragEvent, passed?: boolean) => void;
    render(): import("lit").TemplateResult<1>;
}
declare global {
    interface HTMLElementTagNameMap {
        'affine-drag-handle': DragHandle;
        'affine-drag-indicator': DragIndicator;
        'affine-drag-preview': DragPreview;
    }
}
export {};
//# sourceMappingURL=drag-handle.d.ts.map