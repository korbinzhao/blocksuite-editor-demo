var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BLOCKHUB_FILE_ITEMS, BLOCKHUB_LIST_ITEMS, BLOCKHUB_TEXT_ITEMS, BlockHubIcon, BlockHubRoundedRectangleIcon, CrossIcon, DatabaseTableViewIcon, EmbedIcon, NumberedListIconLarge, TextIconLarge, } from '@blocksuite/global/config';
import { assertExists, isFirefox } from '@blocksuite/global/utils';
import { ShadowlessElement, WithDisposable } from '@blocksuite/lit';
import { css, html } from 'lit';
import { customElement, property, query, queryAll, state, } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
import { calcDropTarget, getClosestBlockElementByPoint, getModelByBlockElement, Point, } from '../__internal__/index.js';
import {} from './drag-handle.js';
import { tooltipStyle } from './tooltip/tooltip.js';
const styles = css `
  affine-block-hub {
    position: absolute;
    z-index: 1;
    user-select: none;
  }

  @media print {
    affine-block-hub {
      display: none;
    }
  }

  .affine-block-hub-container {
    width: 274px;
    position: absolute;
    right: calc(100% + 8px);
    overflow-y: unset;
    display: none;
    justify-content: center;
    fill: var(--affine-icon-color);
    color: var(--affine-icon-color);
    font-size: var(--affine-font-sm);
    background: var(--affine-background-overlay-panel-color);
    box-shadow: var(--affine-menu-shadow);
    border-radius: 8px;
  }

  .affine-block-hub-container[type='text'] {
    top: unset;
    bottom: 0;
    transform: unset;
    right: calc(100% + 4px);
  }

  .visible {
    display: block;
  }

  .invisible {
    display: none;
  }

  .card-container-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    position: relative;
  }

  .card-container {
    display: flex;
    position: relative;
    align-items: center;
    width: 250px;
    height: 54px;
    background: var(--affine-white-80);
    box-shadow: var(--affine-shadow-1);
    border-radius: 8px;
    margin-bottom: 12px;
    cursor: grab;
    top: 0;
    left: 0;
    transition: all 0.1s ease-in-out;
  }

  .card-icon-container {
    display: flex;
    align-items: center;
    position: absolute;
    right: 12px;
  }

  .card-icon-container > svg {
    width: 20px;
    height: 20px;
  }

  .card-container-inner:hover .card-container {
    background: var(--affine-hover-color);
    top: -2px;
    left: -2px;
  }

  .card-container-inner:hover .card-container.grabbing {
    top: unset;
    left: unset;
    box-shadow: var(--affine-shadow-2);
  }

  .card-description-container {
    display: block;
    width: 190px;
    color: var(--affine-text-primary-color);
    font-size: var(--affine-font-base);
    line-height: var(--affine-line-height);
    margin: 8px 0 8px 12px;
    text-align: justify;
  }

  .affine-block-hub-container .description {
    font-size: var(--affine-font-sm);
    line-height: var(--affine-line-height);
    color: var(--affine-text-secondary-color);
    white-space: pre;
  }

  .grabbing {
    cursor: grabbing;
  }

  .grab {
    cursor: grab;
  }

  .affine-block-hub-title-container {
    margin: 16px 0 20px 12px;
    color: var(--affine-text-secondary-color);
    font-size: var(--affine-font-base);
    user-select: none;
  }

  .prominent {
    z-index: 1;
  }

  .block-hub-menu-container {
    display: flex;
    font-family: var(--affine-font-family);
    flex-flow: column;
    justify-content: center;
    align-items: center;
    position: fixed;
    width: 44px;
    background: var(--affine-background-primary-color);
    border-radius: 8px;
  }

  .block-hub-menu-container[expanded] {
    box-shadow: var(--affine-menu-shadow);
    background: var(--affine-background-overlay-panel-color);
  }

  .block-hub-icon-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 8px;
    position: relative;
    border-radius: 4px;
    fill: var(--affine-icon-color);
    color: var(--affine-icon-color);
    height: 36px;
  }
  .block-hub-icon-container svg {
    width: 24px;
    height: 24px;
  }

  .block-hub-icon-container[selected='true'] {
    background: var(--affine-hover-color);
  }

  .block-hub-icon-container:hover {
    background: var(--affine-hover-color);
    border-radius: 4px;
  }

  .new-icon {
    width: 44px;
    height: 44px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    fill: var(--affine-icon-color);
  }

  .new-icon-in-edgeless {
    box-shadow: var(--affine-menu-shadow);
  }
  .block-hub-menu-container[expanded] .new-icon {
    border-radius: 4px;
    box-shadow: unset;
  }

  .new-icon:hover {
    box-shadow: var(--affine-menu-shadow);
    background: var(--affine-white);
  }

  .icon-expanded {
    width: 36px;
    height: 36px;
  }

  .icon-expanded:hover {
    background: var(--affine-hover-color);
  }

  .divider {
    height: 1px;
    width: 36px;
    background: var(--affine-border-color);
    margin: 4px 0;
  }

  [role='menuitem'] tool-tip {
    font-size: var(--affine-font-sm);
  }

  .block-hub-icons-container {
    overflow: hidden;
    transition: all 0.2s cubic-bezier(0, 0, 0.55, 1.6);
  }

  ${tooltipStyle}
`;
const TRANSITION_DELAY = 200;
const BOTTOM_OFFSET = 70;
const RIGHT_OFFSET = 24;
const TOP_DISTANCE = 24;
function shouldDisplayCard(type, expanded, isCardListVisible, visibleCardType) {
    return expanded && isCardListVisible && visibleCardType === type;
}
function BlockHubCards(blockHubItems, type, title, maxHeight, shouldDisplayCard, isGrabbing, showTooltip) {
    const shouldScroll = maxHeight < 800;
    const styles = styleMap({
        maxHeight: `${maxHeight}px`,
        overflowY: shouldScroll ? 'scroll' : 'unset',
    });
    return html `
    <div
      class="affine-block-hub-container ${shouldDisplayCard ? 'visible' : ''}"
      style="${styles}"
      type=${type}
    >
      <div class="affine-block-hub-title-container">${title}</div>
      ${blockHubItems.map(({ flavour, type, name, description, icon, tooltip }, index) => {
        return html `
            <div class="card-container-wrapper">
              <div class="card-container-inner">
                <div
                  class="card-container has-tool-tip ${isGrabbing
            ? 'grabbing'
            : ''}"
                  draggable="true"
                  affine-flavour=${flavour}
                  affine-type=${type ?? ''}
                >
                  <div class="card-description-container">
                    <div>${name}</div>
                    <div class="description">${description}</div>
                  </div>
                  <div class="card-icon-container">${icon}</div>
                  <tool-tip
                    tip-position=${shouldScroll &&
            index === blockHubItems.length - 1
            ? 'top'
            : 'bottom'}
                    style="${showTooltip
            ? ''
            : 'display: none'}; z-index: ${blockHubItems.length -
            index}"
                    >${tooltip}</tool-tip
                  >
                </div>
              </div>
            </div>
          `;
    })}
    </div>
  `;
}
function BlockHubMenu(enableDatabase, expanded, isGrabbing, visibleCardType, isCardListVisible, showTooltip, maxHeight, page) {
    const menuNum = enableDatabase ? 5 : 4;
    const height = menuNum * 44 + 10;
    const blockHubListCards = BlockHubCards(BLOCKHUB_LIST_ITEMS, 'list', 'List', maxHeight, shouldDisplayCard('list', expanded, isCardListVisible, visibleCardType), isGrabbing, showTooltip);
    const blockHubFileCards = BlockHubCards(BLOCKHUB_FILE_ITEMS.filter(({ flavour }) => {
        if (flavour === 'affine:bookmark') {
            return page.awarenessStore.getFlag('enable_bookmark_operation');
        }
        return true;
    }), 'file', 'Content & Media', maxHeight, shouldDisplayCard('file', expanded, isCardListVisible, visibleCardType), isGrabbing, showTooltip);
    return html `
    <div
      class="block-hub-icons-container"
      ?transition=${expanded}
      style="height: ${expanded ? `${height}px` : '0'};"
    >
      <div
        class="block-hub-icon-container has-tool-tip ${isGrabbing
        ? 'grabbing'
        : 'grab'}"
        selected=${visibleCardType === 'blank' ? 'true' : 'false'}
        type="blank"
        draggable="true"
        affine-flavour="affine:paragraph"
        affine-type="text"
      >
        ${BlockHubRoundedRectangleIcon}
        <tool-tip
          inert
          role="tooltip"
          tip-position="left"
          ?hidden=${!showTooltip}
          >Drag to insert blank line
        </tool-tip>
      </div>
      <div
        class="block-hub-icon-container"
        type="text"
        selected=${visibleCardType === 'text' ? 'true' : 'false'}
      >
        ${TextIconLarge}
      </div>
      <div
        class="block-hub-icon-container"
        type="list"
        selected=${visibleCardType === 'list' ? 'true' : 'false'}
      >
        ${blockHubListCards} ${NumberedListIconLarge}
      </div>
      <div
        class="block-hub-icon-container"
        type="file"
        selected=${visibleCardType === 'file' ? 'true' : 'false'}
      >
        ${blockHubFileCards} ${EmbedIcon}
      </div>
      ${enableDatabase
        ? html `
            <div
              class="block-hub-icon-container has-tool-tip"
              type="database"
              draggable="true"
              affine-flavour="affine:database"
              selected=${visibleCardType === 'database' ? 'true' : 'false'}
            >
              ${DatabaseTableViewIcon}
              <tool-tip
                inert
                role="tooltip"
                tip-position="left"
                ?hidden=${!showTooltip}
              >
                Drag to create a database
              </tool-tip>
            </div>
          `
        : null}
      <div class="divider"></div>
    </div>
  `;
}
let BlockHub = class BlockHub extends WithDisposable(ShadowlessElement) {
    constructor(options) {
        super();
        this._expanded = false;
        this._isGrabbing = false;
        this._visibleCardType = null;
        this._showTooltip = true;
        this._inEdgelessMode = false;
        this._maxHeight = 2000;
        this._currentClientX = 0;
        this._currentClientY = 0;
        this._isCardListVisible = false;
        this._lastDroppingTarget = null;
        this._lastDroppingType = 'none';
        this._lastDraggingFlavour = null;
        this._timer = null;
        /**
         * This is currently a workaround, as the height of the _blockHubIconsContainer is determined by the height of its
         * content, and if its child's opacity is set to 0 during a transition, its height won't change, causing the background
         * to exceeds its actual visual height. So currently we manually set the height of those whose opacity is 0 to 0px.
         */
        this._onTransitionStart = (_) => {
            if (this._timer) {
                clearTimeout(this._timer);
            }
            if (!this._expanded) {
                // when the _blockHubMenuContainer is unexpanded, should cancel the vertical padding making it a square
                this._blockHubMenuContainer.style.padding = '0 4px';
                this._timer = window.setTimeout(() => {
                    this._blockHubIconsContainer.style.overflow = 'hidden';
                }, TRANSITION_DELAY);
            }
            else {
                this._blockHubMenuContainer.style.padding = '4px';
                this._timer = window.setTimeout(() => {
                    this._blockHubIconsContainer.style.overflow = 'unset';
                }, TRANSITION_DELAY);
            }
        };
        this._onClickOutside = (e) => {
            const target = e.target;
            if (target instanceof HTMLElement && !target.closest('affine-block-hub')) {
                this._hideCardList();
            }
        };
        this._onClickCard = (e, blockHubElement) => {
            const affineType = blockHubElement.getAttribute('affine-type');
            assertExists(affineType);
            const data = {
                flavour: blockHubElement.getAttribute('affine-flavour') ?? '',
            };
            if (affineType) {
                data.type = affineType;
            }
            this._onClickCardCallback(data);
        };
        this._onBlockHubButtonClick = (_) => {
            this._expanded = !this._expanded;
            if (!this._expanded) {
                this._hideCardList();
            }
        };
        this._onDragStart = (event) => {
            this._showTooltip = false;
            // DragEvent that doesn't dispatch manually, is expected to have dataTransfer property
            assertExists(event.dataTransfer);
            event.dataTransfer.effectAllowed = 'move';
            const blockHubElement = event.target;
            const affineType = blockHubElement.getAttribute('affine-type');
            const data = {
                flavour: blockHubElement.getAttribute('affine-flavour'),
            };
            if (affineType) {
                data.type = affineType;
            }
            event.dataTransfer.setData('affine/block-hub', JSON.stringify(data));
            this._lastDraggingFlavour = data.flavour;
            this._onDragStartCallback();
        };
        this._onMouseDown = (e) => {
            if (isFirefox) {
                this._currentClientX = e.clientX;
                this._currentClientY = e.clientY;
            }
        };
        this._onDrag = (e) => {
            this._hideCardList();
            let x = e.clientX;
            let y = e.clientY;
            if (isFirefox) {
                // In Firefox, `pageX` and `pageY` are always set to 0.
                // Refs: https://stackoverflow.com/questions/13110349/pagex-and-pagey-are-always-set-to-0-in-firefox-during-the-ondrag-event.
                x = this._currentClientX;
                y = this._currentClientY;
            }
            if (!this._indicator ||
                (this._indicator.rect &&
                    this._indicator.rect.left === x &&
                    this._indicator.rect.top === y)) {
                return;
            }
            const point = new Point(x, y);
            const { container, rect: frameRect, scale, } = this.getHoveringFrameState(point.clone());
            if (!frameRect) {
                this._resetDropState();
                return;
            }
            const element = getClosestBlockElementByPoint(point, { container, rect: frameRect, snapToEdge: { x: false, y: true } }, scale);
            if (!element) {
                // if (this._mouseRoot.mode === 'page') {
                //   return;
                // }
                this._resetDropState();
                return;
            }
            let type = 'none';
            let rect = null;
            let lastModelState = null;
            const model = getModelByBlockElement(element);
            const result = calcDropTarget(point, model, element, [], scale, this._lastDraggingFlavour);
            if (result) {
                type = result.type;
                rect = result.rect;
                lastModelState = result.modelState;
            }
            this._lastDroppingType = type;
            this._indicator.rect = rect;
            this._lastDroppingTarget = lastModelState;
        };
        this._onDragOver = (e) => {
            e.preventDefault();
        };
        this._onDragOverDocument = (e) => {
            if (!isFirefox) {
                throw new Error('FireFox only');
            }
            this._currentClientX = e.clientX;
            this._currentClientY = e.clientY;
        };
        this._onDragEnd = (_) => {
            this._showTooltip = true;
            this._isGrabbing = false;
            this._lastDraggingFlavour = null;
            this._resetDropState();
        };
        this._resetDropState = () => {
            this._lastDroppingType = 'none';
            this._indicator.rect = null;
            this._lastDroppingTarget = null;
        };
        this._onDrop = (e) => {
            assertExists(e.dataTransfer);
            if (!e.dataTransfer.getData('affine/block-hub'))
                return;
            this._onDropCallback(e, 
            // `drag.clientY` !== `dragend.clientY` in chrome.
            this._indicator?.rect?.min ?? new Point(e.clientX, e.clientY), this._lastDroppingTarget, this._lastDroppingType);
        };
        this._onCardMouseDown = (_) => {
            this._isGrabbing = true;
        };
        this._onCardMouseUp = (_) => {
            this._isGrabbing = false;
        };
        this._onBlankMenuMouseDown = () => {
            this._isGrabbing = true;
        };
        this._onBlankMenuMouseUp = () => {
            this._isGrabbing = false;
        };
        this._onBlockHubMenuMouseOver = (e) => {
            const menu = e.currentTarget;
            const cardType = menu.getAttribute('type');
            assertExists(cardType);
            this._isCardListVisible = true;
            this._visibleCardType = cardType;
        };
        this._onBlockHubEntryMouseOver = () => {
            this._isCardListVisible = false;
        };
        this._onResize = () => {
            const boundingClientRect = document.body.getBoundingClientRect();
            this._maxHeight = boundingClientRect.height - TOP_DISTANCE - BOTTOM_OFFSET;
        };
        this._page = options.page;
        this._mouseRoot = options.mouseRoot;
        this._enableDatabase = options.enableDatabase;
        this.getAllowedBlocks = options.getAllowedBlocks;
        this.getHoveringFrameState = options.getHoveringFrameState;
        this._onDragStartCallback = options.onDragStart;
        this._onDropCallback = options.onDrop;
        this._onClickCardCallback = options.onClickCard;
    }
    connectedCallback() {
        super.connectedCallback();
        const disposables = this._disposables;
        disposables.addFromEvent(this, 'dragstart', this._onDragStart);
        disposables.addFromEvent(this, 'drag', this._onDrag);
        disposables.addFromEvent(this, 'dragend', this._onDragEnd);
        disposables.addFromEvent(this._mouseRoot, 'dragover', this._onDragOver);
        disposables.addFromEvent(this._mouseRoot, 'drop', this._onDrop);
        disposables.addFromEvent(this, 'mousedown', this._onMouseDown);
        disposables.add(this._mouseRoot.slots.pageModeSwitched.on(mode => {
            this._inEdgelessMode = mode === 'edgeless';
        }));
        if (isFirefox) {
            disposables.addFromEvent(this._mouseRoot, 'dragover', this._onDragOverDocument);
        }
        this._onResize();
    }
    firstUpdated() {
        const disposables = this._disposables;
        this._blockHubCards.forEach(card => {
            disposables.addFromEvent(card, 'mousedown', this._onCardMouseDown);
            disposables.addFromEvent(card, 'mouseup', this._onCardMouseUp);
            disposables.addFromEvent(card, 'click', e => this._onClickCard(e, card));
        });
        for (const blockHubMenu of this._blockHubMenus) {
            disposables.addFromEvent(blockHubMenu, 'mouseover', this._onBlockHubMenuMouseOver);
            if (blockHubMenu.getAttribute('type') === 'blank') {
                disposables.addFromEvent(blockHubMenu, 'mousedown', this._onBlankMenuMouseDown);
                disposables.addFromEvent(blockHubMenu, 'mouseup', this._onBlankMenuMouseUp);
            }
        }
        disposables.addFromEvent(this._blockHubMenuEntry, 'mouseover', this._onBlockHubEntryMouseOver);
        disposables.addFromEvent(document, 'click', this._onClickOutside);
        disposables.addFromEvent(this._blockHubButton, 'click', this._onBlockHubButtonClick);
        disposables.addFromEvent(this._blockHubButton, 'mousedown', e => {
            // Prevent input from losing focus
            e.preventDefault();
        });
        disposables.addFromEvent(this._blockHubIconsContainer, 'transitionstart', this._onTransitionStart);
        disposables.addFromEvent(window, 'resize', this._onResize);
        this._indicator = (document.createElement('affine-drag-indicator'));
        document.body.appendChild(this._indicator);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._disposables.dispose();
    }
    toggleMenu() {
        this._expanded = !this._expanded;
        if (!this._expanded)
            this._hideCardList();
    }
    _hideCardList() {
        if (this._visibleCardType) {
            this._visibleCardType = null;
            this._isCardListVisible = false;
        }
    }
    render() {
        const blockHubMenu = BlockHubMenu(this._enableDatabase, this._expanded, this._isGrabbing, this._visibleCardType, this._isCardListVisible, this._showTooltip, this._maxHeight, this._page);
        const blockHubCards = BlockHubCards(BLOCKHUB_TEXT_ITEMS, 'text', 'Text block', this._maxHeight, shouldDisplayCard('text', this._expanded, this._isCardListVisible, this._visibleCardType), this._isGrabbing, this._showTooltip);
        const classes = classMap({
            'icon-expanded': this._expanded,
            'new-icon-in-edgeless': this._inEdgelessMode && !this._expanded,
            'has-tool-tip': true,
            'new-icon': true,
        });
        return html `
      <div
        class="block-hub-menu-container"
        ?expanded=${this._expanded}
        style="bottom: ${BOTTOM_OFFSET}px; right: ${RIGHT_OFFSET}px;"
      >
        ${blockHubMenu}
        <div class=${classes} role="menuitem" style="cursor:pointer;">
          ${this._expanded ? CrossIcon : BlockHubIcon}
          <tool-tip
            class=${this._expanded ? 'invisible' : ''}
            inert
            tip-position="left"
            role="tooltip"
            >Insert blocks
          </tool-tip>
        </div>
        ${blockHubCards}
      </div>
    `;
    }
};
BlockHub.styles = styles;
__decorate([
    property()
], BlockHub.prototype, "getAllowedBlocks", void 0);
__decorate([
    property()
], BlockHub.prototype, "getHoveringFrameState", void 0);
__decorate([
    state()
], BlockHub.prototype, "_expanded", void 0);
__decorate([
    state()
], BlockHub.prototype, "_isGrabbing", void 0);
__decorate([
    state()
], BlockHub.prototype, "_visibleCardType", void 0);
__decorate([
    state()
], BlockHub.prototype, "_showTooltip", void 0);
__decorate([
    state()
], BlockHub.prototype, "_inEdgelessMode", void 0);
__decorate([
    state()
], BlockHub.prototype, "_maxHeight", void 0);
__decorate([
    queryAll('.card-container')
], BlockHub.prototype, "_blockHubCards", void 0);
__decorate([
    queryAll('.block-hub-icon-container[type]')
], BlockHub.prototype, "_blockHubMenus", void 0);
__decorate([
    query('.new-icon')
], BlockHub.prototype, "_blockHubButton", void 0);
__decorate([
    query('.block-hub-icons-container')
], BlockHub.prototype, "_blockHubIconsContainer", void 0);
__decorate([
    query('.block-hub-menu-container')
], BlockHub.prototype, "_blockHubMenuContainer", void 0);
__decorate([
    query('[role="menuitem"]')
], BlockHub.prototype, "_blockHubMenuEntry", void 0);
BlockHub = __decorate([
    customElement('affine-block-hub')
], BlockHub);
export { BlockHub };
//# sourceMappingURL=block-hub.js.map